from typing import Any
class constants:
    CTRLDEF_BLANK: int
    CTRLDEF_MILDLY: int
    CTRLDEF_QLINEAR: int
    CTRLDEF_SEVERLY: int
    NLSTEP_LOAD_ADAPT: int
    NLSTEP_LOAD_ARCLEN: int
    NLSTEP_LOAD_FIXED: int
    Disp_bp: int
    Load_bp: int
    Strain_bp: int
    FLXSLI_DRIVER_DISP: int
    FLXSLI_DRIVER_FORC: int
    FLXSLI_DRIVER_SENSOR: int
    FLXSLI_DRIVER_UNKNOWN: int
    FLXSLI_FRICTION_DISP: int
    FLXSLI_FRICTION_INF: int
    FLXSLI_FRICTION_NONE: int
    FLXSLI_FRICTION_UNKNOWN: int
    FLXSLI_FRICTION_VELO: int
    FLXSLI_TYPE_CYLF: int
    FLXSLI_TYPE_FLEX: int
    FLXSLI_TYPE_PRIF: int
    FLXSLI_TYPE_TWIF: int
    FLXSLI_TYPE_UNKNOWN: int
    JOINT_ATTACH_CURVES: int
    JOINT_ATTACH_ELEMENTS: int
    JOINT_ATTACH_GROUND: int
    JOINT_ATTACH_NODES: int
    JOINT_ATTACH_POINTS: int
    JOINT_ATTACH_SURFACES: int
    JOINT_ATTACH_UNKNOWN: int
    JOINT_CONVEL: int
    JOINT_CYLDR: int
    JOINT_FIXED: int
    JOINT_INLINE: int
    JOINT_REVOLUTE: int
    JOINT_SCREW: int
    JOINT_SLIDER: int
    JOINT_SLIUNV: int
    JOINT_SPHERE: int
    JOINT_UNIVSEL: int
    JOINT_UNKNOWN: int
    EXPAND_BOTH: int
    EXPAND_BOUNDARY: int
    EXPAND_INTERIOR: int
    EXPAND_CJOINT_RBE2: int
    EXPAND_CJOINT_RBE3: int
    KINEMATIC_CONNECTION: int
    KINEMATIC_JOINT: int
    KINEMATIC_UNKNOWN: int
    AERO_PNL_BODY: int
    AERO_PNL_SURF: int
    FAL_CENTER: int
    FAL_LEFT: int
    FAL_RIGHT: int
    AAF_BIGENDIAN: int
    AAF_FORMATTED: int
    AAF_LITTLEENDIAN: int
    AAF_NONE: int
    AAF_UNFORMATTED: int
    EXTSEOUTTO_DMIGOP2: int
    EXTSEOUTTO_DMIGPCH: int
    EXTSEOUTTO_MATOP4: int
    EXTSEREF_TYPE_OP2: int
    EXTSEREF_TYPE_OP4: int
    EXTSEREF_TYPE_PCH: int
    FAM_ABAQUS: int
    FAM_ANSYS: int
    FAM_FEMAP_STRUCTURAL: int
    FAM_LS_DYNA: int
    FAM_MARC: int
    FAM_MSC_NASTRAN: int
    FAM_NE_NASTRAN: int
    FAM_NX_NASTRAN: int
    FAM_UNKNOWN: int
    FAP_ABAQUS: int
    FAP_ADINA: int
    FAP_ALGOR: int
    FAP_ANSYS: int
    FAP_AP_SATOOLKIT: int
    FAP_CAEFEM: int
    FAP_CDA_SPRINT: int
    FAP_CFDESIGN: int
    FAP_COSMIC_NASTRAN: int
    FAP_COSMOS: int
    FAP_CSA_NASTRAN: int
    FAP_FEMAP_GEN: int
    FAP_FEMAP_STRUCTURAL: int
    FAP_GENESIS: int
    FAP_IDEAS: int
    FAP_LS_DYNA: int
    FAP_MARC: int
    FAP_ME_NASTRAN: int
    FAP_MSC_NASTRAN: int
    FAP_NEUTRAL: int
    FAP_NE_NASTRAN: int
    FAP_NX_NASTRAN: int
    FAP_ODBC: int
    FAP_PAL: int
    FAP_PAL2: int
    FAP_PATRAN: int
    FAP_PC_NASTRAN: int
    FAP_SAP: int
    FAP_SINDA: int
    FAP_STAAD: int
    FAP_STARDYNE: int
    FAP_TABLE: int
    FAP_TMG: int
    FAP_UAI_NASTRAN: int
    FAP_UNKNOWN: int
    FAP_VR_NASTRAN: int
    FAP_WECAN: int
    FTR_ABAQUS: int
    FTR_ACIS: int
    FTR_ADINA: int
    FTR_ALGOR: int
    FTR_ANSYS: int
    FTR_ANSYS_PC_LINEAR: int
    FTR_CAEFEM: int
    FTR_CATIA: int
    FTR_CATIA_V5: int
    FTR_CDA_SPRINT: int
    FTR_CFDESIGN: int
    FTR_COSMIC_NASTRAN: int
    FTR_COSMOS: int
    FTR_CSA_NASTRAN: int
    FTR_DXF: int
    FTR_FEMAP_NEUTRAL: int
    FTR_FIBERSIM: int
    FTR_GENESIS: int
    FTR_IDEAS: int
    FTR_IGES: int
    FTR_JT: int
    FTR_LS_DYNA: int
    FTR_MARC: int
    FTR_ME_NASTRAN: int
    FTR_MODEL_SOLUTION: int
    FTR_MSC_NASTRAN: int
    FTR_NCODE_NOT_USED: int
    FTR_NE_NASTRAN: int
    FTR_NONE: int
    FTR_NX_NASTRAN: int
    FTR_ODBC: int
    FTR_PAL_2: int
    FTR_PARASOLID: int
    FTR_PATRAN: int
    FTR_PC_NASTRAN: int
    FTR_PROE: int
    FTR_SAP: int
    FTR_SINDA: int
    FTR_SLA: int
    FTR_SOLIDEDGE: int
    FTR_SOLIDWORKS: int
    FTR_STAAD: int
    FTR_STARDYNE: int
    FTR_STEP: int
    FTR_TABLE: int
    FTR_TMG: int
    FTR_TOSCA: int
    FTR_UAI_NASTRAN: int
    FTR_UNIGRAPHICS: int
    FTR_VDA: int
    FTR_VR_NASTRAN: int
    FTR_WECAN: int
    FAT_601_STATIC: int
    FAT_601_TRANSIENT: int
    FAT_701_EXPLICIT: int
    FAT_AERO_FLUTTER: int
    FAT_AERO_STATIC: int
    FAT_CFD: int
    FAT_DATA_RECOVERY: int
    FAT_DESIGN_OPTIMIZATION: int
    FAT_EXPLICIT: int
    FAT_FATIGUE: int
    FAT_FREQUENCY_RESPONSE: int
    FAT_IMPLICIT_NONLINEAR: int
    FAT_LINEAR_BUCKLING: int
    FAT_LSDYNA_IMPLICIT: int
    FAT_MODES: int
    FAT_MULTISTEP_KINEMATIC: int
    FAT_MULTISTEP_NONLINEAR: int
    FAT_NONLINEAR_BUCKLING: int
    FAT_NONLINEAR_STATIC: int
    FAT_NONLINEAR_TRANSIENT: int
    FAT_RANDOM: int
    FAT_RESPONSE_SPECTRUM: int
    FAT_STATIC: int
    FAT_STEADY_STATE_HEAT: int
    FAT_TRANSIENT: int
    FAT_TRANSIENT_HEAT: int
    FAT_UNKNOWN: int
    FARS_CYLINDER: int
    FARS_REVOLUTION: int
    FARS_SEGMENTS: int
    APIWARN_EVERY: int
    APIWARN_NEVER: int
    APIWARN_ONCEPERITEM: int
    APIWARN_ONCEPERSESSION: int
    FRA_ERROR: int
    FRA_OPEN: int
    FRA_OPEN_CHECK: int
    FRA_UNLOADED: int
    FRA_UNLOAD_CHECK: int
    FBG_CYLINDER: int
    FBG_DOF: int
    FBG_GENERAL: int
    FBG_SURFDIRSLIDING: int
    FBG_SURFNONSLIDING: int
    FBG_SURFSLIDING: int
    FBMC_SC_ALL: int
    FBMC_SC_AXIAL: int
    FBMC_SC_COMBSHEAR: int
    FBMC_SC_MAXPRIN: int
    FBMC_SC_MAXSHEAR: int
    FBMC_SC_MINPRIN: int
    FBMC_SC_VONMISES: int
    FBMC_SC_YSHEAR: int
    FBMC_SC_ZSHEAR: int
    FCS_CYLINDRICAL: int
    FCS_RECTANGULAR: int
    FCS_SPHERICAL: int
    FCH_AXISSTYLE_LINEAR: int
    FCH_AXISSTYLE_LOG: int
    FCCL_BOTTOM: int
    FCCL_OFF: int
    FCCL_TOP: int
    FCH_LEGEND_DIRECTION_LEFTTORIGHT: int
    FCH_LEGEND_DIRECTION_TOPTOBOTTOM: int
    FCH_LEGEND_LOCATION_CENTER: int
    FCH_LEGEND_LOCATION_FAR: int
    FCH_LEGEND_LOCATION_FAROUTSIDE: int
    FCH_LEGEND_LOCATION_NEAR: int
    FCH_LEGEND_LOCATION_NEAROUTSIDE: int
    FCH_MARKERSTYLE_CIRCLE: int
    FCH_MARKERSTYLE_DIAMOND: int
    FCH_MARKERSTYLE_HEXAGON: int
    FCH_MARKERSTYLE_PENTAGON: int
    FCH_MARKERSTYLE_SQUARE: int
    FCH_MARKERSTYLE_STAR: int
    FCH_MARKERSTYLE_TRIANGLE: int
    FCH_FORMAT_PERCENTAGE: int
    FCH_FORMAT_SCIENTIFIC: int
    FCH_FORMAT_STANDARD: int
    FCH_PALETTE_BLUE: int
    FCH_PALETTE_BROWN: int
    FCH_PALETTE_CUSTOM: int
    FCH_PALETTE_FEMAP: int
    FCH_PALETTE_GRAY: int
    FCH_PALETTE_GREEN: int
    FCH_PALETTE_OFFICE: int
    FCH_PALETTE_RED: int
    FCH_PALETTE_VIBRANT: int
    FCSC_ADD: int
    FCSC_DIVIDE: int
    FCSC_MULTIPLY: int
    FCSC_SUBTRACT: int
    FCSCM_MATCHMODEL: int
    FCSCM_MATCHVIEW: int
    FCSCM_NONE: int
    FCSCM_SYNC: int
    FCHD_TYPE_COMBO: int
    FCHD_TYPE_COMBOVAL: int
    FCHD_TYPE_CPLXEXP: int
    FCHD_TYPE_FUNCTION: int
    FCHD_TYPE_ID: int
    FCHD_TYPE_POSITION: int
    FCHD_TYPE_SET: int
    FCHD_TYPE_SETVAL: int
    FCHD_TYPE_VECVEC: int
    FCH_STYLE_AREA: int
    FCH_STYLE_AREASTEP: int
    FCH_STYLE_LINE: int
    FCH_STYLE_LINEFAST: int
    FCH_STYLE_LINESTEP: int
    FCH_STYLE_POINT: int
    FCH_TEXT_JUSTIFICATION_CENTER: int
    FCH_TEXT_JUSTIFICATION_LEFT: int
    FCH_TEXT_JUSTIFICATION_RIGHT: int
    FCH_TITLE_LOCATION_BOTTOM: int
    FCH_TITLE_LOCATION_LEFT: int
    FCH_TITLE_LOCATION_RIGHT: int
    FCH_TITLE_LOCATION_TOP: int
    FCL_AQUAMARINE: int
    FCL_AVOCADO: int
    FCL_BLACK: int
    FCL_BLUE: int
    FCL_BLUEINDIGO: int
    FCL_BLUELIME: int
    FCL_BLUEVIOLET: int
    FCL_BRIGHTCHARTREUSE: int
    FCL_BRIGHTCOBALT: int
    FCL_BRIGHTLIME: int
    FCL_BRIGHTTURQUOISE: int
    FCL_BRIGHTVIOLET: int
    FCL_BROWN: int
    FCL_CAMOUFLAGEGREEN: int
    FCL_CERISE: int
    FCL_CERULEAN: int
    FCL_CHARTREUSE: int
    FCL_COBALT: int
    FCL_CORAL: int
    FCL_CRIMSON: int
    FCL_CYAN: int
    FCL_DARKBLUE: int
    FCL_DARKCERULEAN: int
    FCL_DARKCYAN: int
    FCL_DARKESTGREEN: int
    FCL_DARKGOLDENROD: int
    FCL_DARKGRAY: int
    FCL_DARKKHAKI: int
    FCL_DARKOLIVEGREEN: int
    FCL_DARKPASTELGREEN: int
    FCL_DARKRASPBERRY: int
    FCL_DARKRED: int
    FCL_DARKSEAGREEN: int
    FCL_DARKSLATEBLUE: int
    FCL_DARKSLATEGRAY: int
    FCL_DARKTURQUOISE: int
    FCL_DARKVIOLET: int
    FCL_DEEPPINK: int
    FCL_DEEPSKYBLUE: int
    FCL_DODGERBLUE: int
    FCL_EGGPLANT: int
    FCL_FERNGREEN: int
    FCL_FIREBRICK: int
    FCL_FORESTGREEN: int
    FCL_FUCHSIA: int
    FCL_GOLD: int
    FCL_GOLDENROD: int
    FCL_GRAY: int
    FCL_GRAY10: int
    FCL_GRAY100: int
    FCL_GRAY110: int
    FCL_GRAY120: int
    FCL_GRAY130: int
    FCL_GRAY140: int
    FCL_GRAY150: int
    FCL_GRAY160: int
    FCL_GRAY170: int
    FCL_GRAY180: int
    FCL_GRAY190: int
    FCL_GRAY20: int
    FCL_GRAY200: int
    FCL_GRAY210: int
    FCL_GRAY220: int
    FCL_GRAY230: int
    FCL_GRAY240: int
    FCL_GRAY250: int
    FCL_GRAY30: int
    FCL_GRAY40: int
    FCL_GRAY50: int
    FCL_GRAY60: int
    FCL_GRAY70: int
    FCL_GRAY80: int
    FCL_GRAY90: int
    FCL_GRAYBEIGE: int
    FCL_GRAYBEIGE_DARK: int
    FCL_GRAYBEIGE_EXTRADARK: int
    FCL_GRAYBEIGE_EXTRALIGHT: int
    FCL_GRAYBEIGE_LIGHT: int
    FCL_GRAYBLUE: int
    FCL_GRAYBLUE_DARK: int
    FCL_GRAYBLUE_EXTRADARK: int
    FCL_GRAYBLUE_EXTRALIGHT: int
    FCL_GRAYBLUE_LIGHT: int
    FCL_GRAYGREEN: int
    FCL_GRAYGREEN_DARK: int
    FCL_GRAYGREEN_EXTRADARK: int
    FCL_GRAYGREEN_EXTRALIGHT: int
    FCL_GRAYGREEN_LIGHT: int
    FCL_GREEN: int
    FCL_GREENYELLOW: int
    FCL_HOTPINK: int
    FCL_INDIGO: int
    FCL_JADE: int
    FCL_LEMONCHIFFON: int
    FCL_LIGHTGREEN: int
    FCL_LIGHTSALMON: int
    FCL_LIGHTSPRINGGREEN: int
    FCL_LIME: int
    FCL_LIMEGREEN: int
    FCL_MAGENTA: int
    FCL_MAROON: int
    FCL_MAUVE: int
    FCL_MEDIUMAQUAMARINE: int
    FCL_MEDIUMBLUE: int
    FCL_MEDIUMORCHID: int
    FCL_MEDIUMPURPLE: int
    FCL_MEDIUMSLATEBLUE: int
    FCL_MEDIUMSPRINGGREEN: int
    FCL_MEDIUMTURQUOISE: int
    FCL_MEDIUMVIOLETRED: int
    FCL_MIDNIGHTBLUE: int
    FCL_MINTCREAM: int
    FCL_NOTEYELLOW: int
    FCL_OLDGOLD: int
    FCL_OLIVE: int
    FCL_OLIVEYELLOW: int
    FCL_ORANGE: int
    FCL_ORANGERED: int
    FCL_ORCHID: int
    FCL_PALEBLUE: int
    FCL_PALEBLUEPURPLE: int
    FCL_PALEBRIGHTGREEN: int
    FCL_PALECOBALT: int
    FCL_PALELIME: int
    FCL_PALELIMEGREEN: int
    FCL_PALEOLIVE: int
    FCL_PALEPINK: int
    FCL_PALEPURPLE: int
    FCL_PALEREDVIOLET: int
    FCL_PALESKYBLUE: int
    FCL_PALEYELLOW: int
    FCL_PERSIANBLUE: int
    FCL_PERU: int
    FCL_PINEGREEN: int
    FCL_PINK: int
    FCL_PINKCERISE: int
    FCL_PLUM: int
    FCL_POWDERBLUE: int
    FCL_PURPLE: int
    FCL_RASPBERRY: int
    FCL_RED: int
    FCL_REDPINK: int
    FCL_ROSYBROWN: int
    FCL_ROYALBLUE: int
    FCL_SANDYBROWN: int
    FCL_SEAGREEN: int
    FCL_SEPIA: int
    FCL_SIENNA: int
    FCL_SILVER: int
    FCL_SKYBLUE: int
    FCL_SLATEBLUE: int
    FCL_SPRINGGREEN: int
    FCL_STEELBLUE: int
    FCL_TEAGREEN: int
    FCL_THISTLE: int
    FCL_TOMATO: int
    FCL_TURQUOISE: int
    FCL_USER1: int
    FCL_USER10: int
    FCL_USER2: int
    FCL_USER3: int
    FCL_USER4: int
    FCL_USER5: int
    FCL_USER6: int
    FCL_USER7: int
    FCL_USER8: int
    FCL_USER9: int
    FCL_VIOLET: int
    FCL_VIOLETEGGPLANT: int
    FCL_VIRIDIAN: int
    FCL_WHITE: int
    FCL_WISTERIA: int
    FCL_YELLOW: int
    FCL_YELLOWGREEN: int
    FCL_YELLOWLIMEGREEN: int
    FPF_BDIAGONAL: int
    FPF_CROSS: int
    FPF_DIAGCROSS: int
    FPF_FDIAGONAL: int
    FPF_HORIZONTAL: int
    FPF_SOLID: int
    FPF_TRANSPARENT1: int
    FPF_TRANSPARENT2: int
    FPF_TRANSPARENT3: int
    FPF_TRANSPARENT4: int
    FPF_TRANSPARENT5: int
    FPF_TRANSPARENT6: int
    FPF_TRANSPARENT7: int
    FPF_TRANSPARENT8: int
    FPF_VERTICAL: int
    FPL_DASH: int
    FPL_DASHDOT: int
    FPL_DASHDOTDOT: int
    FPL_DOT: int
    FPL_SOLID: int
    FPL_THICK2: int
    FPL_THICK3: int
    FPL_THICK4: int
    FCOM_ALL: int
    FCOM_COLOR: int
    FCOM_LINESTYLE: int
    FCOM_PATTERN: int
    FCC_BOTH: int
    FCC_OFF: int
    FCC_ON: int
    FCPT_CONTACT: int
    FCPT_GLUED: int
    FRT_BOLT: int
    FRT_CONNECTION: int
    FRT_FLUID: int
    FRT_NSM: int
    FRT_ROTOR: int
    FCF_BEAM_DIAGRAM: int
    FCF_CONTOUR: int
    FCF_CONTOUR_VECTOR: int
    FCF_CRITERIA: int
    FCF_ISOSURFACE: int
    FCF_MODEL_COLOR: int
    FCF_NONE: int
    FCF_SECTION_CUT: int
    FPC_ABOVE_MAX: int
    FPC_AT: int
    FPC_BELOW_MIN: int
    FPC_BETWEEN: int
    FPC_OUTSIDE: int
    FCPPR_DUP_MATL: int
    FCPPR_DUP_PROP: int
    FCPPR_KEEP: int
    FCPPR_OVERRIDE: int
    FCPRNM_BLOCK: int
    FCPRNM_DEFAULT: int
    FCPRNM_OFFSET: int
    FCMT_FREEEDGE: int
    FCMT_MANIFOLD: int
    FCMT_NONMANIFOLD: int
    FCMT_UNKNOWN: int
    FCMT_WIREEDGE: int
    FCO_POINT: int
    FCO_RADIAL: int
    FCO_VECTOR: int
    FCR_BY_LOCATION: int
    FCR_BY_LOCATION_REV: int
    FCR_BY_VECTOR: int
    FCR_BY_VECTOR_REV: int
    FCRO_AGGRESSIVE: int
    FCRO_COMBINE: int
    FCRO_NORMAL: int
    FCU_ARC: int
    FCU_BSPLINE: int
    FCU_CIRCLE: int
    FCU_COMPOSITE: int
    FCU_LINE: int
    FCU_SOLID: int
    FCU_SPLINE: int
    FMDC_AVG: int
    FMDC_AVG_SKIP_CORNER: int
    FMDC_MAX: int
    FMDC_MAX_SKIP_CORNER: int
    FMDC_MIN: int
    FMDC_MIN_SKIP_CORNER: int
    FMDC_VU: int
    FCT_BOOL: int
    FCT_DOUBLE: int
    FCT_INT: int
    FCT_STRING: int
    FSF_CSV: int
    FSF_HTML: int
    FSF_RTF: int
    FSF_TEXT: int
    FT_AERO_PANEL: int
    FT_AERO_PROP: int
    FT_AERO_SPLINE: int
    FT_AERO_SURF: int
    FT_AMGR_CASE: int
    FT_AMGR_DIR: int
    FT_ANALYSIS_STUDY: int
    FT_BCO: int
    FT_BCO_GEOM: int
    FT_BC_DEFINITION: int
    FT_BC_DIR: int
    FT_BEQ: int
    FT_BOLT_PRELOAD: int
    FT_BOUNDARY: int
    FT_CHART: int
    FT_CHART_SERIES: int
    FT_CONNECTION: int
    FT_CONNECTION_PROP: int
    FT_CONTACT: int
    FT_CSYS: int
    FT_CURVE: int
    FT_DATA_SURF: int
    FT_DESIGN_EQUATION: int
    FT_DESIGN_OPT: int
    FT_DISCRETE_VALUE: int
    FT_DISCRETE_VALUE_DIR: int
    FT_DRIVER_LOAD: int
    FT_ELEM: int
    FT_ETHERM_LOAD: int
    FT_FLEXIBLE_SLIDER: int
    FT_FREEBODY: int
    FT_FREQUENCY: int
    FT_FUNCTION_DIR: int
    FT_FUNCTION_TABLE: int
    FT_GEOM_LOAD: int
    FT_GROUP: int
    FT_JOINT: int
    FT_LAYER: int
    FT_LAYUP: int
    FT_LAYUP_GLOBALPLY: int
    FT_LAYUP_PLY: int
    FT_LOAD_DEFINITION: int
    FT_LOAD_DIR: int
    FT_MATL: int
    FT_MATL_TABLE: int
    FT_MATRIX_INPUT: int
    FT_MESH_POINT: int
    FT_MESH_POINT_DEFINITION: int
    FT_MODEL_NOTES: int
    FT_MONITOR_POINT: int
    FT_NODE: int
    FT_NTHERM_LOAD: int
    FT_OPT_MANCON: int
    FT_OPT_REL: int
    FT_OPT_RESP: int
    FT_OUT_CASE: int
    FT_OUT_DATA: int
    FT_OUT_DIR: int
    FT_PLANE: int
    FT_POINT: int
    FT_PROP: int
    FT_REFERENCE: int
    FT_REPORT: int
    FT_RES_ATTACH: int
    FT_SOLID: int
    FT_SOLID_VOLUME: int
    FT_SURFACE: int
    FT_SURF_LOAD: int
    FT_TABLE_DATA: int
    FT_TEXT: int
    FT_TMG_BCO: int
    FT_TMG_CONTROL: int
    FT_TMG_INTEGER: int
    FT_TMG_OPTION: int
    FT_TMG_REAL: int
    FT_VAR: int
    FT_VECTOR: int
    FT_VIEW: int
    FT_VOLUME: int
    FDF_ANIMATE: int
    FDF_ANIMATE_MULTICASE: int
    FDF_ARROW: int
    FDF_DEFORMED: int
    FDF_MODEL_UNDEF: int
    FDF_NONE: int
    FDF_STREAMLINE: int
    FDF_TRACE: int
    FET_L_AXISYM: int
    FET_L_AXISYM_SHELL: int
    FET_L_BAR: int
    FET_L_BEAM: int
    FET_L_BENDING: int
    FET_L_COHESIVE_SOLID: int
    FET_L_CONTACT: int
    FET_L_CURVED_BEAM: int
    FET_L_CURVED_TUBE: int
    FET_L_DOF_SPRING: int
    FET_L_DOF_SPRING_TO_GROUND: int
    FET_L_GAP: int
    FET_L_GENERAL_MATRIX: int
    FET_L_LAMINATE_PLATE: int
    FET_L_LAMINATE_SOLID: int
    FET_L_LINK: int
    FET_L_MASS: int
    FET_L_MASS_MATRIX: int
    FET_L_MEMBRANE: int
    FET_L_NASTRAN_MATRIX: int
    FET_L_PLANE_STRAIN: int
    FET_L_PLATE: int
    FET_L_PLOT: int
    FET_L_PLOT_PLATE: int
    FET_L_RIGID: int
    FET_L_ROD: int
    FET_L_SHEAR: int
    FET_L_SLIDE_LINE: int
    FET_L_SOLID: int
    FET_L_SPRING: int
    FET_L_SPRING_TO_GROUND: int
    FET_L_TUBE: int
    FET_L_WELD: int
    FET_NONE: int
    FET_P_AXISYM: int
    FET_P_AXISYM_SHELL: int
    FET_P_BEAM: int
    FET_P_BENDING: int
    FET_P_COHESIVE_SOLID: int
    FET_P_LAMINATE_PLATE: int
    FET_P_LAMINATE_SOLID: int
    FET_P_MEMBRANE: int
    FET_P_PLANE_STRAIN: int
    FET_P_PLATE: int
    FET_P_SHEAR: int
    FET_P_SOLID: int
    FEVENT_ANALYSISEND: int
    FEVENT_CLOSINGMODEL: int
    FEVENT_COMMAND: int
    FEVENT_DRAWEND: int
    FEVENT_DRAWSTART: int
    FEVENT_ENDMODEL: int
    FEVENT_FILEIMPORTEND: int
    FEVENT_FILEOPENEND: int
    FEVENT_INITIALIZE: int
    FEVENT_LEAVINGMODEL: int
    FEVENT_NEWMODEL: int
    FEVENT_PROGEND: int
    FEVENT_PROGSTART: int
    FEVENT_RESULTSEND: int
    FEVENT_SELECTOR: int
    FEVENT_SHUTDOWN: int
    FEVENT_SWITCHMODEL: int
    FEVENT_UPDATEDSAVEDSET: int
    FEX_EXISTING: int
    FEX_NONEXISTING: int
    FBC_FX: int
    FBC_FY: int
    FBC_FZ: int
    FBC_MX: int
    FBC_MY: int
    FBC_MZ: int
    FBL_APPLIED: int
    FBL_CONTACT: int
    FBL_EL_FB: int
    FBL_EL_PER: int
    FBL_GLUE: int
    FBL_MPC: int
    FBL_SPC: int
    FBL_TOTAL: int
    FBD_DISPLAYMODE_FREEBODY: int
    FBD_DISPLAYMODE_INTERFACE: int
    FBD_DISPLAYMODE_SECTION: int
    FBD_SECTMODE_CURVE: int
    FBD_SECTMODE_PLANENORMAL: int
    FBD_SECTMODE_PLANEVECTOR: int
    FBD_SECTMODE_VECTOR: int
    FBD_SECTION_SUMLOC_BASE: int
    FBD_SECTION_SUMLOC_CENTROID: int
    FBD_SECTION_SUMLOC_LOCATION: int
    FBD_VEC_MODE_COMPONENT: int
    FBD_VEC_MODE_OFF: int
    FBD_VEC_MODE_RESULTANT: int
    FEAT_FMP_XCELERATOR_SHARE: int
    FEAT_MAYA_ADVANCED_THERMAL: int
    FEAT_MAYA_FLOW: int
    FEAT_MAYA_THERMAL: int
    FEAT_MAYA_TOOLKIT: int
    FEAT_NX_NASTRAN_ADV_NONLINEAR: int
    FEAT_NX_NASTRAN_ADV_NONLINEAR_EXPLICIT: int
    FEAT_NX_NASTRAN_AERO_BASIC: int
    FEAT_NX_NASTRAN_BASIC: int
    FEAT_NX_NASTRAN_DMAP: int
    FEAT_NX_NASTRAN_DMP: int
    FEAT_NX_NASTRAN_DYNAMICS: int
    FEAT_NX_NASTRAN_NONLINEAR: int
    FEAT_NX_NASTRAN_OPTIMIZATION: int
    FEAT_NX_NASTRAN_RDMODES: int
    FEAT_NX_NASTRAN_ROTORDYN: int
    FEAT_NX_NASTRAN_SUPERELEMENTS: int
    FEAT_NX_NASTRAN_TOPOLOGY_OPTIMIZATION: int
    FEAT_NX_NASTRAN_USS: int
    FLNG_AUTO: int
    FLNG_CN: int
    FLNG_DE: int
    FLNG_EN: int
    FLNG_JP: int
    FLNG_TW: int
    FREQ: int
    FREQ1: int
    FREQ2: int
    FREQ3: int
    FREQ4: int
    FREQ5: int
    FTB_ACCELLOC: int
    FTB_ACCFREQ: int
    FTB_AEROFACTOR: int
    FTB_ANGACCFREQ: int
    FTB_ANGLEINCIDENCE: int
    FTB_ANGVELFREQ: int
    FTB_CRITDAMP: int
    FTB_CURVELENGTH: int
    FTB_CURVEPARAM: int
    FTB_DAMPFUNC: int
    FTB_DIRECTIONINCIDENCE: int
    FTB_DISPFREQ: int
    FTB_FORCEFREQ: int
    FTB_FREQ: int
    FTB_FUNCSTRAINRATE: int
    FTB_FUNCTEMP: int
    FTB_FUNCVAL: int
    FTB_GDAMP: int
    FTB_HEATFLOWRATE: int
    FTB_LATITUDE: int
    FTB_MACHFREQ: int
    FTB_MASSFLOWRATE: int
    FTB_MODE: int
    FTB_MOMENTFREQ: int
    FTB_NONE: int
    FTB_PLASTICSTRAIN: int
    FTB_PRESSURE: int
    FTB_QDAMP: int
    FTB_ROTFREQ: int
    FTB_STRAINFREQ: int
    FTB_STRAINRATE: int
    FTB_STRAINSTRESS: int
    FTB_STRESSFREQ: int
    FTB_STRESSSTRAIN: int
    FTB_TBLM1LINLIN: int
    FTB_TBLM1LINLOG: int
    FTB_TBLM1LOGLIN: int
    FTB_TBLM1LOGLOG: int
    FTB_TBLM5DAMAGEFORCE: int
    FTB_TEMP: int
    FTB_TEMPDIFF: int
    FTB_THERMALCAPACITANCE: int
    FTB_TIME: int
    FTB_TRUEPLASTICSTRAIN: int
    FTB_TRUESTRAINSTRESS: int
    FTB_VELFREQ: int
    FTB_VELOCITY: int
    FTB_VOLUMEFLOWRATE: int
    FTB_WAVELENGTH: int
    GAM_ABSOLUTE: int
    GAM_SCALED: int
    GAS_DOUBLE_LINE: int
    GAS_DOUBLE_SOLID: int
    GAS_LINE: int
    GAS_REV_DOUBLE_LINE: int
    GAS_REV_DOUBLE_SOLID: int
    GAS_SOLID: int
    GEF_ALL: int
    GEF_EDGE1: int
    GEF_EDGE2: int
    GEF_EDGE3: int
    GEF_EDGE4: int
    GEF_NONE: int
    GPS_BLANK: int
    GPS_CIRCLE: int
    GPS_CIRCLE_FILLED: int
    GPS_CROSS: int
    GPS_DIAMOND: int
    GPS_POINT: int
    GPS_SMALL_TRIANGLE: int
    GPS_SQUARE: int
    GPS_SQUARE_FILLED: int
    GPS_TRIANGLE: int
    GPS_X: int
    GIFC_DITHER: int
    GIFC_NET: int
    GIFC_OCTREE: int
    FGB_ADD: int
    FGB_INALL: int
    FGB_NOTINALL: int
    FGB_NOTINANY: int
    FGB_ONLYINONE: int
    FGB_SUBTRACT: int
    FGR_BCO: int
    FGR_BEQ: int
    FGR_CBCO: int
    FGR_CLOAD: int
    FGR_CONNECTION: int
    FGR_CONNECTIONPROP: int
    FGR_CONTACT: int
    FGR_CSYS: int
    FGR_CURVE: int
    FGR_ELEM: int
    FGR_ELOAD: int
    FGR_LAYUP: int
    FGR_MATL: int
    FGR_MESHPOINT: int
    FGR_NLOAD: int
    FGR_NODE: int
    FGR_PBCO: int
    FGR_PLOAD: int
    FGR_POINT: int
    FGR_PROP: int
    FGR_REGLOAD: int
    FGR_SBCO: int
    FGR_SLOAD: int
    FGR_SOLID: int
    FGR_SURFACE: int
    FGR_TEXT: int
    FGR_VOLUME: int
    FGD_AEROCTRLSURF_BYCOLOR: int
    FGD_AEROCTRLSURF_BYLAYER: int
    FGD_AEROCTRLSURF_ID: int
    FGD_AEROPANEL_BYCOLOR: int
    FGD_AEROPANEL_BYLAYER: int
    FGD_AEROPANEL_BYPROP: int
    FGD_AEROPANEL_ID: int
    FGD_AEROPROP_BYCOLOR: int
    FGD_AEROPROP_BYLAYER: int
    FGD_AEROPROP_ID: int
    FGD_AEROSPLINE_BYCOLOR: int
    FGD_AEROSPLINE_BYLAYER: int
    FGD_AEROSPLINE_BYPANEL: int
    FGD_AEROSPLINE_ID: int
    FGD_BCO_BYCURVE: int
    FGD_BCO_BYPOINT: int
    FGD_BCO_BYSURFACE: int
    FGD_BCO_ID: int
    FGD_BEQ_BYNODE: int
    FGD_CONNECTIONPROP_BYCOLOR: int
    FGD_CONNECTIONPROP_BYLAYER: int
    FGD_CONNECTIONPROP_ID: int
    FGD_CONNECTIONPROP_ONCONNECTION: int
    FGD_CONNECTION_BYCOLOR: int
    FGD_CONNECTION_BYCONTACT: int
    FGD_CONNECTION_BYLAYER: int
    FGD_CONNECTION_BYPROP: int
    FGD_CONNECTION_ID: int
    FGD_CONTACT_BYCOLOR: int
    FGD_CONTACT_BYCURVE: int
    FGD_CONTACT_BYELEM: int
    FGD_CONTACT_BYLAYER: int
    FGD_CONTACT_BYNODE: int
    FGD_CONTACT_BYPROP: int
    FGD_CONTACT_BYSURFACE: int
    FGD_CONTACT_ID: int
    FGD_CONTACT_ONCONNECTION: int
    FGD_CONTACT_ONSOLID: int
    FGD_CSYS_BYCOLOR: int
    FGD_CSYS_BYDEFCSYS: int
    FGD_CSYS_BYLAYER: int
    FGD_CSYS_BYTYPE: int
    FGD_CSYS_ID: int
    FGD_CSYS_ONCSYS: int
    FGD_CSYS_ONELEM: int
    FGD_CSYS_ONNODE: int
    FGD_CSYS_ONPOINT: int
    FGD_CSYS_ONPROP: int
    FGD_CURVE_BYCOLOR: int
    FGD_CURVE_BYLAYER: int
    FGD_CURVE_BYPOINT: int
    FGD_CURVE_BYPROP: int
    FGD_CURVE_ID: int
    FGD_CURVE_ONREGION: int
    FGD_CURVE_ONSOLID: int
    FGD_CURVE_ONSURFACE: int
    FGD_ELEM_ALLNODESONSOLID: int
    FGD_ELEM_ATCURVE: int
    FGD_ELEM_ATCURVESOFSOLID: int
    FGD_ELEM_ATPOINT: int
    FGD_ELEM_ATPOINTSOFSOLID: int
    FGD_ELEM_ATSOLID: int
    FGD_ELEM_ATSURFACE: int
    FGD_ELEM_ATSURFACESOFSOLID: int
    FGD_ELEM_BYALLNODES: int
    FGD_ELEM_BYCOLOR: int
    FGD_ELEM_BYGLOBALPLY: int
    FGD_ELEM_BYLAYER: int
    FGD_ELEM_BYLAYUP: int
    FGD_ELEM_BYMATL: int
    FGD_ELEM_BYNODE: int
    FGD_ELEM_BYORIENTNODE: int
    FGD_ELEM_BYPROP: int
    FGD_ELEM_BYSHAPE: int
    FGD_ELEM_BYTYPE: int
    FGD_ELEM_ID: int
    FGD_ELEM_ONREGION: int
    FGD_LAYUP_BYGLOBALPLY: int
    FGD_LAYUP_BYMATL: int
    FGD_LAYUP_ID: int
    FGD_LAYUP_ONPROP: int
    FGD_LOAD_BYCURVE: int
    FGD_LOAD_BYELEM: int
    FGD_LOAD_BYNODE: int
    FGD_LOAD_BYPOINT: int
    FGD_LOAD_BYREGION: int
    FGD_LOAD_BYSURFACE: int
    FGD_MATL_BYCOLOR: int
    FGD_MATL_BYLAYER: int
    FGD_MATL_BYTYPE: int
    FGD_MATL_ID: int
    FGD_MATL_ONELEM: int
    FGD_MATL_ONPROP: int
    FGD_MESHPOINT_BYCOLOR: int
    FGD_MESHPOINT_BYCURVE: int
    FGD_MESHPOINT_BYLAYER: int
    FGD_MESHPOINT_BYPOINT: int
    FGD_MESHPOINT_BYSOLID: int
    FGD_MESHPOINT_BYSURFACE: int
    FGD_MESHPOINT_ID: int
    FGD_NODE_ATCURVE: int
    FGD_NODE_ATCURVESOFSOLID: int
    FGD_NODE_ATPOINT: int
    FGD_NODE_ATPOINTSOFSOLID: int
    FGD_NODE_ATSOLID: int
    FGD_NODE_ATSURFACE: int
    FGD_NODE_ATSURFACESOFSOLID: int
    FGD_NODE_BYCOLOR: int
    FGD_NODE_BYDEFCSYS: int
    FGD_NODE_BYLAYER: int
    FGD_NODE_BYOUTCSYS: int
    FGD_NODE_BYSUPERELEMENT: int
    FGD_NODE_BYTYPE: int
    FGD_NODE_ID: int
    FGD_NODE_ONELEM: int
    FGD_NODE_ONELEMASORIENT: int
    FGD_NODE_ONREGION: int
    FGD_POINT_BYCOLOR: int
    FGD_POINT_BYDEFCSYS: int
    FGD_POINT_BYLAYER: int
    FGD_POINT_BYPROP: int
    FGD_POINT_ID: int
    FGD_POINT_ONCURVE: int
    FGD_POINT_ONSOLID: int
    FGD_POINT_ONSURFACE: int
    FGD_PROP_BYCOLOR: int
    FGD_PROP_BYLAYER: int
    FGD_PROP_BYLAYUP: int
    FGD_PROP_BYMATL: int
    FGD_PROP_BYTYPE: int
    FGD_PROP_ID: int
    FGD_PROP_ONCURVE: int
    FGD_PROP_ONELEM: int
    FGD_PROP_ONPOINT: int
    FGD_PROP_ONREGION: int
    FGD_PROP_ONSOLID: int
    FGD_PROP_ONSURFACE: int
    FGD_SOLID_BYCOLOR: int
    FGD_SOLID_BYCURVE: int
    FGD_SOLID_BYLAYER: int
    FGD_SOLID_BYPROP: int
    FGD_SOLID_BYSURFACE: int
    FGD_SOLID_BYTYPE: int
    FGD_SOLID_ID: int
    FGD_SURFACE_BYCOLOR: int
    FGD_SURFACE_BYCURVE: int
    FGD_SURFACE_BYLAYER: int
    FGD_SURFACE_BYPROP: int
    FGD_SURFACE_ID: int
    FGD_SURFACE_ONREGION: int
    FGD_SURFACE_ONSOLID: int
    FGD_SURFACE_ONVOLUME: int
    FGD_TEXT_BYCOLOR: int
    FGD_TEXT_BYLAYER: int
    FGD_TEXT_ID: int
    FGD_VOLUME_BYCOLOR: int
    FGD_VOLUME_BYLAYER: int
    FGD_VOLUME_BYPROP: int
    FGD_VOLUME_BYSURFACE: int
    FGD_VOLUME_ID: int
    FIVT_MAX_PRIN: int
    FIVT_MAX_SHEAR: int
    FIVT_MEAN_PRIN: int
    FIVT_MID_PRIN: int
    FIVT_MIN_PRIN: int
    FIVT_VON_MISES: int
    JT_UNIT_CENTI: int
    JT_UNIT_DECI: int
    JT_UNIT_FEET: int
    JT_UNIT_INCH: int
    JT_UNIT_KILO: int
    JT_UNIT_METER: int
    JT_UNIT_MICRO: int
    JT_UNIT_MILE: int
    JT_UNIT_MILLI: int
    JT_UNIT_UNKNOWN: int
    JT_UNIT_YARD: int
    JT_UNTI_MIL: int
    JT_V_10_0: int
    JT_V_10_1: int
    JT_V_10_2: int
    JT_V_10_3: int
    JT_V_10_4: int
    JT_V_10_5: int
    JT_V_10_6: int
    JT_V_8_0: int
    JT_V_8_1: int
    JT_V_8_2: int
    JT_V_9_0: int
    JT_V_9_1: int
    JT_V_9_2: int
    JT_V_9_3: int
    JT_V_9_4: int
    JT_V_9_5: int
    JT_SETS_ACTIVE: int
    JT_SETS_ALL: int
    JT_SETS_NONE: int
    JT_SETS_SELECT: int
    JT_SETS_VISIBLE: int
    FLIB_DIALOG: int
    FLIB_PERSONAL: int
    FLIB_SHARED: int
    FLIB_SYSTEM: int
    FS_INTEGRATED: int
    FS_LINKED: int
    FS_VISQ: int
    FDST_ALL: int
    FDST_FILE: int
    FDST_FILE_PRINT: int
    FDST_PRINTER: int
    FDST_SCREEN: int
    FDST_SCR_FILE: int
    FDST_SCR_PRINT: int
    FLD_ALONGCURVE: int
    FLD_NONE: int
    FLD_NORMALTOPLANE: int
    FLD_NORMALTOSURFACE: int
    FLD_VECTOR: int
    FLS_ACCEL: int
    FLS_ANY: int
    FLS_BODY: int
    FLS_DISP: int
    FLS_ECONVECTION: int
    FLS_EHTFLUX: int
    FLS_EHTGEN: int
    FLS_ERADIATION: int
    FLS_ETEMP: int
    FLS_FLFAN: int
    FLS_FLPERIODIC: int
    FLS_FLPRESSURE: int
    FLS_FLSLIP: int
    FLS_FLTRACKING: int
    FLS_FLUNKNOWN: int
    FLS_FORCE: int
    FLS_LINELOAD: int
    FLS_NHTFLUX: int
    FLS_NHTGEN: int
    FLS_NONE: int
    FLS_NONLINEAR: int
    FLS_NTEMP: int
    FLS_NTRANSIENT: int
    FLS_PRESS: int
    FLS_VELOCITY: int
    FLT_CECONVECTION: int
    FLT_CEHEATFLUX: int
    FLT_CEHEATGEN: int
    FLT_CEPRESSURE: int
    FLT_CERADIATION: int
    FLT_CETEMPERATURE: int
    FLT_CNACCELERATION: int
    FLT_CNBEARING: int
    FLT_CNDISPLACEMENT: int
    FLT_CNFANCURVE: int
    FLT_CNFLUIDHEIGHT: int
    FLT_CNFOLLOWERFORCE: int
    FLT_CNFOLLOWERMOMENT: int
    FLT_CNFORCE: int
    FLT_CNFORCEATNODE: int
    FLT_CNFORCEPERLEN: int
    FLT_CNHEATFLUX: int
    FLT_CNHEATFLUXATNODE: int
    FLT_CNHEATFLUXPERLEN: int
    FLT_CNHEATGEN: int
    FLT_CNHUMIDITY: int
    FLT_CNMOMENT: int
    FLT_CNMOMENTATNODE: int
    FLT_CNMOMENTPERLEN: int
    FLT_CNPERIODIC: int
    FLT_CNPRESSURE: int
    FLT_CNROTACCELERATION: int
    FLT_CNROTDISPLACEMENT: int
    FLT_CNROTVELOCITY: int
    FLT_CNSCALAR: int
    FLT_CNSLIPCONDITION: int
    FLT_CNSTEAMQUALITY: int
    FLT_CNTEMPERATURE: int
    FLT_CNTORQUE: int
    FLT_CNTOTALPRESSURE: int
    FLT_CNUNKNOWNCONDITION: int
    FLT_CNVELOCITY: int
    FLT_EBOLTPRELOAD: int
    FLT_ECONVECTION: int
    FLT_EHEATFLUX: int
    FLT_EHEATGEN: int
    FLT_ELINELOAD: int
    FLT_EPRESSURE: int
    FLT_ERADIATION: int
    FLT_ETEMPERATURE: int
    FLT_NACCELERATION: int
    FLT_NBODY: int
    FLT_NDISPLACEMENT: int
    FLT_NFANCURVE: int
    FLT_NFLUIDHEIGHT: int
    FLT_NFOLLOWERFORCE: int
    FLT_NFOLLOWERMOMENT: int
    FLT_NFORCE: int
    FLT_NHEATFLUX: int
    FLT_NHEATGEN: int
    FLT_NHUMIDITY: int
    FLT_NMOMENT: int
    FLT_NPERIODIC: int
    FLT_NPRESSURE: int
    FLT_NROTACCELERATION: int
    FLT_NROTDISPLACEMENT: int
    FLT_NROTVELOCITY: int
    FLT_NSCALAR: int
    FLT_NSLIPCONDITION: int
    FLT_NSTEAMQUALITY: int
    FLT_NTEMPERATURE: int
    FLT_NTOTALPRESSURE: int
    FLT_NTRANSIENT: int
    FLT_NUNKNOWNCONDITION: int
    FLT_NVELOCITY: int
    FLT_PNACCELERATION: int
    FLT_PNDISPLACEMENT: int
    FLT_PNFANCURVE: int
    FLT_PNFLUIDHEIGHT: int
    FLT_PNFOLLOWERFORCE: int
    FLT_PNFOLLOWERMOMENT: int
    FLT_PNFORCE: int
    FLT_PNHEATFLUX: int
    FLT_PNHEATGEN: int
    FLT_PNHUMIDITY: int
    FLT_PNMOMENT: int
    FLT_PNPERIODIC: int
    FLT_PNPRESSURE: int
    FLT_PNROTACCELERATION: int
    FLT_PNROTDISPLACEMENT: int
    FLT_PNROTVELOCITY: int
    FLT_PNSCALAR: int
    FLT_PNSLIPCONDITION: int
    FLT_PNSTEAMQUALITY: int
    FLT_PNTEMPERATURE: int
    FLT_PNTOTALPRESSURE: int
    FLT_PNUNKNOWNCONDITION: int
    FLT_PNVELOCITY: int
    FLT_SECONVECTION: int
    FLT_SEHEATFLUX: int
    FLT_SEHEATGEN: int
    FLT_SEPRESSURE: int
    FLT_SERADIATION: int
    FLT_SETEMPERATURE: int
    FLT_SNACCELERATION: int
    FLT_SNBEARING: int
    FLT_SNDISPLACEMENT: int
    FLT_SNFANCURVE: int
    FLT_SNFLUIDHEIGHT: int
    FLT_SNFOLLOWERFORCE: int
    FLT_SNFOLLOWERMOMENT: int
    FLT_SNFORCE: int
    FLT_SNFORCEATNODE: int
    FLT_SNFORCEPERAREA: int
    FLT_SNHEATFLUX: int
    FLT_SNHEATFLUXATNODE: int
    FLT_SNHEATFLUXPERAREA: int
    FLT_SNHEATGEN: int
    FLT_SNHUMIDITY: int
    FLT_SNMOMENT: int
    FLT_SNMOMENTATNODE: int
    FLT_SNMOMENTPERAREA: int
    FLT_SNPERIODIC: int
    FLT_SNPRESSURE: int
    FLT_SNROTACCELERATION: int
    FLT_SNROTDISPLACEMENT: int
    FLT_SNROTVELOCITY: int
    FLT_SNSCALAR: int
    FLT_SNSLIPCONDITION: int
    FLT_SNSTEAMQUALITY: int
    FLT_SNTEMPERATURE: int
    FLT_SNTORQUE: int
    FLT_SNTOTALPRESSURE: int
    FLT_SNUNKNOWNCONDITION: int
    FLT_SNVELOCITY: int
    FLV_DATASURFACE: int
    FLV_EQUATION: int
    FLV_FUNCTION: int
    FLV_INTERPOLATION: int
    FLV_NONE: int
    FLO_AFTER: int
    FLO_AFTER_EQUAL: int
    FLO_BEFORE: int
    FLO_BEFORE_EQUAL: int
    FVMDC_ELEM_ALT_TAPER: int
    FVMDC_ELEM_ASPECT_RATIO: int
    FVMDC_ELEM_COMBINED: int
    FVMDC_ELEM_EXPLICIT_TIME_STEP: int
    FVMDC_ELEM_ID: int
    FVMDC_ELEM_INTERNAL_ANGLE: int
    FVMDC_ELEM_JACOBIAN: int
    FVMDC_ELEM_NASTRAN_WARPING: int
    FVMDC_ELEM_NHEXAR: int
    FVMDC_ELEM_NHEXDETJ: int
    FVMDC_ELEM_NHEXEPIA: int
    FVMDC_ELEM_NHEXEPLR: int
    FVMDC_ELEM_NHEXWARP: int
    FVMDC_ELEM_NPENAR: int
    FVMDC_ELEM_NPENDETJ: int
    FVMDC_ELEM_NPENEPIA: int
    FVMDC_ELEM_NPENEPLR: int
    FVMDC_ELEM_NPENWARP: int
    FVMDC_ELEM_NPYRAR: int
    FVMDC_ELEM_NPYRDETJ: int
    FVMDC_ELEM_NPYREPIA: int
    FVMDC_ELEM_NPYREPLR: int
    FVMDC_ELEM_NPYRWARP: int
    FVMDC_ELEM_NQAR: int
    FVMDC_ELEM_NQIAMAX: int
    FVMDC_ELEM_NQIAMIN: int
    FVMDC_ELEM_NQSKEW: int
    FVMDC_ELEM_NQTAPER: int
    FVMDC_ELEM_NQWARP: int
    FVMDC_ELEM_NT6EPLR: int
    FVMDC_ELEM_NTAR: int
    FVMDC_ELEM_NTETAR: int
    FVMDC_ELEM_NTETDETJ: int
    FVMDC_ELEM_NTETEPIA: int
    FVMDC_ELEM_NTETEPLR: int
    FVMDC_ELEM_NTIAMAX: int
    FVMDC_ELEM_NTSKEW: int
    FVMDC_ELEM_PLATE_OFFSET: int
    FVMDC_ELEM_SKEW: int
    FVMDC_ELEM_TAPER: int
    FVMDC_ELEM_TET_COLLAPSE: int
    FVMDC_ELEM_WARPING: int
    FVMDC_MATL_E: int
    FVMDC_MATL_ID: int
    FVMDC_MATL_TABLE: int
    FVMDC_NONE_SELECTED: int
    FVMDC_PROP_ID: int
    FVMDC_PROP_LINE_AREA: int
    FVMDC_PROP_LINE_I1: int
    FVMDC_PROP_LINE_I2: int
    FVMDC_PROP_PLATE_THICKNESS: int
    FVMDC_PROP_TABLE: int
    FMRA_DETACH: int
    FMRA_LOAD: int
    FMRA_UNLOAD: int
    FMRA_UPDATE_PATH: int
    FMLT_EHEATFLUX: int
    FMLT_EHEATGEN: int
    FMLT_EPRESSURE: int
    FMLT_ETEMPERATURE: int
    FMLT_NACCELERATION: int
    FMLT_NDISPLACEMENT: int
    FMLT_NFORCE: int
    FMLT_NMOMENT: int
    FMLT_NPRESSURE: int
    FMLT_NROTACCELERATION: int
    FMLT_NROTDISPLACEMENT: int
    FMLT_NROTVELOCITY: int
    FMLT_NTEMPERATURE: int
    FMLT_NVELOCITY: int
    FMO_EXTEND: int
    FMO_INTERP: int
    FMO_NONE: int
    FMO_VALUE: int
    FMO_ZERO: int
    FMP_ELEMENT: int
    FMP_NODE: int
    FMP_STANDARD: int
    MAT_AMP_PHASE: int
    MAT_REAL_IMAG: int
    MAT_OP2: int
    MAT_PCH: int
    MAT_CPLX_DOUBLE: int
    MAT_CPLX_SINGLE: int
    MAT_MACHPRES: int
    MAT_REAL_DOUBLE: int
    MAT_REAL_SINGLE: int
    MAT_RECT2: int
    MAT_RECT9: int
    MAT_SQUARE: int
    MAT_SYMMETRIC: int
    MAT_COMB: int
    MAT_EXT: int
    MAT_INT: int
    FMTCH_ALL: int
    FMTCH_ALL_CONSTRAINED: int
    FMTCH_ALL_TRUE: int
    FMTCH_ANY: int
    FMTCH_ANY_CONSTRAINED: int
    FMTCH_ANY_TRUE: int
    FMT_ANISOTROPIC_2D: int
    FMT_ANISOTROPIC_3D: int
    FMT_FLUID: int
    FMT_GENERAL: int
    FMT_HYPERELASTIC: int
    FMT_ISOTROPIC: int
    FMT_ORTHOTROPIC_2D: int
    FMT_ORTHOTROPIC_3D: int
    FMRRNM_BLOCK: int
    FMRRNM_COMPRESS: int
    FMRRNM_MINIMAL: int
    FMRRNM_NONE: int
    FMRRNM_OFFSET: int
    FMAP_FREE_PARAMETRIC: int
    FMAP_FREE_PLANAR: int
    FMAP_MAP_3CORNER: int
    FMAP_MAP_3CORNERFAN: int
    FMAP_MAP_4CORNER: int
    FMAP_MAP_LINKED: int
    FMAP_NONE: int
    FMAP_TRI_PARAMETRIC: int
    FMAP_TRI_PLANAR: int
    MBAS_ALL: int
    MBAS_REQD: int
    MBAS_SELECT: int
    FMOF_BOTTOM: int
    FMOF_CENTERLINE: int
    FMOF_TOP: int
    MSPE_ALL: int
    MSPE_FREEONLY: int
    MSPE_FREEPLUS: int
    MSPE_OFF: int
    MSPS_ALL: int
    MSPS_MESHED: int
    FMSH_3DTRI: int
    FMSH_AUTO: int
    FMSH_FASTTRI: int
    FMSH_SUBDIVISION: int
    FCM_COMMAND: int
    FCM_ERROR: int
    FCM_HIGHLIGHT: int
    FCM_NORMAL: int
    FCM_WARNING: int
    MPT_FX: int
    MPT_FY: int
    MPT_FZ: int
    MPT_MX: int
    MPT_MY: int
    MPT_MZ: int
    MPT_APPLIED: int
    MPT_DMIG: int
    MPT_MPC: int
    MPT_SPC: int
    MPT_1_AEROMESH: int
    MPT_1_AEROPANEL: int
    MPT_1_STRUCT: int
    MPT_3: int
    FSNAS_LIC_DESK: int
    FSNAS_LIC_ENT: int
    FND_EPOINT: int
    FND_FLPOINT: int
    FND_NODE: int
    FND_SPOINT: int
    FOPBT_PCT: int
    FOPBT_RELATIVE: int
    FOPBT_VALUES: int
    FOG_COMPLIANCE: int
    FOG_DRESP: int
    FOG_MINWEIGHT: int
    FOG_NONE: int
    FOG_VOLUME: int
    FOG_WEIGHT: int
    FOL_BARAXIALSTRAIN: int
    FOL_BARAXIALSTRESS: int
    FOL_BARMAXSTRAIN: int
    FOL_BARMAXSTRESS: int
    FOL_BARMINSTRAIN: int
    FOL_BARMINSTRESS: int
    FOL_EIGENVALUE: int
    FOL_FREQUENCY: int
    FOL_NODXDISP: int
    FOL_NODXRDISP: int
    FOL_NODYDISP: int
    FOL_NODYRDISP: int
    FOL_NODZDISP: int
    FOL_NODZRDISP: int
    FOL_NONE: int
    FOL_PLTMAXPRINSTRAIN: int
    FOL_PLTMAXPRINSTRESS: int
    FOL_PLTMINPRINSTRAIN: int
    FOL_PLTMINPRINSTRESS: int
    FOL_PLTVONMISESSTRAIN: int
    FOL_PLTVONMISESSTRESS: int
    FOL_PLTXNORMALSTRAIN: int
    FOL_PLTXNORMALSTRESS: int
    FOL_PLTXYSHEARSTRAIN: int
    FOL_PLTXYSHEARSTRESS: int
    FOL_PLTYNORMALSTRAIN: int
    FOL_PLTYNORMALSTRESS: int
    FOL_RODAXIALSTRAIN: int
    FOL_RODAXIALSTRESS: int
    FOL_RODTORSIONSTRAIN: int
    FOL_RODTORSIONSTRESS: int
    FOPMC_ADDM: int
    FOPMC_CAST: int
    FOPMC_CHECK: int
    FOPMC_CSYM: int
    FOPMC_EXTR: int
    FOPMC_MAXS: int
    FOPMC_MINS: int
    FOPMC_PSYM: int
    FOPRT_ELEM: int
    FOPRT_MATERIAL: int
    FOPRT_PROPERTY: int
    FOPRT_TOPOLOGY: int
    FOPATT_BLANK: int
    FOPATT_CHAR: int
    FOPATT_INT: int
    FOPATT_REAL: int
    FOPRSP_BUCKLE: int
    FOPRSP_COMPL: int
    FOPRSP_CUSTOM: int
    FOPRSP_EIGEN: int
    FOPRSP_ELEM: int
    FOPRSP_ESE: int
    FOPRSP_FRDISP: int
    FOPRSP_FRELEM: int
    FOPRSP_FREQ: int
    FOPRSP_FRSPCF: int
    FOPRSP_NDISP: int
    FOPRSP_SPCFORCE: int
    FOPRSP_VOL: int
    FOPRSP_WEIGHT: int
    FOP_GOAL: int
    FOP_LIMIT: int
    FOP_NONE: int
    FOP_VARY: int
    FOV_BARAREA: int
    FOV_BARI1: int
    FOV_BARI2: int
    FOV_BARTORSION: int
    FOV_NONE: int
    FOV_PLATETHICKNESS: int
    FOV_RODAREA: int
    FOV_RODTORSION: int
    FOC_ANY: int
    FOC_IMAGINARY: int
    FOC_MAGNITUDE: int
    FOC_PHASE: int
    FOC_REAL: int
    FOD_LINE_TO_CSYS: int
    FOD_NONE: int
    FOD_PLATE_TO_CSYS: int
    FOD_PLATE_TO_MATL: int
    FOD_PLATE_TO_VECTOR: int
    FOD_SOLID_TO_CSYS: int
    FOD_SOLID_TO_MATL: int
    FOD_VECTOR_TO_CSYS: int
    FOD_VECTOR_TO_NODE_OUTPUT_CSYS: int
    FOPC_ALL: int
    FOPC_EACH_VECTOR: int
    FOPC_IN_SET: int
    FOPA_ALL: int
    FOPA_EACH: int
    FOPA_LOCATIONS: int
    FOPE_MAX: int
    FOPE_MAXABS: int
    FOPE_MIN: int
    FOPM_DIFFAVG: int
    FOPM_MAXDIFF: int
    FOPM_NORMDIFFAVG: int
    FOPM_NORMMAXDIFF: int
    FOPM_PCTDIFFAVG: int
    FOPM_PCTMAXDIFF: int
    FOT_ACCEL: int
    FOT_ANY: int
    FOT_DISP: int
    FOT_FORCE: int
    FOT_STRAIN: int
    FOT_STRESS: int
    FOT_TEMP: int
    FPAD_AUTO: int
    FPAD_CURVE: int
    FPAD_VECTOR: int
    FPAD_DIST: int
    FPAD_SCALE: int
    FPM_AVI: int
    FPM_AVI_UNCOMPRESSED: int
    FPM_BMP: int
    FPM_BMPSERIES: int
    FPM_GIF: int
    FPM_GIFANIM: int
    FPM_JPEG: int
    FPM_JT: int
    FPM_METAFILE: int
    FPM_PLACEMF: int
    FPM_PNG: int
    FPM_TIF: int
    FPM2_BMP: int
    FPM2_GIF: int
    FPM2_JPEG: int
    FPM2_PNG: int
    FPM2_TIF: int
    FPRG_DESKTOP: int
    FPRG_LAYOUT: int
    FPRG_WINDOW: int
    FPD_BISECT: int
    FPD_COMPONENTS: int
    FPD_DEFCS_AXIS: int
    FPD_GLOBAL_AXIS: int
    FPD_NORMAL: int
    FPD_NORMAL_TO_CURVE: int
    FPD_NORMAL_TO_SURFACE: int
    FPD_NORMAL_TO_VIEW: int
    FPD_POSITION: int
    FPD_SAVED: int
    FPD_USE_NODES: int
    FPD_USE_POINTS: int
    FPTM_ADJUSTPCT: int
    FPTM_BOTTOMTONODE: int
    FPTM_INCREMENT: int
    FPTM_SETTOVALUE: int
    FPTM_TOPTONODE: int
    FPTO_ELEM_OFFSET: int
    FPTO_ELEM_THICKNESS: int
    FPTO_PROP_THICKNESS: int
    FCD_ALONG: int
    FCD_ALONGLENGTH: int
    FCD_BETWEEN: int
    FCD_CENTER: int
    FCD_CENTER_POINTS: int
    FCD_CG_SURFACE: int
    FCD_COORDINATES: int
    FCD_DISTANCE: int
    FCD_INTERSECTCURVESURFACE: int
    FCD_INTERSECTION: int
    FCD_MESH_LOCATION: int
    FCD_MIDPOINT: int
    FCD_OFFSET: int
    FCD_ON_SURFACE: int
    FCD_PROJECT_ON_CURVE: int
    FCD_PROJECT_ON_SURFACE: int
    FCD_USE_NODES: int
    FCD_USE_POINTS: int
    FCD_WORKPLANE_COORDINATES: int
    FPT_DEFAULT: int
    FPT_SOLID: int
    PAFM_AVI: int
    PAFM_BMP: int
    PAFM_BMPSERIES: int
    PAFM_GIF: int
    PPFM_BMP: int
    PPFM_GIF: int
    PPFM_JPEG: int
    PPFM_PNG: int
    PPFM_TIF: int
    FPS_APIPROGRAM: int
    FPS_CHART: int
    FPS_DATATABLE: int
    FPS_DESKTOP: int
    FPS_ENTITYINFO: int
    FPS_FILE: int
    FPS_LAYOUT: int
    FPS_MESSAGES: int
    FPS_PROGRAMFILE: int
    FPS_VIEW: int
    FPA_CLOSEST: int
    FPA_RADIAL_POINT: int
    FPA_RADIAL_VECTOR: int
    FPA_VECTOR: int
    FPO_CURVE: int
    FPO_PLANE: int
    FPO_SURFACE: int
    FPO_VECTOR: int
    PUBALN_CENTER: int
    PUBALN_LEFT: int
    PUBALN_RIGHT: int
    PUB_HTML: int
    PUB_RTF: int
    PUBIF_BITMAP: int
    PUBIF_GIF: int
    PUBIF_JPEG: int
    PUBIF_PNG: int
    PUBIF_TIF: int
    FRNG_ABOVE: int
    FRNG_ANY: int
    FRNG_BELOW: int
    FRNG_BETWEEN: int
    FRNG_OUTSIDE: int
    FRKA_ALL: int
    FRKA_EACH: int
    FRKM_ENTITY: int
    FRKM_SETS: int
    FRKT_MAX: int
    FRKT_MAXABS: int
    FRKT_MIN: int
    FRFM_EXPONENTIAL: int
    FRFM_NASTRAN: int
    FRFM_NORMAL: int
    FRC_AVG: int
    FRC_AVG_SKIP_CORNER: int
    FRC_MAX: int
    FRC_MAX_SKIP_CORNER: int
    FRC_MIN: int
    FRC_MIN_SKIP_CORNER: int
    FRC_NONE: int
    FRL_CSV: int
    FRL_DB: int
    FRL_FNO: int
    FRL_ODB: int
    FRL_OP2: int
    FRL_VIRTUAL: int
    FRL_XDB: int
    FRPROC_ENV_ABSMAX: int
    FRPROC_ENV_ABSMAX_SETID: int
    FRPROC_ENV_MAX: int
    FRPROC_ENV_MAX_SETID: int
    FRPROC_ENV_MIN: int
    FRPROC_ENV_MIN_SETID: int
    FRPROC_LINEAR: int
    FRPROC_NONE: int
    FRPROC_RSS: int
    FE_BAD_DATA: int
    FE_BAD_TYPE: int
    FE_CANCEL: int
    FE_FAIL: int
    FE_FILE_OPEN_FAILED: int
    FE_FILE_WRITE_FAILED: int
    FE_INVALID: int
    FE_INVALID_DEVELOPER: int
    FE_NEGATIVE_MASS_VOLUME: int
    FE_NOT_AVAILABLE: int
    FE_NOT_EXIST: int
    FE_NO_FILENAME: int
    FE_NO_MEMORY: int
    FE_NO_VALID_GRAPHICS_WINDOW: int
    FE_NO_VALID_GRAPHIC_VIEW: int
    FE_OK: int
    FE_SECURITY: int
    FE_TOO_SMALL: int
    FRIG_METHOD_AUTO: int
    FRIG_METHOD_LAGRAN: int
    FRIG_METHOD_LGELIM: int
    FRIG_METHOD_LINEAR: int
    FRIG_METHOD_STIFF: int
    FSD_FRONT: int
    FSD_OFF: int
    FSD_QUERY: int
    FS_BC_EQUATION: int
    FS_BC_NODAL: int
    FS_BC_ON_CURVE: int
    FS_BC_ON_POINT: int
    FS_BC_ON_SURFACE: int
    FS_CONNECTION: int
    FS_CONNECTION_PROP: int
    FS_CONNECTION_REGION: int
    FS_CSYS: int
    FS_CURVE: int
    FS_ELEM: int
    FS_LOAD_ELEMENTAL: int
    FS_LOAD_NODAL: int
    FS_LOAD_ON_CURVE: int
    FS_LOAD_ON_POINT: int
    FS_LOAD_ON_SURFACE: int
    FS_MATL: int
    FS_NODE: int
    FS_NONE: int
    FS_POINT: int
    FS_PROP: int
    FS_SOLID: int
    FS_SURFACE: int
    FS_TEXT: int
    FSEV_ALT: int
    FSEV_AUTO: int
    FSEV_ORIG: int
    FSEV_PBEAML: int
    FSOR_DOWN: int
    FSOR_LEFT: int
    FSOR_RIGHT: int
    FSOR_UP: int
    FSHP_C: int
    FSHP_CIRC_BAR: int
    FSHP_CIRC_TUBE: int
    FSHP_HAT: int
    FSHP_HEX_BAR: int
    FSHP_HEX_TUBE: int
    FSHP_I: int
    FSHP_L: int
    FSHP_NAS_BAR: int
    FSHP_NAS_BOX: int
    FSHP_NAS_BOX1: int
    FSHP_NAS_CHAN: int
    FSHP_NAS_CHAN1: int
    FSHP_NAS_CHAN2: int
    FSHP_NAS_CROSS: int
    FSHP_NAS_H: int
    FSHP_NAS_HAT: int
    FSHP_NAS_HAT1: int
    FSHP_NAS_HEXA: int
    FSHP_NAS_I: int
    FSHP_NAS_I1: int
    FSHP_NAS_L: int
    FSHP_NAS_ROD: int
    FSHP_NAS_T: int
    FSHP_NAS_T1: int
    FSHP_NAS_T2: int
    FSHP_NAS_TUBE: int
    FSHP_NAS_Z: int
    FSHP_RECT_BAR: int
    FSHP_RECT_TUBE: int
    FSHP_T: int
    FSHP_TRAP_BAR: int
    FSHP_TRAP_TUBE: int
    FSHP_Z: int
    FSAV_VECASK: int
    FSAV_VECAUTO: int
    FSAV_VECINPUT: int
    FESL_DEFAULT: int
    FESL_ELLOC: int
    FESL_OFFSET: int
    FESL_PRLOC: int
    FESO_ELCID: int
    FESO_NODE: int
    FESO_NONE: int
    FESO_PRCID: int
    FESO_VECTOR: int
    FSU_BEZIER: int
    FSU_BILINEAR: int
    FSU_BOUNDARY: int
    FSU_BSPLINE: int
    FSU_COONS: int
    FSU_REVOLUTION: int
    FSU_RULED: int
    FSU_SOLID: int
    FTBL_FUNCTION: int
    FTBL_LOADSETCOMBINATION: int
    FTBL_NONE: int
    FTBL_RESULTSETPROCESS: int
    FTBL_VECTORFUNCTION: int
    FTP_PYR: int
    FTP_SURFACEONLY: int
    FTP_TET: int
    FTO_BRICK20: int
    FTO_BRICK8: int
    FTO_CONTACT2: int
    FTO_LINE2: int
    FTO_LINE3: int
    FTO_MULTILIST2: int
    FTO_POINT1: int
    FTO_PYRAMID13: int
    FTO_PYRAMID5: int
    FTO_QUAD4: int
    FTO_QUAD8: int
    FTO_RIGIDLIST: int
    FTO_RIGIDLIST2: int
    FTO_TETRA10: int
    FTO_TETRA4: int
    FTO_TRIA3: int
    FTO_TRIA6: int
    FTO_WEDGE15: int
    FTO_WEDGE6: int
    FTO_WELD2: int
    FULD_ELEM: int
    FULD_REVERSE: int
    FULD_VECTOR: int
    VCX_IMAGINARY: int
    VCX_MAGNITUDE: int
    VCX_PHASE: int
    VCX_REAL: int
    VEO_APPLIED_LOAD: int
    VEO_CONVECTION_FORCED: int
    VEO_CONVECTION_FREE: int
    VEO_CRACK_STRESS_1: int
    VEO_CRACK_STRESS_2: int
    VEO_CRACK_STRESS_3: int
    VEO_CRACK_STRESS_4: int
    VEO_CRACK_STRESS_5: int
    VEO_CRACK_STRESS_6: int
    VEO_CRACK_STRESS_7: int
    VEO_CRACK_STRESS_8: int
    VEO_CRACK_STRESS_9: int
    VEO_ENERGY_LOSS: int
    VEO_ENERGY_LOSS_DENSITY: int
    VEO_ENERGY_LOSS_PERCENT: int
    VEO_FLUID_PRESSURE: int
    VEO_GASKET_CLOSURE: int
    VEO_GASKET_PLASTIC_CLOSURE: int
    VEO_GASKET_PRESSURE: int
    VEO_GASKET_STATUS: int
    VEO_GASKET_YIELD_STRESS: int
    VEO_HEAT_FLOW_TOTAL: int
    VEO_HEAT_FLUX_TOTAL: int
    VEO_HEAT_FLUX_X: int
    VEO_HEAT_FLUX_Y: int
    VEO_HEAT_FLUX_Z: int
    VEO_KINETIC_ENERGY: int
    VEO_KINETIC_ENERGY_DENSITY: int
    VEO_KINETIC_ENERGY_PERCENT: int
    VEO_NORMALIZED_MASS_DENSITY: int
    VEO_RADIATION: int
    VEO_STRAIN_ENERGY: int
    VEO_STRAIN_ENERGY_DENSITY: int
    VEO_STRAIN_ENERGY_PERCENT: int
    VEO_TEMP_GRADIENT_TOTAL: int
    VEO_TEMP_GRADIENT_X: int
    VEO_TEMP_GRADIENT_Y: int
    VEO_TEMP_GRADIENT_Z: int
    VLT_BAR: int
    VLT_BEAM: int
    VLT_WELD: int
    VLE_A: int
    VLE_B: int
    VLE_OVERALL: int
    VLL_1: int
    VLL_2: int
    VLL_3: int
    VLL_4: int
    VLL_MAX: int
    VLL_MIN: int
    VLL_OVERALL: int
    VLO_BUSHFAST_FORCE_X: int
    VLO_BUSHFAST_FORCE_Y: int
    VLO_BUSHFAST_FORCE_Z: int
    VLO_BUSHFAST_MOMENT_X: int
    VLO_BUSHFAST_MOMENT_Y: int
    VLO_BUSHFAST_MOMENT_Z: int
    VLO_BUSHFAST_STRAIN_RX: int
    VLO_BUSHFAST_STRAIN_RY: int
    VLO_BUSHFAST_STRAIN_RZ: int
    VLO_BUSHFAST_STRAIN_TX: int
    VLO_BUSHFAST_STRAIN_TY: int
    VLO_BUSHFAST_STRAIN_TZ: int
    VLO_BUSHFAST_STRESS_RX: int
    VLO_BUSHFAST_STRESS_RY: int
    VLO_BUSHFAST_STRESS_RZ: int
    VLO_BUSHFAST_STRESS_TX: int
    VLO_BUSHFAST_STRESS_TY: int
    VLO_BUSHFAST_STRESS_TZ: int
    VLO_BUSH_AXIAL_DISPLACEMENT: int
    VLO_BUSH_AXIAL_FORCE: int
    VLO_BUSH_AXIAL_PLASTIC_STRAIN: int
    VLO_BUSH_AXIAL_STRAIN: int
    VLO_BUSH_AXIAL_STRESS: int
    VLO_BUSH_AXIAL_VELOCITY: int
    VLO_GAP_DISPLACEMENT_AXIAL: int
    VLO_GAP_DISPLACEMENT_V: int
    VLO_GAP_DISPLACEMENT_W: int
    VLO_GAP_FORCE_X: int
    VLO_GAP_FORCE_Y: int
    VLO_GAP_FORCE_Z: int
    VLO_GAP_SLIP_V: int
    VLO_GAP_SLIP_W: int
    VLO_ROD_AXIAL_FORCE: int
    VLO_ROD_STRAIN_AXIAL: int
    VLO_ROD_STRAIN_AXIAL_MARGIN: int
    VLO_ROD_STRAIN_CREEP: int
    VLO_ROD_STRAIN_PLASTIC: int
    VLO_ROD_STRAIN_TORSIONAL: int
    VLO_ROD_STRAIN_TORSIONAL_MARGIN: int
    VLO_ROD_STRAIN_TOTAL: int
    VLO_ROD_STRESS_AXIAL: int
    VLO_ROD_STRESS_AXIAL_MARGIN: int
    VLO_ROD_STRESS_EQUIVALENT: int
    VLO_ROD_STRESS_TORSIONAL: int
    VLO_ROD_STRESS_TORSIONAL_MARGIN: int
    VLO_ROD_TORQUE: int
    VLO_SPRING_FORCE: int
    VLO_SPRING_STRAIN: int
    VLO_SPRING_STRESS: int
    VLO_WELD_AXIAL_STRESS: int
    VLO_WELD_BEARING_STRESS: int
    VLO_WELD_MAX_SHEAR_STRESS: int
    VLV_AXIAL_FORCE: int
    VLV_MOMENT_PLANE1: int
    VLV_MOMENT_PLANE2: int
    VLV_SHEAR_PLANE1: int
    VLV_SHEAR_PLANE2: int
    VLV_STRAIN_AXIAL: int
    VLV_STRAIN_BENDING: int
    VLV_STRAIN_COMBINED: int
    VLV_STRAIN_COMPRESSION_MARGIN: int
    VLV_STRAIN_CREEP: int
    VLV_STRAIN_PLASTIC: int
    VLV_STRAIN_TENSION_MARGIN: int
    VLV_STRAIN_TOTAL: int
    VLV_STRESS_AXIAL: int
    VLV_STRESS_BENDING: int
    VLV_STRESS_COMBINED: int
    VLV_STRESS_COMPRESSION_MARGIN: int
    VLV_STRESS_EQUIVALENT: int
    VLV_STRESS_TENSION_MARGIN: int
    VLV_TORQUE: int
    VLV_TORQUE_WARPING: int
    VNV_ACCELERATION: int
    VNV_AERO_ROTATION: int
    VNV_AERO_TRANSLATION: int
    VNV_ANG_ACCELERATION: int
    VNV_ANG_VELOCITY: int
    VNV_APPLIED_FORCE: int
    VNV_APPLIED_MOMENT: int
    VNV_CONSTRAINT_FORCE: int
    VNV_CONSTRAINT_MOMENT: int
    VNV_CONTACT_FORCE: int
    VNV_CONTACT_INCSLIDEDISTANCE: int
    VNV_CONTACT_SLIDEDISTANCE: int
    VNV_CONTACT_TRACTION: int
    VNV_GLUE_FORCE: int
    VNV_GLUE_INCSLIDEDISTANCE: int
    VNV_GLUE_MOMENT: int
    VNV_GLUE_SLIDEDISTANCE: int
    VNV_GLUE_TRACTION: int
    VNV_GP_APPLIED_FORCE: int
    VNV_GP_APPLIED_MOMENT: int
    VNV_GP_CONSTRAINT_FORCE: int
    VNV_GP_CONSTRAINT_MOMENT: int
    VNV_GP_CONTACT_FORCE: int
    VNV_GP_CONTACT_MOMENT: int
    VNV_GP_DRILLING_FORCE: int
    VNV_GP_DRILLING_MOMENT: int
    VNV_GP_MPC_FORCE: int
    VNV_GP_MPC_MOMENT: int
    VNV_GP_TOTAL_FORCE: int
    VNV_GP_TOTAL_MOMENT: int
    VNV_MPC_FORCE: int
    VNV_MPC_MOMENT: int
    VNV_ROTATION: int
    VNV_TRANSLATION: int
    VNV_VELOCITY: int
    VNS_COMPLEX_MODE_SHAPE: int
    VNS_CONTACT_DEFSEPDIST: int
    VNS_CONTACT_FRICTIONFORCE: int
    VNS_CONTACT_FRICTIONSTRESS1: int
    VNS_CONTACT_FRICTIONSTRESS2: int
    VNS_CONTACT_INISEPDIST: int
    VNS_CONTACT_NORMALFORCE: int
    VNS_CONTACT_NORMALSTRESS: int
    VNS_CONTACT_PRESSURE: int
    VNS_CONTACT_STATUS: int
    VNS_CONTACT_X_FORCE: int
    VNS_CONTACT_X_FRICTIONFORCE: int
    VNS_CONTACT_Y_FORCE: int
    VNS_CONTACT_Y_FRICTIONFORCE: int
    VNS_CONTACT_Z_FORCE: int
    VNS_CONTACT_Z_FRICTIONFORCE: int
    VNS_ENTHALPY: int
    VNS_ENTHALPY_CHANGE: int
    VNS_GLUE_PRESSURE: int
    VNS_PRESSURE: int
    VNS_TEMPERATURE: int
    VNS_THERMAL_APPLIEDLOAD: int
    VNS_THERMAL_CONSTRAINTFORCE: int
    VNS_THERMAL_MULTIPOINTFORCE: int
    VNT_TOTAL_NONE: int
    VNT_X: int
    VNT_Y: int
    VNT_Z: int
    VPL_1: int
    VPL_2: int
    VPL_3: int
    VPL_4: int
    VPL_CENTROID: int
    VPP_BOT: int
    VPP_MID: int
    VPP_TOP: int
    VPV_CURVATURE: int
    VPV_ELASTIC_CURVATURE: int
    VPV_ELASTIC_STRAIN: int
    VPV_FORCE: int
    VPV_MOMENT: int
    VPV_NONLINEAR_STRAIN: int
    VPV_NONLINEAR_STRESS: int
    VPV_STRAIN: int
    VPV_STRESS: int
    VPV_THERMAL_CURVATURE: int
    VPV_THERMAL_STRAIN: int
    VPS_AXISYM_AXIALFORCE1: int
    VPS_AXISYM_AXIALFORCE2: int
    VPS_AXISYM_AXIALFORCE3: int
    VPS_AXISYM_AXIALFORCE4: int
    VPS_AXISYM_AXIALSTRAIN: int
    VPS_AXISYM_AXIALSTRAINNL: int
    VPS_AXISYM_AXIALSTRESS: int
    VPS_AXISYM_AXIALSTRESSNL: int
    VPS_AXISYM_AZIMUTHFORCE1: int
    VPS_AXISYM_AZIMUTHFORCE2: int
    VPS_AXISYM_AZIMUTHFORCE3: int
    VPS_AXISYM_AZIMUTHFORCE4: int
    VPS_AXISYM_AZIMUTHSTRAIN: int
    VPS_AXISYM_AZIMUTHSTRAINNL: int
    VPS_AXISYM_AZIMUTHSTRESS: int
    VPS_AXISYM_AZIMUTHSTRESSNL: int
    VPS_AXISYM_EFFCREEPSTRAIN: int
    VPS_AXISYM_EFFCREEPSTRAINNL: int
    VPS_AXISYM_EFFPLASTICSTRAIN: int
    VPS_AXISYM_EFFPLASTICSTRAINNL: int
    VPS_AXISYM_MAXPRINSTRAIN: int
    VPS_AXISYM_MAXPRINSTRESS: int
    VPS_AXISYM_MAXSHEARSTRAIN: int
    VPS_AXISYM_MAXSHEARSTRESS: int
    VPS_AXISYM_MEANPRESSURE: int
    VPS_AXISYM_MEANPRESSURENL: int
    VPS_AXISYM_MINPRINSTRESS: int
    VPS_AXISYM_OCTAHEDRALSTRAIN: int
    VPS_AXISYM_OCTAHEDRALSTRESS: int
    VPS_AXISYM_RADIALFORCE1: int
    VPS_AXISYM_RADIALFORCE2: int
    VPS_AXISYM_RADIALFORCE3: int
    VPS_AXISYM_RADIALFORCE4: int
    VPS_AXISYM_RADIALSTRAIN: int
    VPS_AXISYM_RADIALSTRAINNL: int
    VPS_AXISYM_RADIALSTRESS: int
    VPS_AXISYM_RADIALSTRESSNL: int
    VPS_AXISYM_SHEARSTRAIN: int
    VPS_AXISYM_SHEARSTRAINNL: int
    VPS_AXISYM_SHEARSTRESS: int
    VPS_AXISYM_SHEARSTRESSNL: int
    VPS_AXISYM_VOLUMETRICSTRAIN: int
    VPS_AXISYM_VOLUMETRICSTRAINNL: int
    VPS_AXISYM_VONMISESSTRAIN: int
    VPS_AXISYM_VONMISESSTRESS: int
    VPS_AXISYM_VONMISESSTRESSNL: int
    VPS_FIBER_BOTTOM: int
    VPS_FIBER_BOTTOMELASTIC: int
    VPS_FIBER_BOTTOMNL: int
    VPS_FIBER_BOTTOMTHERMAL: int
    VPS_FIBER_TOP: int
    VPS_FIBER_TOPELASTIC: int
    VPS_FIBER_TOPNL: int
    VPS_FIBER_TOPTHERMAL: int
    VPS_LAMINATE_MAXFAILUREINDEX: int
    VPS_LAMINATE_MINSTRENGTHRATIO: int
    VPS_SHEAR_13DIAG: int
    VPS_SHEAR_1FROM2: int
    VPS_SHEAR_1FROM4: int
    VPS_SHEAR_24DIAG: int
    VPS_SHEAR_2FROM1: int
    VPS_SHEAR_2FROM3: int
    VPS_SHEAR_3FROM2: int
    VPS_SHEAR_3FROM4: int
    VPS_SHEAR_4FROM1: int
    VPS_SHEAR_4FROM3: int
    VPS_SHEAR_AVGSHEAR: int
    VPS_SHEAR_AVGSHEARSTRAIN: int
    VPS_SHEAR_FLOW12: int
    VPS_SHEAR_FLOW23: int
    VPS_SHEAR_FLOW34: int
    VPS_SHEAR_FLOW41: int
    VPS_SHEAR_KICK1: int
    VPS_SHEAR_KICK2: int
    VPS_SHEAR_KICK3: int
    VPS_SHEAR_KICK4: int
    VPS_SHEAR_MARGINOFSAFETY: int
    VPS_SHEAR_MAXSHEAR: int
    VPS_SHEAR_MAXSHEARSTRAIN: int
    VPS_SHEAR_STRAINMARGINOFSAFETY: int
    VPT_ANG_PRIN: int
    VPT_MAX_PRIN: int
    VPT_MAX_SHEAR: int
    VPT_MEAN: int
    VPT_MID_PRIN: int
    VPT_MIN_PRIN: int
    VPT_VON_MISES: int
    VPT_X: int
    VPT_XY: int
    VPT_XZ: int
    VPT_Y: int
    VPT_YZ: int
    VPT_Z: int
    VSLL_BOT: int
    VSLL_MID: int
    VSLL_TOP: int
    VSLV_FAILURE: int
    VSLV_STRAIN: int
    VSLV_STRENGTHRATIO: int
    VSLV_STRESS: int
    VSLT_BOND: int
    VSLT_MAX_PRIN: int
    VSLT_MAX_SHEAR: int
    VSLT_MEAN: int
    VSLT_MID_PRIN: int
    VSLT_MIN_PRIN: int
    VSLT_PLY_11: int
    VSLT_PLY_12: int
    VSLT_PLY_13: int
    VSLT_PLY_22: int
    VSLT_PLY_23: int
    VSLT_PLY_33: int
    VSLT_VON_MISES: int
    VSLT_X: int
    VSLT_XY: int
    VSLT_Y: int
    VSLT_YZ: int
    VSLT_Z: int
    VSLT_ZX: int
    VSL_1: int
    VSL_2: int
    VSL_3: int
    VSL_4: int
    VSL_5: int
    VSL_6: int
    VSL_7: int
    VSL_8: int
    VSL_CENTROID: int
    VSO_BOLT_AXIALFORCE: int
    VSO_BOLT_INITAXIALSTRAIN: int
    VSO_BOLT_MOMENT1: int
    VSO_BOLT_MOMENT2: int
    VSO_BOLT_SHEARFORCE1: int
    VSO_BOLT_SHEARFORCE2: int
    VSO_COHESIVE_DAMAGE1: int
    VSO_COHESIVE_DAMAGE2: int
    VSO_COHESIVE_DAMAGE3: int
    VSO_COHESIVE_MATCSID: int
    VSO_COHESIVE_NORMALSTRESS: int
    VSO_COHESIVE_NORMRELSEP: int
    VSO_COHESIVE_RELMATCS: int
    VSO_COHESIVE_XRELDISP: int
    VSO_COHESIVE_XRELDISPMATCS: int
    VSO_COHESIVE_XSHEARSTRESS: int
    VSO_COHESIVE_XSTRESS: int
    VSO_COHESIVE_YRELDISP: int
    VSO_COHESIVE_YRELDISPMATCS: int
    VSO_COHESIVE_YSHEARSTRESS: int
    VSO_COHESIVE_YSTRESS: int
    VSO_COHESIVE_ZRELDISP: int
    VSO_COHESIVE_ZRELDISPMATCS: int
    VSO_COHESIVE_ZSHEARSTRESS: int
    VSO_COHESIVE_ZSTRESS: int
    VSV_NONLINEAR_STRAIN: int
    VSV_NONLINEAR_STRESS: int
    VSV_STRAIN: int
    VSV_STRESS: int
    VST_CREEP: int
    VST_INT_PRIN: int
    VST_MAX_PRIN: int
    VST_MAX_SHEAR: int
    VST_MEAN: int
    VST_MIN_PRIN: int
    VST_OCT_SHEAR: int
    VST_PLASTIC: int
    VST_VOLUMETRIC: int
    VST_VON_MISES: int
    VST_X: int
    VST_XY: int
    VST_Y: int
    VST_YZ: int
    VST_Z: int
    VST_ZX: int
    FVD_AXIS_OF_SURFACE: int
    FVD_BISECT: int
    FVD_COMPONENTS: int
    FVD_DEFCS_AXIS: int
    FVD_DIRECTION: int
    FVD_GLOBAL_AXIS: int
    FVD_NORMAL: int
    FVD_NORMAL_TO_SURFACE: int
    FVD_NORMAL_TO_VIEW: int
    FVD_POSITION: int
    FVD_POSITION_LENGTH: int
    FVD_SAVED: int
    FVD_TANGENT: int
    FVD_USE_NODES: int
    FVD_USE_POINTS: int
    FTBV_ACCELERATION: int
    FTBV_NONE: int
    FTBV_SPHERICALVECTORSUNPLANET: int
    FTBV_SPHERICALVECTORSUNPLANETALTITUDE: int
    FTBV_SUNPLANET: int
    FTBV_SUNPLANETALTITUDE: int
    FVM_DRAW: int
    FVM_FEATURE: int
    FVM_FREE: int
    FVM_FREE_FACE: int
    FVM_HIDE: int
    FVM_SORT: int
    FVM_XY_OF_FUNCTION: int
    FVM_XY_VS_CASE: int
    FVM_XY_VS_ID: int
    FVM_XY_VS_POSITION: int
    FVM_XY_VS_VALUE: int
    FVI_AERO_INTERFERENCE: int
    FVI_AERO_MESH: int
    FVI_AERO_PANEL: int
    FVI_AERO_SPLINE: int
    FVI_AERO_SURFACE: int
    FVI_ANIMATED_STYLE: int
    FVI_ASPECT_RATIO: int
    FVI_AXISYM_AXIS: int
    FVI_BEAM_DIAGRAM: int
    FVI_BEAM_ORIENT: int
    FVI_BEAM_YAXIS: int
    FVI_BOLT_PRELOAD: int
    FVI_BOUNDARY: int
    FVI_CLIPPING_PLANE: int
    FVI_CLIP_PLANE: int
    FVI_COMPOSITE_CURVE: int
    FVI_CONNECTION_REGION: int
    FVI_CONNECTOR: int
    FVI_CONSTRAINT: int
    FVI_CONSTRAINT_EQUATION: int
    FVI_CONTOUR_ARROW_OPT: int
    FVI_CONTOUR_LEGEND: int
    FVI_CONTOUR_LEVELS: int
    FVI_CONTOUR_STYLE: int
    FVI_CONTOUR_TYPE: int
    FVI_CONTOUR_VECTOR: int
    FVI_CRITERIA_FAIL: int
    FVI_CRITERIA_LIMITS: int
    FVI_CRITERIA_PASS: int
    FVI_CSYS: int
    FVI_CURVE: int
    FVI_CURVE_ACCURACY: int
    FVI_CURVE_CONNECTIVITY: int
    FVI_CURVE_MESHSIZE: int
    FVI_DEFORMED: int
    FVI_DEFORMED_STYLE: int
    FVI_DRIVER_LOAD: int
    FVI_ELEMENT: int
    FVI_ELEMENT_COHESIVE: int
    FVI_ELEMENT_DIRECTION: int
    FVI_ELEMENT_MATL_DIR: int
    FVI_ELEMENT_OFFSET: int
    FVI_ELEMENT_ORIENT: int
    FVI_ELEMENT_SHELL: int
    FVI_ELEMENT_WELD: int
    FVI_ELEM_CSYS: int
    FVI_FEATURE_LINE: int
    FVI_FILLED_EDGES: int
    FVI_FILL_ELEM: int
    FVI_FREEBODY: int
    FVI_FREEBODY_NODAL_F: int
    FVI_FREEBODY_NODAL_M: int
    FVI_FREEBODY_NODEMARKER: int
    FVI_FREEBODY_TOTAL_F: int
    FVI_FREEBODY_TOTAL_M: int
    FVI_FREEBODY_VECTOR: int
    FVI_FREE_EDGE: int
    FVI_INTERIOR_CURVE: int
    FVI_INTERIOR_POINT: int
    FVI_INTERIOR_SURFACE: int
    FVI_ISOLINE: int
    FVI_ISOSURFACE: int
    FVI_KINEMATIC_JOINT: int
    FVI_LABEL: int
    FVI_LOAD_ACCELERATION: int
    FVI_LOAD_BODY: int
    FVI_LOAD_CONVECTION: int
    FVI_LOAD_DISTRIBUTEDLOAD: int
    FVI_LOAD_ENFORCEDDISP: int
    FVI_LOAD_FANCURVE: int
    FVI_LOAD_FLUIDTRACKING: int
    FVI_LOAD_FORCE: int
    FVI_LOAD_HEATFLUX: int
    FVI_LOAD_HEATGEN: int
    FVI_LOAD_MOMENT: int
    FVI_LOAD_NONLINEARFORCE: int
    FVI_LOAD_PERIODIC: int
    FVI_LOAD_PRESSURE: int
    FVI_LOAD_RADIATION: int
    FVI_LOAD_SLIPWALL: int
    FVI_LOAD_THERMAL: int
    FVI_LOAD_UNKNOWN: int
    FVI_LOAD_VECTORS: int
    FVI_LOAD_VELOCITY: int
    FVI_MESH_POINT: int
    FVI_MONITOR_POINT: int
    FVI_NASTRAN_GENERAL_MATRIX: int
    FVI_NODE: int
    FVI_NODE_PERMCONSTRAINT: int
    FVI_ORIGIN: int
    FVI_PERF_GRAPHICS: int
    FVI_PERSPECTIVE: int
    FVI_POINT: int
    FVI_POST_TITLES: int
    FVI_PREVIEW: int
    FVI_REGION_POST: int
    FVI_RENDER_OPTIONS: int
    FVI_RIGID: int
    FVI_SHADING: int
    FVI_SHRINK_ELEM: int
    FVI_SOLID: int
    FVI_STEREO: int
    FVI_STREAMLINE: int
    FVI_SURFACE: int
    FVI_SYMBOL: int
    FVI_TEXT: int
    FVI_TRACE_STYLE: int
    FVI_TRANSPARENCY: int
    FVI_UNDEFORMED: int
    FVI_VECTOR_STYLE: int
    FVI_VIEW_AXES: int
    FVI_VIEW_LEGEND: int
    FVI_VOLUME: int
    FVI_WORKPLANE: int
    FVI_WORKPLANE_GRID: int
    FVI_XY_AXES_STYLE: int
    FVI_XY_CURVE1: int
    FVI_XY_CURVE2: int
    FVI_XY_CURVE3: int
    FVI_XY_CURVE4: int
    FVI_XY_CURVE5: int
    FVI_XY_CURVE6: int
    FVI_XY_CURVE7: int
    FVI_XY_CURVE8: int
    FVI_XY_CURVE9: int
    FVI_XY_LEGEND: int
    FVI_XY_TITLES: int
    FVI_XY_XAXIS: int
    FVI_XY_YAXIS: int
    FVIS_AERO_PANEL: int
    FVIS_AERO_SPLINE: int
    FVIS_AERO_SURFACE: int
    FVIS_CONNECTION: int
    FVIS_CONNECTION_REGION: int
    FVIS_CSYS: int
    FVIS_CURVE: int
    FVIS_ELEM: int
    FVIS_ELEM_SHAPE: int
    FVIS_ELEM_TYPE: int
    FVIS_FREEBODY: int
    FVIS_MATL: int
    FVIS_POINT: int
    FVIS_PROP: int
    FVIS_SOLID: int
    FVIS_SURFACE: int
    FVO_BRICK: int
    FVO_PYRAMID: int
    FVO_TETRA: int
    FVO_WEDGE: int


class Read:
    CLSID: Any
    Exclusive: Any
    Line: Any
    Shared: Any
    SharedDelete: Any
    Truncated: Any

    def AtEOF(self) -> Any:
        """
        **Description:**
            This function indicates whether you have reached the end of the file.
        **Remarks/Usage:**
            You should always use this check to determine when you reach the end of the file. Depending on how the file was created, Read can continue to read and return unwanted characters after reaching the true end of the file. This method will however indicate the end when you reach it.
        **Return Code:** True\n
        """
        ...

    def BoolField(self, fieldID, defValue) -> Any:
        """
        **Description:**
            Parses the current line and returns the indicated field as a boolean value.
        **Remarks/Usage:**
            This function will interpret either 1, y, or yes as True, and 0, n or no as False. There is a limit of 49 fields which can be read by this method
        **Input:**
            **fieldID:** The ID of the field on the line (1..49).\n
            **defValue:** If the selected field is blank, the return value will be this value.\n
        **Return Code:** True\n
        :type fieldID: int

        :type defValue: bool

        """
        ...

    def ClearSearch(self) -> Any:
        """
        **Description:**
            Removes any search string(s) currently set via SetSearchString so they will no longer be considered when reading the file
        **Remarks/Usage:**
            After using this method, you can always use SetSearchString again to look for the same string(s) or different string(s), then simply use this method again to stop looking for those search strings
        **Return Code:** True\n
        """
        ...

    def Close(self) -> Any:
        """
        **Description:**
            This function closes the current file and frees the memory used for file buffering.
        **Remarks/Usage:**
            You should always call this method when you are done reading a file. You should not call this method if you have not successfully opened a file.
        **Return Code:** False\n
        """
        ...

    def Field(self, fieldID) -> Any:
        """
        **Description:**
            Parses the current line and returns the indicated field as a text string.
        **Remarks/Usage:**
            There is a limit of 49 fields which can be read by this method
        **Input:**
            **fieldID:** The ID of the field on the line (1..49).\n
        **Return Code:** False\n
        :type fieldID: int

        """
        ...

    def FixedFormat(self, numField, width) -> Any:
        """
        **Description:**
            Used to specify the number of fields and field widths for a fixed format read.
        **Remarks/Usage:**
            None
        **Input:**
            **numField:** The number of fields to parse from the line. Must be between 1 and 50.\n
            **width:** The widths, in characters, of the fields to parse.\n
        **Return Code:** False\n
        :type numField: int

        :type width: tuple[int]

        """
        ...

    def IntField(self, fieldID, defValue) -> Any:
        """
        **Description:**
            Parses the current line and returns the indicated field as an integer.
        **Remarks/Usage:**
            If the field is not blank, but does not contain an integer - either a real number or some other text - the return value will be 0, not the default value. There is a limit of 49 fields which can be read by this method
        **Input:**
            **fieldID:** The ID of the field on the line (1..49).\n
            **defValue:** If the selected field is blank, the return value will be this value.\n
        **Return Code:** True\n
        :type fieldID: int

        :type defValue: int

        """
        ...

    def Jump(self, jumpto) -> Any:
        """
        **Description:**
            This function repositions the location in the file where the next read will occur.
        **Remarks/Usage:**
            You should only specify jumpto as a value that you previously retrieved from a call to Position. Computing numbers yourself is prone to error because of handling of carriage control.
        **Input:**
            **jumpto:** The position to start reading. This position is the offset from the first byte in the file. Setting jumpto=0 positions to the beginning of the file\n
        **Return Code:** False\n
        :type jumpto: int

        """
        ...

    def JumpToEnd(self, jumpto) -> Any:
        """
        **Description:**
            This function repositions the location in the file where the next read will occur.
        **Remarks/Usage:**
            You should only specify jumpto as a value that you previously retrieved from a call to Position. Computing numbers yourself is prone to error because of handling of carriage control.
        **Input:**
            **jumpto:** The position to start reading. This position is the offset from the last byte in the file. Setting jumpto=0 positions to the end of the file\n
        **Return Code:** False\n
        :type jumpto: int

        """
        ...

    def LineInit(self, maxLineLength) -> Any:
        """
        **Description:**
            Used to initialize the necessary properties required for line parsing if you are not reading a file.
        **Remarks/Usage:**
            Normally you will not call this method. If you are reading a file and want to use the parsing/field capabilities, all of that will be handled automatically. If, however, you just want to use the parsing/field capabilities to parse text that you have from some other source, you can call this method to initialize the necessary properties. Then you simply set the line property to the text you want to parse and call the various field methods.
        **Input:**
            **maxLineLength:** The maximum length of line that you will be parsing.\n
        **Return Code:** False\n
        :type maxLineLength: int

        """
        ...

    def Open(self, filename, maxLineLength) -> Any:
        """
        **Description:**
            This function opens a file and prepares for reading.
        **Remarks/Usage:**
            You must call this function prior to reading from a file. You should always call Close when you are finished.
        **Input:**
            **filename:** The complete path to the file that you want to read.\n
            **maxLineLength:** The maximum length of any line of text in this file. Actually, this is simply the maximum length that you are interested in reading. Longer lines may exist in the file, but they will simply be truncated at this length.\n
        **Return Code:** True\n
        :type filename: str

        :type maxLineLength: int

        """
        ...

    def Position(self) -> Any:
        """
        **Description:**
            This function returns the current location in the file where you are reading.
        **Remarks/Usage:**
            This function can be used with Jump to reposition to a specific file location for rereading.
        **Return Code:** True\n
        """
        ...

    def Read(self) -> Any:
        """
        **Description:**
            This function reads a line from an open file.
        **Remarks/Usage:**
            This function reads the next line from the open file. The text from that line (without any carriage control) is loaded into the line property and can be accessed from there. If you use the various parsing/field methods; you do not need to access the line property. You should always call AtEOF to check whether you have reached the end of the file.
        **Return Code:** True\n
        """
        ...

    def RealField(self, fieldID, defValue) -> Any:
        """
        **Description:**
            Parses the current line and returns the indicated field as a real number.
        **Remarks/Usage:**
            If the field is not blank, but does not contain a real number - some other text - the return value will be 0.0, not the default value. There is a limit of 49 fields which can be read by this method.
        **Input:**
            **fieldID:** The ID of the field on the line (1..49).\n
            **defValue:** If the selected field is blank, the return value will be this value.\n
        **Return Code:** True\n
        :type fieldID: int

        :type defValue: float

        """
        ...

    def Reparse(self) -> Any:
        """
        **Description:**
            Used to indicate that you want to reparse the current line.
        **Remarks/Usage:**
            Use this method if you want to use multiple formats to parse the line. Call the field methods with the first format, change the format, call Reparse, and call the field routines again.
        **Return Code:** False\n
        """
        ...

    def SetAutoFormat(self) -> Any:
        """
        **Description:**
            Indicates that you want to parse a line using either fixed or free format.
        **Remarks/Usage:**
            This option checks the line for a comma. If any commas exist, free format is used; otherwise, fixed format is used.
        **Return Code:** False\n
        """
        ...

    def SetFixedFormat(self) -> Any:
        """
        **Description:**
            Indicates that you want to parse a line using fixed field widths.
        **Remarks/Usage:**
            You must call FixedFormat to specify the field widths.
        **Return Code:** False\n
        """
        ...

    def SetFormFeed(self, on) -> Any:
        """
        **Description:**
            Indicates that Form Feed (FF) characters should be treated as end-of-line carriage control.
        **Remarks/Usage:**
            Normally this method can be ignored - most text files do not contain form feed characters. If you are reading the formatted output of some other program, however, this may be important if the program relies on writing a form feed to end certain lines.
        **Input:**
            **on:** If True, FF characters will also end a line.\n
        **Return Code:** False\n
        :type on: bool

        """
        ...

    def SetFreeFormat(self) -> Any:
        """
        **Description:**
            Indicates that you want to parse a line using free format.
        **Remarks/Usage:**
            Free format indicates fields with either spaces or commas. Multiple commas create multiple fields. Multiple spaces do not.
        **Return Code:** False\n
        """
        ...

    def SetNoBlankLines(self, on) -> Any:
        """
        **Description:**
            Indicate whether or not to read blank lines.
        **Remarks/Usage:**
            Blank lines are lines containing no text, or lines that because of other processing are reduced to being a blank line.
        **Input:**
            **on:** If True, blank lines will be skipped.\n
        **Return Code:** False\n
        :type on: bool

        """
        ...

    def SetNoShortLines(self, on, minLineLength) -> Any:
        """
        **Description:**
            Indicate whether or not to read lines that are shorter than a specified length.
        **Remarks/Usage:**
            None
        **Input:**
            **on:** If True, short lines will be skipped.\n
            **minLineLength:** If on=True, lines shorter than this length will be skipped.\n
        **Return Code:** False\n
        :type on: bool

        :type minLineLength: int

        """
        ...

    def SetSearch(self, on) -> Any:
        """
        **Description:**
            Indicates that lines containing the search strings are to be kept and others are to be skipped.
        **Remarks/Usage:**
            This function must be used in combination with the SetSearchString method. This cannot be used with the SetSkip method.
        **Input:**
            **on:** If True, all lines that do not contain the search strings are skipped.\n
        **Return Code:** False\n
        :type on: bool

        """
        ...

    def SetSearchString(self, s, sor) -> Any:
        """
        **Description:**
            Searches for lines containing the specified strings.
        **Remarks/Usage:**
            This method can be called up to five times before reading to search for multiple strings.
        **Input:**
            **s:** The primary search string.\n
            **sor:** A second alternate string which could be on the line instead of mainStr. This should normally be specified as a blank string to just use the primary search string.\n
        **Return Code:** True\n
        :type s: str

        :type sor: str

        """
        ...

    def SetSkip(self, on) -> Any:
        """
        **Description:**
            Indicates that lines containing the search strings are to be skipped.
        **Remarks/Usage:**
            This function must be used in combination with the SetSearchString method. This cannot be used with the SetSearch method
        **Input:**
            **on:** If True, all lines that contain the search strings are skipped.\n
        **Return Code:** False\n
        :type on: bool

        """
        ...

    def SetSkipAfterSearch(self, lines) -> Any:
        """
        **Description:**
            Specifies the number of lines to skip after finding a line that contains one of the search strings.
        **Remarks/Usage:**
            In some cases you may want to skip certain headers in a file. You can search for a keyword in the header, then use this to skip the remaining header lines. If not specified, no lines are skipped.
        **Input:**
            **lines:** The number of lines to skip.\n
        **Return Code:** False\n
        :type lines: int

        """
        ...

    def SetTabSize(self, tabsize) -> Any:
        """
        **Description:**
            Specifies the number of spaces to convert tab characters into.
        **Remarks/Usage:**
            The size that you specify will be overridden by any choice that the user has made in the Global property Pref_ReadTabSize
        **Input:**
            **tabsize:** The number of spaces to convert into.\n
        **Return Code:** False\n
        :type tabsize: int

        """
        ...

    def SetTrimEndSpace(self, on) -> Any:
        """
        **Description:**
            Indicate whether or not to trim all white space characters off the end of each line.
        **Remarks/Usage:**
            Turning this on will delete all trailing spaces. This is just like SetTrimSpace, but only trims trailing, not leading white space.
        **Input:**
            **on:** If True, trailing white space will be trimmed.\n
        **Return Code:** False\n
        :type on: bool

        """
        ...

    def SetTrimFront(self, on, numChar) -> Any:
        """
        **Description:**
            Indicate whether or not to trim a certain number of characters off of the front of each line.
        **Remarks/Usage:**
            Turning this on trims numChar from the front of every line.
        **Input:**
            **on:** If True, leading characters will be trimmed.\n
            **numChar:** The number of characters to trim, regardless of content.\n
        **Return Code:** False\n
        :type on: bool

        :type numChar: int

        """
        ...

    def SetTrimSpace(self, on) -> Any:
        """
        **Description:**
            Indicate whether or not to trim all white space characters off of the front and back of each line.
        **Remarks/Usage:**
            Turning this on will delete all leading and trailing spaces. You normally only want to do this if the line is to be parsed using a free format. White space on the interior (after the first non-white space character and before the last non-white space character) is not deleted.
        **Input:**
            **on:** If True, white space will be trimmed.\n
        **Return Code:** False\n
        :type on: bool

        """
        ...

    def SetUppercase(self, on) -> Any:
        """
        **Description:**
            Returns all text in uppercase.
        **Remarks/Usage:**
            None
        **Input:**
            **on:** If True, all text will be returned in uppercase.\n
        **Return Code:** False\n
        :type on: bool

        """
        ...

    def ShowStatus(self, on) -> Any:
        """
        **Description:**
            Turn on or off the status bar in FEMAP during the read.
        **Remarks/Usage:**
            None
        **Input:**
            **on:** If True, the Status bar will be displayed showing the reading progress. If False, no Status bar will be displayed.\n
        **Return Code:** False\n
        :type on: bool

        """
        ...

    def Size(self, nSize) -> Any:
        """
        **Description:**
            This function returns the size of the file in bytes.
        **Remarks/Usage:**
            Note that the file size is an 8-byte integer - this allows support for files over 4 GByte.
        **Input:**
            **nSize:** The size of the file.\n
        **Return Code:** True\n
        :type nSize: int

        """
        ...

    def Skipped(self) -> Any:
        """
        **Description:**
            Indicates whether the last read actually skipped over one or more lines.
        **Remarks/Usage:**
            This method will only indicate lines were skipped if one or more of the methods are being used that causes short, blank or searched lines to be skipped.
        **Return Code:** True\n
        """
        ...

    def TimeAccessed(self, nTime) -> Any:
        """
        **Description:**
            Returns the time that the file was accessed.
        **Remarks/Usage:**
            Note that the file size is an 8-byte integer.
        **Input:**
            **nTime:** The time the file was accessed.\n
        **Return Code:** True\n
        :type nTime: int

        """
        ...

    def TimeCreated(self, nTime) -> Any:
        """
        **Description:**
            Returns the time that the file was created.
        **Remarks/Usage:**
            Note that the file size is an 8-byte integer.
        **Input:**
            **nTime:** The time the file was created.\n
        **Return Code:** True\n
        :type nTime: int

        """
        ...

    def TimeWritten(self, nTime) -> Any:
        """
        **Description:**
            Returns the time that the file was written.
        **Remarks/Usage:**
            Note that the file size is an 8-byte integer.
        **Input:**
            **nTime:** The time the file was written.\n
        **Return Code:** True\n
        :type nTime: int

        """
        ...


class Set:
    CLSID: Any
    CurrentID: Any
    ID: Any
    Save: Any

    def Add(self, entID) -> Any:
        """
        **Description:**
            This function adds an ID into a selection set.
        **Remarks/Usage:**
            The ID that you are adding to the selection set is just that, an ID. Although it usually represents the ID of some other existing entity in your model, there is no requirement for this.
        **Input:**
            **entID:** ID to add to the selection set.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def AddAll(self, entityTYPE) -> Any:
        """
        **Description:**
            This function adds the IDs of all existing entities of a selected type into the current selection set.
        **Remarks/Usage:**
            All entity IDs are added to the current set. The set is not emptied before this operation.
        **Input:**
            **entityTYPE:** Type of entity to select. For more information, see Section 3.3.6, "Entity Types". \n
        **Return Code:** True\n
        :type entityTYPE: int

        """
        ...

    def AddAllAnalysisCases(self, nAnalysisSetID) -> Any:
        """
        **Description:**
            This method adds the IDs of all Analysis Cases in the specified Analysis Set to the Set object.
        **Remarks/Usage:**
            None
        **Input:**
            **nAnalysisSetID:** ID of Analysis Set containing Analysis Cases to be added\n
        **Return Code:** True\n
        :type nAnalysisSetID: int

        """
        ...

    def AddAllColor(self, entityTYPE, nSetID, nColor, nColorMatch) -> Any:
        """
        **Description:**
            This function adds the selected entities which match a specified color.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entity to add. The entity type must have a color to be valid for this method.\n
            **nSetID:** Normally this should be 1. For specific set-based types such as the various load and constraint types, it must be the ID of the set to search for matching colors.\n
            **nColor:** The color to search for. This number is a combination of the color, linestyle and pattern/transparency\n
            **nColor:** Any combination of 1=Match Color only, 2=Match Pattern only, 4=Match Linestyle only. So 3=Match Color & Pattern, 6=Pattern & Linestyle, 5=Color & Linestyle, 7=Match All\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type nSetID: int

        :type nColor: int

        :type nColor: int

        """
        ...

    def AddAllConnectedElements(self) -> Any:
        """
        **Description:**
            This function adds all elements that are connected to the elements in the set to the current set
        **Remarks/Usage:**
            Connected elements are those that are connected to the same body as the specified elements, not just the elements that share nodes with the specified elements
        **Return Code:** False\n
        """
        ...

    def AddAllExcept(self, entityTYPE, exceptSET) -> Any:
        """
        **Description:**
            This function adds the IDs of all existing entities of a selected type into the current selection set, except those already selected in exceptSET.
        **Remarks/Usage:**
            The set is not emptied before this operation.
        **Input:**
            **entityTYPE:** Type of entity to select. For more information, see Section 3.3.6, "Entity Types". \n
            **exceptSET:** The ID of a set that contains the IDs of entities to not add into this set. Specify a negative number to skip adding a single entity.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type exceptSET: int

        """
        ...

    def AddAllInRange(self, entityTYPE, startID, stopID) -> Any:
        """
        **Description:**
            This function adds all IDs in a given range specified by a start ID (first ID in range) and stop ID (last ID in range).
        **Remarks/Usage:**
            Cannot be properly used with set-based Entity Types (i.e., output vectors, individual loads, individual boundary conditions, etc), as it will always return entities in the given range from Set ID 1.
        **Input:**
            **entityTYPE:** Type of entity to select. For more information, see Section 3.3.6, "Entity Types". \n
            **startID:** The first ID in the range of IDs to add\n
            **stopID:** The last ID in the range of IDs to add\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type startID: int

        :type stopID: int

        """
        ...

    def AddAllInRangeInSetV2(self, entityTYPE, nSetID, startID, stopID) -> Any:
        """
        **Description:**
            This method replaces AddAllInRangeInSet. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above". This method adds a range of entities by ID from an already populated entity set.
        **Remarks/Usage:**

        **Input:**
            **nSetID:** The ID of the set object to add from. \n
            **startID:** The ID of the entity to start from. \n
            **stopID:** The ID of the entity to stop at. \n
        **Return Code:** True\n
        :type nSetID: int

        :type startID: int

        :type stopID: int

        """
        ...

    def AddAllSavedSetIDs(self) -> Any:
        """
        **Description:**
            This method will add the IDs of the Sets currently saved to this set.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def AddAllTitleV2(self, entityTYPE, nSetID, sFind) -> Any:
        """
        **Description:**
            This method replaces AddAllTitleV2. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above". This function adds the selected entities which have matching titles.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entity to add. The entity type must have a title to be valid for this method.\n
            **nSetID:** Normally this should be 1. For specific set-based types such as Load and Constraint Definitions, it must be the ID of the set to search for matching titles.\n
            **sFind:** A text string that will be compared to the entity title. If this string is found anywhere in the title, that entity ID will be added to the set. Comparisons are not case sensitive.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type nSetID: int

        :type sFind: str

        """
        ...

    def AddAroundPlane(self, entityTYPE, vBase, vVec, nMode, dMin, vdMax) -> Any:
        """
        **Description:**
            This function adds entity IDs of entities which are currently visible into a set as selected by their proximity to a specified plane
        **Remarks/Usage:**
            This works just like the Around Plane coordinate selection available from the entity selection dialog.
        **Input:**
            **entityTYPE:** The type of entities being included into the set. For entity information, see Section 3.3.6, "Entity Types". Only Point, Curve, Surface, Boundary, Solid, Volume, Node, Element, Property, Material, Coordinate System, Layup, Text, Connection_Region, Connection and Connection _Prop entity types are valid.\n
            **vBase:** The coordinates, in Global Rectangular coordinates, of a point on the plane around which to search for selections.\n
            **vVec:** The components, in Global Rectangular coordinates, of the normal to the plane around which to search for selections.\n
            **nMode:** 0=Select Above Maximum (Positive Side), 1=Select Below Minimum (Negative Side), 2=Select Outside (Below Min,Above Max), 3=Select Between (Above Min and Below Max), 4=Select At within Tolerance\n
            **dMin:** The minimum coordinate for most modes. Not used for Above Maximum. For Select At the coordinate location to select around.\n
            **vdMax:** The maximum coordinate for most modes. Not used for Below Minimum. For Select At the tolerance around the specified location that the coordinate must fall within to be selected.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type vBase: tuple[float]

        :type vVec: tuple[float]

        :type nMode: int

        :type dMin: float

        :type vdMax: float

        """
        ...

    def AddAroundPlane2(self, entityTYPE, vBase, vVec, nMode, dMin, vdMax) -> Any:
        """
        **Description:**
            This function adds entity IDs into a set as selected by their proximity to a specified plane
        **Remarks/Usage:**
            This works just like the Around Plane coordinate selection available from the entity selection dialog except it selects both visible and non-visible entities.
        **Input:**
            **entityTYPE:** The type of entities being included into the set. For entity information, see Section 3.3.6, "Entity Types". Only Point, Curve, Surface, Solid, Node, Element, Property, Material, Coordinate System, Layup, Text, Connection_Region, and Connection types are valid.\n
            **vBase:** The coordinates, in Global Rectangular coordinates, of a point on the plane around which to search for selections.\n
            **vVec:** The components, in Global Rectangular coordinates, of the normal to the plane around which to search for selections.\n
            **nMode:** 0=Select Above Maximum (Positive Side), 1=Select Below Minimum (Negative Side), 2=Select Outside (Below Min,Above Max), 3=Select Between (Above Min and Below Max), 4=Select At within Tolerance\n
            **dMin:** The minimum coordinate for most modes. Not used for Above Maximum. For Select At the coordinate location to select around.\n
            **vdMax:** The maximum coordinate for most modes. Not used for Below Minimum. For Select At the tolerance around the specified location that the coordinate must fall within to be selected.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type vBase: tuple[float]

        :type vVec: tuple[float]

        :type nMode: int

        :type dMin: float

        :type vdMax: float

        """
        ...

    def AddAroundPoint(self, entityTYPE, vBase, nMode, dMin, vdMax) -> Any:
        """
        **Description:**
            This function adds entity IDs of entities which are currently visible into a set as selected by their proximity to a specified location
        **Remarks/Usage:**
            This works just like the Around Point coordinate selection available from the entity selection dialog.
        **Input:**
            **entityTYPE:** The type of entities being included into the set. For entity information, see Section 3.3.6, "Entity Types". Only Point, Curve, Surface, Boundary, Solid, Volume, Node, Element, Property, Material, Coordinate System, Layup, Text, Connection_Region, Connection and Connection _Prop entity types are valid.\n
            **vBase:** The coordinates, in Global Rectangular coordinates, of the point to search around for selections.\n
            **nMode:** 0=Select Above Maximum (Farther Than), 1=Select Below Minimum (Closer Than), 2=Select Outside (Below Min,Above Max), 3=Select Between (Above Min and Below Max), 4=Select At within Tolerance\n
            **dMin:** The minimum coordinate for most modes. Not used for Above Maximum. For Select At the coordinate location to select around.\n
            **vdMax:** The maximum coordinate for most modes. Not used for Below Minimum. For Select At the tolerance around the specified location that the coordinate must fall within to be selected.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type vBase: tuple[float]

        :type nMode: int

        :type dMin: float

        :type vdMax: float

        """
        ...

    def AddAroundPoint2(self, entityTYPE, vBase, nMode, dMin, vdMax) -> Any:
        """
        **Description:**
            This function adds entity IDs into a set as selected by their proximity to a specified location
        **Remarks/Usage:**
            This works just like the Around Point coordinate selection available from the entity selection dialog except it selects both visible and non-visible entities.
        **Input:**
            **entityTYPE:** The type of entities being included into the set. For entity information, see Section 3.3.6, "Entity Types". Only Point, Curve, Surface, Solid, Node, Element, Property, Material, Coordinate System, Layup, Text, Connection_Region, and Connection types are valid.\n
            **vBase:** The coordinates, in Global Rectangular coordinates, of the point to search around for selections.\n
            **nMode:** 0=Select Above Maximum (Farther Than), 1=Select Below Minimum (Closer Than), 2=Select Outside (Below Min,Above Max), 3=Select Between (Above Min and Below Max), 4=Select At within Tolerance\n
            **dMin:** The minimum coordinate for most modes. Not used for Above Maximum. For Select At the coordinate location to select around.\n
            **vdMax:** The maximum coordinate for most modes. Not used for Below Minimum. For Select At the tolerance around the specified location that the coordinate must fall within to be selected.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type vBase: tuple[float]

        :type nMode: int

        :type dMin: float

        :type vdMax: float

        """
        ...

    def AddAroundVector(self, entityTYPE, vBase, vVec, nMode, dMin, vdMax) -> Any:
        """
        **Description:**
            This function adds entity IDs of entities which are currently visible into a set as selected by their proximity to a specified vector
        **Remarks/Usage:**
            This works just like the Around Vector coordinate selection available from the entity selection dialog.
        **Input:**
            **entityTYPE:** The type of entities being included into the set. For entity information, see Section 3.3.6, "Entity Types". Only Point, Curve, Surface, Boundary, Solid, Volume, Node, Element, Property, Material, Coordinate System, Layup, Text, Connection_Region, Connection and Connection _Prop entity types are valid.\n
            **vBase:** The coordinates, in Global Rectangular coordinates, of the base of the vector around which to search for selections.\n
            **vVec:** The components, in Global Rectangular coordinates, of the vector around which to search for selections.\n
            **nMode:** 0=Select Above Maximum (Farther Than), 1=Select Below Minimum (Closer Than), 2=Select Outside (Below Min,Above Max), 3=Select Between (Above Min and Below Max), 4=Select At within Tolerance\n
            **dMin:** The minimum coordinate for most modes. Not used for Above Maximum. For Select At the coordinate location to select around.\n
            **vdMax:** The maximum coordinate for most modes. Not used for Below Minimum. For Select At the tolerance around the specified location that the coordinate must fall within to be selected.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type vBase: tuple[float]

        :type vVec: tuple[float]

        :type nMode: int

        :type dMin: float

        :type vdMax: float

        """
        ...

    def AddAroundVector2(self, entityTYPE, vBase, vVec, nMode, dMin, vdMax) -> Any:
        """
        **Description:**
            This function adds entity IDs into a set as selected by their proximity to a specified vector
        **Remarks/Usage:**
            This works just like the Around Vector coordinate selection available from the entity selection dialog except it selects both visible and non-visible entities.
        **Input:**
            **entityTYPE:** The type of entities being included into the set. For entity information, see Section 3.3.6, "Entity Types". Only Point, Curve, Surface, Solid, Node, Element, Property, Material, Coordinate System, Layup, Text, Connection_Region, and Connection types are valid.\n
            **vBase:** The coordinates, in Global Rectangular coordinates, of the base of the vector around which to search for selections.\n
            **vVec:** The components, in Global Rectangular coordinates, of the vector around which to search for selections.\n
            **nMode:** 0=Select Above Maximum (Farther Than), 1=Select Below Minimum (Closer Than), 2=Select Outside (Below Min,Above Max), 3=Select Between (Above Min and Below Max), 4=Select At within Tolerance\n
            **dMin:** The minimum coordinate for most modes. Not used for Above Maximum. For Select At the coordinate location to select around.\n
            **vdMax:** The maximum coordinate for most modes. Not used for Below Minimum. For Select At the tolerance around the specified location that the coordinate must fall within to be selected.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type vBase: tuple[float]

        :type vVec: tuple[float]

        :type nMode: int

        :type dMin: float

        :type vdMax: float

        """
        ...

    def AddArray(self, numID, arrayID) -> Any:
        """
        **Description:**
            This function adds an array of IDs into a selection set.
        **Remarks/Usage:**
            This is just like the Add Method, but it can be used to add multiple IDs in one call.
        **Input:**
            **numID:** The number of entries in the arrayID array\n
            **arrayID:** An array of IDs to be added to the selection set.\n
        **Return Code:** True\n
        :type numID: int

        :type arrayID: tuple[int]

        """
        ...

    def AddBySize(self, entityTYPE, nLimitSetID, nMethod, dMinVal, dMaxVal) -> Any:
        """
        **Description:**
            This method adds entities from an existing set by a method type given a minimum and maximum value.
        **Remarks/Usage:**
            Minimum and Maximum values apply to the corresponding entity type, length for Curve, area for Surface, Volume for Solid.
        **Input:**
            **nLimitSetID:** The ID of the set object to add from. \n
            **nMethod:** Type of method to add by. 0 = FPC_ABOVE_MAX, 1 = FPC_BELOW_MIN, 2 = FPC_OUTSIDE, 3 = FPC_BETWEEN, 4 = FPC_AT\n
            **dMinVal:**  The minimum value used in the method type for adding.\n
            **dMaxVal:** The maximum value used in the method type for adding. \n
        **Return Code:** True\n
        :type nLimitSetID: int

        :type nMethod: int

        :type dMinVal: float

        :type dMaxVal: float

        """
        ...

    def AddCommon(self, set1, set2) -> Any:
        """
        **Description:**
            This function adds all IDs that are in both set1 and set2 to the current selection set.
        **Remarks/Usage:**
            IDs must exist in both set1 and set2 to be added. Only the current set is updated by this command - the other sets remain unchanged.
        **Input:**
            **set1:** ID of the first selection set to check.\n
            **set2:** ID of the second selection set to check.\n
        **Return Code:** True\n
        :type set1: int

        :type set2: int

        """
        ...

    def AddComplexOutputVectorsV2(self, nFromOutputSetID) -> Any:
        """
        **Description:**
            This method replaces AddComplexOutputVectors. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above". This method adds complex Output Vectors found in the specified Output Set, which correspond to the Output Vector IDs currently in the Set Object. For instance, if Magnitude Output Vectors are currently in the Set Object, then the corresponding Phase Output Vectors will be added or vice versa. Also, if Real Output Vectors are currently in the Set Object, then the corresponding Imaginary Output Vectors will be added and vice versa.
        **Remarks/Usage:**

        **Input:**
            **nFromOutputSetID:** Output Set ID\n
        **Return Code:** True\n
        :type nFromOutputSetID: int

        """
        ...

    def AddComponentOutputVectorsV2(self, nFromOutputSetID) -> Any:
        """
        **Description:**
            This method replaces AddComponentOutputVectors. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above". This method adds any Component and/or Corner Output Vectors found in the specified Output Set ID, which are component/corner output vectors for Output Vector IDs currently in the Set Object.
        **Remarks/Usage:**
            This method is similar to using the Add Component/Corner Resultsbutton in dialog boxes which allow you to select any combination of Output Sets and Output Vectors.
        **Input:**
            **nFromOutputSetID:** Output Set ID\n
        **Return Code:** True\n
        :type nFromOutputSetID: int

        """
        ...

    def AddConnectedElements(self) -> Any:
        """
        **Description:**
            This function adds elements that are connected to the elements in the set to the current set
        **Remarks/Usage:**
            Connected elements are those elements that share at least one node with the specified elements
        **Return Code:** False\n
        """
        ...

    def AddConnectedFillets(self) -> Any:
        """
        **Description:**
            This function adds all connected fillets to the ones specified in the set and adds them to the set
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def AddConstrained(self, bInAnySet, nSetID, bExpandBC, enOnType, enMatch, bDOF1, bDOF2, bDOF3, bDOF4, bDOF5,
                       bDOF6) -> Any:
        """
        **Description:**
            This function adds constrained nodes, points, curves or surfaces to the current set
        **Remarks/Usage:**
            How the six degree-of-freedom flags are used for matching constraints depends on the specified match type for enMatch
        **Input:**
            **bInAnySet:** When True, adds entities constrained in any constraint set. When False, only considers entities constrained in the constraint set specified for nSetID\n
            **nSetID:** ID of Constraint set. Ignored if bInAnySet = TRUE\n
            **bExpandBC:** Expand geometric constraints when searching for constrained nodes\n
            **enOnType:** Constrained entity type. For more information, see Section 3.3.6, "Entity Types". Supported types are Nodes (FT_NODE), Points (FT_POINT), Curves (FT_CURVE), and Surfaces (FT_SURFACE)\n
            **enMatch:** Match method for degrees of freedom (See Remarks/Usage section). \n
            **bDOF1:** DOF1 (TX)\n
            **bDOF2:** DOF2 (TY)\n
            **bDOF3:** DOF3 (TZ)\n
            **bDOF4:** DOF4 (RX)\n
            **bDOF5:** DOF5 (RY)\n
            **bDOF6:** DOF6 (RZ)\n
        **Return Code:** True\n
        :type bInAnySet: bool

        :type nSetID: int

        :type bExpandBC: bool

        :type enOnType: int

        :type enMatch: int

        :type bDOF1: bool

        :type bDOF2: bool

        :type bDOF3: bool

        :type bDOF4: bool

        :type bDOF5: bool

        :type bDOF6: bool

        """
        ...

    def AddCoordinate(self, entityTYPE, nCSysID, vbXYZ, vnMode, vdMin, vdMax) -> Any:
        """
        **Description:**
            This function adds entity IDs of entities which are currently visible into a set as selected by their coordinate locations
        **Remarks/Usage:**
            This works just like the coordinate selection available from the entity selection dialog.
        **Input:**
            **entityTYPE:** The type of entities being included into the set. For entity information, see Section 3.3.6, "Entity Types". Only Point, Curve, Surface, Boundary, Solid, Volume, Node, Element, Property, Material, Coordinate System, Layup, Text, Connection_Region, Connection and Connection _Prop entity types are valid.\n
            **nCSysID:** The ID of the coordinate system to select in. For Rectangular systems, coordinate directions are XYZ. For Cylindrical systems, the coordinate directions are R,Theta,Z, and for Spherical, R,Theta,Phi\n
            **vbXYZ:** Flags to consider selecting based on the associated coordinate direction. If True, then the other arguments are used to define the selection. If False, no selections will be done based on that coordinate.\n
            **vnMode:** 0=Select Above Maximum, 1=Select Below Minimum, 2=Select Outside (Below Min,Above Max), 3=Select Between (Above Min and Below Max), 4=Select At within Tolerance\n
            **vdMin:** The minimum coordinate for most modes. Not used for Above Maximum. For Select At the coordinate location to select around.\n
            **vdMax:** The maximum coordinate for most modes. Not used for Below Minimum. For Select At the tolerance around the specified location that the coordinate must fall within to be selected.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type nCSysID: int

        :type vbXYZ: tuple[bool]

        :type vnMode: tuple[int]

        :type vdMin: tuple[float]

        :type vdMax: tuple[float]

        """
        ...

    def AddCoordinate2(self, entityTYPE, nCSysID, vbXYZ, vnMode, vdMin, vdMax) -> Any:
        """
        **Description:**
            This function adds entity IDs into a set as selected by their coordinate locations
        **Remarks/Usage:**
            This works just like the coordinate selection available from the entity selection dialog except it selects both visible and non-visible entities.
        **Input:**
            **entityTYPE:** The type of entities being included into the set. For entity information, see Section 3.3.6, "Entity Types". Only Point, Curve, Surface, Solid, Node, Element, Property, Material, Coordinate System, Layup, Text, Connection_Region, and Connection types are valid.\n
            **nCSysID:** The ID of the coordinate system to select in. For Rectangular systems, coordinate directions are XYZ. For Cylindrical systems, the coordinate directions are R,Theta,Z, and for Spherical, R,Theta,Phi\n
            **vbXYZ:** Flags to consider selecting based on the associated coordinate direction. If True, then the other arguments are used to define the selection. If False, no selections will be done based on that coordinate.\n
            **vnMode:** 0=Select Above Maximum, 1=Select Below Minimum, 2=Select Outside (Below Min,Above Max), 3=Select Between (Above Min and Below Max), 4=Select At within Tolerance\n
            **vdMin:** The minimum coordinate for most modes. Not used for Above Maximum. For Select At the coordinate location to select around.\n
            **vdMax:** The maximum coordinate for most modes. Not used for Below Minimum. For Select At the tolerance around the specified location that the coordinate must fall within to be selected.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type nCSysID: int

        :type vbXYZ: tuple[bool]

        :type vnMode: tuple[int]

        :type vdMin: tuple[float]

        :type vdMax: tuple[float]

        """
        ...

    def AddEntitiesOnLayer(self, laySET, entityTYPE) -> Any:
        """
        **Description:**
            This function adds all entities of a selected type that are on a set of layers into the set.
        **Remarks/Usage:**
            None
        **Input:**
            **laySET:** The setID that contains the layers to include. Specify a negative number to include entities on a single layer.\n
            **entityTYPE:** The type of entities being included into the set. Only those entities that reference a layer in laySET will be included. For entity information, see Section 3.3.6, "Entity Types"\n
        **Return Code:** True\n
        :type laySET: int

        :type entityTYPE: int

        """
        ...

    def AddGroup(self, entityTYPE, groupID) -> Any:
        """
        **Description:**
            This function adds the all of the IDs of a selected type from a group into the current selection set.
        **Remarks/Usage:**
            All entity IDs from the group are added to the current set. The set is not emptied before this operation.
        **Input:**
            **entityTYPE:** Type of entity to select. For more information, see Section 3.3.6, "Entity Types".\n
            **groupID:** ID of the group to copy IDs from.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type groupID: int

        """
        ...

    def AddLoaded(self, bInAnySet, nSetID, bExpandLoad, enLoadType, enRangeOpt, dMin, dMax) -> Any:
        """
        **Description:**
            This function adds loaded entities to the current set. The type of entity added depends on the load type specified and if geometric loads are expanded.
        **Remarks/Usage:**
            For loads that consist of multiple components, such as nodal forces, the search is performed on the resultant value, not each individual component
        **Input:**
            **bInAnySet:** When True, adds entities loaded in any load set. When False, only considers entities loaded in the load set specified for nSetID\n
            **nSetID:** ID of load set. Ignored if bInAnySet = TRUE\n
            **bExpandLoad:** Expand geometric loads when searching for loaded nodes or elements, as appropriate\n
            **enLoadType:** Loaded entity type. For more information, see Section 3.3.6, "Entity Types". Supported types are Nodes (FT_NODE), Elements (FT_ELEM), Points (FT_POINT), Curves (FT_CURVE), and Surfaces (FT_SURFACE)\n
            **enRangeOpt:** Search Range\n
            **dMin:** Minimum Load Value\n
            **dMax:** Maximum Load Value\n
        **Return Code:** True\n
        :type bInAnySet: bool

        :type nSetID: int

        :type bExpandLoad: bool

        :type enLoadType: int

        :type enRangeOpt: int

        :type dMin: float

        :type dMax: float

        """
        ...

    def AddMidsideNodes(self, nSetID) -> Any:
        """
        **Description:**
            This function adds the midside nodes that are on selected elements
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** The ID of a Set object that contains the elements that reference the midside nodes to add. Alternatively, if you specify a negative value, this is simply the ID of the single element.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def AddNewRemoveCommonSet(self, addID) -> Any:
        """
        **Description:**
            This function adds all IDs in addID that are not in the current set, and removes any IDs that are common to both sets
        **Remarks/Usage:**
            This method implements a boolean XOR of the addID set and the current set.
        **Input:**
            **addID:** ID of the set to combine with the current set\n
        **Return Code:** True\n
        :type addID: int

        """
        ...

    def AddNodesOnFreeEdges(self, elemSetID, bParabolicEdges, bLineElem) -> Any:
        """
        **Description:**
            This method adds the nodes found on the free edges in a set of elements to a set.
        **Remarks/Usage:**
            None
        **Input:**
            **elemSetID:** The ID of a Set object that contains the elements that reference the nodes on free edges to add. If 0, all elements in the model are used. Alternatively, if you specify a negative value, this is simply the ID of the single element.\n
            **bParabolicEdges:** If True, the computation of Free Edges includes checking the midside nodes (if any). If False, only corner nodes are considered.\n
            **bLineElem:** If True, then any line elements that lie along an edge are considered when deciding if the edge is free.\n
        **Return Code:** True\n
        :type elemSetID: int

        :type bParabolicEdges: bool

        :type bLineElem: bool

        """
        ...

    def AddNodesOnFreeFaces(self, elemSetID, bParabolicEdges, bPlaneElem) -> Any:
        """
        **Description:**
            This method adds the nodes found on the free faces in a set of elements to a set.
        **Remarks/Usage:**
            None
        **Input:**
            **elemSetID:** The ID of a Set object that contains the elements that reference the nodes on free faces to add. If 0, all elements in the model are used. Alternatively, if you specify a negative value, this is simply the ID of the single element.\n
            **bParabolicEdges:** If True, the computation of Free Faces includes checking the midside nodes (if any). If False, only corner nodes are considered.\n
            **bPlaneElem:** If True, then any selected plane elements are considered when deciding if the face is free.\n
        **Return Code:** True\n
        :type elemSetID: int

        :type bParabolicEdges: bool

        :type bPlaneElem: bool

        """
        ...

    def AddNodesOnGeometry(self, geomTYPE, geomID, bClear, bFullTree, bBoundaryOnly) -> Any:
        """
        **Description:**
            This function adds nodes to the set which are attached to the specified geometry.
        **Remarks/Usage:**
            If bClear is false this method can be called multiple times to build up an accumulated list.
        **Input:**
            **geomTYPE:** The type of entity to find attached nodes.\n
            **geomID:** ID of entity to find attached nodes.\n
            **bClear:** Flag to clear the set before adding nodes.\n
            **bFullTree:** If True, the nodes attached to the sub entities are also included ( Solid = Surf,Curve,Point: Surf=Curve,Point: Curve=Point )\n
            **bBoundaryOnly:** Flag to only include nodes at the boundary of the entity.\n
        **Return Code:** True\n
        :type geomTYPE: int

        :type geomID: int

        :type bClear: bool

        :type bFullTree: bool

        :type bBoundaryOnly: bool

        """
        ...

    def AddRange(self, startID, stopID, increment) -> Any:
        """
        **Description:**
            This function adds a range of IDs into a selection set.
        **Remarks/Usage:**
            This is just like the Add Method, but it can be used to add multiple IDs in one call.
        **Input:**
            **startID:** The first ID to add to the selection set.\n
            **stopID:** The last ID to add to the selection set.\n
            **increment:** The ID increment between startID and stopID. Must be a positive number. \n
        **Return Code:** True\n
        :type startID: int

        :type stopID: int

        :type increment: int

        """
        ...

    def AddRule(self, nID, ruleID) -> Any:
        """
        **Description:**
            This function adds to a selection set by using one of the standard group selection rules.
        **Remarks/Usage:**
            This is a very powerful tool to create selections which reference attributes of another entity. There are many group selection rules - review them carefully to choose the appropriate one for your task. This function adds to the set; it does not clear previous additions.
        **Input:**
            **nID:** The ID that you are specifying. The interpretation of this value depends on the type of rule that you select.\n
            **ruleID:** ID of a selection rule. For more information, see Section 4.6.2.7, "Group Selection Rules".\n
        **Return Code:** True\n
        :type nID: int

        :type ruleID: int

        """
        ...

    def AddSet(self, addID) -> Any:
        """
        **Description:**
            This function adds all of the selected IDs from another set into the current set.
        **Remarks/Usage:**
            This function simply adds all IDs in the addID set into the current set. Duplication does not cause an error; the ID will simply remain selected. The addID set remains unchanged during this command - only the current set is updated.
        **Input:**
            **addID:** ID of the selection set containing IDs to add. Accessed from the ID property of the set.\n
        **Return Code:** True\n
        :type addID: int

        """
        ...

    def AddSetFromModel(self, addID, nModelID, bClear) -> Any:
        """
        **Description:**
            This method adds the IDs of an set which exists in another model into a set in the current model.
        **Remarks/Usage:**
            None
        **Input:**
            **addID:** ID of a Set that exists in the model specified in nModelID\n
            **nModelID:** Model identifier\n
            **bClear:** If True, clears the set in the current model before adding IDs from set in the other model\n
        **Return Code:** True\n
        :type addID: int

        :type nModelID: int

        :type bClear: bool

        """
        ...

    def AddSetRule(self, addID, ruleID) -> Any:
        """
        **Description:**
            This function adds to a selection set by using one of the standard group selection rules. It uses the IDs from another selection set to create the new one.
        **Remarks/Usage:**
            This function is just like calling AddRule( ) once for each of the IDs in the addID set. This function adds to the current set; it does not clear previous additions.
        **Input:**
            **addID:** The selection set where the IDs will be found. The interpretation of these IDs depends on the type of rule that you select.\n
            **ruleID:** ID of a selection rule. For more information, see Section 4.6.2.7, "Group Selection Rules". \n
        **Return Code:** True\n
        :type addID: int

        :type ruleID: int

        """
        ...

    def AddSetToSavedSet(self, nSavedID, entityTYPE) -> Any:
        """
        **Description:**
            This method adds the contents of the current Set into a SavedSet
        **Remarks/Usage:**
            This method can be called to add the same Set into a SavedSet multiple times however the entities in the Set will only be added once. In addition, a single RemoveSetFromSavedSet will eliminate the entities in the Set from the SavedSet.
        **Input:**
            **nSavedID:** The ID of the SavedSet to create or overwrite. To create a new SavedSet you should always use EmptySavedSet method to find the ID of an available set. \n
            **entityTYPE:** Type of entity whose IDs are in the Set. For more information, see Section 3.3.6, "Entity Types". Currently, the following types will automatically support renumbering and locking entities from delete: FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, FT_ELEM, FT_MATL, FT_PROP, FT_CSYS and FT_FUNCTION_DIR. \n
        **Return Code:** True\n
        :type nSavedID: int

        :type entityTYPE: int

        """
        ...

    def AddSimilarOutputVectorsV2(self, nFromOutputSetID) -> Any:
        """
        **Description:**
            This method replaces AddSimilarOutputVectors. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above". This method adds any Similar Output Vectors found in the specified Output Set ID, which are similar output vectors for Output Vector IDs currently in the Set Object. Similar Output Vectors include output vectors at different locations and corners/ends (i.e., Top/Bottom for shell elements at Centroid and Corners, All Four Stress Recovery Points on End A and End B for Bar/Beam elements, All Plies for laminate elements, etc).
        **Remarks/Usage:**
            This method is somewhat similar to using the Add Similar Layer/Ply Resultsbutton and Add Component/Corner Resultsbutton in dialog boxes which allow you to select any combination of Output Sets and Output Vectors, but may result in more similar output vectors then expected to be selected.
        **Input:**
            **nFromOutputSetID:** Output Set ID\n
        **Return Code:** True\n
        :type nFromOutputSetID: int

        """
        ...

    def AddSolidElementsAlongVector(self, p1, p2, elemSET, bRequireIntersect, bInfiniteVector,
                                    bDirectionalVector) -> Any:
        """
        **Description:**
            This function adds solid elements along the specified vector.
        **Remarks/Usage:**
            Midside nodes of parabolic elements are ignored when using the intersection check, therefore, all element faces of parabolic elements are tested the same as those of linear elements.
        **Input:**
            **elemSET:** ID of set of elements which can be added. Alternatively, if you specify a negative value, this is simply the ID of a single element. Enter a value of 0 to allow all solid elements to potentially be added.\n
            **bRequireIntersect:** When True, vector must hit the element. When False, vector must only hit the element box (faster but returns more elements, including ones that don't really touch the vector)\n
            **bInfiniteVector:** When False, vector is really the line segment between the two points, intersections beyond the ends are not returned. When True, vector extends to infinity\n
            **bDirectionalVector:** Only used if bInfiniteVector is True. If True, Vector only extends beyond point 2, not behind point 1. If False, extends in both directions.\n
        **Return Code:** True\n
        :type elemSET: int

        :type bRequireIntersect: bool

        :type bInfiniteVector: bool

        :type bDirectionalVector: bool

        """
        ...

    def AddTangentSurfaces(self, dTol) -> Any:
        """
        **Description:**
            This method finds all surfaces tangent to those within the current set, within the specified tolerance, and adds them to the set
        **Remarks/Usage:**

        **Input:**
            **dTol:** Tangency tolerance angle, in degrees\n
        **Return Code:** True\n
        :type dTol: float

        """
        ...

    def AddToSavedSet(self, nSavedID, entityTYPE, entID) -> Any:
        """
        **Description:**
            This method adds a single entity ID to a SavedSet
        **Remarks/Usage:**
            This method can be called to add the same entity into a SavedSet multiple times however it will only be added once. In addition, a single RemoveFromSavedSet will eliminate the entity from the SavedSet.
        **Input:**
            **nSavedID:** The ID of the SavedSet to create or overwrite. To create a new SavedSet you should always use EmptySavedSet method to find the ID of an available set. \n
            **entityTYPE:** Type of entity whose IDs are in the Set. For more information, see Section 3.3.6, "Entity Types". Currently, the following types will automatically support renumbering and locking entities from delete: FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, FT_ELEM, FT_MATL, FT_PROP, FT_CSYS and FT_FUNCTION_DIR. \n
            **entID:** The ID of the entity to add to the SavedSet\n
        **Return Code:** True\n
        :type nSavedID: int

        :type entityTYPE: int

        :type entID: int

        """
        ...

    def AddVisible(self, nVuID, entityTYPE, bUseViewDrawEntityOption) -> Any:
        """
        **Description:**
            This function adds entities of the specified type which are visible in the specified view to the current set.
        **Remarks/Usage:**
            With respect to this function, visible entities are any entities currently visible in the view, even if the entities are off screen because of the current orientation or you are zoomed in and only looking at a portion of the model.
        **Input:**
            **nVuID:** ID of View\n
        **Return Code:** True\n
        :type nVuID: int

        """
        ...

    def ConvertToAllCurves(self) -> Any:
        """
        **Description:**
            This function expands the current Set to contain all curves referenced by what is currently in the Set
        **Remarks/Usage:**
            If any Combined Curves are in the Set, then all curves used to define them are also added. If any Curves used to define Combined Curves are in the Set, then those Combined Curves are also added.
        **Return Code:** True\n
        """
        ...

    def ConvertToAllSurfaces(self) -> Any:
        """
        **Description:**
            This function expands the current Set to contain all surfaces (Parasolid or boundary surfaces) referenced by the surfaces currently in the set.
        **Remarks/Usage:**
            If any Combined Surfaces are in the Set, then all surfaces used to define them are also added. If any Surfaces used to define Combined Surfaces are in the Set, then those Combined Surfaces are also added.
        **Return Code:** True\n
        """
        ...

    def ConvertToBoundarySurfaces(self) -> Any:
        """
        **Description:**
            This function replaces surfaces that are used to define Combined Surfaces with the Combined Surface.
        **Remarks/Usage:**
            If any Surfaces used to define Combined Surfaces are in the Set, then those surfaces are removed, and the Combined Surfaces are added. Other Surfaces, either Combined Surfaces themselves, or surfaces not used to define Combined Surfaces are not changed in the Set.
        **Return Code:** True\n
        """
        ...

    def ConvertToBoundarySurfacesOnly(self) -> Any:
        """
        **Description:**
            This function replaces surfaces that are used to define Combined Surfaces with the Combined Surface and removes all others.
        **Remarks/Usage:**
            If any Surfaces used to define Combined Surfaces are in the Set, then those surfaces are removed, and the Combined Surfaces are added. Other Surfaces, either Combined Surfaces themselves, or surfaces not used to define Combined Surfaces are all removed from the Set.
        **Return Code:** True\n
        """
        ...

    def ConvertToCombinedCurves(self) -> Any:
        """
        **Description:**
            This function replaces curves that are used to define Combined Curves with the Combined Curve.
        **Remarks/Usage:**
            If any Curves used to define Combined Curves are in the Set, then those curves are removed, and the Combined Curves are added. Other Curves, either Combined Curves themselves, or curves not used to define Combined Curves are not changed in the Set.
        **Return Code:** True\n
        """
        ...

    def ConvertToCombinedCurvesOnly(self) -> Any:
        """
        **Description:**
            This function replaces curves that are used to define Combined Curves with the Combined Curve and removes all others.
        **Remarks/Usage:**
            If any Curves used to define Combined Curves are in the Set, then those curves are removed, and the Combined Curves are added. Other Curves, either Combined Curves themselves, or curves not used to define Combined Curves are all removed from the Set.
        **Return Code:** True\n
        """
        ...

    def ConvertToInternalCurves(self) -> Any:
        """
        **Description:**
            This function replaces any Combined Curves in the Set with the curves used to define them.
        **Remarks/Usage:**
            If any Combined Curves are in the Set, then those curves are removed, and the curves used to define them are added. Other curves are not changed in the Set.
        **Return Code:** True\n
        """
        ...

    def ConvertToInternalSurfaces(self) -> Any:
        """
        **Description:**
            This function replaces any Combined Surfaces in the Set with the surfaces used to define them.
        **Remarks/Usage:**
            If any Combined Surfaces are in the Set, then those surfaces are removed, and the surfaces used to define them are added. Other surfaces are not changed in the Set.
        **Return Code:** True\n
        """
        ...

    def ConvertToSlavedMasterSurfaceSet(self) -> Any:
        """
        """
        ...

    def Copy(self, origID) -> Any:
        """
        **Description:**
            This function makes a duplicate copy of a selection set.
        **Remarks/Usage:**
            If the current set already existed and contained selected IDs, those will be deleted prior to copying. The resulting copy will always match the original.
        **Input:**
            **origID:** ID of the selection set to duplicate.\n
        **Return Code:** True\n
        :type origID: int

        """
        ...

    def CopyToClipboard(self, bAsList) -> Any:
        """
        **Description:**
            This function copies the IDs of the selected entities to the Clipboard as text.
        **Remarks/Usage:**
            None
        **Input:**
            **bAsList:** If True, the IDs are placed on the clipboard in a format that is one ID per line. If False, ranges of consecutive IDs are placed on the clipboard in the format startID, stopID, increment on each line. stopID is zero if a single ID is selected in this format.\n
        **Return Code:** False\n
        :type bAsList: bool

        """
        ...

    def Count(self) -> Any:
        """
        **Description:**
            This function counts the number of IDs that are currently selected in the set.
        **Remarks/Usage:**
            This function simply looks at each of the selected IDs and counts the number that it finds.
        **Return Code:** True\n
        """
        ...

    def CountCommon(self, set1) -> Any:
        """
        **Description:**
            This function counts the number of IDs that are in the current set that are also in the specified set.
        **Remarks/Usage:**
            None
        **Input:**
            **set1:** The ID of another set to compare this set to.\n
        **Return Code:** True\n
        :type set1: int

        """
        ...

    def CountNotCommon(self, set1) -> Any:
        """
        **Description:**
            This function counts the number of IDs that are in the current set that are not in the specified set.
        **Remarks/Usage:**
            None
        **Input:**
            **set1:** The ID of another set to compare this set to.\n
        **Return Code:** True\n
        :type set1: int

        """
        ...

    def CountSavedSets(self, pnAllSets) -> Any:
        """
        **Description:**
            This method returns the number of SavedSets in the Database both the number matching your DeveloperID and the total number
        **Remarks/Usage:**
            You do not need to set a DeveloperID to use this method to retrieve AllSets, but if you do not, the return code will always be 0.
        **Output:**
            **pnAllSets:** The total number of SavedSets in the database from all developers\n
        **Return Code:** True\n
        :type pnAllSets: int

        """
        ...

    def Debug(self) -> Any:
        """
        **Description:**
            This function simply writes all of the IDs contained in a Set to the Message Window
        **Remarks/Usage:**
            This method is really only intended for Debugging. There is no particular formatting of the list of IDs (which can be quite long), it is simply dumped in a comma-separated fashion to the Message Window
        **Return Code:** True\n
        """
        ...

    def DeleteAll(self) -> Any:
        """
        **Description:**
            This function simply deletes Sets which are saved in the model.
        **Remarks/Usage:**
            Great caution must be used when using this method.It deletes ALL sets in the model without any further notification. Any set objects in your program file will also be cleared.
        **Return Code:** False\n
        """
        ...

    def DeleteAllSavedSets(self) -> Any:
        """
        **Description:**
            This method deletes all previously SavedSets
        **Remarks/Usage:**
            Only Saved Sets stored with your DeveloperID are deleted by this method
        **Return Code:** True\n
        """
        ...

    def DeleteOtherSavedSets(self) -> Any:
        """
        **Description:**
            This method deletes any previously SavedSet that has an ID that is not specified in the current object
        **Remarks/Usage:**
            Only SavedSets stored with your DeveloperID are deleted by this method. This method is intended to be used to cleanup any leaked SavedSets. Load this Set object with all the SavedSet IDs that you want to keep, then call this method it will delete all others. You should follow this procedure periodically to insure the database does not contain unnecessary orphaned data. When a user calls the File, Rebuild command is a good time to do this, although it can be done more often.
        **Return Code:** True\n
        """
        ...

    def DeleteSavedSet(self, nSavedID) -> Any:
        """
        **Description:**
            This method deletes a SavedSet which was previously saved
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def EmptyBlock(self, nStartID, nCount, nFirstEmptyID) -> Any:
        """
        **Description:**
            This function returns the first empty ID of an empty block of IDs of a specified size, after the specified starting ID
        **Remarks/Usage:**
            As an example, a set object contains IDs 1-10 and 12-20. If nCount is set to 1, then the nFirstEmptyID will be returned as 11, as that is the first ID where an empty block of 1 is available. If, however, nCount is set to 2, then the nFirstEmptyID will be returned as 21, as there are no empty blocks of 2 IDs available within the IDs already entered into the set. Finally, if nStartID is set to 12 and nCount is set to 1, then nFirstEmptyID will be returned as 21, as the available block at 11 is not included in the search.
        **Input:**
            **nStartID:** ID used to begin searching\n
            **nCount:** Size of empty block needed to be found\n
        **Output:**
            **nFirstEmptyID:** First available ID in the set where an empty block of the size specified in nCount exists\n
        **Return Code:** True\n
        :type nStartID: int

        :type nCount: int

        :type nFirstEmptyID: int

        """
        ...

    def EmptySavedSet(self) -> Any:
        """
        **Description:**
            This method returns the ID of an available/nonexisting Saved Set
        **Remarks/Usage:**
            This method always returns the lowest ID available. You do not need to set a DeveloperID to use this method.
        **Return Code:** False\n
        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This function returns the first selected ID in a selection set.
        **Remarks/Usage:**
            The first ID is the lowest number, not the first entity added to the set. Calling this method is the same as calling Reset( ) followed by Next( ).
        **Return Code:** True\n
        """
        ...

    def GetAllSavedSets(self) -> Any:
        """
        **Description:**
            This method loads the IDs of all SavedSets into the current object
        **Remarks/Usage:**
            Any previous contents of the Set object are automatically cleared prior to loading the IDs of the Saved Sets.
        **Return Code:** True\n
        """
        ...

    def GetArray(self) -> tuple[int, int, tuple[int, ...]]:
        """
        **Description:**
            This function populates an array of IDs from a selection set.
        **Remarks/Usage:**
            None
        **Output:**
            **numID:** The number of entries in the set\n
            **arrayID:** The array of all IDs in the set.\n
        **Return Code:** True\n
        :returns: numID, arrayID
        :type numID: int

        :type arrayID: tuple[int]

        """
        ...

    def GetSavedSet(self, nSavedID, bClear) -> Any:
        """
        **Description:**
            This method loads the IDs stored in a Saved Set into the current object
        **Remarks/Usage:**
            You can only access Saved Sets that were stored with your DeveloperID using this method
        **Input:**
            **nSavedID:** The ID of the SavedSet\n
            **bClear:** If True, any previous contents of the object are removed. If False, the Saved Set is merged with the current contents\n
        **Return Code:** True\n
        :type nSavedID: int

        :type bClear: bool

        """
        ...

    def GetSavedSetType(self, nSavedID, pnDataType) -> Any:
        """
        **Description:**
            This method returns the type of entities currently stored in a Saved Set.
        **Remarks/Usage:**
            This method does not actually get the Saved Set, only the type of entities that are currently stored in the Saved Set.
        **Input:**
            **nSavedID:** The ID of the Saved Set to check entity type.\n
        **Output:**
            **pnDataType:** Type of entities found in the Saved Set. For more information, see Section 3.3.6, "Entity Types".\n
        **Return Code:** True\n
        :type nSavedID: int

        :type pnDataType: int

        """
        ...

    def HasCommon(self, set1) -> Any:
        """
        **Description:**
            This function checks to see if there are any common IDs between two Sets
        **Remarks/Usage:**
            Neither Set is changed by this method, it simply looks for the same ID in both Sets.
        **Input:**
            **set1:** The ID of the Set to check for common IDs with the current Set\n
        **Return Code:** True\n
        :type set1: int

        """
        ...

    def HasMultiple(self) -> Any:
        """
        **Description:**
            This method checks if a set has multiple entities added to it.
        **Remarks/Usage:**
            API developers should employ this method instead of testing whether Count() > 1.
        **Return Code:** True\n
        """
        ...

    def HasNotCommon(self, set1) -> Any:
        """
        **Description:**
            This function checks to see if there are any IDs in the current Set that are not in the specified Set
        **Remarks/Usage:**
            Neither Set is changed by this method, it simply looks for common IDs in both Sets.
        **Input:**
            **set1:** The ID of the Set to check with the current Set\n
        **Return Code:** True\n
        :type set1: int

        """
        ...

    def HasOne(self) -> Any:
        """
        **Description:**
            This method checks if a set has only one entity added to it.
        **Remarks/Usage:**
            API developers should employ this method instead of testing whether Count() == 1.
        **Return Code:** True\n
        """
        ...

    def IndexInSet(self, entID, index) -> Any:
        """
        :type entID: Any
        :type index: Any
        """
        ...

    def IsAdded(self, entID) -> Any:
        """
        **Description:**
            This function checks to see if an ID is currently added into a selection set.
        **Remarks/Usage:**
            The selection set need not exist to use this function. However, if it does not, the return code will simply be FE_FAIL - the ID is not selected.
        **Input:**
            **entID:** ID to check.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def IsArrayAdded(self, numID, arrayID) -> Any:
        """
        **Description:**
            This function checks to see if all IDs from an array are currently added into a selection set.
        **Remarks/Usage:**
            None
        **Input:**
            **numID:** The number of IDs in the array\n
            **arrayID:** The array containing IDs to check to see if they are in the current Set\n
        **Return Code:** True\n
        :type numID: int

        :type arrayID: tuple[int]

        """
        ...

    def IsEmpty(self) -> Any:
        """
        **Description:**
            This method checks if a set has no entities added to it, thus is empty.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def IsIdenticalSet(self, set1) -> Any:
        """
        **Description:**
            This function checks to see if a set has identical entity IDs as another set.
        **Remarks/Usage:**
            None
        **Input:**
            **set1:** The ID of the Set to check to see if it contains identical entity IDs\n
        **Return Code:** True\n
        :type set1: int

        """
        ...

    def IsNotEmpty(self) -> Any:
        """
        **Description:**
            This method checks if a set has one or more entities added to it, thus is NOT empty.
        **Remarks/Usage:**
            API developers should employ this method instead of testing whether Count() > 0.
        **Return Code:** True\n
        """
        ...

    def IsSetAdded(self, set1) -> Any:
        """
        **Description:**
            This function checks to see if all IDs from a Set are currently added into a selection set.
        **Remarks/Usage:**
            None
        **Input:**
            **set1:** The ID of the Set to check to see if all IDs are in this Set\n
        **Return Code:** True\n
        :type set1: int

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This function returns the last selected ID in a selection set.
        **Remarks/Usage:**
            The last ID is the highest number, not the last entity added to the set.
        **Return Code:** True\n
        """
        ...

    def Match(self, otherID) -> Any:
        """
        **Description:**
            This function tests to see if the contents of set setID match the current set.
        **Remarks/Usage:**
            To match, the two sets must include all of the same IDs.
        **Input:**
            **otherID:** ID of the set to compare to this set.\n
        **Return Code:** True\n
        :type otherID: int

        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This function returns the next selected ID in a selection set
        **Remarks/Usage:**
            To find the first ID in a set, you must use the Reset method before calling Next. If you have just created a set and have not used Next, it is already reset.
        **Return Code:** True\n
        """
        ...

    def NextAfter(self, nStartID) -> Any:
        """
        **Description:**
            This function returns the next higher ID after the specified starting ID
        **Remarks/Usage:**
            Unlike Next( ), this method does not rely on the internal pointers, nor Reset( ) - it simply uses the starting ID that you supply.
        **Input:**
            **nStartID:** The starting ID\n
        **Return Code:** True\n
        :type nStartID: int

        """
        ...

    def NextEmptyAfter(self, nStartID) -> Any:
        """
        **Description:**
            This function returns the first empty ID after the specified starting ID
        **Remarks/Usage:**
            Unlike Next( ), this method does not rely on the internal pointers, nor Reset( ) - it simply uses the starting ID that you supply.
        **Input:**
            **nStartID:** The starting ID\n
        **Return Code:** True\n
        :type nStartID: int

        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This function returns the next selected ID in a selection set.
        **Remarks/Usage:**
            This function is just like Next() except that it just returns the next ID. It does not increment the internal pointers, so if you repeatedly call NextID( ), you will get the same ID every time.
        **Return Code:** True\n
        """
        ...

    def NextSavedSet(self) -> Any:
        """
        **Description:**
            This method returns the ID of the next Saved Set
        **Remarks/Usage:**
            Only SavedSets stored with your DeveloperID are accessible by this method. To find the first SavedSet, you must first use the ResetSavedSet method before calling NextSavedSet This function updates internal pointers in the Set so that if you call it repeatedly it will walk through all available SavedSets.
        **Return Code:** True\n
        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This function returns the previous selected ID in a selection set
        **Remarks/Usage:**
            To find the last ID in a set, you must use the Reset method before calling Prev. If you have just created a set and have not used Prev, it is already reset.
        **Return Code:** True\n
        """
        ...

    def PrevBefore(self, nStartID) -> Any:
        """
        **Description:**
            This function returns the next lower ID after the specified starting ID
        **Remarks/Usage:**
            Unlike Prev( ), this method does not rely on the internal pointers, nor Reset( ) - it simply uses the starting ID that you supply.
        **Input:**
            **nStartID:** The starting ID\n
        **Return Code:** True\n
        :type nStartID: int

        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This function returns the previous selected ID in a selection set.
        **Remarks/Usage:**
            This function is just like Prev() except that it just returns the previous ID. It does not increment the internal pointers, so if you repeatedly call PrevID( ), you will get the same ID every time.
        **Return Code:** True\n
        """
        ...

    def PutSavedSet(self, nPutID, entityTYPE, nSavedID) -> Any:
        """
        **Description:**
            This method saves the contents of the Set object to a selected SavedSet
        **Remarks/Usage:**
            If you save a Set using this method, its current contents are copied to the Saved Set. Future changes to the Set object are not reflected in the Saved Set unless you also call PutSavedSet again after those changes.
        **Input:**
            **nPutID:** The ID of the Saved Set to create or overwrite. To create a new Saved Set, specify nPutID=0 (or any negative number). If you are overwriting a previously Saved Set, set nPutID to the value that was returned in nSavedID when you created the SavedSet.\n
            **entityTYPE:** Type of entity whose IDs are in the Set. For more information, see Section 3.3.6, "Entity Types". Currently, the following types will automatically support renumbering and locking entities from delete: FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, FT_ELEM, FT_MATL, FT_PROP, FT_CSYS and FT_FUNCTION_DIR. \n
        **Output:**
            **nSavedID:** The ID of the Saved Set that was created or overwritten. If nPutID was 0 (or negative) this is the ID of the new Saved Set that you must remember to retrieve the set later. If nPutID was a positive number nSaveID will simply equal nPutID.\n
        **Return Code:** True\n
        :type nPutID: int

        :type entityTYPE: int

        :type nSavedID: int

        """
        ...

    def Reload(self, oldID) -> Any:
        """
        **Description:**
            This function reloads a saved selection set. This method is obsolete and should be replaced with Reload2().
        **Remarks/Usage:**
            Selection sets can be made to persist across programs or modeling sessions using the Save property. If a set is saved, it can be reloaded with this method.
        **Input:**
            **oldID:** The ID of the selection set to reload. This ID can be determined by querying the ID property of a set.\n
        **Return Code:** True\n
        :type oldID: int

        """
        ...

    def Reload2(self, oldID) -> Any:
        """
        **Description:**
            This function reloads a saved selection set. This function replaces Reload()
        **Remarks/Usage:**
            Selection sets can be made to persist across programs or modeling sessions using the Save property. If a set is saved, it can be reloaded with this method.
        **Input:**
            **oldID:** The ID of the selection set to reload. This ID can be determined by querying the ID property of a set.\n
        **Return Code:** True\n
        :type oldID: int

        """
        ...

    def Remove(self, entID) -> Any:
        """
        **Description:**
            This function removes an ID from a selection set.
        **Remarks/Usage:**
            Any ID can be removed from a selection set. Although it has no effect, it is not an error to remove an ID that was not currently added to a selection set, or even removing from a selection set that does not exist.
        **Input:**
            **entID:** ID to remove from the selection set.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def RemoveArray(self, numID, arrayID) -> Any:
        """
        **Description:**
            This function removes a list of IDs specified in an array from a selection set.
        **Remarks/Usage:**
            This is just like the Remove Method, but it can be used to remove multiple IDs in one call.
        **Input:**
            **numID:** The number of IDs in the array to be removed\n
            **arrayID:** The array of IDs to be removed\n
        **Return Code:** True\n
        :type numID: int

        :type arrayID: tuple[int]

        """
        ...

    def RemoveFromSavedSet(self, nSavedID, entityTYPE, entID) -> Any:
        """
        **Description:**
            This method removes a single entity ID from a SavedSet
        **Remarks/Usage:**
            This method can be called to remove an entity that is not actually contained in the selected SavedSet without causing any harm.
        **Return Code:** True\n
        """
        ...

    def RemoveGroup(self, entityTYPE, groupID) -> Any:
        """
        **Description:**
            This function removes any IDs that are in a Group
        **Remarks/Usage:**
            This function removes all IDs from the current Set that are in the selected Group and entityType. The Group is unchanged.
        **Input:**
            **groupID:** The ID of the group to test\n
        **Return Code:** True\n
        :type groupID: int

        """
        ...

    def RemoveInternalCurves(self) -> Any:
        """
        **Description:**
            This function removes the IDs of any curves that are internal to a boundary/compound surface
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def RemoveNotCommon(self, set1) -> Any:
        """
        **Description:**
            This function removes any IDs that are not in both the current Set and the specified Set
        **Remarks/Usage:**
            This function removes all IDs from the current Set that are not in the selected Set. The result is that the current Set will only contain IDs that are common to both Sets. The Set nSetID remains unchanged during this command - only the current set is updated.
        **Input:**
            **set1:** ID of a Set that is checked for IDs that are common to the current Set\n
        **Return Code:** True\n
        :type set1: int

        """
        ...

    def RemoveNotCommonToGroup(self, entityTYPE, groupID) -> Any:
        """
        **Description:**
            This function removes any IDs that are not in both the current Set and the specified Group
        **Remarks/Usage:**
            This function removes all IDs from the current Set that are not in the selected Group of the specified entityTYPE. The result is that the current Set will only contain IDs that are common to the Set and the Group. The Group remains unchanged during this command - only the current set is updated.
        **Input:**
            **groupID:** The ID of the group to test\n
        **Return Code:** True\n
        :type groupID: int

        """
        ...

    def RemoveNotVisible(self, nVuID, entityTYPE, bUseViewDrawEntityOption) -> Any:
        """
        **Description:**
            This function removes entities of the specified type which are not visible in the specified view from the current set.
        **Remarks/Usage:**
            With respect to this function, visible entities are any entities currently visible in the view, even if the entities are off screen because of the current orientation or you are zoomed in and only looking at a portion of the model.
        **Return Code:** True\n
        """
        ...

    def RemoveRange(self, startID, stopID, increment) -> Any:
        """
        **Description:**
            This function removes a range of IDs from a selection set.
        **Remarks/Usage:**
            This is just like the Remove Method, but it can be used to remove multiple IDs in one call.
        **Input:**
            **startID:** The first ID to remove from the selection set.\n
            **stopID:** The last ID to remove from the selection set.\n
            **increment:** The ID increment between startID and stopID. Must be a positive number. \n
        **Return Code:** True\n
        :type startID: int

        :type stopID: int

        :type increment: int

        """
        ...

    def RemoveRule(self, nID, ruleID) -> Any:
        """
        **Description:**
            This function removes from a selection set by using one of the standard group selection rules
        **Remarks/Usage:**
            This function is similar to AddRule, however instead of adding IDs to the set, it removes them from the set
        **Input:**
            **nID:** The ID that you are specifying. The interpretation of this value depends on the type of rule that you select.\n
            **ruleID:** ID of a selection rule. For more information, see Section 4.6.2.7, "Group Selection Rules"\n
        **Return Code:** True\n
        :type nID: int

        :type ruleID: int

        """
        ...

    def RemoveSet(self, addID) -> Any:
        """
        **Description:**
            This function removes all of the selected IDs in another set from the current set.
        **Remarks/Usage:**
            This function removes all IDs in the removeID set that are currently selected. If removeID contains IDs that are not currently selected, they are skipped. This is not an error. The removeID set remains unchanged during this command - only the current set is updated.
        **Input:**
            **addID:** ID of the selection set containing the IDs to remove.\n
        **Return Code:** True\n
        :type addID: int

        """
        ...

    def RemoveSetFromSavedSet(self, nSavedID, entityTYPE) -> Any:
        """
        **Description:**
            This method removes the contents of the current Set from a SavedSet
        **Remarks/Usage:**
            This method can be called to remove entities that are not actually contained in the selected SavedSet without causing any harm. Only entities that are actually in the SavedSet will be removed.
        **Return Code:** True\n
        """
        ...

    def RemoveSetRule(self, removeID, ruleID) -> Any:
        """
        **Description:**
            This function removes from a selection set by using one of the standard group selection rules. It uses the IDs from another selection set to operate on the current one
        **Remarks/Usage:**
            This function is similar to AddSetRule, however instead of adding IDs to the set, it removes them from the set
        **Input:**
            **ruleID:** ID of a selection rule. For more information, see Section 4.6.2.7, "Group Selection Rules"\n
        **Return Code:** True\n
        :type ruleID: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This function resets the nextpointer so that the next call to nextwill return the first entry in a selection set.
        **Remarks/Usage:**
            To find the first ID in a set, you must use the Reset method before calling Next. If you have just created a set and have not used Next, it is already reset.
        **Return Code:** False\n
        """
        ...

    def ResetSavedSet(self) -> Any:
        """
        **Description:**
            This method resets the SavedSet next pointer so that the next call to NextSavedSet will return the first available SavedSet
        **Remarks/Usage:**
            Only SavedSets stored with your Developer ID will be accessible by NextSavedSet method
        **Return Code:** False\n
        """
        ...

    def Select(self, entityTYPE, clear, title) -> Any:
        """
        **Description:**
            This function displays a standard selection dialog box to allow a user to choose entities of a specific type and create a selection set.
        **Remarks/Usage:**
            After the dialog box is closed, the set contains the list of all IDs that were selected. If clear=False, then some of the entities could have been selected prior to the dialog being displayed. If the user hits Cancel to close the dialog, then the set contains whatever it contained before, unless clear=True, in which case it contains nothing.
        **Input:**
            **entityTYPE:** Type of entity to select. For more information, see Section 3.3.6, "Entity Types". \n
            **clear:** If True, the set is cleared prior to selection, and only the selected entities will be in the set. If False, previously selected entities will be displayed in the dialog box for editing, or for combining with new selections.\n
            **title:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type clear: bool

        :type title: str

        """
        ...

    def SelectID(self, entityTYPE, title, selID) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The ID of the entity is returned and is stored in the current selection set.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **entityTYPE:** Type of entity to select. For more information, see Section 3.3.6, "Entity Types". \n
            **title:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Output:**
            **selID:** The ID of the entity that was selected.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type title: str

        :type selID: int

        """
        ...

    def SelectIDInSetV2(self, entityTYPE, title, nInSetID, selID) -> Any:
        """
        **Description:**
            This method replaces SelectIDInSet. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above". This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The ID of the entity is returned and is stored in the current selection set.
        **Remarks/Usage:**
            This function is designed to be used to select a single item (i.e., a Load Definition, Constraint Definition, Output Vector) which exists in a specific Set in the database (i.e., Load Set, Constraint Set, Output Set). For entities which are not Set-based, nInSetID must be set to 1, therefore, there is no benefit to use the method instead of the SelectID method.
        **Input:**
            **entityTYPE:** Type of entity to select. For more information, see Section 3.3.6, "Entity Types". \n
            **title:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
            **nInSetID:** Select the entity from the specified SetID - for example an Output Vector from a specific Output Set, or a Load or Constraint Definition from a specific Load or Constraint Set\n
        **Output:**
            **selID:** The ID of the entity that was selected.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type title: str

        :type nInSetID: int

        :type selID: int

        """
        ...

    def SelectIDWithNew(self, entityTYPE, title, selID) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The ID of the entity is returned and stored in the current selection set
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **entityTYPE:** Type of entity to select. For more information, see Section 3.3.6, "Entity Types". \n
            **title:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Output:**
            **selID:** The ID of the entity that was selected.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type title: str

        :type selID: int

        """
        ...

    def SelectList(self, nNumEntity, entityTYPE) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a specified number of entities of a specific type. The IDs of the selected entities are stored in the current selection set.
        **Remarks/Usage:**
            The dialog box that is displayed by this method automatically closes when nNumEntity entities have been selected.
        **Input:**
            **nNumEntity:** Number of entities to be selected.\n
            **entityTYPE:** Type of entity to select. For more information, see Section 3.3.6, "Entity Types". \n
        **Return Code:** True\n
        :type nNumEntity: int

        :type entityTYPE: int

        """
        ...

    def SelectMultiIDV2(self, entityTYPE, entitySET, title) -> Any:
        """
        **Description:**
            This method replaces SelectMultiID. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above". This function displays a multi-selection dialog box to allow a user to choose one or more entities of a specific type. The IDs of the selected entities are stored in the current selection set.
        **Remarks/Usage:**
            This function will work for most entity types, however in most cases you should only use it for entities with titles. If you use it for entities like Nodes or Elements, you will just see a potentially large list of numbers which are not very useful for selection.
        **Input:**
            **entityTYPE:** Type of entity to select. For more information, see Section 3.3.6, "Entity Types". \n
            **entitySET:** The setID associated with the entities you want to select. For most entities this is 1, however for some like Loads and Constraints, they may be stored in other sets.\n
            **title:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type title: str

        """
        ...

    def SelectOutputVectorIDV2(self, title, outputSetID, limitOutputType, limitComplex, limitToEntity, allowCorner,
                               selID) -> Any:
        """
        **Description:**
            This method replaces SelectOutputVectorID. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above". This function displays a selection dialog box to allow a user to choose an output vector. The ID of the entity is returned and is stored in the current selection set.
        **Remarks/Usage:**
            None
        **Input:**
            **title:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
            **outputSetID:** The ID of the Output Set containing the list of possible vectors to select.\n
            **limitOutputType:** Reduces list of output vectors shown to the specified type (0=All, 1=Disp, 2=Accel, 3=Force, 4=Stress, 5=Strain, 6=Temp)\n
            **limitComplex:** Reduces list of output vectors shown based on type of real or complex data they contain (0=Magnitude, 1=Phase, 2=Real, 3=Imaginary, 4=Any)\n
            **limitToEntity:** Reduces list of output vectors to those containing data on the specified entity type\n
            **allowCorner:** If True, output vectors at element corners will also be included\n
        **Output:**
            **selID:** The ID of the selected output vector.\n
        **Return Code:** True\n
        :type title: str

        :type outputSetID: int

        :type limitOutputType: int

        :type limitComplex: int

        :type limitToEntity: int

        :type allowCorner: bool

        :type selID: int

        """
        ...

    def SetDeveloperID(self, DeveloperID) -> Any:
        """
        **Description:**
            This method is used to specify a DeveloperID and unlocks the "SavedSet" functionality
        **Remarks/Usage:**
            This method only needs to be called once per object, but must be called prior to any of the other SavedSet type methods otherwise they will all fail. Using this, and the other SavedSet methods does not prevent the use of any other Set object functionality.
        **Input:**
            **DeveloperID:** The developer ID assigned by Siemens to the registered developer.\n
        **Return Code:** True\n
        :type DeveloperID: int

        """
        ...

    def Show(self, entityTYPE) -> Any:
        """
        **Description:**
            Uses the current settings of the Window, Show Entities command to highlight all of the entities of the selected entity type currently in the group, in the graphics window
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def ShowAutoscale(self, entityTYPE) -> Any:
        """
        **Description:**
            Uses the current settings of the Window, Show Entities command, other than the Autoscale option, to highlight all of the entities of the selected entity type currently in the group, in the graphics window. This method is essentially identical to the Show method, with the only different being this method always autoscales to show only the entities in the group.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            This function simply removes all selections and exclusions from the current set.
        **Remarks/Usage:**
            If coding in anything other than Visual Basic or WinWrap ((language used in the API Programming dockable pane available within the Femap user interface), this method must use all lowercase letters. For more information, see Section 1.5, "Other Considerations".
        **Return Code:** False\n
        """
        ...


class SortSet:
    CLSID: Any
    ID: Any
    dReal1: Any
    dReal2: Any
    dReal3: Any
    eDataType: Any
    nInt1: Any
    nInt2: Any
    nInt3: Any

    def Add(self, nID) -> Any:
        """
        **Description:**
            This function adds an ID into a sort object.
        **Remarks/Usage:**
            The ID that you are adding to the sort object is just that, an ID. Although it usually represents the ID of some other existing entity in your model, there is no requirement for this.
        **Input:**
            **nID:** ID to add to the sort object.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def AddAll(self, nID, dReal1, dReal2, dReal3, dInt1, dInt2, dInt3, eDataType) -> Any:
        """
        **Description:**
            This function adds an ID and associated integer properties into a sort object.
        **Remarks/Usage:**
            The ID that you are adding to the sort object is just that, an ID. Although it usually represents the ID of some other existing entity in your model, there is no requirement for this.
        **Input:**
            **nID:** ID to add to the sort object.\n
            **dReal1:** Real properties to associate with ID\n
            **dReal2:** REAL8 dReal3\n
            **dReal3:** INT4 nInt1\n
            **dInt1:** Integer properties to associate with ID\n
            **dInt2:** INT4 nInt3\n
            **dInt3:** INT4 eDataType\n
            **eDataType:** Entity Type that is associated with an entry in the object. For possible values, refer to Section 3.3.6, "Entity Types"\n
        **Return Code:** True\n
        :type nID: int

        :type dReal1: float

        :type dReal2: float

        :type dReal3: float

        :type dInt1: int

        :type dInt2: int

        :type dInt3: int

        :type eDataType: int

        """
        ...

    def AddAroundPlane(self, entityTYPE, nSetID, vBase, vDir, bAbs) -> Any:
        """
        **Description:**
            This function adds selected entities with their sort value equal to the distance from the specified plane
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities being included into the set. For entity information, see Section 3.3.6, "Entity Types". Only Point and Node types are valid.\n
            **nSetID:** The ID of a Set object that contains the entities to add.\n
            **vBase:** The coordinates, in Global Rectangular coordinates, of the base of the vector used to compute the sort value\n
            **vDir:** The components, in Global Rectangular coordinates, of the vector used to compute the sort value\n
            **bAbs:** If False, the sort value is computed as positive if the entity is on the side of the plane pointed to by vVec and negative if in the other direction. If True, the sort value is simply the distance to the plane.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type nSetID: int

        :type vBase: tuple[float]

        :type vDir: tuple[float]

        :type bAbs: bool

        """
        ...

    def AddAroundPoint(self, entityTYPE, nSetID, vBase) -> Any:
        """
        **Description:**
            This function adds selected entities with their sort value equal to the distance from the specified location.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities being included into the set. For entity information, see Section 3.3.6, "Entity Types". Only Point and Node types are valid.\n
            **nSetID:** The ID of a Set object that contains the entities to add.\n
            **vBase:** The coordinates, in Global Rectangular coordinates, of the point used to compute the sort value\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type nSetID: int

        :type vBase: tuple[float]

        """
        ...

    def AddAroundVector(self, entityTYPE, nSetID, vBase, vDir) -> Any:
        """
        **Description:**
            This function adds selected entities with their sort value equal to the distance from the specified vector
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities being included into the set. For entity information, see Section 3.3.6, "Entity Types". Only Point and Node types are valid.\n
            **nSetID:** The ID of a Set object that contains the entities to add.\n
            **vBase:** The coordinates, in Global Rectangular coordinates, of the base of the vector used to compute the sort value\n
            **vDir:** The components, in Global Rectangular coordinates, of the vector used to compute the sort value\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type nSetID: int

        :type vBase: tuple[float]

        :type vDir: tuple[float]

        """
        ...

    def AddInt(self, nID, dInt1, dInt2, dInt3) -> Any:
        """
        **Description:**
            This function adds an ID and associated integer properties into a sort object.
        **Remarks/Usage:**
            The ID that you are adding to the sort object is just that, an ID. Although it usually represents the ID of some other existing entity in your model, there is no requirement for this.
            This method adds the ID and sets the values of the nIntX properties. The current values of dRealX and eDataType properties are also associated with this ID.
        **Input:**
            **nID:** ID to add to the sort object.\n
            **dInt1, dInt2, dInt3:** Integer properties to associate with ID\n
        **Return Code:** True\n
        :type nID: int

        :type dInt1: int

        :type dInt2: int

        :type dInt3: int

        """
        ...

    def AddReal(self, nID, dReal1, dReal2, dReal3) -> Any:
        """
        **Description:**
            This function adds an ID and associated real properties into a sort object.
            This method adds the ID and sets the values of the dRealX properties. The current values of nIntX and eDataType properties are also associated with this ID.
        **Remarks/Usage:**
            The ID that you are adding to the sort object is just that, an ID. Although it usually represents the ID of some other existing entity in your model, there is no requirement for this.
        **Input:**
            **nID:** ID to add to the sort object.\n
            **dReal1, dReal2, dReal3:** Real properties to associate with ID\n

        **Return Code:** True\n
        :type nID: int

        :type dReal1: float

        :type dReal2: float

        :type dReal3: float

        """
        ...

    def ConvertToBoundarySurfaces(self) -> Any:
        """
        **Description:**
            This function replaces surfaces that are used to define Combined Surfaces with the Combined Surface.
        **Remarks/Usage:**
            If any Surfaces used to define Combined Surfaces are in the Sort Set, then those surfaces are removed, and the Combined Surfaces are added. Other Surfaces, either Combined Surfaces themselves, or surfaces not used to define Combined Surfaces are not changed in the Sort Set.
        **Return Code:** True\n
        """
        ...

    def Count(self) -> Any:
        """
        **Description:**
            This function counts the number of IDs that are currently selected in the object.
        **Remarks/Usage:**
            This function simply looks at each of the selected IDs and counts the number that it finds.
        **Return Code:** True\n
        """
        ...

    def Current(self) -> Any:
        """
        **Description:**
            This function returns the currently selected ID in a sort object.
        **Remarks/Usage:**
            This method works just like Next() and Prev(), except that it does not move to a different ID. By calling this method, you retrieve the ID and the properties dRealX, nIntX and eDataType are all udpated to match the values associated with that ID.
        **Return Code:** True\n
        """
        ...

    def Find(self, nID) -> Any:
        """
        **Description:**
            This function locates an ID within the object.
        **Remarks/Usage:**
            If the ID is found, the dRealX, nIntX and eDataType properties are all updated to match those associated with the ID.
        **Input:**
            **nID:** ID to locate\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This function returns the first ID in a sort object.
        **Remarks/Usage:**
            The first ID is the first ID in the object, either the first added, or the first after a sort. Calling this method is the same as calling Reset( ) followed by Next( ).
        **Return Code:** True\n
        """
        ...

    def GetData(self, nID, dReal1, dReal2, dReal3, dInt1, dInt2, dInt3, eDataType) -> Any:
        """
        **Description:**
            This function retrieves the properties associated with an already added ID.
        **Remarks/Usage:**
            None
        **Input:**
            **nID:** ID to update in the sort object. This ID must have been already added to the object.\n
        **Output:**
            **dReal1:** Real properties associated with ID\n
            **dReal2:** REAL8 dReal3\n
            **dReal3:** INT4 nInt1\n
            **dInt1:** Integer properties associated with ID\n
            **dInt2:** INT4 nInt3\n
            **dInt3:** INT4 eDataType\n
            **eDataType:** Entity Type that is associated with an entry in the object. For possible values, refer to Section 3.3.6, "Entity Types"\n
        **Return Code:** True\n
        :type nID: int

        :type dReal1: float

        :type dReal2: float

        :type dReal3: float

        :type dInt1: int

        :type dInt2: int

        :type dInt3: int

        :type eDataType: int

        """
        ...

    def GetDataType(self, nID, eDataType) -> Any:
        """
        **Description:**
            This function retrieves the entity type associated with an already added ID.
        **Remarks/Usage:**
            None
        **Input:**
            **nID:** ID to update in the sort object. This ID must have been already added to the object.\n
        **Output:**
            **eDataType:** Entity Type that is associated with an entry in the object. For possible values, refer to Section 3.3.6, "Entity Types"\n
        **Return Code:** True\n
        :type nID: int

        :type eDataType: int

        """
        ...

    def GetInt(self, nID, dInt1, dInt2, dInt3) -> Any:
        """
        **Description:**
            This function retrieves the integer properties associated with an already added ID.
        **Remarks/Usage:**
            None
        **Input:**
            **nID:** ID to update in the sort object. This ID must have been already added to the object.\n
        **Output:**
            **dInt1:** Integer properties associated with ID\n
            **dInt2:** INT4 nInt3\n
            **dInt3:** Return Code:\n
        **Return Code:** True\n
        :type nID: int

        :type dInt1: int

        :type dInt2: int

        :type dInt3: int

        """
        ...

    def GetReal(self, nID, dReal1, dReal2, dReal3) -> Any:
        """
        **Description:**
            This function retrieves the real properties associated with an already added ID.
        **Remarks/Usage:**
            None
        **Input:**
            **nID:** ID to update in the sort object. This ID must have been already added to the object.\n
        **Output:**
            **dReal1:** Real properties associated with ID\n
            **dReal2:** REAL8 dReal3\n
            **dReal3:** Return Code:\n
        **Return Code:** True\n
        :type nID: int

        :type dReal1: float

        :type dReal2: float

        :type dReal3: float

        """
        ...

    def GetSet(self, nSetID, bClear) -> Any:
        """
        **Description:**
            This function populates a set object with the IDs currently in the sort object, with the option to add the IDs to the IDs already in the set object or clear the set object first, so the set object will only contain the entities from the sort object.
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of the set object\n
            **bClear:** Flag to indicate if the set object should be cleared of all existing IDs before IDs from sort object are sent to set object. True=clear, then add, False=add to existing IDs\n
        **Return Code:** False\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def IsAdded(self, nID) -> Any:
        """
        **Description:**
            This function checks to see if an ID is currently added into a sort object.
        **Remarks/Usage:**
            None
        **Input:**
            **nID:** ID to check.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def IsEmpty(self) -> Any:
        """
        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This function returns the last selected ID in a sort object.
        **Remarks/Usage:**
            The last ID is the last ID in the object, either the first added, or the first after a sort. Calling this method is the same as calling Reset( ) followed by Prev( ).
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This function returns the next selected ID in a sort object.
        **Remarks/Usage:**
            To find the first ID in a set, you must use the Reset method before calling Next. If you have just created a set and have not used Next, it is already reset.
        **Return Code:** True\n
        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This function returns the previous selected ID in a sort object.
        **Remarks/Usage:**
            To find the last ID in a set, you must use the Reset method before calling Prev. If you have just created a set and have not used Prev (or Next), it is already reset.
        **Return Code:** True\n
        """
        ...

    def Remove(self, nID) -> Any:
        """
        **Description:**
            This function removes an ID from a sort object.
        **Remarks/Usage:**
            None
        **Input:**
            **nID:** ID to remove from the sort object.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def RemoveSet(self, nSetID) -> Any:
        """
        **Description:**
            This function removes all of the selected IDs in another sort object from the current sort object.
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of the sort set containing the IDs to remove. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This function resets the nextpointer so that the next call to next will return the first entry in a sort object.
        **Remarks/Usage:**
            To find the first ID in a set, you must use the Reset method before calling Next. If you have just created a set and have not used Next, it is already reset.
        **Return Code:** False\n
        """
        ...

    def Select(self, entityTYPE, Reload, title) -> Any:
        """
        **Description:**
            This function displays a standard selection dialog box to allow a user to choose entities of a specific type and create a sort object.
        **Remarks/Usage:**
            The final selection list contains all of the IDs that were selected when the user pressed OK. If clear=True, these are all entities that were just selected. If clear=False, it is a combination of old and new entities.
        **Input:**
            **entityTYPE:** Type of entity to select. For more information, see Section 3.3.6, "Entity Types". \n
            **Reload:** If True, previously selected IDs will be displayed in the dialog box for editing, or for combining with new selections.\n
            **title:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type Reload: bool

        :type title: str

        """
        ...

    def SelectID(self, entityTYPE, title, selID) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The ID of the entity is returned and is stored in the current sort object.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **entityTYPE:** Type of entity to select. For more information, see Section 3.3.6, "Entity Types". \n
            **title:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Output:**
            **selID:** The ID of the entity that was selected.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type title: str

        :type selID: int

        """
        ...

    def SelectList(self, nNumEntity, entityTYPE) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a specified number of entities of a specific type. The IDs of the selected entities are stored in the current sort set.
        **Remarks/Usage:**
            The dialog box automatically closes when nNumEntity entities have been selected.
        **Input:**
            **nNumEntity:** Number of entities to be selected.\n
            **entityTYPE:** Type of entity to select. For more information, see Section 3.3.6, "Entity Types". \n
        **Return Code:** True\n
        :type nNumEntity: int

        :type entityTYPE: int

        """
        ...

    def SetData(self, nID, dReal1, dReal2, dReal3, dInt1, dInt2, dInt3, eDataType) -> Any:
        """
        **Description:**
            This function updates the properties associated with an already added ID.
        **Remarks/Usage:**
            As an alternative to setting the properties prior to, or at the same time as you add IDs into the object, you can simply add IDs and update the associated values with this method.
        **Input:**
            **nID:** ID to update in the sort object. This ID must have been already added to the object.\n
            **dReal1:** Real properties to associate with ID\n
            **dReal2:** REAL8 dReal3\n
            **dReal3:** INT4 nInt1\n
            **dInt1:** Integer properties to associate with ID\n
            **dInt2:** INT4 nInt3\n
            **dInt3:** INT4 eDataType\n
            **eDataType:** Entity Type that is associated with an entry in the object. For possible values, refer to Section 3.3.6, "Entity Types"\n
        **Return Code:** True\n
        :type nID: int

        :type dReal1: float

        :type dReal2: float

        :type dReal3: float

        :type dInt1: int

        :type dInt2: int

        :type dInt3: int

        :type eDataType: int

        """
        ...

    def SetDataType(self, nID, eDataType) -> Any:
        """
        **Description:**
            This function updates the entity type associated with an already added ID.
        **Remarks/Usage:**
            As an alternative to setting the properties prior to, or at the same time as you add IDs into the object, you can simply add IDs and update the associated entity type with this method.
        **Input:**
            **nID:** ID to update in the sort object. This ID must have been already added to the object.\n
            **eDataType:** Entity Type that is associated with an entry in the object. For possible values, refer to Section 3.3.6, "Entity Types"\n
        **Return Code:** True\n
        :type nID: int

        :type eDataType: int

        """
        ...

    def SetInt(self, nID, dInt1, dInt2, dInt3) -> Any:
        """
        **Description:**
            This function updates the integer properties associated with an already added ID.
        **Remarks/Usage:**
            As an alternative to setting the properties prior to, or at the same time as you add IDs into the object, you can simply add IDs and update the associated integer property values with this method.
        **Input:**
            **nID:** ID to update in the sort object. This ID must have been already added to the object.\n
            **dInt1, dInt2, dInt3:** Integer properties to associate with ID\n

        **Return Code:** True\n
        :type nID: int

        :type dInt1: int

        :type dInt2: int

        :type dInt3: int

        """
        ...

    def SetReal(self, nID, dReal1, dReal2, dReal3) -> Any:
        """
        **Description:**
            This function updates the real properties associated with an already added ID.
        **Remarks/Usage:**
            As an alternative to setting the properties prior to, or at the same time as you add IDs into the object, you can simply add IDs and update the associated real property values with this method.
        **Input:**
            **nID:** ID to update in the sort object. This ID must have been already added to the object.\n
            **dReal1, dReal2, dReal3:** Real properties to associate with ID\n

        **Return Code:** True\n
        :type nID: int

        :type dReal1: float

        :type dReal2: float

        :type dReal3: float

        """
        ...

    def Sort(self, bSortReal) -> Any:
        """
        **Description:**
            This function sorts the IDs in the object based on values associated with each ID
        **Remarks/Usage:**
            Sorting is always done in increasing order, and always using all three values. If bSortReal is True, then the primary sort value is dReal1, the second is dReal2 and third is dReal3. The same approach follows for nInt1, nInt2, and nInt3. Even though sorting is always done in one direction, you can traverse the list in either direction using either Next( ) or Prev( ), so you can still retrieve IDs in decreasing order.
        **Input:**
            **bSortReal:** If True, the IDs are sorted based on the dRealX values, if False, the sort is based on the nIntX values.\n
        **Return Code:** True\n
        :type bSortReal: bool

        """
        ...

    def SortRemoveDuplicates(self, bSortReal) -> Any:
        """
        **Description:**
            This function is the same as Sort( ) except it also removes duplicate entries from the sorted object, leaving just one of each unique entry.
        **Remarks/Usage:**
            Sorting is always done in increasing order, and always using all three values. If bSortReal is True, then the primary sort value is dReal1, the second is dReal2 and third is dReal3. The same approach follows for nInt1, nInt2, and nInt3. Even though sorting is always done in one direction, you can traverse the list in either direction using either Next( ) or Prev( ), so you can still retrieve IDs in decreasing order.
        **Input:**
            **bSortReal:** If True, the IDs are sorted based on the dRealX values, if False, the sort is based on the nIntX values.\n
        **Return Code:** True\n
        :type bSortReal: bool

        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            This function simply removes all IDs from the current object.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...


class MapData:
    CLSID: Any

    def Count(self) -> Any:
        """
        **Description:**
            Number of IDs in the MapData object
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def DefineBool(self) -> Any:
        """
        **Description:**
            Defines an Boolean field in MapData object and returns a number from 0..n that represents the index ID of that piece of data.
        **Remarks/Usage:**
            If the data cannot be successfully added to the MapData object, -1 is returned.
        **Return Code:** True\n
        """
        ...

    def DefineInt(self) -> Any:
        """
        **Description:**
            Defines an integer field in MapData object and returns a number from 0..n that represents the index ID of that piece of data.
        **Remarks/Usage:**
            If the data cannot be successfully added to the MapData object, -1 is returned.
        **Return Code:** True\n
        """
        ...

    def DefineReal(self) -> Any:
        """
        **Description:**
            Defines a double field in MapData object and returns a number from 0..n that represents the index ID of that piece of data.
        **Remarks/Usage:**
            If the data cannot be successfully added to the MapData object, -1 is returned.
        **Return Code:** True\n
        """
        ...

    def DefineString(self, nLength) -> Any:
        """
        **Description:**
            Defines an String field of a specified maximum length in MapData object and returns a number from 0..n that represents the index ID of that piece of data.
        **Remarks/Usage:**

        **Input:**
            **nLength:** Maximum length of String\n
        **Return Code:** True\n
        :type nLength: int

        """
        ...

    def DefineVariant(self, vVar) -> Any:
        """
        **Description:**
            Defines an String field of a specified length in MapData object and returns a number from 0..n that represents the index ID of that piece of data.
        **Remarks/Usage:**
            The size and data type of the Variant my be defined using the Array call in the API Programming Window
        **Input:**
            **vVar:** Name of the variant\n
        **Return Code:** True\n
        :type vVar: Any

        """
        ...

    def GetBool(self, nIndex, nID, pbVal) -> Any:
        """
        **Description:**
            Gets Boolean value from field filled by SetBool method for DataMap object for given Index-ID data pair.
        **Remarks/Usage:**

        **Input:**
            **nIndex:** Index value for Boolean field\n
            **nID:** ID value for Boolean field\n
        **Output:**
            **pbVal:** Boolean value from Boolean field\n
        **Return Code:** True\n
        :type nIndex: int

        :type nID: int

        :type pbVal: bool

        """
        ...

    def GetIDs(self, nIDSet) -> Any:
        """
        **Description:**
            Fills Set Object with IDs from MapData object
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def GetInt(self, nIndex, nID, pnVal) -> Any:
        """
        **Description:**
            Gets Integer value from field filled by SetInt method for DataMap object for given Index-ID data pair.
        **Remarks/Usage:**

        **Input:**
            **nIndex:** Index value for integer field\n
            **nID:** ID value for integer field\n
        **Output:**
            **pnVal:** Integer value from integer field\n
        **Return Code:** True\n
        :type nIndex: int

        :type nID: int

        :type pnVal: int

        """
        ...

    def GetReal(self, nIndex, nID, pdVal) -> Any:
        """
        **Description:**
            Gets Real value from field filled by SetReal method for DataMap object for given Index-ID data pair.
        **Remarks/Usage:**

        **Input:**
            **nIndex:** Index value for real field\n
            **nID:** ID value for real field\n
        **Output:**
            **pdVal:** Real value from real field\n
        **Return Code:** True\n
        :type nIndex: int

        :type nID: int

        :type pdVal: float

        """
        ...

    def GetString(self, nIndex, nID, psVal) -> Any:
        """
        **Description:**
            Gets String value from field filled by SetString method for DataMap object for given Index-ID data pair.
        **Remarks/Usage:**

        **Input:**
            **nIndex:** Index value for string field\n
            **nID:** ID value for string field\n
        **Output:**
            **psVal:** String value from string field\n
        **Return Code:** True\n
        :type nIndex: int

        :type nID: int

        :type psVal: str

        """
        ...

    def GetVariant(self, nIndex, nID, vVal) -> Any:
        """
        **Description:**
            Gets Variant from field filled by SetVarient method for DataMap object for given Index-ID data pair.
        **Remarks/Usage:**
            The data type used here needs to be the exact same data type used with the DefineVariant() method
        **Input:**
            **nIndex:** Index value for variant field\n
            **nID:** ID value for variant field\n
        **Output:**
            **vVal:** Name of variant for variant field\n
        **Return Code:** True\n
        :type nIndex: int

        :type nID: int

        :type vVal: Any

        """
        ...

    def Initialize(self, nCount) -> Any:
        """
        **Description:**
            Sets approximate number of IDs to be added to MapData object
        **Remarks/Usage:**
            The count supplied is only an estimate to the number of entries the MapData object will hold. If more or fewer entries planned to be stored, there is no need to call this method again as the MapData will automatically resize itself as appropriate, however a more accurate count will result in more efficient memory utilization and better performance.
        **Input:**
            **nCount:** Approximate number of IDs to be added to MapData object\n
        **Return Code:** True\n
        :type nCount: int

        """
        ...

    def Remove(self, nID) -> Any:
        """
        **Description:**
            Deletes a selected ID and associated data from the MapData object
        **Remarks/Usage:**

        **Input:**
            **nID:** ID to delete from MapData object\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def RemoveAll(self) -> Any:
        """
        **Description:**
            Deletes a all data associated with all IDs from the MapData object, but the field definitions remain
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def SetBool(self, nIndex, nID, bVal) -> Any:
        """
        **Description:**
            Sets Boolean value for a field defined using DefineBool method for DataMap object for given Index-ID data pair
        **Remarks/Usage:**

        **Input:**
            **nIndex:** Index value for Boolean field\n
            **nID:** ID value for Boolean field\n
            **bVal:** Boolean value for Boolean field\n
        **Return Code:** True\n
        :type nIndex: int

        :type nID: int

        :type bVal: bool

        """
        ...

    def SetInt(self, nIndex, nID, nVal) -> Any:
        """
        **Description:**
            Sets Integer value for a field defined using DefineInt method for DataMap object for given Index-ID data pair
        **Remarks/Usage:**

        **Input:**
            **nIndex:** Index value for integer field\n
            **nID:** ID value for integer field\n
            **nVal:** Integer value for integer field\n
        **Return Code:** True\n
        :type nIndex: int

        :type nID: int

        :type nVal: int

        """
        ...

    def SetReal(self, nIndex, nID, dVal) -> Any:
        """
        **Description:**
            Sets Real value in field defined using DefineReal method for DataMap object for given index-ID data pair
        **Remarks/Usage:**

        **Input:**
            **nIndex:** Index value for real field\n
            **nID:** ID value for real field\n
            **dVal:** Real value for real field\n
        **Return Code:** True\n
        :type nIndex: int

        :type nID: int

        :type dVal: float

        """
        ...

    def SetString(self, nIndex, nID, sVal) -> Any:
        """
        **Description:**
            Sets String value for a field defined using DefineString method for DataMap object for given Index-ID data pair
        **Remarks/Usage:**

        **Input:**
            **nIndex:** Index value for string field\n
            **nID:** ID value for string field\n
            **sVal:** String value for string field\n
        **Return Code:** True\n
        :type nIndex: int

        :type nID: int

        :type sVal: str

        """
        ...

    def SetVariant(self, nIndex, nID, vVal) -> Any:
        """
        **Description:**
            Sets Variant value for a field defined using DefineVariant method for DataMap object for given Index-ID data pair
        **Remarks/Usage:**
            The data type used here needs to be the exact same data type used with the DefineVariant() method
        **Input:**
            **nIndex:** Index value for variant field\n
            **nID:** ID value for variant field\n
            **vVal:** Name of variant for variant field\n
        **Return Code:** True\n
        :type nIndex: int

        :type nID: int

        :type vVal: Any

        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            Clears everything in the MapData object, including all data definitions, which then must be set again.
        **Remarks/Usage:**
            To clear all of the data, but retain the data definitions, use the RemoveAll method instead.
        **Return Code:** True\n
        """
        ...


class TrackData:
    CLSID: Any

    def Created(self, entityTYPE, nSetID, bClear) -> Any:
        """
        **Description:**
            Fills the specified Set object with the entities of the specified type which were created during the entity tracking period.
        **Remarks/Usage:**
            Calling the Created method stops tracking of the specified entity type. To begin tracking this entity type again, the Start, StartGeometry, or StartMesh method must be called again.
        **Input:**
            **entityTYPE:** Type of entity created during tracking period. 3=Point, 4=Curve, 5=Surface, 6=Volume, 7=Node, 8=Element, 9=Coordinate System, 10=Material, 11=Property, 12=Load Set, 17=Constraint Set, 21=Text, 22=View, 24=Group, 28=Output Set, 32=Boundary Surface, 33=Layer, 35=Function, 39=Solid, 45=Design Optimization, 58=Region, 60=Analysis Set, 69=Data Surface, 71=Connector, 72=Connection Property, 81=Layup, 83=Global Ply, 95=Aero Panel/Body, 96=Aero Property, 98=Aero Spline, 99=Aero Control Surface. For more information, see Section 3.3.6, "Entity Types".\n
            **nSetID:** ID of the Set object to fill with entities of the specified entity type created during the entity tracking period. It is recommended to use a unique Set object for tracking created entities of each entity type.\n
            **bClear:** If True, removes all entities of the specified entity type created in the current tracking period from the Set object specified with SetID. If false, entities created during the previous tracking period(s) will remain in the Set object until cleared.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type nSetID: int

        :type bClear: bool

        """
        ...

    def Deleted(self, entityTYPE, nSetID, bClear) -> Any:
        """
        **Description:**
            Fills the specified Set object with the entities of the specified type which were deleted during the entity tracking period.
        **Remarks/Usage:**
            Calling the Deleted method stops tracking of the specified entity type. To begin tracking this entity type again, the Start, StartGeometry, or StartMesh method must be called again.
        **Input:**
            **entityTYPE:** Type of entity deleted during tracking period. 3=Point, 4=Curve, 5=Surface, 6=Volume, 7=Node, 8=Element, 9=Coordinate System, 10=Material, 11=Property, 12=Load Set, 17=Constraint Set, 21=Text, 22=View, 24=Group, 28=Output Set, 32=Boundary Surface, 33=Layer, 35=Function, 39=Solid, 45=Design Optimization, 58=Region, 60=Analysis Set, 69=Data Surface, 71=Connector, 72=Connection Property, 81=Layup, 83=Global Ply, 95=Aero Panel/Body, 96=Aero Property, 98=Aero Spline, 99=Aero Control Surface. For more information, see Section 3.3.6, "Entity Types".\n
            **nSetID:** ID of the Set object to fill with entities of the specified entity type deleted during the entity tracking period. It is recommended to use a unique Set object for tracking deleted entities of each entity type.\n
            **bClear:** If True, removes all entities of the specified entity type deleted in the current tracking period from the Set object specified with SetID. If false, entities deleted during the previous tracking period(s) will remain in the Set object until cleared.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type nSetID: int

        :type bClear: bool

        """
        ...

    def Start(self, entityTYPE) -> Any:
        """
        **Description:**
            Begins entity tracking for the specified entity type.
        **Remarks/Usage:**

        **Input:**
            **entityTYPE:** Type of entity to begin tracking. 3=Point, 4=Curve, 5=Surface, 6=Volume, 7=Node, 8=Element, 9=Coordinate System, 10=Material, 11=Property, 12=Load Set, 17=Constraint Set, 21=Text, 22=View, 24=Group, 28=Output Set, 32= Boundary Surface, 33=Layer, 35=Function, 39=Solid, 45=Design Optimization, 58=Region, 60=Analysis Set, 69=Data Surface, 71=Connector, 72=Connection Property, 81=Layup, 83=Global Ply, 95=Aero Panel/Body, 96=Aero Property, 98=Aero Spline, 99=Aero Control Surface. For more information, see Section 3.3.6, "Entity Types".\n
        **Return Code:** True\n
        :type entityTYPE: int

        """
        ...

    def StartGeometry(self) -> Any:
        """
        **Description:**
            Begins entity tracking of Point, Curve, Surface, Boundary Surface, and Solid entity types.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def StartMesh(self) -> Any:
        """
        **Description:**
            Begins entity tracking for Node, Element, Material, and Property entity types.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def Stop(self, entityTYPE) -> Any:
        """
        **Description:**
            Ends entity tracking for the specified entity type.
        **Remarks/Usage:**

        **Input:**
            **entityTYPE:** Type of entity to stop tracking. 3=Point, 4=Curve, 5=Surface, 6=Volume, 7=Node, 8=Element, 9=Coordinate System, 10=Material, 11=Property, 12=Load Set, 17=Constraint Set, 21=Text, 22=View, 24=Group, 28=Output Set, 32=Boundary Surface, 33=Layer, 35=Function, 39=Solid, 45=Design Optimization, 58=Region, 60=Analysis Set, 69=Data Surface, 71=Connector, 72=Connection Property, 81=Layup, 83=Global Ply, 95=Aero Panel/Body, 96=Aero Property, 98=Aero Spline, 99=Aero Control Surface. For more information, see Section 3.3.6, "Entity Types".\n
        **Return Code:** True\n
        :type entityTYPE: int

        """
        ...

    def StopAll(self) -> Any:
        """
        **Description:**
            Ends entity tracking for all entity types.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            Clears everything in the TrackData object.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...


class ResultsIDQuery:
    CLSID: Any

    def Complex(self, enRVComplex, nRVOriginalVector) -> Any:
        """
        **Description:**
            Determines the ID of the output vector which is the corresponding complex output vector to the output vector ID specified as the Original Output Vector (i.e., the ID of the phase output vector when a magnitude output vector has been specified or vice versa). See Remarks/Usage section.
        **Remarks/Usage:**
            This method can be used as a secondary step to determine the corresponding complex output vector after another method on the Results ID Query object has been used to find the ID of the Original Vector. Typically, if a magnitude vector ID has been found first, set zVecComplex to VCX_PHASE to find the corresponding phase vector ID. Another use might be to find the ID of the real output vector if the ID of the imaginary vector is already known.
        **Input:**
            **enRVComplex:** Used to determine which type of complex output vector ID should be found to correspond with the Original Vector ID. \n
            **nRVOriginalVector:** Original Vector ID\n
        **Return Code:** True\n
        :type enRVComplex: Any

        :type nRVOriginalVector: int

        """
        ...

    def Elemental(self, enRVResult) -> Any:
        """
        **Description:**
            Determines the ID of the output vector which contains specialized output data for elements which is not able to be determined using the Line, LineOther, Plate, Laminate, LaminateGlobalPly, PlateOther, Solid, SolidOther, LaminateSolid, or LaminateSolidGlobalPlymethods. See Section 4.18.1.10, "Constants for Elemental Method". Also, see Remarks/Usage section.
        **Remarks/Usage:**
            This method is used to determine the output vector ID for almost any Strain Energy, Heat Transfer, Kinetic Energy, Energy Loss, Crack Stress, or Fluid Pressure output quantity. In addition, it can be used to determine the Output Vector ID for any Gasket element output quantity. Finally, it can also determine the output vector ID for Normalized Mass Density, which is useful when reviewing results recovered from a Topology Optimization run performed with SOL 200 of Simcenter Nastran.
        **Input:**
            **enRVResult:** The element output quantity\n
        **Return Code:** True\n
        :type enRVResult: Any

        """
        ...

    def Find(self, nRVOutSetID, sRVTitle) -> Any:
        """
        **Description:**
            Determines the ID of an output vector which matches the specified title that exists in the specified output set. Attempting to Exact Matches is the best approach, but this method can sometimes use a Partial Match to determine the output vector ID, as long as there is only a single Partial Match. See Remarks/Usage section.
        **Remarks/Usage:**
            Using more characters for sRVTitle increases the chances of finding the correct Output Vector ID.
        **Input:**
            **nRVOutSetID:** ID of Output Set to find output vector ID\n
            **sRVTitle:** Title of Output Vector to find in specified output set\n
        **Return Code:** True\n
        :type nRVOutSetID: int

        :type sRVTitle: str

        """
        ...

    def Laminate(self, enRVResult, enRVType, nRVPly, enRVLoc) -> Any:
        """
        **Description:**
            Determines the ID of the output vector which contains output data for laminate planar elements (Force, Moment, Stress, Strain, etc) at a specified location (Centroid or individual Corner), for a specified laminate ply ID. See Section 4.18.1.5, "Constants for Planar Element Methods"
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** Type of results on laminate planar element\n
            **enRVType:** Sub-type of laminate planar results (Tensor, Invariant, or Other)\n
            **nRVPly:** ID of laminate ply\n
            **enRVLoc:** Location on element for the results:\n
        **Return Code:** True\n
        :type enRVResult: Any

        :type enRVType: Any

        :type nRVPly: int

        :type enRVLoc: Any

        """
        ...

    def LaminateGlobalPly(self, enRVResult, enRVType, nRVGlobalPly, enRVLoc) -> Any:
        """
        **Description:**
            Determines the ID of the output vector which contains output data for laminate planar elements (Force, Moment, Stress, Strain, etc) at a specified location (Centroid or individual Corner), for a specified laminate global ply ID. See Section 4.18.1.5, "Constants for Planar Element Methods"
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** Type of results on laminate planar element\n
            **enRVType:** Sub-type of laminate planar results (Tensor, Invariant, or Other)\n
            **nRVGlobalPly:** ID of laminate global ply\n
            **enRVLoc:** Location on element for the results:\n
        **Return Code:** True\n
        :type enRVResult: Any

        :type enRVType: Any

        :type nRVGlobalPly: int

        :type enRVLoc: Any

        """
        ...

    def LaminateGlobalPlyWithCorners(self, enRVResult, enRVType, nRVGlobalPly, VectorIDs) -> Any:
        """
        **Description:**
            Determines the IDs of the output vectors which contain output data for laminate planar elements (Force, Moment, Stress, Strain, etc) for a specified laminate global ply ID. See Section 4.18.1.5, "Constants for Planar Element Methods".
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** Type of results on laminate planar element\n
            **enRVType:** Sub-type of laminate planar results (Tensor, Invariant, or Other)\n
            **nRVGlobalPly:** ID of laminate global ply\n
        **Output:**
            **VectorIDs:** Array of five output vector IDs:\n
        **Return Code:** True\n
        :type enRVResult: Any

        :type enRVType: Any

        :type nRVGlobalPly: int

        :type VectorIDs: tuple[Any]

        """
        ...

    def LaminateSolid(self, enRVResult, enRVType, nRVPly, enRVPlyLoc, enRVLoc) -> Any:
        """
        **Description:**
            Determines the ID of the output vector which contains output data for solid laminate planar elements (Stress, Strain, Failure, or Strength Ratio) at a specified location (Centroid or individual Corner), for the top, middle, or bottom of the specified solid laminate ply ID. See Section 4.18.1.9, "Constants for Sold Laminate Element Methods".
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** Type of results on solid laminate element\n
            **enRVType:** Sub-type of solid laminate results (Tensor, Invariant, or Other)\n
            **nRVPly:** ID of solid laminate ply\n
            **enRVPlyLoc:** Results at Top, Middle, or Bottom of specified solid laminate ply\n
            **enRVLoc:** Location on element for the results:\n
        **Return Code:** True\n
        :type enRVResult: Any

        :type enRVType: Any

        :type nRVPly: int

        :type enRVPlyLoc: Any

        :type enRVLoc: Any

        """
        ...

    def LaminateSolidGlobalPly(self, enRVResult, enRVType, nRVGlobalPly, enRVPlyLoc, enRVLoc) -> Any:
        """
        **Description:**
            Determines the ID of the output vector which contains output data for solid laminate planar elements (Stress, Strain, Failure, or Strength Ratio) at a specified location (Centroid or individual Corner), for the top, middle, or bottom of the specified solid laminate global ply ID. See Section 4.18.1.9, "Constants for Sold Laminate Element Methods".
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def LaminateSolidGlobalPlyWithCorners(self, enRVResult, enRVType, nRVGlobalPly, enRVPlyLoc, VectorIDs) -> Any:
        """
        **Description:**
            Determines the IDs of the output vectors which contain output data for solid laminate elements (Stress, Strain, Failure, or Strength Ratio) for the top, middle, or bottom of the specified solid laminate global ply ID. See Section 4.18.1.9, "Constants for Sold Laminate Element Methods".
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** Type of results on solid laminate element\n
            **enRVType:** Sub-type of solid laminate results (Tensor, Invariant, or Other)\n
            **enRVPlyLoc:** Results at Top, Middle, or Bottom of specified solid laminate global ply\n
        **Output:**
            **VectorIDs:** Array of nine output vector IDs:\n
        **Return Code:** True\n
        :type enRVResult: Any

        :type enRVType: Any

        :type enRVPlyLoc: Any

        :type VectorIDs: tuple[Any]

        """
        ...

    def LaminateSolidWithCorners(self, enRVResult, enRVType, nRVPly, enRVPlyLoc, VectorIDs) -> Any:
        """
        **Description:**
            Determines the IDs of the output vectors which contain output data for solid laminate elements (Stress, Strain, Failure, or Strength Ratio) for the top, middle, or bottom of the specified solid laminate ply ID. See Section 4.18.1.9, "Constants for Sold Laminate Element Methods".
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** Type of results on solid laminate element\n
            **enRVType:** Sub-type of solid laminate results (Tensor, Invariant, or Other)\n
            **nRVPly:** ID of solid laminate ply\n
            **enRVPlyLoc:** Results at Top, Middle, or Bottom of specified solid laminate ply\n
        **Output:**
            **VectorIDs:** Array of nine output vector IDs:\n
        **Return Code:** True\n
        :type enRVResult: Any

        :type enRVType: Any

        :type nRVPly: int

        :type enRVPlyLoc: Any

        :type VectorIDs: tuple[Any]

        """
        ...

    def LaminateWithCorners(self, enRVResult, enRVType, nRVPly, VectorIDs) -> Any:
        """
        **Description:**
            Determines the IDs of the output vectors which contain output data for laminate planar elements (Force, Moment, Stress, Strain, etc) for a specified laminate ply ID. See Section 4.18.1.5, "Constants for Planar Element Methods".
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** Type of results on laminate planar element\n
            **enRVType:** Sub-type of laminate planar results (Tensor, Invariant, or Other)\n
            **nRVPly:** ID of laminate ply\n
        **Output:**
            **VectorIDs:** Array of five output vector IDs:\n
        **Return Code:** True\n
        :type enRVResult: Any

        :type enRVType: Any

        :type nRVPly: int

        :type VectorIDs: tuple[Any]

        """
        ...

    def Line(self, enRVElemType, enRVResult, enRVEnd, enRVLoc) -> Any:
        """
        **Description:**
            Determines the ID of the output vector which contains output data for Bar, Beam, or Weld elements by entering the type of element, the type of results (Axial Force, Torque, Moment, Shear, Stresses, and Strains), which end of the line element, and stress recovery locations. See Section 4.18.1.3, "Constants for Line and LineAllLocations Methods"
        **Remarks/Usage:**
            None
        **Input:**
            **enRVElemType:** Type of line element:\n
            **enRVResult:** Type of results on line element\n
            **enRVEnd:** Specifies end of the line element for the results:\n
            **enRVLoc:** Specifies stress recovery location of the line element for results:\n
        **Return Code:** True\n
        :type enRVElemType: Any

        :type enRVResult: Any

        :type enRVEnd: Any

        :type enRVLoc: Any

        """
        ...

    def LineAllLocations(self, enRVElemType, enRVResult, VectorIDs) -> Any:
        """
        **Description:**
            Determines the IDs of the output vectors which contain output data for Bar, Beam, or Weld elements, at all locations, by entering the type of element and the type of results (Axial Force, Torque, Moment, Shear, Stresses, and Strains). See Section 4.18.1.3, "Constants for Line and LineAllLocations Methods".
        **Remarks/Usage:**
            None
        **Input:**
            **enRVElemType:** Type of line element:\n
            **enRVResult:** Type of results on line element\n
        **Output:**
            **VectorIDs:** Array of eight output vector IDs:\n
        **Return Code:** True\n
        :type enRVElemType: Any

        :type enRVResult: Any

        :type VectorIDs: tuple[Any]

        """
        ...

    def LineOther(self, enRVResult) -> Any:
        """
        **Description:**
            Determines the ID of the output vector which contains output data for line elements other than Bars or Beams, (i.e., Springs, Rods, Gaps, CBUSH, Bush/Fastener), and some for Welds. See Section 4.18.1.4, "Constants for LineOther Method"
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** The line element output quantity\n
        **Return Code:** True\n
        :type enRVResult: Any

        """
        ...

    def Nodal(self, enRVResult, enRVType) -> Any:
        """
        **Description:**
            Determines the ID of the output vector which contains vector-based output data on nodes by entering a type of vector output (Translations, Rotations, Applied Forces, Grid Point Forces, Contact Forces, etc) and if a specific component direction (X,Y, or Z) or the resultant (Total) is needed. See Section 4.18.1.1, "Constants for Nodal and NodalWithComponents Methods"
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** The vector-based nodal output quantity. \n
            **enRVType:** Specific component direction or resultant:\n
        **Return Code:** True\n
        :type enRVResult: Any

        :type enRVType: Any

        """
        ...

    def NodalOther(self, enRVResult) -> Any:
        """
        **Description:**
            Determines the ID of the output vector which contains scalar output data on nodes by entering a type of vector output (Temperature, Enthalpy, Contact Pressure, Contact Normal Force, etc). See Section 4.18.1.2, "Constants for NodalOther Method"
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** The scalar nodal output quantity.\n
        **Return Code:** True\n
        :type enRVResult: Any

        """
        ...

    def NodalWithComponents(self, enRVResult, VectorIDs) -> Any:
        """
        **Description:**
            Determines the IDs of the output vectors which contain vector-based output data on nodes by entering a type of vector output (Translations, Rotations, Applied Forces, Grid Point Forces, Contact Forces, etc). See Section 4.18.1.1, "Constants for Nodal and NodalWithComponents Methods".
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** The vector-based nodal output quantity.\n
        **Output:**
            **VectorIDs:** Array of four output vector IDs:\n
        **Return Code:** True\n
        :type enRVResult: Any

        :type VectorIDs: tuple[Any]

        """
        ...

    def Plate(self, enRVResult, enRVType, enRVPly, enRVLoc) -> Any:
        """
        **Description:**
            Determines the ID of the output vector which contains output data for non-laminate planar elements (Force, Moment, Stress, Strain, etc) at a specified position (Top/Middle/Bottom) and location (Centroid or Corner). See Section 4.18.1.5, "Constants for Planar Element Methods"
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** Type of results on non-laminate planar element\n
            **enRVType:** Sub-type of non-laminate planar results (Tensor, Invariant, or Other)\n
            **enRVPly:** Position on element for the results:\n
            **enRVLoc:** Location on element for the results:\n
        **Return Code:** True\n
        :type enRVResult: Any

        :type enRVType: Any

        :type enRVPly: Any

        :type enRVLoc: Any

        """
        ...

    def PlateOther(self, enRVResult) -> Any:
        """
        **Description:**
            Determines the ID of the output vector which contains output data for planar elements other than plates and laminates, with or without global plies including Shear and Axisymmetric elements. Also, this method can be used to determine the output vector ID for scalar output on plate or laminate elements, with or without global plies (i.e., only one output value exists for the element). See Section 4.18.1.6, "Constants for PlateOther Method"
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** The planer element output quantity (typically a scalar)\n
        **Return Code:** True\n
        :type enRVResult: Any

        """
        ...

    def PlateWithCorners(self, enRVResult, enRVType, enRVPly, VectorIDs) -> Any:
        """
        **Description:**
            Determines the IDs of the output vectors which contain output data for non-laminate planar elements (Force, Moment, Stress, Strain, etc) for a specified position (Top/Middle/Bottom). See Section 4.18.1.5, "Constants for Planar Element Methods".
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** Type of results on non-laminate planar element\n
            **enRVType:** Sub-type of non-laminate planar results (Tensor, Invariant, or Other)\n
            **enRVPly:** Position on element for the results:\n
        **Output:**
            **VectorIDs:** Array of five output vector IDs:\n
        **Return Code:** True\n
        :type enRVResult: Any

        :type enRVType: Any

        :type enRVPly: Any

        :type VectorIDs: tuple[Any]

        """
        ...

    def Solid(self, enRVResult, enRVType, enRVLoc) -> Any:
        """
        **Description:**
            Determines the ID of the output vector which contains output data for non-laminate solid elements (Stress, Nonlinear Stress, Strain, and Nonlinear Strain) at specified location (Centroid or Corner). See Section 4.18.1.7, "Constants for Solid Element Methods".
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** Type of results on non-laminate solid element\n
            **enRVType:** Sub-type of non-laminate solid results (Tensor, Invariant, or Other)\n
            **enRVLoc:** Location on element for the results:\n
        **Return Code:** True\n
        :type enRVResult: Any

        :type enRVType: Any

        :type enRVLoc: Any

        """
        ...

    def SolidOther(self, enRVResult, enRVLoc) -> Any:
        """
        **Description:**
            Determines the ID of the output vector which contains specialized output data for solid elements, such as solid elements used as Bolts, as well as Solid Cohesive elements. See Section 4.18.1.8, "Constants for SolidOther Method"
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** The specialized solid element output quantity\n
        **Return Code:** True\n
        :type enRVResult: Any

        """
        ...

    def SolidWithCorners(self, enRVResult, enRVType, VectorIDs) -> Any:
        """
        **Description:**
            Determines the IDs of the output vectors which contain output data for non-laminate solid elements (Stress, Nonlinear Stress, Strain, and Nonlinear Strain) at all locations. See Section 4.18.1.7, "Constants for Solid Element Methods".
        **Remarks/Usage:**
            None
        **Input:**
            **enRVResult:** Type of results on non-laminate solid element\n
            **enRVType:** Sub-type of non-laminate solid results (Tensor, Invariant, or Other)\n
        **Output:**
            **VectorIDs:** Array of nine output vector IDs:\n
        **Return Code:** True\n
        :type enRVResult: Any

        :type enRVType: Any

        :type VectorIDs: tuple[Any]

        """
        ...

    def User(self, nRVUserVector) -> Any:
        """
        **Description:**
            Determines the ID an output vector in the User Output range for the specified output vector ID
        **Remarks/Usage:**
            See example. This would return a value of 49000001, the first value in the User Output range for Phase
        **Input:**
            **nRVUserVector:** ID of output vector to determine output vector in User Output range. The only values which can be used are:\n
        **Return Code:** True\n
        :type nRVUserVector: int

        """
        ...


class Results:
    CLSID: Any
    AutoPopulate: Any
    NextSetStartID: Any
    NextStudyStartID: Any
    NextVectorStartID: Any
    ValueForNonExisting: Any

    def AddColumnV2(self, nSetID, nVectorID, bAddComponentsCorners, nNumColumnsAdded, nColumnIndices) -> Any:
        """
        **Description:**
            This method adds a column to the object that will be filled by a specified Output Vector. This method replaces AddColumn. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above".\n
        **Remarks/Usage:**
            Always remember to remember the nColumnIndices values - they will be needed to query the actual results after data is loaded by Populate.\n

        **Input:**
            **nSetID** The ID of the Output Set to load\n
            **nVectorID** The ID of the Output Vector to Load\n
            **bAddComponentsCorners** If True, additional columns will be added to accommodate the components of the selected vector, if any.\n
        **Output:**
            **nNumColumnsAdded** The total number of columns added.\n
            **nColumnIndices** The indices of the columns that were added. nColumnIndices[0] is always the index of the column for the selected vector. If component/corner vectors were added, their indices will be in nColumnIndices[1] and beyond.\n
        **Return Code:**
            **FE_INVALID** The object has already been populated with data. You can only add columns prior to populating the object.\n
            **FE_NOT_EXIST** The selected vector does not exist\n
            **FE_BAD_TYPE** The selected vector is not of the same type (Nodal or Elemental) as other vectors in the object.\n
        :type nSetID: int
        :type nVectorID: int
        :type bAddComponentsCorners: bool
        :type nNumColumnsAdded: int
        :type nColumnIndices: tuple[int]
        """
        ...

    def AddConversionColumnV2(self, nSetID, nVectorID, nConversionApproach, nColumnIndex) -> Any:
        """
        **Description:**
            This method adds one or more columns that are not associated with any Output Vectors. This method replaces AddConversionColumn.
            For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            Use this method to add columns that you want to use to convert existing Nodal results to Elemental, or vice versa. When you populate the object, these columns
            will be automatically populated with the con­verted results.
            If you do not want to convert based on results in the entire model, you must call DataNeeded() and define the Element ID set prior to
            calling this method. You must define the Element ID set, no matter whether you are converting Elemental to Nodal results or Nodal to Elemental.
        **Input:**
            **nSetID** The ID of the Output Set to load\n
            **nVectorID** The ID of the Output Vector to Load\n
            **nConversionApproach** 0=Average, 1=Max Value, 2= Average, Skip Corner Results, 3=Max Value, Skip Corner Results, 4=Min Value, 5=Min Value, Skip Corner Results.\n
        **Return Code:**
            **FE_INVALID** The object has already been populated with data. You can only add columns prior to populating the object.\n
            **FE_NOT_EXIST** The selected vector does not exist\n
            **FE_BAD_TYPE** The selected vector is not of the same type (Nodal or Elemental) as other vectors in the object.\n
            **FE_FAIL** Unable to add column.\n

        :type nSetID: int
        :type nVectorID: int
        :type nConversionApproach: int
        :type nColumnIndex: int
        """
        ...

    def AddElemWithCornerColumnsV2(self, nSetID, nVectorID, Vec1, Vec2, Vec3, Vec4, Vec5, Vec6, Vec7, Vec8, title,
                                   category, nonlinear, pnColumnIndices) -> Any:
        """
         **Description:**
            This method initializes a column to prepare it for creating an output vector containing scalar values at elements.
        **Input:**
            **nSetID** The ID of the Output Set.\n
            **nVectorID, Vec1, Vec2, Vec3, Vec4, Vec5, Vec6, Vec7, Vec8** The ID of the output vector which will be created containing the results at the corresponding element corners. \n
            **title*** The title of columns being added.\n
            **category** General category of output: 0=Any, 1=Disp, 2=Accel, 3=Force, 4=Stress, 5=Strain, 6=Temp, others=User.\n
            **nonlinear** If True, this result cannot be linearly combined. \n
         **Output:**
            **pnColumnIndices** The indice of the columns that were initialized.\n
         **Return Code:**
             **FE_NO_MEMORY** Insufficient memory to allocate space for values \n
             **FE_FAIL** Unable to set data for the specified row/columns \n

        :type nSetID: int
        :type nVectorID: int
        :type Vec1: int
        :type Vec2: int
        :type Vec3: int
        :type Vec4: int
        :type Vec5: int
        :type Vec6: int
        :type Vec7: int
        :type Vec8: int
        :type title: str
        :type category: int
        :type nonlinear: bool
        :type pnColumnIndices: int
        """
        ...

    def AddEmptyColumns(self, nNumberOfColumns, nColumnIndices) -> Any:
        """
        **Description:**
            This method adds one or more columns that are not associated with any Output Vectors.
        **Remarks/Usage:**
            Use this method to add columns that you want to use to compute other values. When you populate the object, these columns will remain empty, but they will be available for you to store values computed from querying the other values.

        **Input:**
            **nNumberOfColumns** The number of columns to add\n
        **Output:**
            **nColumnIndices**  The indices of the columns that were added. \n
        **Return Code:**
            **FE_INVALID** The object has already been populated with data. You can only add columns prior to populating the object.\n
            **FE_NO_MEMORY** Unable to allocate memory to return the column indices \n

        :type nNumberOfColumns: int
        :type nColumnIndices: int
        """
        ...

    def AddEnvelopeColumn(self, nEnvelopeType, nDataColumnIndex, nColumnColumnIndex) -> Any:
        """
        **Description:**
            This method adds columns that will be Populated() with an envelope of the results from the Output Vec­tors in each row.
        **Remarks/Usage:**
            Use this method if you want to find the maximum or minimum value of other Output Vectors. You can Add any other combination of Output Vectors that you want and they will be “enveloped” during Popu­late(). Empty columns are not considered. The envelope is performed as a final step so that all conver­sions and transforms have already been applied to the populated data prior to enveloping.

        **Input:**
            **nEnvelopeType** 0=Max Value, 1=Min Value, 2=Max Absolute Value\n
        **Output:**
            **nDataColumnIndex** The index of the column that contains the enveloped results value\n
            **nColumnColumnIndex** The index of the column that contains the index of the column where the enveloped value came from.\n

        **Return Code:**
            **FE_INVALID** The object has already been populated with data. You can only add columns prior to populating the object.\n
            **FE_BAD_DATA** An invalid value has been specified for the envelope type\n
            **FE_BAD_DATA** Unable to add column.\n

        :type nEnvelopeType: int
        :type nDataColumnIndex: int
        :type nColumnColumnIndex: int
        """
        ...

    def AddScalarAtBeamColumnsV2(self, nSetID, VecA, VecB, title, vecstyle, category, nonlinear, add_endAB_titles,
                                 pnColumnIndices) -> Any:
        """
        **Description:**
            This method initialized the column to prepare it for creating Beam output vectors for EndA and EndB.
        **Remarks/Usage:**
            This method allows you to update the values of specific columns for given entities in a Set.
        **Input:**
            **nSetID** The ID of the Output Set. \n
            **VecA** The ID of the EndA output vector to be created.\n
            **VecB** The ID of the EndB output vector to be created.\n
            **title** The title of columns being added.\n
            **vecstyle** If 1, component[0..2] are the X,Y,Z component values. If 2, data at end of beams. If 3, reverse data at second end of beam\n
            **category** General category of output: 0=Any, 1=Disp, 2=Accel, 3=Force, 4=Stress, 5=Strain, 6=Temp, others=User.\n
            **nonlinear** If True, this result cannot be linearly combined.\n
            **add_endAB_titles** Flag to prepend “End A”, “End B” to the title. \n

        **Output:**
            **pnColumnIndices** The indices of the columns.

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values \n
            **FE_FAIL** Unable to set data for the specified row/columns \n

        :type nSetID: int
        :type VecA: int
        :type VecB: int
        :type title: str
        :type vecstyle: int
        :type category: int
        :type nonlinear: bool
        :type add_endAB_titles: bool
        :type pnColumnIndices: Any
        """
        ...

    def AddScalarAtElemColumnV2(self, nSetID, nVectorID, title, category, nonlinear, nColumnIndex) -> Any:
        """
        **Description:**
            This method initializes a column to prepare it for creating an output vector containing scalar values at elements.
        **Input:**
            **nSetID** The ID of the Output Set.

            **nVectorID** The ID of the Vector to initialize.

            **title** The title of columns being added.

            **category** General category of output: 0=Any, 1=Disp, 2=Accel, 3=Force, 4=Stress, 5=Strain, 6=Temp, others=User.

            **nonlinear** If True, this result cannot be linearly combined.

        **Output:**
            **nColumnIndex** The index of the columns that was initialized.

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_FAIL** Unable to set data for the specified row/columns


        :type nSetID: Any
        :type nVectorID: Any
        :type title: Any
        :type category: Any
        :type nonlinear: Any
        :type nColumnIndex: Any
        """
        ...

    def AddScalarAtNodeColumnV2(self, nSetID, nVectorID, title, category, nonlinear, nColumnIndex) -> Any:
        """
        **Description:**
            This method initializes a column to prepare it for creating an output vector containing scalar values at nodes.

        **Input:**
            **nSetID** The ID of the Output Set.

            **nVectorID** The ID of the Vector to initialize.

            **title** The title of columns being added.

            **category** General category of output: 0=Any, 1=Disp, 2=Accel, 3=Force, 4=Stress, 5=Strain, 6=Temp, others=User.

            **nonlinear** If True, this result cannot be linearly combined.
        **Output:**
            **nColumnIndex** The index of the column that was initialized.

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values
            **FE_FAIL** Unable to set data for the specified row/columns

        :type nSetID: Any
        :type nVectorID: Any
        :type title: Any
        :type category: Any
        :type nonlinear: Any
        :type nColumnIndex: Any
        """
        ...

    def AddVectorAtNodeColumnsV2(self, nSetID, nVectorID, VecX, VecY, VecZ, title, category, nonlinear,
                                 pnColumnIndices) -> Any:
        """
        **Description:**
            This method initializes columns to prepare it for creating output vectors containing vector values at nodes.

        **Input:**
            **nSetID** The ID of the Output Set.

            **nVectorID** The ID of the output vector which will be created to contain the mag-nitude of the output vectors.

            **VecX** The ID of the output vector which will be created to contain the X components of output.

            **VecY** The ID of the output vector which will be created to contain the Y components of output.
            **VecZ** The ID of the output vector which will be created to contain the Z components of output.

            **title** The title of columns being added.

            **category** General category of output: 0=Any, 1=Disp, 2=Accel, 3=Force, 4=Stress, 5=Strain, 6=Temp, others=User.

            **nonlinear** If True, this result cannot be linearly combined.

        **Output:**
            **pnColumnIndices** The indices of the columns that were initialized.

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_FAIL** Unable to set data for the specified row/columns

        :type nSetID: int
        :type nVectorID: int
        :type VecX: int
        :type VecY: int
        :type VecZ: int
        :type title: str
        :type category: int
        :type nonlinear: bool
        :type pnColumnIndices: int
        """
        ...

    def DataLocation(self, nDataType) -> Any:
        """
        **Description:**
            This method indicates whether Nodal or Elemental data is or will be in the object

        **Output:**
            **nDataType** 7=Node, 8=Element

        **Return Code:**
            **FE_FAIL** No columns have yet been defined that identify whether nodal or ele­mental data will be loaded into this object.

        :type nDataType: Any
        """
        ...

    def DataNeeded(self, nDataType, nEntitySetID) -> Any:
        """
        **Description:**
            This method defines a set of entity IDs that will be used to Populate the object.
        **Remarks/Usage:**
            This method must be called prior to calling Populate() and must specify the same data type as the Output Vectors being loaded if it is to be effective.   You can also use this method prior to calling AddConver­sionColumn() to specify Element IDs to be used in converting results during Populate().\n
        **Input:**
            **nSetID** The only available data types are 7=Node, 8=Element\n
            **nVectorID** The ID of a Set object that contains the desired entity IDs

        **Return Code:**
            **FE_BAD_TYPE** The specified data type is not valid

        :type nDataType: Any
        :type nEntitySetID: Any
        """
        ...

    def EntityValueV2(self, nSetID, nVectorID, nEntityID, pdVal) -> Any:
        """
        **WARNING:**
            This method must be used with great caution - especially with attached results files. Using it may result in reading large amounts of data for every call, and performance will be especially poor. The only appropriate time to use this is if you must dynamically query the results on small numbers of nodes/elements. In almost any other case, it will be more efficient to code an algorithm using the “spreadsheet” capability of this object.
        **Description:**
            This method returns the Output Value for a node/element in a selected Output Vector. This method replaces EntityValue. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            See WARNING Above !


        **Input:**
            **nSetID** The ID of the Output Set to query

            **nVectorID** The ID of the Output Vector to query

            **nEntityID** The ID of the Node or Element to query. If the vector contains nodal data, this must be the ID of a node. Likewise, if the vector contains elemental data, this must be the ID of an element. Vectors that con­tain element corner data are still elemental vectors, and must be spec­ified by element ID.

        **Output:**
            **pdVal** The Output Value for the selected Set, Vector and Node/Element.

        **Return Code:**
            **FE_FAIL** Unable to query the selected Output Vector - probably because it does not exist.

        :type nSetID: int
        :type nVectorID: int
        :type nEntityID: int
        :type pdVal: int
        """
        ...

    def FindColumnV2(self, nSetID, nVectorID, nColumnIndex) -> Any:
        """
        **Description:**
            This method locates a column based on the Output Set and Output Vector IDs. This method replaces FindColumn. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above".


        **Input:**
            **nSetID** The desired Output Set ID

            **nVectorID** The desired Output Vector ID

        **Output:**
            **nColumnIndex** The zero-based index of the location of the desired column

        **Return Code:**
            **FE_NOT_AVAILABLE** No columns have been defined

            **FE_FAIL** Unable to located the desired column.

        :type nSetID: int
        :type nVectorID: int
        :type nColumnIndex: int
        """
        ...

    def GetColumn(self, nColIndex, pnIDs, pdVals) -> Any:
        """
        **Description:**
            This method returns the entity IDs and values from all rows in the selected column

        **Remarks/Usage:**
            This method will only work once the object has been populated. It simply returns values for all rows that have been defined.

        **Input:**
            **nColIndex** Zero-based index of the desired column

        **Output:**
            **pnIDs** The IDs of the Node/Element\n
            **pdVals** The result values\n

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_FAIL** Unable to find data for the specified row/columns

        :type nColIndex: int
        :type pnIDs: tuple
        :type pdVals: tuple
        """
        ...

    def GetColumnAbsMax(self, nColumnIndex, nLimitToSet, pnAbsMaxID, pdAbsMaxVal) -> Any:
        """
        **Description:**
            This method returns the maximum absolute value in a column

        **Input:**
            **nColumnIndex** Zero-based index of the desired column

            **nLimitToSet** ID of Set object that contains the entities to consider when searching for min/max. Set to 0 if you want to consider all results that have been loaded in the column.

        **Output:**
            **pnAbsMaxID** ID of the Node/Element where the maximum absolute value occurs

            **pdAbsMaxVal** The maximum absolute value

        **Return Code:**
            **FE_BAD_DATA** Column index is outside of the range of available columns

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_FAIL** Unable to compute max


        :type nColumnIndex: int
        :type nLimitToSet: int
        :type pnAbsMaxID: int
        :type pdAbsMaxVal: int
        """
        ...

    def GetColumnComponents(self, nColumnIndex, pnNumComponents, pnComponentColumns) -> Any:
        """
        **Description:**
            This method returns the number of components of an Output Vector and the column index in which the component results are stored.

        **Input:**
            **nColumnIndex** The index of the column.

        **Output:**
            **pnNumComponents** The number of components.

            **pnComponentColumns** The indices of the component columns.

        **Return Code:**
            **FE_FAIL** Unable to get data for the specified row/columns

        :type nColumnIndex: int
        :type pnNumComponents: int
        :type pnComponentColumns: tuple
        """
        ...

    def GetColumnInfo(self, nColumnIndex, nDataType, nOutputType, bCentroidTotal, bCalcWarn) -> Any:
        """
        **FIY**
            This signature of this method does not match the description in the documentation

        :type nColumnIndex: Any
        :type nDataType: Any
        :type nOutputType: Any
        :type bCentroidTotal: Any
        :type bCalcWarn: Any
        """
        ...

    def GetColumnInteger(self, nColumnIndex, bIsInteger) -> Any:
        """
        **Description:**
            This method finds if an Output Vector in a specified column is integer values.

        **Input:**
            **nColumnIndex** The index of the column.

        **Output:**
            **bIsInteger** If True, this vector was initialized to store integer values

        **Return Code:**
            **FE_FAIL** Unable to get data for the specified row/columns

        :type nColumnIndex: int
        :type bIsInteger: bool
        """
        ...

    def GetColumnMinMax(self, nColumnIndex, nLimitToSet, pnMinID, pnMaxID, pdMinVal, pdMaxVal) -> Any:
        """
        **Description:**
            This method returns the minimum and maximum values in a column

        **Input:**
            **nColumnIndex** Zero-based index of the desired column

            **nLimitToSet** ID of Set object that contains the entities to consider when searching for min/max. Set to 0 if you want to consider all results that have been loaded in the column.

        **Output:**
            **pnMinID** ID of the Node/Element where the minimum value occurs

            **pnMaxID** ID of the Node/Element where the maximum value occurs

            **pdMinVal, pdMaxVal** The maximum\minimum value


        **Return Code:**
            **FE_BAD_DATA** Column index is outside of the range of available columns

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_FAIL** Unable to compute min/max


        :type nColumnIndex: Any
        :type nLimitToSet: Any
        :type pnMinID: Any
        :type pnMaxID: Any
        :type pdMinVal: Any
        :type pdMaxVal: Any
        """
        ...

    def GetColumnSum(self, nColumnIndex, nLimitToSet, pnNumVal, pdSum, pdSumSq) -> Any:
        """
        **Description:**
            This method returns values for the sum and the sum of squares in a column

        **Input:**
            **nColumnIndex** Zero-based index of the desired column

            **nLimitToSet** ID of Set object that contains the entities to consider when calculat­ing sum and sum of squares. Set to 0 if you want to consider all results that have been loaded in the column.


        **Output:**
            **pnNumVal** Number of values used to compute sum and sum of squares

            **pdSum** The sum of the column

            **pdSum** The sum of squares of the column

        **Return Code:**
            **FE_BAD_DATA** Column index is outside of the range of available columns

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_FAIL** Unable to compute sum and/or sum of squares


        :type nColumnIndex: int
        :type nLimitToSet: int
        :type pnNumVal: int
        :type pdSum: int
        :type pdSumSq: int
        """
        ...

    def GetColumnTitle(self, nColumnIndex, sTitle) -> Any:
        """
        **Description:**
            This method returns the title of the Output Vector loaded in the specified column


        **Remarks/Usage:**

        **Input:**
            **nColumnIndex** Zero-based index of the desired column

        **Output:**
            **sTitle** Title of the Output Vector in specified column

        **Return Code:**
            **FE_BAD_DATA** Column index is outside of the range of available columns

            **FE_FAIL** Unable to retrieve title.

        :type nColumnIndex: int
        :type sTitle: str
        """
        ...

    def GetColumnVectorV2(self, nColumnIndex, pnSetID, pnVectorID) -> Any:
        """
        **Description:**
            This method returns the Output Set ID and Output Vector ID of a selected column. This method replaces GetColumnVector. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above".

        **Input:**
            **nColumnIndex** Zero-based index of the desired column

        **Output:**
            **pnSetID** ID of the Output Set in the selected column

            **pnVectorID** ID of the Output Vector in the selected column

        **Return Code:**
            **FE_BAD_DATA** Column index is outside of the range of available columns

            **FE_FAIL** Unable to retrieve vector info

        :type nColumnIndex: int
        :type pnSetID: int
        :type pnVectorID: int
        """
        ...

    def GetColumns(self, nNumberOfColumns, nColIndices, pnIDs, pdVals) -> Any:
        """
        **Description:**
            This method returns the entity IDs and multiple values from the selected columns and all rows

        **Remarks/Usage:**
            This method will only work once the object has been populated. The entries in nIDs[ ] are the Node/Ele­ment IDs that directly correspond to the rows of the columns selected in nColIndices. The entries in dVals are the values from all the selected columns and all rows. Data is stored by rows so that all selected columns for the first row come before the second row, and so on. For example, dVals[0] is from the first row of the first selected column, dVals[1] is from the first row of the second selected col­umn...then dVals[nNumberOfColumns] is from the second row of the first selected column, and so on.

        **Input:**
            **nNumberOfColumns** The number of column indices in nColIndices

            **nColIndices** Zero-based indices of the desired columns

        **Output:**
            **pnIDs** The Node/Element ID from each row

            **pdVals** The result values


        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_FAIL** Unable to find data for the specified columns/rows

        :type nNumberOfColumns: int
        :type nColIndices: tuple
        :type pnIDs: tuple
        :type pdVals: tuple
        """
        ...

    def GetElemWithCornerColumnsV2(self, nColumnIndices, listcount, maxcorner, nID, centroid, c1, c2, c3, c4, c5, c6,
                                   c7, c8) -> Any:
        """
        **Description:**
            This method gets centroid and corner results of elements from given columns.

        **Input:**
            **nColumnIndices** The indices of the columns to set.

        **Output:**
            **listcount** The count of elements in the column.

            **maxcorner** The ID of the maximum corner available for this object. For exam-ple, if this object contains results on quadrilateral plates, maxcorner will typically equal 4, since results are only available for corners 1,2,3, and 4.

            **nID** The IDs of the elements.

            **centroid** The results at the element centroid associated with the corresponding node/element in the ID array.

            **c1, c2, c3, c4, c5, c6,c7, c8** The results at the element corners associated with the corresponding node/element in the ID array. Some elements have missing corners. For example, Tetrahedral results are stored on corners 1,2,3 and 5. Wedge results are stored on 1,2,3 and 5,6,7.

        **Return Code:**
            **FE_FAIL** Unable to get data for the specified row/columns

        :type nColumnIndices: tuple
        :type listcount: int
        :type maxcorner: int
        :type nID: tuple
        :type centroid: int
        :type c1: tuple
        :type c2: tuple
        :type c3: tuple
        :type c4: tuple
        :type c5: tuple
        :type c6: tuple
        :type c7: tuple
        :type c8: tuple
        """
        ...

    def GetElemWithCornerSetV2(self, nColumnIndices, nElemSetID, maxcorner, centroid, c1, c2, c3, c4, c5, c6, c7,
                               c8) -> Any:
        """
         **FIY:**
            **centroid** This signature of this method does not match the description in the documentation **centroid**
        **Description:**
            This method retrieves the centroid and corner results stored in an object that contains elemental data with corners. Results are retrieved for all elements specified in the Set.

        **Input:**
            **nColumnIndices** The indices of the columns to get.

            **nElemSetID** The ID of the set of elements.

        **Output:**
            **maxcorner** The ID of the maximum corner available for this object. For exam-ple, if this object contains results on quadrilateral plates, maxcorner will typically equal 4, since results are only available for corners 1,2,3, and 4.

            **centroid**

            **c1, c2, c3, c4, c5, c6, c7, c8** The results at the element corners associated with the corresponding node/element in the Set. Some elements have missing corners. For example, Tetrahedral results are stored on corners 1,2,3 and 5. Wedge results are stored on 1,2,3 and 5,6,7.

        **Return Code:**
            **FE_FAIL** Unable to get data.

        :type nColumnIndices: int
        :type nElemSetID: int
        :type maxcorner: int
        :type centroid: Any
        :type c1: tuple
        :type c2: tuple
        :type c3: tuple
        :type c4: tuple
        :type c5: tuple
        :type c6: tuple
        :type c7: tuple
        :type c8: tuple
        """
        ...

    def GetInRow(self, nRowIndex, nColumnIndex, pnID, pdVal) -> Any:
        """
        **Description:**
            This method returns the entity ID and value from the selected row and column

        **Remarks/Usage:**
            This method will only work once the object has been populated.

        **Input:**
            **nRowIndex** Zero-based index of the desired row

            **nColumnIndex** Zero-based index of the desired column

        **Output:**
            **pnID** The ID of the Node/Element

            **pdVal** The result value

        **Return Code:**
            **FE_BAD_DATA** Either Row or Column index is outside of the range of available rows/columns

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_FAIL** Unable to find data for the specified row/column


        :type nRowIndex: int
        :type nColumnIndex: int
        :type pnID: int
        :type pdVal: int
        """
        ...

    def GetModel(self, nModelID) -> Any:
        """
        **Description:**
            This method returns the identifier of the model being used by the object.

        **Remarks/Usage:**
            When the object is created, nModelID is set to the current/active model.

        **Output:**
            **nModelID** Model identifier

        :type nModelID: int
        """
        ...

    def GetMultipleInRow(self, nRowIndex, nNumberOfColumns, nColumnIndices, pnID, pdVals) -> Any:
        """
        **Description:**
            This method returns the entity ID and multiple values from the selected row and columns

        **Remarks/Usage:**
            This method will only work once the object has been populated.

        **Input:**
            **nRowIndex** Zero-based index of the desired row

            **nNumberOfColumns** The number of entries in nColumnIndices

            **nColumnIndices** Zero-based indices of the desired columns

        **Output:**
            **pnID** The ID of the Node/Element

            **pdVals** The result values, in the same order as nColumnIndices

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_INVALID** Unable to find data for the specified row/columns


        :type nRowIndex: int
        :type nNumberOfColumns: int
        :type nColumnIndices: tuple
        :type pnID: int
        :type pdVals: tuple
        """
        ...

    def GetRow(self, nRowIndex, pnID, pdVals) -> Any:
        """
        **Description:**
            This method returns the entity ID and multiple values from the selected row and all columns

        **Remarks/Usage:**
            This method will only work once the object has been populated. It is similar to GetMultipleInRow( ), except that it simply returns values for all columns that have been defined. You can use the column index values that were returned when columns were added as an index into the returned value array

        **Input:**
            **nRowIndex** Zero-based index of the desired row

        **Output:**
            **pnID** The ID of the Node/Element

            **pdVals** The result values

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_FAIL** Unable to find data for the specified row/columns


        :type nRowIndex: int
        :type pnID: int
        :type pdVals: tuple
        """
        ...

    def GetRowByID(self, nID, pdVals) -> Any:
        """
        **Description:**
            This method returns multiple values from the selected Node/Element and all columns

        **Remarks/Usage:**
            This method will only work once the object has been populated. Rather than using the rowIndex, this method directly looks for a specific Node/Element ID. It is similar to GetMultipleInRow( ), except that it simply returns values for all columns that have been defined. You can use the column index values that were returned when columns were added as an index into the returned value array

        **Input:**
            **nID** The ID of the Node/Element

        **Output:**
            **pdVals** The result values

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_FAIL** Unable to find data for the specified Node/Element


        :type nID: int
        :type pdVals: tuple
        """
        ...

    def GetRows(self, nNumberOfRows, nRowIndices, pnIDs, pdVals) -> Any:
        """
        **Description:**
            This method returns the entity IDs and multiple values from the selected rows and all columns

        **Remarks/Usage:**
            This method will only work once the object has been populated. It is just like GetRow( ), except that it will return data from multiple selected rows. The entries in nIDs[ ] are the Node/Element IDs that directly correspond to the rows selected in nRowIndices. The entries in dVals are the values from all the selected rows and all columns. Data is stored by row so that all columns for the first selected row come before the second row, and so on.  For example, dVals[0] is from the first column of the first selected row, dVals[1] is from the second column of the first row ...then dVals[nNumberOfColumns] is from the first column of the second row, and so on.

        **Input:**
            **nNumberOfRows** The number of row indices in nRowIndices

            **nRowIndices** Zero-based indices of the desired rows

        **Output:**
            **pnIDs** The IDs of the Node/Element from each selected row

            **pdVals** The result values

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_FAIL** Unable to find data for the specified row/columns

        :type nNumberOfRows: Any
        :type nRowIndices: Any
        :type pnIDs: Any
        :type pdVals: Any
        """
        ...

    def GetRowsAndColumns(self, nNumberOfRows, nRowIndices, nNumberOfColumns, nColIndices, pnIDs, pdVals,
                          pbAllExist) -> Any:
        """
        **Description:**
            This method returns the entity IDs and multiple values from selected rows and columns

        **Remarks/Usage:**
            This method will only work once the object has been populated. It is just like GetRow( ), except that it will return data from multiple selected rows and columns. The entries in nIDs[ ] are the Node/Ele­ment IDs that directly correspond to the rows selected in nRowIndices. The entries in dVals are the values from all the selected rows and selected columns. Data is stored by row so that all selected columns for the first selected row come before the second row, and so on. For example, dVals[0] is from the first column of the first selected row, dVals[1] is from the second column of the first row...then dVals[nNumberOfColumns] is from the first column of the second row, and so on.

        **Input:**
            **nNumberOfRows** The number of row indices in nRowIndices

            **nRowIndices** Zero-based indices of the desired rows

            **nNumberOfColumns** The number of column indices in nColIndices

            **nColIndices** Zero-based indices of the desired columns

        **Output:**
            **pnIDs** The IDs of the Node/Element from each selected row

            **pdVals** The result values

            **pbAllExist** When True, all rows and columns have values. When False, at least one value in the selected columns and rows is missing.

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_INVALID** Object has not yet been populated. This method is only avail­able after results have been loaded.

            **FE_FAIL** Unable to find data for the specified row/columns


        :type nNumberOfRows: int
        :type nRowIndices: tuple[int]
        :type nNumberOfColumns: int
        :type nColIndices: tuple[int]
        :type pnIDs: tuple[int]
        :type pdVals: tuple[int]
        :type pbAllExist: bool
        """
        ...

    def GetRowsAndColumnsByID(self, nEntitySetID, nNumberOfColumns, nColIndices, pdVals, pbAllExist) -> Any:
        """
        **Description:**
            This method returns the values from selected columns for the selected entities.

        **Remarks/Usage:**
             This method will only work once the object has been populated. It is just like GetRowByID( ),
             except that it will return data from multiple selected rows using selected columns. The entries in
             dVals are the values from all the selected rows and selected columns. nNumberOfRows is the number
             of IDs in nEn­titySetID, and IDs/rows are always in increasing order from smallest to largest,
             no matter how the Set Object was created. Data is stored by row so that selected columns for the first
             selected row come before the second row, and so on. For example, dVals[0] is from the first column of
             the first selected row, dVals[1] is from the second column of the first row...then dVals[nNumberOfColumns]
             is from the first column of the second row, and so on.

        **Input:**
            **nEntitySetID** The ID of a Set object that contains the Node/Element IDs that are desired.

            **nNumberOfColumns** The number of column indices in nColIndices

            **nColIndices** Zero-based indices of the desired columns

        **Output:**
            **pdVals** The result values

            **pbAllExist** When True, all rows and columns have values. When False, at least one value in the selected columns and rows is missing.

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_FAIL** Unable to find data for the specified row/columns

        :type nEntitySetID: int
        :type nNumberOfColumns: int
        :type nColIndices: tuple[int]
        :type pdVals: tuple[int]
        :type pbAllExist: bool
        """
        ...

    def GetRowsByID(self, nEntitySetID, pdVals) -> Any:
        """
        **Description:**
            This method returns the values from all columns for the selected entities.

        **Remarks/Usage:**
            This method will only work once the object has been populated. It is just like GetRowByID( ),
            except that it will return data from multiple selected rows. The entries in dVals are the values
            from all the selected rows and all columns. nNumberOfRows is the number of IDs in nEntitySetID, and
            IDs/rows are always in increasing order from smallest to largest, no matter how the Set Object was created.
            Data is stored by row so that all columns for the first selected row come before the second row, and so on.
            For example, dVals[0] is from the first column of the first selected row, dVals[1] is from the second
            col­umn of the first row ...then dVals[nNumberOfColumns] is from the first column of the second row, and so on.

        **Input:**
            **nEntitySetID** The ID of a Set object that contains the Node/Element IDs that are desired.

        **Output:**
            **pdVals** The result values

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_FAIL** Unable to find data for the specified row/columns

        :type nEntitySetID: int
        :type pdVals: tuple[int]
        """
        ...

    def GetScalarAtBeamColumnsV2(self, nColumnIndices, listcount, nID, ValA, ValB) -> Any:
        """
        **Description:**
            This method gets Beam output vectors for EndA and EndB containing a single scalar value.

        **Input:**
            **nColumnIndices** The indices of the columns to get.

        **Output:**
            **listcount** The count of elements in the column.

            **nID** The IDs of the elements.

            **ValA** The EndA output values associated with the corresponding element IDs array.

            **ValB** The EndB output values associated with the corresponding element IDs array.

        **Return Code:**

            **FE_FAIL** Unable to get data for the specified row/columns

        :type nColumnIndices: tuple[int]
        :type listcount: int
        :type nID: tuple[int]
        :type ValA: float
        :type ValB: float
        """
        ...

    def GetScalarAtBeamSetV2(self, nColumnIndices, nElemSetID, ValA, ValB) -> Any:
        """
        **Description:**
            This method gets scalar data of a given set of beam elements.

        **Remarks/Usage:**

        **Input:**
            **nColumnIndices** The indices of the columns to get.

            **nElemSetID** The ID of the set of elements.

        **Output:**
            **ValA** The EndA values associated with the corresponding element in the Set.

            **ValB** The EndB values associated with the corresponding element in the Set.

        **Return Code:**

            **FE_FAIL** Unable to get data.



        :type nColumnIndices: Any
        :type nElemSetID: Any
        :type ValA: Any
        :type ValB: Any
        """
        ...

    def GetScalarAtElemColumnV2(self, nColumnIndex, listcount, nID, value) -> Any:
        """
        **Description:**
            This method returns the entity IDs and values from all rows in the selected column.

        **Input:**
            **nColumnIndex** The index of the column.

        **Output:**
            **listcount** The count of nodes in the column.

            **nID** The IDs of the Node/Element.

            **value** The results values.

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_FAIL** Unable to get data for the specified row/columns


        :type nColumnIndex: int
        :type listcount: int
        :type nID: tuple[int]
        :type value: tuple[float]
        """
        ...

    def GetScalarAtElemSetV2(self, nColumnIndex, nElemSetID, value) -> Any:
        """
        **Description:**
            This method gets scalar data of a given set of elements.


        **Input:**
            **nColumnIndex** The index of the column to get.
            **nElemSetID** The ID of the set of elements.

        **Output:**
            **value** The elemental results value of the nodes in the set.

        **Return Code:**

            **FE_FAIL** Unable to get data.

        :type nColumnIndex: int
        :type nElemSetID: int
        :type value: tuple[float]
        """
        ...

    def GetScalarAtNodeColumnV2(self, nColumnIndex, listcount, nID, value) -> Any:
        """
         **Description:**
            This method returns the entity IDs and values from all rows in the selected column.

        **Input:**
            **nColumnIndex** The index of the column.

        **Output:**
            **listcount** The count of nodes in the column.

            **nID** The IDs of the Node/Element.

            **value** The results values.

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_FAIL** Unable to get data for the specified row/columns

        :type nColumnIndex: int
        :type listcount: int
        :type nID: tuple[int]
        :type value: tuple[float]
        """
        ...

    def GetScalarAtNodeSetV2(self, nColumnIndex, nNodeSetID, value) -> Any:
        """
        **Description:**
            This method gets scalar data of a given set of nodes.

        **Input:**
            **nColumnIndex** The index of the column to get.

            **nNodeSetID** The ID of the set of nodes.
        **Output:**
            **value** The nodal results value of the nodes in the set.

        **Return Code:**

            **FE_FAIL** Unable to get data.

        :type nColumnIndex: int
        :type nNodeSetID: int
        :type value: tuple[int]
        """
        ...

    def GetValue(self, nID, nColumnIndex, pdVal) -> Any:
        """
         **Description:**
            This method returns the value from the selected column for the specified Node/Element

        **Remarks/Usage:**
            This method will only work once the object has been populated.

        **Input:**
            **nID** The ID of the Node/Element desired

            **nColumnIndex** Zero-based index of the desired column

        **Output:**
            **pdVal** The result value

        **Return Code:**
            **FE_NO_MEMORY** Column index is outside of the range of available columns

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_FAIL** Unable to find data for the specified ID

        :type nID: int
        :type nColumnIndex: int
        :type pdVal: float
        """
        ...

    def GetVectorAtNodeColumnsV2(self, nColumnIndices, listcount, nID, total, x, y, z) -> Any:
        """
        **Description:**
            This method returns the entity IDs and the components of the results stored from all rows in the selected column.

        **Input:**
            **nColumnIndices** The indices of the columns.

        **Output:**
            **listcount** The count of nodes in the column.

            **nID** The IDs of the Node/Element.

            **total** The total results values.

            **x, y, z** The component results values.
        **Return Code:**
            **FE_FAIL** Unable to get data for the specified row/columns

        :type nColumnIndices: tuple[int]
        :type listcount: int
        :type nID: tuple[int]
        :type total: tuple[float]
        :type x: tuple[float]
        :type y: tuple[float]
        :type z: tuple[float]
        """
        ...

    def GetVectorAtNodeSetV2(self, nColumnIndices, nNodeSetID, total, x, y, z) -> Any:
        """
        **Description:**
            This method gets vector data of a given set of nodes.

        **Input:**
            **nColumnIndices** The indices of the columns to get.

            **nNodeSetID** The ID of the set of nodes.

        **Output:**
            **total** The total magnitude values associated with the corresponding ele­ment in the Set.

            **x, y, z** The component values associated with the corresponding element in the Set.

        **Return Code:**
            **FE_FAIL** Unable to get data.

        :type nColumnIndices: tuple[int]
        :type nNodeSetID: int
        :type total: tuple[float]
        :type x: tuple[float]
        :type y: tuple[float]
        :type z: tuple[float]
        """
        ...

    def IsAPIColumn(self, nColumnIndex) -> Any:
        """
        **Description:**
            This method identifies whether a column is an normal API column or one that was addded for internal computations.

        **Remarks/Usage:**
            In some cases, especially with attached result files, FEMAP must create additional columns to compute the results that were requested. These columns will return FE_FAIL from this method.

        **Input:**
            **nColumnIndex** Zero-based index of the desired column

        **Return Code:**
            **FE_BAD_DATA** Column index is outside of the range of available columns

            **FE_FAIL** Not an API Column

        :type nColumnIndex: Any
        """
        ...

    def IsPopulated(self) -> Any:
        """
        **Description:**
            This method indicates whether Populate( ) has already been called.

        **Return Code:**
            **FE_FAIL** The object has not been populated.

        """
        ...

    def Next(self, nColumnIndex, pnID, pdVal) -> Any:
        """
        **Description:**
            This method returns the entityID and value from the next row in a selected column

        **Remarks/Usage:**
            This method will only work once the object has been populated. You must call Reset() prior to calling this
            function so that repeated calls will start at the first row. Changing nColumnIndex will not automati­cally
            reset back to the first row, it will continue from the location of the previous call to Next().

        **Input:**
            **nColumnIndex** Zero-based index of the desired column

        **Output:**
            **pnID** The ID of the Node/Element from the next row

            **pdVal** The result value from the selected column in the next row.

        **Return Code:**
            **FE_BAD_DATA** Column index is outside of the range of available columns

            **FE_INVALID** Object has not yet been populated. This method is only available after results have been loaded.

            **FE_FAIL** You have reached the end of available rows.

        :type nColumnIndex: int
        :type pnID: int
        :type pdVal: int
        """
        ...

    def NextSet(self, nExistState, nLocateOption) -> Any:
        """
        **Description:**
            This method returns the ID of the next available Output Set

        **Input:**
            **nExistState** 0=ID of Next Existing Output Set, 1=ID of next NonExisting Output Set

            **nLocateOption** 1=After, 2=Before, 3=After or Equal, 4=Before or Equal. To incre­ment from smallest to
            largest ID use 1. To go from largest to smallest use 2. Options 3 and 4 are normally only used for finding
            the next NonExisting Output Set - care must be taken with these options to avoid infinite loops.

        **Return Code:**
            **Any other number** The ID of the Existing/NonExisting Output Set found.

            **FE_FAIL** No more Output Set IDs are found given the specified options.

        :type nExistState: int
        :type nLocateOption: int
        """
        ...

    def NextSetReset(self) -> Any:
        """
        **Description:**
            This method resets the next pointer so that the next call to NextSet will return the first available Output Set.
        """
        ...

    def NextStudy(self, nExistState, nLocateOption) -> Any:
        """
        **Description:**
            This method returns the next Analysis Study ID.

        **Input:**
            **nExistState** 0=ID of Next Existing Analysis Study, 1=ID of next NonExisting Analysis Study

            **nLocateOption** 1=After, 2=Before, 3=After or Equal, 4=Before or Equal. To incre­ment from smallest to
            largest ID use 1. To go from largest to smallest use 2. Options 3 and 4 are normally only used for finding
            the next NonExisting Analysis Study - care must be taken with these options to avoid infinite loops.

        **Return Code:**
            **Any other number** The ID of the Existing/NonExisting Analysis Study found.

            **FE_FAIL** No more Analysis Study IDs are found given the specified options.

        :type nExistState: int
        :type nLocateOption: int
        """
        ...

    def NextStudyReset(self) -> Any:
        """
        **Description:**
            This method resets the next pointer so that the next call to NextStudy will return the first available Anal­ysis Study.

        **Return Code:**
            **Number of Studies** The number of Studies
        """
        ...

    def NextVectorResetV2(self, nSetID) -> Any:
        """
        **FIY:**
            **nSetID** This signature of this method does not match the description in the documentation **centroid**
        **Description:**
            This method resets the next pointer so that the next call to NextVector will return the first available
            Out­put Vector in the Output Set. This method replaces NextVectorReset. For more information see, Section
            2.4, "Working with Output in FEMAP 2020.1 and above".

        """
        ...

    def NextVectorV2(self, nSetID, nExistState, nLocateOption) -> Any:
        """
        **Description:**
            This method returns the ID of the next available Output Vector in a selected Output Set. This method
            replaces NextVector. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".

        **Input:**
            **nSetID** The ID of the Output Set to query for Output Vectors

            **nExistState** 0=ID of Next Existing Output Set, 1=ID of next Non-Existing Out­put Set

            **nLocateOption** 1=After, 2=Before, 3=After or Equal, 4=Before or Equal. To incre­ment from smallest to
            largest ID use 1. To go from largest to smallest use 2. Options 3 and 4 are normally only used for finding
            the next Non-Existing Output Set - care must be taken with these options to avoid infinite loops.

        :type nSetID: int
        :type nExistState: int
        :type nLocateOption: int
        """
        ...

    def NonExistingUserVectorV2(self, nSetID) -> Any:
        """
        **Description:**
            This method an output vector ID of the next non-existing vector in the user created output vector block. Output Set.

        **Input:**
            **nSetID** The ID of the Output Set to query.

        **Return Code:**
            **FE_FAIL** Unable to return next non-existing vector ID.

        :type nSetID: int
        """
        ...

    def NumberOfColumns(self) -> Any:
        """
        **Description:**
            This method indicates the number of columns that have been defined.

        **Return Code:**
            **Number** The number of columns of data that have been defined.

        """
        ...

    def NumberOfRows(self) -> Any:
        """
        **Description:**
            This method indicates the number of rows that have been defined.
        **Return Code:**
            **Number:** The number of rows of data that have been loaded. Prior to calling Populate() this will be 0
        """
        ...

    def NumberOfSets(self) -> Any:
        """
        **Description:**
            This method returns the number of output sets that are currently available.\n
        **Return Code:** The number of available Sets\n

        """
        ...

    def NumberOfStudies(self) -> Any:
        """
        **Description:**
            This method returns the total number of Analysis Studies in the model.

        **Return Code:**
            **Number of Studies** The number of Studies

        """
        ...

    def Populate(self) -> Any:
        """
        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This function resets the next pointer so that the next call to next will return the first entry in a sort object.

        **Remarks/Usage:**
            To find the first ID in a set, you must use the Reset method before calling Next. If you have just created a set and have not used Next, it is already reset.
        """
        ...

    def Save(self) -> Any:
        """
        **Description:**
            This method saves the data that is filled in the columns and rows. This method should be used after modifying or creating any data that is added to the table.

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_FAIL** Unable to set data for the specified row/columns

        """
        ...

    def SaveColumn(self, nColumnIndex) -> Any:
        """
        **Description:**
            This method saves the data that is filled in a specific columns.

        **Remarks/Usage:**

        **Input:**
            **nColumnIndex** The index of the column to save.

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_FAIL** Unable to set data for the specified row/columns

        :type nColumnIndex: int
        """
        ...

    def SendToDataTable(self) -> Any:
        """
        **Description:**
            This method sends the contents of a populated Results Browsing Object to the Data Table. The Data Table must visible and be unlocked

        **Return Code:**

            **FE_SECURITY** Results Browsing Object has not been populated or Data Table is not visible.

            **FE_FAIL** Results Browsing Object has not been populated or Data Table is not visible.

        """
        ...

    def SetColumn(self, nColIndex, nNumberOfRows, nIDs, dVals) -> Any:
        """
        **Description:**
            This method fills a column with data.

        **Remarks/Usage:**
            The Save method must be used after SetColumn to put results.

        **Input:**
            **nColIndex** The column index to fill.

            **nNumberOfRows** The number of rows that will be filled.

            **nIDs** The IDs of the nodes/elements associated with the filled data.

            **dVals** The values associated with each of the node/element IDs accord­ingly.

        **Return Code:**

            **FE_FAIL** Unable to fill column with data.

        :type nColIndex: Any
        :type nNumberOfRows: Any
        :type nIDs: Any
        :type dVals: Any
        """
        ...

    def SetColumnComponents(self, nColumnIndex, nNumComponents, nComponentColumns) -> Any:
        """
        **Description:**
            This method sets the number of components of an Output Vector and the column index in which the component results are stored.

        **Remarks/Usage:**
            SetColumnsComponent is an identical method to SetColumnComponents, thus functions in the same manner, but if possible, it is recommended to use SetColumnComponents.

        **Input:**
            **nColumnIndex** The index of the column.

            **nNumComponents** The number of components.

            **nComponentColumns** The indices of the component columns.

        **Return Code:**

            **FE_FAIL** Unable to set data for the specified row/columns

        :type nColumnIndex: int
        :type nNumComponents: int
        :type nComponentColumns: tuple[int]
        """
        ...

    def SetColumnGlobalPly(self, nColumnIndex, nGlobalPlyID) -> Any:
        """
        **Description:**
            This method specifies that a column be populated with data from a Global Ply rather than simply data from a single Output Vector.

        **Remarks/Usage:**
            This method is used for laminate ply results and must be called prior to calling Populate(). If you simply
            want results from a specific ply on all selected elements, you do not need to use this method. However,
            if you want the column to be filled with data from a Global Ply that is represented by various ply num­bers
            then use this method to choose that Global Ply.

        **Input:**
            **nColumnIndex** The index of a column that was created by AddColumn( )

            **nGlobalPlyID** The ID of a Global Ply or 0=Bottom Ply, or -2=Top Ply

        **Return Code:**
            **FE_INVALID** The object has already been populated with data.

            **FE_BAD_DATA** An invalid value has been specified for nColumnIndex


        :type nColumnIndex: Any
        :type nGlobalPlyID: Any
        """
        ...

    def SetColumnInfo(self, nColumnIndex, nDataType, nOutputType, bCentroidTotal, bNonlinear) -> Any:
        """
        **FIY**
            **nOutputType** This signature of this method does not match the description in the documentation **centroid**
        **Description:**
            This method set information of output vector stored in a column.

        **Input:**
            **nColumnIndex** The index of to set.

            **nDataType** The data type of the entity. FT_NODE for nodal data or FT_ELEM for elemental data.

            **bCentroidTotal** If True, this vector has centroidal or nodal output.

            **bNonlinear**  If True, this result cannot be linearly combined.

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_FAIL** Unable to set data for the specified row/columns

        :type nColumnIndex: int
        :type nDataType: int
        :type nOutputType: int
        :type bCentroidTotal: bool
        :type bNonlinear: bool
        """
        ...

    def SetColumnInteger(self, nColumnIndex, bIsInteger) -> Any:
        """
        **Description:**
            This method finds if an Output Vector in a specified column is integer values.

        **Remarks/Usage:**

        **Input:**
            **nColumnIndex** The index of the column.

            **bIsInteger** If True, this vector will be initialized to store integer values

        **Return Code:**
            **FE_FAIL** Unable to set data for the specified row/columns

        :type nColumnIndex: int
        :type bIsInteger: bool
        """
        ...

    def SetColumnTitle(self, nColumnIndex, title) -> Any:
        """
        **Description:**
            This method sets the title of a column for naming the Output Vector.

        **Input:**
            **nColumnIndex** The index of the column.

            **title** The title to name the Output Vector.

        **Return Code:**

            **FE_FAIL** Unable to set data for the specified row/columns

        :type nColumnIndex: int
        :type title: str
        """
        ...

    def SetColumnVectorV2(self, nColumnIndex, nSetID, nVectorID) -> Any:
        """
        **Description:**
            This method sets the Output Vector ID for a specific column of in an Output Set.


        **Input:**
            **nColumnIndex** The index of the column.

            **nSetID** The ID of the Output Set.

            **nVectorID** The ID of the Output Vector to set.

        **Return Code:**

            **FE_FAIL** Unable to get data for the specified row/columns

        :type nColumnIndex: int
        :type nSetID: int
        :type nVectorID: int
        """
        ...

    def SetColumns(self, nNumberOfColumns, nColIndices, nNumberOfRows, nIDs, dVals) -> Any:
        """
        **Description:**
            This method fills a column with data.

        **Remarks/Usage:**
            The data for nIDs is stored in 1-dimensional array, while the data for dVals is stored in a separate 1-dimensional array using the following format:
            (Column0,Row0), (Column1,Row0)…(ColumnN,Row0); (Column0,Row1), (Column1,Row1)… (ColumnN,Row1);...; (Column0,RowM), (Column1,RowM)…(ColumnN,RowM)
            In addition, the Save method must be used after SetColumns to put results.

        **Input:**
            **nNumberOfColumns** The number of columns to be filled.

            **nColIndices** An index of the columns that will be filled.

            **nNumberOfRows** The number of rows that will be filled.

            **nIDs** The IDs of the nodes/elements associated with the filled data.

            **dVals** The values associated with each of the node/element IDs accord­ingly.

        **Return Code:**

            **FE_FAIL** Unable to fill columns with data.

        :type nNumberOfColumns: int
        :type nColIndices: int
        :type nNumberOfRows: int
        :type nIDs: tuple[int]
        :type dVals: tuple[int]
        """
        ...

    def SetColumnsComponent(self, nColumnIndex, nNumComponents, nComponentColumns) -> Any:
        """
        **Description:**
            This method sets the number of components of an Output Vector and the column index in which the component results are stored.

        **Remarks/Usage:**
            SetColumnsComponent is an identical method to SetColumnComponents, thus functions in the same manner, but if possible, it is recommended to use SetColumnComponents.

        **Input:**
            **nColumnIndex** The index of the column.

            **nNumComponents** The number of components.

            **nComponentColumns** The indices of the component columns.

        **Return Code:**

            **FE_FAIL** Unable to set data for the specified row/columns

        :type nColumnIndex: int
        :type nNumComponents: int
        :type nComponentColumns: tuple[int]
        """
        ...

    def SetComplexOptions(self, bExpandComplex, dComplexPhase) -> Any:
        """
        **Description:**
            This method defines parameters to expand complex results when they are populated.

        **Input:**
            **bExpandComplex** If True, complex results will be expanded during Populate using the value specified for dComplexPhase

            **dComplexPhase** Phase value to use during complex expansion

        **Return Code:**

            **FE_FAIL** No Output Sets were found.

        :type bExpandComplex: bool
        :type dComplexPhase: float
        """
        ...

    def SetCreate(self, nSetID, sTitle, nStudyID, nAnalysisProgram, nAnalysisType, dSetValue) -> Any:
        """
        **Description:**
            This method creates a new Output Set.


        **Input:**
            **nSetID** The ID of the Output Set to create.

            **sTitle** The title of the Output Set.

            **nStudyID** The ID of the Study the Output Set is associated with.

            **nAnalysisProgram** The analysis program of the Output Set. 1=FEMAP Generated, 2=PAL, 3=PAL 2, 4=MSC/NASTRAN,
            5=ANSYS, 6=STAR­DYNE, 7=COSMOS, 8=PATRAN, 9=FEMAP Neutral, 10=ALGOR, 11=SSS/NASTRAN, 12=Comma Separated, 13=UAI/NASTRAN,
            14=Cosmic NASTRAN, 15=STAAD, 16=ABAQUS, 17=WECAN, 18=MTAB/SAP, 19=CDA/Sprint, 20=CAEFEM, 21=I-DEAS, 22=ME/NASTRAN,
            26=CSA/NASTRAN, 28=CFDe­sign, 31=LS-DYNA, 32=MARC, 33=SINDA, 38=NX Nastran.

            **nAnalysisType** The analysis type of the Output Set. 0=Unknown, 1=Static, 2=Nor­mal Modes/ Eigenvalue,
            3=Transient Dynamic/Time History, 4=Fre-quency/Harmonic Response, 5=Response Spectrum, 6=Ran-dom Response,
            7=Buckling, 8=Design Opt, 9=Explicit Transient Dynam­ics, 10=Nonlinear Static, 11=Nonlinear Buckling,
            12=Nonlinear Transient, 13=Implicit Transient Dynamics, 17=Fatigue, 19=Com­putational Fluid Dynamics,
            20=Steady-State Heat Transfer, 21=Transient Heat Transfer, 22=Advanced Nonlinear Static, 23=Advanced Nonlinear
            Transient, 24=Advanced Nonlinear Explicit, 25=Static Aero-elasticity, 26=Aerodynamic Flutter.

            **dSetValue** The output set value. For modal analyses, the modal frequency. For any transient or nonlinear
            analysis, the time value at this step. For Buckling, the eigenvalue. For static analysis = 0.0

        **Return Code:**

            **FE_FAIL** Output Set was not created.

        :type nSetID: int
        :type sTitle: str
        :type nStudyID: int
        :type nAnalysisProgram: int
        :type nAnalysisType: int
        :type dSetValue: float
        """
        ...

    def SetElemWithCornerColumnsV2(self, nColumnIndices, listcount, maxcorner, nID, centroid, c1, c2, c3, c4, c5, c6,
                                   c7, c8) -> Any:
        """
        **Description:**
            This method sets centroid and corner results of elements of given columns.


        **Input:**
            **nColumnIndices** The indices of the columns to set.

            **listcount** The count of elements in the column.

            **maxcorner** The ID of the maximum corner available for this object. For exam-ple, if this object
            contains results on quadrilateral plates, maxcorner will typically equal 4, since results are only available for corners 1,2,3, and 4.

            **nID** The IDs of the elements.

            **centroid** The results at the element centroid associated with the corresponding node/element in the ID array.

            **c1, c2, c3, c4, c5, c6, c7, c8** The results at the element corners associated with the corresponding
            node/element in the ID array. Some elements have missing corners. For example, Tetrahedral results are stored
            on corners 1,2,3 and 5. Wedge results are stored on 1,2,3 and 5,6,7.

        **Return Code:**

            **FE_FAIL** Unable to set data for the specified row/columns

        :type nColumnIndices: tuple[int]
        :type listcount: int
        :type maxcorner: int
        :type nID: tuple[int]
        :type centroid: float
        :type c1: tuple[float]
        :type c2: tuple[float]
        :type c3: tuple[float]
        :type c4: tuple[float]
        :type c5: tuple[float]
        :type c6: tuple[float]
        :type c7: tuple[float]
        :type c8: tuple[float]
        """
        ...

    def SetEngrShearStrain(self, bEngrShearStrain) -> Any:
        """
        **Description:**
            This method sets the assumption for shear strain

        **Remarks/Usage:**
            This method is not normally required, as defaults are set as preferences, but if it is used, it must be called prior to calling Populate().

        **Input:**
            **bEngrShearStrain** True=Engineering Shear Strain, False = Actual Shear Strain

        **Return Code:**
            **FE_INVALID** The object has already been populated with data.

        :type bEngrShearStrain: bool
        """
        ...

    def SetExists(self, nSetID) -> Any:
        """
        **Description:**
            This method determines if a selected Output Set exists.

        **Input:**
            **nSetID** The ID of the Output Set to query.

        **Return Code:**

            **FE_FAIL** The Output Set does not exist.

        :type nSetID: int
        """
        ...

    def SetHasVectorsInDB(self, nSetID) -> Any:
        """
        **Description:**
            This method indicates whether an Output Set contains Output Vectors that are in the FEMAP Database.

        **Remarks/Usage:**
            If this method returns FE_OK, then it contains Output Vectors located in the FEMAP Database. Even Output
            Sets that are located in an attached external file can contain certain Output Vectors in the FEMAP Database,
            if one of the FEMAP commands (like Model->Output->Process) was used to create additional Output Vectors in that Output Set.

        **Input:**
            **nSetID** The ID of the Output Set to query.

        **Return Code:**

            **FE_FAIL** There are no Output Vectors in the FEMAP Database for this Set

        :type nSetID: int
        """
        ...

    def SetInRow(self, nRowIndex, nColumnIndex, dVal) -> Any:
        """
        **Description:**
            This method sets the value in the selected column for the specified row

        **Remarks/Usage:**
            This method allows you to update the value in a row/column. It is intended to be used so that you can use the data in other columns, combined with data and logic in your program to fill values in empty col­umns.

        **Input:**
            **nRowIndex** Zero-based index of the desired row

            **nColumnIndex** Zero-based index of the desired column

            **dVal** The value to set in the row and column


        **Return Code:**
            **FE_BAD_DATA** Either Row or Column index is outside of the range of available rows/columns

            **FE_FAIL** Unable to find data for the specified ID

        :type nRowIndex: int
        :type nColumnIndex: int
        :type dVal: float
        """
        ...

    def SetInfo(self, nSetID, pnAnalysisProgram, pnAnalysisType, pdSetValue) -> Any:
        """
        **Description:**
            This method returns information about a selected Output Set

        **Input:**
            **nSetID** The ID of the Output Set to query.

        **Output:**
            **pnAnalysisProgram** Refer to the “program” property of the Output Set object

            **pnAnalysisType** Refer to the “analysis” property of the Output Set object

            **pdSetValue** Refer to the “value” property of the Output Set object

        **Return Code:**

            **FE_FAIL** Unable to retrieve information about selected set - most likely the set does not exist.

        :type nSetID: int
        :type pnAnalysisProgram: int
        :type pnAnalysisType: int
        :type pdSetValue: float
        """
        ...

    def SetLineTransform(self, nTransformTo, nCSysID) -> Any:
        """
        **Description:**
            This method defines parameters to transform nodal results when they are populated.

        **Remarks/Usage:**
            This method must be called prior to calling Populate(), but is not required if you do not want to trans­form results.

        **Input:**
            **nTransformTo** 0=No Transform, results in Global Rectangular, 8=Trasform to line CSys.

            **nCSysID** ID of Coordinate System to transform into when nTransformTo=1

        **Return Code:**
            **FE_NOT_EXIST** The coordinate system specified by nCSysID does not exist

            **FE_INVALID** The object has already been populated with data.

            **FE_BAD_DATA** An invalid value has been specified for nTransformTo

        :type nTransformTo: int
        :type nCSysID: int
        """
        ...

    def SetLocation(self, nSetID, pnSetLocation) -> Any:
        """
        **Description:**
            This method identifies whether data for the Output Set is in the database or in an attached external file.

        **Input:**
            **nSetID** The ID of the Output Set to query.

        **Output:**
            **pnSetLocation** 1=In FEMAP Database (FRL_DB)

            2=In Nastran OP2 File (FRL_OP2)
            3=In FNO File (FRL_FNO)
            4=Not Used
            5=In Nastran XDB File (FRL_XDB)
            6=In Comma-Separated Value (CSV) File (FRL_CSV)
            7=In Virtual Output Set (FRL_VIRTUAL)
            8=In ABAQUS ODB File (FRL_ODB)

        **Return Code:**

            **FE_FAIL** Unable to retrieve information about selected set - most likely the set does not exist.

        :type nSetID: int
        :type pnSetLocation: int
        """
        ...

    def SetModel(self, nModelID) -> Any:
        """
        **Description:**
            This method chooses the model to be used for all further operations.

        **Remarks/Usage:**
            When the object is created, nModelID is set to the current/active model.

        **Input:**
            **nModelID** Model identifier

        :type nModelID: int
        """
        ...

    def SetMultipleInRow(self, nRowIndex, nNumberOfColumns, nColumnIndices, dVals) -> Any:
        """
        **Description:**
            This method sets the values in multiple columns of a selected row.

        **Remarks/Usage:**
            This method allows you to update the value in a row/column. It is intended to be used so that you can use
            the data in other columns, combined with data and logic in your program to fill values in empty col­umns.

        **Input:**
            **nRowIndex** Zero-based index of the desired row

            **nNumberOfColumns** The number of entries in nColumnIndices

            **nColumnIndices** Zero-based indices of the desired columns

            **dVals** The values to define, in the same order as nColumnIndices

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_FAIL** Unable to find data for the specified row/columns

        :type nRowIndex: int
        :type nNumberOfColumns: int
        :type nColumnIndices: tuple[int]
        :type dVals: tuple[float]
        """
        ...

    def SetNodalTransform(self, nTransformTo, nCSysID) -> Any:
        """
        **Description:**
            This method defines parameters to transform nodal results when they are populated.

        **Remarks/Usage:**
            This method must be called prior to calling Populate(), but is not required if you do not want to trans­form results.

        **Input:**
            **nTransformTo** 0=No Transform, results in Global Rectangular, 1=Results in nCSysID, 2=Results in Nodal Output Coordinate Systems

            **nCSysID** ID of Coordinate System to transform into when nTransformTo=1

        **Return Code:**
            **FE_NOT_EXIST** The coordinate system specified by nCSysID does not exist

            **FE_INVALID** The object has already been populated with data.

            **FE_BAD_DATA** An invalid value has been specified for nTransformTo

        :type nTransformTo: int
        :type nCSysID: int
        """
        ...

    def SetNotes(self, nSetID, sNotes) -> Any:
        """
        **Description:**
            This method returns the notes of a selected Output Set

        **Input:**
            **nSetID** The ID of the Output Set to query.

        **Output:**
            **sNotes** The notes of the selected Output Set

        **Return Code:**

            **FE_FAIL** Unable to retrieve information about selected set - most likely the set does not exist.

        :type nSetID: int
        :type sNotes: str
        """
        ...

    def SetPlateTransform(self, nTransformTo, nCSysID, nCSysAxis, dVecX, dVecY, dVecZ, dToleranceAngle) -> Any:
        """
        **Description:**
            This method defines parameters to transform Elemental Results on planar/plate elements when they are populated.

        **Remarks/Usage:**
            This method must be called prior to calling Populate(), but is not required if you do not want to trans­form
            results. When you transform plate data, you are really specifying a direction that the X component of the stress/strain/... is transformed into.

        **Input:**
            **nTransformTo** 0=No Transform, 3=Transform to Material Coordinate System, 4=Transform to CSys nCSysID, 5=Transform to specified vector

            **nCSysID** ID of Coordinate System to transform into when nTransformTo=4

            **nCSysAxis** The Axis of nCSysID Coordinate System to use as the transform direction (1=X Axis, 2=Y Axis, 3=Z Axis).

            **dVecX, dVecY, dVecZ** The components of the vector to transform into when nTrans­formTo=5

            **dToleranceAngle** This angle corresponds to the Minimum Angle From Normal option in the Transform Output Data dialog box.
            It is used to determine if the vector representing an element’s normal direction is too closely aligned with
            the vector specified for transformation. If the angle between the two vectors is smaller than the specified
            tolerance then the transformation vector cannot be accurately projected onto the plane of the planar element,
            thus no transformation will occur. Only used when nTransformTo is set to 4 or 5.

        **Return Code:**
            **FE_BAD_DATA** An invalid value has been specified for nTransformTo

            **FE_INVALID** The object has already been populated with data.

            **FE_NOT_EXIST** The coordinate system specified by nCSysID does not exist

        :type nTransformTo: int
        :type nCSysID: int
        :type nCSysAxis: int
        :type dVecX: float
        :type dVecY: float
        :type dVecZ: float
        :type dToleranceAngle: float
        """
        ...

    def SetQuad4Orientation(self, nStress, nStrain, nForce) -> Any:
        """
        **Description:**
            This method sets the default orientations for Elemental Results on 4-noded quadrilateral

        **Remarks/Usage:**
            This method is not normally required, as defaults are set as preferences, but if it is used, it must be called prior to calling Populate().

        **Input:**
            **nStress** 0=First Edge, 1=Midside Locations, 2=Diagonal Bisector, 3=Mate­rial Direction

            **nStrain** 0=First Edge, 1=Midside Locations, 2=Diagonal Bisector, 3=Mate­rial Direction

            **nForce** 0=First Edge, 1=Midside Locations, 2=Diagonal Bisector, 3=Mate­rial Direction


        **Return Code:**
            **FE_BAD_DATA** One or more of the arguments has an invalid value.

            **FE_INVALID** The object has already been populated with data.

        :type nStress: int
        :type nStrain: int
        :type nForce: int
        """
        ...

    def SetQuad8Orientation(self, nStress, nStrain, nForce) -> Any:
        """
        **Description:**
            This method sets the default orientations for Elemental Results on 8-noded quadrilateral

        **Remarks/Usage:**
            This method is not normally required, as defaults are set as preferences, but if it is used, it must be called prior to calling Populate().

        **Input:**
            **nStress** 0=First Edge, 1=Midside Locations, 2=Diagonal Bisector, 3=Mate­rial Direction

            **nStrain** 0=First Edge, 1=Midside Locations, 2=Diagonal Bisector, 3=Mate­rial Direction

            **nForce** 0=First Edge, 1=Midside Locations, 2=Diagonal Bisector, 3=Mate­rial Direction

        **Return Code:**

            **FE_INVALID** The object has already been populated with data.

            **FE_BAD_DATA** One or more of the arguments has an invalid value.

        :type nStress: int
        :type nStrain: int
        :type nForce: int
        """
        ...

    def SetRevision(self, nSetID) -> Any:
        """
        **Description:**
            This method returns the revision number of a selected Output Set

        **Remarks/Usage:**
            These revision numbers are automatically created for Nastran Output Sets when the Track Revision  option is on in the Results tab of the File, Preference command.

        **Input:**
            **nSetID** The ID of the Output Set to query.

        **Return Code:**
            **Value** The ID of the revision number associated with the Nastran Output Set. If 0, no revision is associated with the output set.

        :type nSetID: int
        """
        ...

    def SetRow(self, nID, dVals) -> Any:
        """
        **Description:**
            This method sets the values in multiple columns for a selected node or element ID.

        **Input:**
            **nID** The ID of the node/element.

            **dVals** The values to be put in the columns of the specified node/element.

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_FAIL** Unable to set data for the specified row/columns

        :type nID: int
        :type dVals: tuple[float]
        """
        ...

    def SetRows(self, nNumberOfRows, nIDs, dVals) -> Any:
        """
        **Description:**
            This method sets the values in multiple columns of a selected node or element IDs.

        **Remarks/Usage:**
            The data for nIDs is stored in 1-dimensional array, while the data for dVals is stored in a separate 1-dimensional array using the following format:
            (Column0,Row0), (Column1,Row0)…(ColumnN,Row0); (Column0,Row1), (Column1,Row1)… (ColumnN,Row1);...; (Column0,RowM), (Column1,RowM)…(ColumnN,RowM)
            This method allows you to update the values of columns for multiple node or element IDs.

        **Input:**
            **nNumberOfRows** The number or rows or nodes/elements.

            **nIDs** The IDs of the nodes/elements.

            **dVals** The values to be put in the columns for the specified node/elements.

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_FAIL** Unable to set data for the specified row/columns

        :type nNumberOfRows: int
        :type nIDs: tuple[int]
        :type dVals: tuple[float]
        """
        ...

    def SetRowsAndColumnsByID(self, nEntitySetID, nNumberOfColumns, nColIndices, dVals) -> Any:
        """
        **FIY**
            the description of the method is not on the documentation
        :type nEntitySetID: Any
        :type nNumberOfColumns: Any
        :type nColIndices: Any
        :type dVals: Any
        """
        ...

    def SetRowsByID(self, nEntitySetID, dVals) -> Any:
        """
        **Description:**
            This method sets the values in multiple columns of a given Entity Set.

        **Remarks/Usage:**
            This method allows you to update the values of columns for given entities in a Set.

        **Input:**
            **nEntitySetID** The ID of the Set of nodes/elements.

            **dVals** The values to be put in the columns for the specified Set.

        **Return Code:**
            **FE_NO_MEMORY** Insufficient memory to allocate space for values

            **FE_FAIL** Unable to set data for the specified row/columns

        :type nEntitySetID: int
        :type dVals: tuple[float]
        """
        ...

    def SetScalarAtBeamColumnsV2(self, nColumnIndices, listcount, nID, ValA, ValB) -> Any:
        """
        **Description:**
            This method sets Beam output vectors for EndA and EndB containing a single scalar value.

        **Remarks/Usage:**

        **Input:**
            **nColumnIndices** The indices of the columns to get.

            **listcount** The count of elements in the column.

            **nID** The IDs of the elements.

            **ValA** The EndA output values associated with the corresponding element IDs array.

            **ValB** The EndB output values associated with the corresponding element IDs array.

        **Return Code:**

            **FE_FAIL** Unable to set data for the specified row/columns

        :type nColumnIndices: tuple[int]
        :type listcount: int
        :type nID: tuple[int]
        :type ValA: float
        :type ValB: float
        """
        ...

    def SetScalarAtElemColumnV2(self, nColumnIndex, listcount, nID, value) -> Any:
        """
        **Description:**
            This method stores output data in a column.

        **Remarks/Usage:**

        **Input:**
            **nColumnIndex** The index of the column.

            **listcount** The count of nodes in the column.

            **nID** The IDs of the Node/Element.

            **value** The results values.

        **Return Code:**
            **FE_FAIL** Unable to set data for the specified row/columns

        :type nColumnIndex: int
        :type listcount: int
        :type nID: tuple[int]
        :type value: tuple[float]
        """
        ...

    def SetScalarAtNodeColumnV2(self, nColumnIndex, listcount, nID, value) -> Any:
        """
        **Description:**
            This method stores output data in a column.

        **Input:**
            **nColumnIndex** The index of the column.

            **listcount** The count of nodes in the column.

            **nID** The IDs of the Node/Element.

            **value** The results values.

        **Return Code:**

            **FE_FAIL** Unable to set data for the specified row/columns

        :type nColumnIndex: int
        :type listcount: int
        :type nID: tuple[int]
        :type value: tuple[float]
        """
        ...

    def SetSolidOrientation(self, nIsotropic, nAnisotropic, nHyperelastic) -> Any:
        """
        :type nIsotropic: Any
        :type nAnisotropic: Any
        :type nHyperelastic: Any
        """
        ...

    def SetSolidTransform(self, nTransformTo, nCSysID) -> Any:
        """
        :type nTransformTo: Any
        :type nCSysID: Any
        """
        ...

    def SetSubcase(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def SetTitle(self, nSetID, sTitle) -> Any:
        """
        **Description:**
            This method returns the title of a selected Output Set
        **Remarks/Usage:**
            None
        **Input:**
            **SetID:** The ID of the Output Set to query.\n
        **Output:**
            **sTitle:** The title of the selected Output Set\n
        **Return Code:** True\n

        :type nSetID: int
        :type sTitle: str
        """
        ...

    def SetTri3Orientation(self, nStress, nStrain, nForce) -> Any:
        """
        **Description:**
            This method sets the default orientations for Elemental Results on 3-noded triangles

        **Remarks/Usage:**
            This method is not normally required, as defaults are set as preferences, but if it is used, it must be called prior to calling Populate().

        **Input:**
            **nStress** 0=First Edge, 1=Midside Locations, 3=Material Direction

            **nStrain** 0=First Edge, 1=Midside Locations, 3=Material Direction

            **nForce** 0=First Edge, 1=Midside Locations, 3=Material Direction

        **Return Code:**
            **FE_INVALID** The object has already been populated with data.

            **FE_BAD_DATA** One or more of the arguments has an invalid value.

        :type nStress: int
        :type nStrain: int
        :type nForce: int
        """
        ...

    def SetTri6Orientation(self, nStress, nStrain, nForce) -> Any:
        """
        **Description:**
            This method sets the default orientations for Elemental Results on 6-noded triangles

        **Remarks/Usage:**
            This method is not normally required, as defaults are set as preferences, but if it is used, it must be called prior to calling Populate().

        **Input:**
            **nStress** 0=First Edge, 1=Midside Locations, 3=Material Direction

            **nStrain** 0=First Edge, 1=Midside Locations, 3=Material Direction

            **nForce** 0=First Edge, 1=Midside Locations, 3=Material Direction

        **Return Code:**
            **FE_INVALID** The object has already been populated with data.

            **FE_BAD_DATA** One or more of the arguments has an invalid value.

        :type nStress: int
        :type nStrain: int
        :type nForce: int
        """
        ...

    def SetValue(self, nID, nColumnIndex, dVal) -> Any:
        """
        **Description:**
            This method sets the value in the selected column for the specified Node/Element

        **Remarks/Usage:**
            This method allows you to update the value in a row/column. It is intended to be used so that you can
            use the data in other columns, combined with data and logic in your program to fill values in empty col­umns
        **Input:**
            **nID** The ID of the Node/Element desired

            **nColumnIndex** Zero-based index of the desired column

            **dVal** The value to set in the row and column

        **Return Code:**
            **FE_BAD_DATA** Column index is outside of the range of available columns

            **FE_FAIL** Unable to find data for the specified ID

        :type nID: int
        :type nColumnIndex: int
        :type dVal: float
        """
        ...

    def SetVectorAtNodeColumnsV2(self, nColumnIndices, listcount, nID, x, y, z) -> Any:
        """
        **Description:**
            This method sets nodal vector data in a column.

        **Input:**
            **nColumnIndices** The indices of the columns to set.

            **listcount** The count of nodes in the columns

            **nID** The IDs of the Nodes.

            **x, y, z** The component results values.

        **Return Code:**

            **FE_FAIL** Unable to set data for the specified row/columns

        :type nColumnIndices: tuple[int]
        :type listcount: int
        :type nID: tuple[int]
        :type x: tuple[float]
        :type y: tuple[float]
        :type z: tuple[float]
        """
        ...

    def Sets(self, nSetSetID, bClear) -> Any:
        """
        :type nSetSetID: Any
        :type bClear: Any
        """
        ...

    def Sort(self, nColumnIndex, bAscending, bAbsoluteValue) -> Any:
        """
        **Description:**
            This method sorts the data of a specified column.

        **Remarks/Usage:**
            This method should be used before calling Populate.

        **Input:**
            **nColumnIndex** The index of the column to sort.

            **bAscending** If True the values will be listed in ascending order.

            **bAbsoluteValue** If True the values will be sorted by the absolute value.

        **Return Code:**

            **FE_FAIL** Unable to sort data.

        :type nColumnIndex: int
        :type bAscending: bool
        :type bAbsoluteValue: bool
        """
        ...

    def StudyCreate(self, nStudyID, sTitle, nAnalysisProgram, nAnalysisType) -> Any:
        """
        **Description:**
            This method creates and Analysis Study.

        **Remarks/Usage:**

        **Input:**
            **nStudyID** The ID of the Analysis Study.

            **sTitle** The title of the Analysis Study.

            **nAnalysisProgram** Analysis program where output came from: 0=Unknown, 4=MSC/NASTRAN, 5=ANSYS, 16=ABAQUS,
            28=LS-Dyna, 29=MSC.Marc, 31=NE/Nastran, 34=FEMAP Struc-tural. 36=NX Nastran. Use enum zAnalysisProgram

            **nAnalysisType** Type of analysis the results came from: 0=None, 1=Static, 2=Normal Modes/Eigenvalue,
            3=Transient Dynamic/Time History, 4=Fre­quency/Harmonic Response, 5=Response Spec-trum, 6=Random Response,
            7=Buckling, 8=Design Opt, 9=Explicit Transient Dynam­ics, 10=Nonlinear Static, 11=Nonlinear Buckling, 12=Nonlinear
            Transient, 13=Implicit Transient Dynamics, 17=Fatigue, 19=Com­putational Fluid Dynamics, 20=Steady-State Heat Transfer,
            21=Transient Heat Transfer, 22=Advanced Nonlinear Static, 23=Advanced Non-linear Transient, 24=Advanced Nonlinear
            Explicit, 25=Static Aeroelasticity, 26=Aerodynamic Flutter. Use enum zAnalysisType .

        **Return Code:**

            **FE_FAIL** Unable to create Analysis Study

        :type nStudyID: int
        :type sTitle: str
        :type nAnalysisProgram: int
        :type nAnalysisType: int
        """
        ...

    def StudyExists(self, nStudyID) -> Any:
        """
        **Description:**
            This method determines if a selected Analysis Study exists.

        **Input:**
            **nStudyID** The ID of the Analysis Study to check.

        **Return Code:**

            **FE_FAIL** The Analysis Study does not exist.

        :type nStudyID: int
        """
        ...

    def StudyInfo(self, nStudyID, pnAnalysisProgram, pnAnalysisType) -> Any:
        """
        **Description:**
            This method retrieves the information of a selected Analysis Study.

        **Remarks/Usage:**
            Unable to retrieve information about selected Analysis Study - most likely the study does not exist.

        **Input:**
            **nStudyID** The ID of the Analysis Study to check.

        **Output:**
            **pnAnalysisProgram** Analysis program where output came from: 0=Unknown, 4=MSC/NASTRAN, 5=ANSYS,
            16=ABAQUS, 28=LS-Dyna, 29=MSC.Marc, 31=NE/Nastran, 34=FEMAP Struc-tural. 36=NX Nastran. Use enum zAnalysisProgram

            **pnAnalysisType** Type of analysis the results came from: 0=None, 1=Static, 2=Normal Modes/Eigenvalue,
            3=Transient Dynamic/Time History, 4=Fre­quency/Harmonic Response, 5=Response Spec-trum, 6=Random Response,
            7=Buckling, 8=Design Opt, 9=Explicit Transient Dynam­ics, 10=Nonlinear Static, 11=Nonlinear Buckling, 12=Nonlinear
            Transient, 13=Implicit Transient Dynamics, 17=Fatigue, 19=Com­putational Fluid Dynamics, 20=Steady-State Heat
            Transfer, 21=Transient Heat Transfer, 22=Advanced Nonlinear Static, 23=Advanced Non-linear Transient, 24=Advanced
            Nonlinear Explicit, 25=Static Aeroelasticity, 26=Aerodynamic Flutter. Use enum zAnalysisType .

        **Return Code:**

            **FE_FAIL** Unable to retrieve information about selected Analysis Study - most likely the study does not exist.

        :type nStudyID: int
        :type pnAnalysisProgram: int
        :type pnAnalysisType: int
        """
        ...

    def StudyNotes(self, nStudyID, sNotes) -> Any:
        """
        **Description:**
            This method retrieves the notes of a selected Analysis Study.

        **Remarks/Usage:**

        **Input:**
            **nStudyID** The ID of the Analysis Study to check.

        **Output:**
            **sNotes** The notes of the Analysis Study.

        **Return Code:**

            **FE_FAIL** Unable to retrieve notes of selected Analysis Study.

        :type nStudyID: int
        :type sNotes: str
        """
        ...

    def StudyTitle(self, nStudyID, sTitle) -> Any:
        """
        **Description:**
            This method retrieves the title of a selected Analysis Study.

        **Input:**
            **nStudyID** The ID of the Analysis Study to check.

        **Output:**
            **sTitle** The title of the Analysis Study.

        **Return Code:**

            **FE_FAIL** Unable to retrieve title of selected Analysis Study.

        :type nStudyID: int
        :type sTitle: str
        """
        ...

    def VectorComponentsV2(self, nSetID, nVectorID, pnNumComponents, pnComponents) -> Any:
        """
        **Description:**
            This method indicates whether a selected Output Vector has Component Output Vectors and, if so, returns the
            number of Component Output Vectors and their IDs. This method replaces VectorCompo­nents. For more information
            see, Section 2.4, "Working with Output in FEMAP 2020.1 and above".

        **Remarks/Usage:** Components are the IDs of other Output Vectors that are related to the selected Output Vectors.
        For things like “Total Translation” (or any other Total Nodal output), there will be 3 components that repre­sent the X,Y,Z
        component of the translation in Global Rectangular coordinates. For Elemental Output such as Plate or Solid Stresses,
        the Vector that contains the centroidal value will have components that represent the same value at the associated corners
        (nodes) of the element. For Beam/Bar results, there will be 2 components which are the vectors that contain the results
        at the two ends of the element. One of these will be the same ID as the selected vector.


        **Input:**
            **nSetID** The ID of the Output Set to query

            **nVectorID** The ID of the Output Vector to query

        **Output:**
            **pnNumComponents** The number of components

            **pnComponents** An array of component vector IDs

        **Return Code:**

            **FE_FAIL** Unable to query the selected Output Vector - probably because it does not exist.

        :type nSetID: int
        :type nVectorID: int
        :type pnNumComponents: int
        :type pnComponents: tuple[int]
        """
        ...

    def VectorEntitiesV2(self, nSetID, nVectorID, nEntitySetID, bClear) -> Any:
        """
        **Description:**
            This method loads the IDs of all Nodes or Elements that contain data in the selected vector into a Set Object.
            This method replaces VectorEntities. For more information see, Section 2.4, "Working with Out­put in FEMAP 2020.1 and above".

        **Remarks/Usage:**
            You can tell whether the IDs reference Nodes or Elements by using the VectorInfo method.

        **Input:**
            **nSetID** The ID of the Output Set to query

            **nVectorID** The ID of the Output Vector to query

            **nEntitySetID** The ID of the Set Object that will receive the IDs of the Nodes or Elements that have data in this Output Vector

            **bClear** If True, the Set Object is cleared prior to loading it with the entity IDs

        **Return Code:**

            **FE_FAIL** Unable to query the selected Output Vector - probably because it does not exist.

        :type nSetID: int
        :type nVectorID: int
        :type nEntitySetID: int
        :type bClear: bool
        """
        ...

    def VectorExistsV2(self, nSetID, nVectorID) -> Any:
        """
        **Description:**
            This method indicates whether a selected Output Vector exists in a selected Output Set. This method replaces
            VectorExist. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above".

        **Remarks/Usage:**

        **Input:**
            **nSetID** The ID of the Output Set to query

            **nVectorID** The ID of the Output Vector to query


        **Return Code:**

            **FE_FAIL** The Output Vector does not exist in the selected Output Set

        :type nSetID: int
        :type nVectorID: int
        """
        ...

    def VectorID(self) -> Any:
        """
        **Description:**
            This method returns a ResultsIDQuery Object. It is often used for querying an output vector ID without initially
            declaring a ResultsIDQuery object. For more on the ResultsIDQuery object, see Section 4.18, "Results Vector ID Query Objects"

        """
        ...

    def VectorInfoV2(self, nSetID, nVectorID, pnDataType, pnOutputType, pbCentroidTotal, pbNonlinear, pnCompDir) -> Any:
        """
        **Description:**
            This method returns selected information about a selected Output Vector. This method replaces Vec­torInfo.
            For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above".

        **Remarks/Usage:**
            Unable to query the selected Output Vector - probably because it does not exist.

        **Input:**
            **nSetID** The ID of the Output Set to query

            **nVectorID** The ID of the Output Vector to query

        **Output:**
            **pnDataType** Refer to the “location” property of the Output object

            **pnOutputType** Refer to the “category” property of the Output object

            **pbCentroidTotal** Refer to the “centroidtotal” property of the Output object

            **pbNonlinear** Refer to the “nonlinear” property of the Output object

            **pnCompDir** Refer to the “hascomponent” property of the Output object

        **Return Code:**

            **FE_FAIL** Unable to query the selected Output Vector - probably because it does not exist.

        :type nSetID: int
        :type nVectorID: int
        :type pnDataType: int
        :type pnOutputType: int
        :type pbCentroidTotal: bool
        :type pbNonlinear: bool
        :type pnCompDir: int
        """
        ...

    def VectorLocationV2(self, nSetID, nVectorID, pnVectorLocation) -> Any:
        """
        :type nSetID: Any
        :type nVectorID: Any
        :type pnVectorLocation: Any
        """
        ...

    def VectorTitleV2(self, nSetID, nVectorID, sTitle) -> Any:
        """
        :type nSetID: Any
        :type nVectorID: Any
        :type sTitle: Any
        """
        ...

    def VectorTitlesV2(self, nSetID, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        :type nSetID: Any
        :type bIncludeID: Any
        :type minID: Any
        :type maxID: Any
        :type Count: Any
        :type listID: Any
        :type listTITLE: Any
        """
        ...

    def VectorsV2(self, nSetID, nVectorSetID, bClear) -> Any:
        """
        :type nSetID: Any
        :type nVectorSetID: Any
        :type bClear: Any
        """
        ...

    def clear(self) -> Any:
        """
        """
        ...


class Mesher:
    CLSID: Any
    AdjacentSurfaceMatching: Any
    AdjustColors: Any
    AskAlreadyMeshed: Any
    AttributePropOnly: Any
    AutoBoundarySmallSurfPct: Any
    AutoBoundarySmallSurfPctOn: Any
    AutoSelectTriMesher: Any
    CombineSmallSurfaces: Any
    CombinedCurveAngle: Any
    ConnectEdgeNodes: Any
    ConnectEdgeNodesOn: Any
    CurveSuppressPct: Any
    CutQuadDeviationAngle: Any
    CutSlivers: Any
    DeletePreviousMesh: Any
    DetectClosePoints: Any
    FeatureEdgeAngle: Any
    FixedGroupID: Any
    GeometryCleanup: Any
    InitialSizeRatio: Any
    InteriorGrowthFactor: Any
    LengthBasedSizing: Any
    MapAlternateBias: Any
    MapEqualSidesOnly: Any
    MapMaxAngleDeviation: Any
    MapMinCornerAngle: Any
    MapRightBias: Any
    MapSplitQuadMap: Any
    MapSubdivisions: Any
    MappedMeshingAllowed: Any
    MappedMeshingRefinement: Any
    MaxAngleTolerance: Any
    MaxAngleToleranceOn: Any
    MaxElemAspectRatio: Any
    MaxElemSmallFeature: Any
    MaxElemSmallFeatureOn: Any
    MaxPctSmallFeature: Any
    MaxPctSmallFeatureOn: Any
    MeshSize: Any
    MeshSizing: Any
    MeshType: Any
    Meshing: Any
    MidsideMaxDistortionAngle: Any
    MidsideMaxDistortionAngleOn: Any
    MidsideMoveToGeometry: Any
    MidsideNodes: Any
    MinElemBetweenBoundary: Any
    MinElemOnEdge: Any
    MinElemOnEdgeOn: Any
    NarrowAngle: Any
    NarrowSizePct: Any
    NodeMergeOption: Any
    OffsetMeshDistance: Any
    OffsetMeshMode: Any
    PostMeshingCleanup: Any
    PreV10Meshing: Any
    PrepareGeometry: Any
    PrepareSize: Any
    ProcessBlends: Any
    QuadEdgeLayers: Any
    QuickCutBoundaryOn: Any
    QuickCutMaxNodes: Any
    RefineSurfaceMesh: Any
    RefinementRatio: Any
    RefinementRatioOn: Any
    RemovePreviousOnly: Any
    RemovePreviousPrep: Any
    RemovePreviousSlaving: Any
    Silent: Any
    SkipSizingOnSlaved: Any
    SmoothingIterations: Any
    SmoothingLaplacian: Any
    SmoothingTolerance: Any
    SuppressShortEdgesPct: Any
    SuppressShortEdgesPctOn: Any
    SuppressVoids: Any
    SyncSizes: Any
    TetAdjustNodalPrecision: Any
    TetCheckSurfaceElem: Any
    TetDeleteSurfaceElem: Any
    TetGrowthRatio: Any
    TetMeshVoids: Any
    TetMidsideMaxDistortionAngle: Any
    TetMidsideMaxDistortionAngleOn: Any
    TetMidsideMoveToGeometry: Any
    TetPreV10Meshing: Any
    TetQualityToDataTable: Any
    TetSmoothSolidElem: Any
    TetSmoothSolidElemOn: Any
    TetStatusMessages: Any
    TriMesher: Any
    VertexAspectRatio: Any
    VertexAspectRatioOn: Any

    def AddSolid(self, nSetID, bSetSizes) -> Any:
        """
        **Description:**
            This method selects one or more solids to be processed by the other methods in this object
        **Remarks/Usage:**
            Typically this is the first method called when using this object.
        **Input:**
            **nSetID:** The ID of a set that contains a list of Solid IDs that will be processed. Alternatively, if you specify a negative value, this is simply the ID of the single Solid to process.\n
            **bSetSizes:** If True, the solid(s) are evaluated and default geometry preparation and mesh sizes are determined based on these solids. If False, default sizes are based on the overall model sizes, or any changes you have made to the defaults prior to calling this method\n
        **Return Code:** True\n
        :type nSetID: int

        :type bSetSizes: bool

        """
        ...

    def AddSurface(self, nSetID, bSetSizes) -> Any:
        """
        **Description:**
            This method selects one or more surfaces to be processed by the other methods in this object
        **Remarks/Usage:**
            In most cases, AddSolid() is used instead of AddSurface()
        **Input:**
            **nSetID:** The ID of a set that contains a list of Surface IDs that will be processed. Alternatively, if you specify a negative value, this is simply the ID of the single Surface to process.\n
            **bSetSizes:** If True, the Surface(s) are evaluated and default geometry preparation and mesh sizes are determined based on these Surfaces. If False, default sizes are based on the overall model sizes, or any changes you have made to the defaults prior to calling this method\n
        **Return Code:** True\n
        :type nSetID: int

        :type bSetSizes: bool

        """
        ...

    def Apply(self) -> Any:
        """
        **Description:**
            This method can remove previous preparation, prepare geometry, apply mesh sizing and meshselected geometry using the current options/properties.
        **Remarks/Usage:**
            Four properties control the options that are executed by this method. If RemovePreviousOnly is True, then any previous geometry preparation is removed and no other steps are performed. If it is False (the default) then PrepareGeometry, MeshSizing and Meshing control whether each of those steps is performed.
        **Return Code:** True\n
        """
        ...

    def HasPrevious(self) -> Any:
        """
        **Description:**
            This method indicates whether the selected solid has previous geometry preparation.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Mesh(self) -> Any:
        """
        **Description:**
            This method Meshes the selected geometry using the current options/properties.
        **Remarks/Usage:**
            This method will mesh regardless of the setting of the Meshing property
        **Return Code:** True\n
        """
        ...

    def Prepare(self) -> Any:
        """
        **Description:**
            This method performs Geometry Preparation on the selected geometry using the current options/properties.
        **Remarks/Usage:**
            This method will prepare the selected geometry regardless of the setting of the PrepareGeometry property
        **Return Code:** True\n
        """
        ...

    def RemovePrevious(self) -> Any:
        """
        **Description:**
            This method removes previous geometry preparation.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def SetSizes(self, dPrepareSize, dMeshSize, dInteriorGrowthFactor) -> Any:
        """
        **Description:**
            This method provides a way to easily set the mesh sizes in a single call
        **Remarks/Usage:**
            Calling this method is identical to setting the three properties directly.
        **Input:**
            **dPrepareSize:** Sets the PrepareSize property\n
            **dMeshSize:** Sets the MeshSize property\n
            **dInteriorGrowthFactor:** Sets the InteriorGrowthFactor\n
        **Return Code:** False\n
        :type dPrepareSize: float

        :type dMeshSize: float

        :type dInteriorGrowthFactor: float

        """
        ...

    def Size(self) -> Any:
        """
        **Description:**
            This method performs Mesh Sizing on the selected geometry using the current options/properties.
        **Remarks/Usage:**
            This method will apply Mesh Sizes regardless of the setting of the MeshSizing property
        **Return Code:** True\n
        """
        ...

    def UI(self, bMeshingOptions) -> Any:
        """
        **Description:**
            This method displays the dialog box user interface, just like the Geometry Preparation command.
        **Remarks/Usage:**
            This method uses the current object properties to initialize the dialogs and updates the properties to the users selections.
        **Input:**
            **bMeshingOptions:** If False, the dialog box showing Geometry Preparation and Mesh Sizing options will be used. If True, the dialog box will also contain Meshing Options.\n
        **Return Code:** True\n
        :type bMeshingOptions: bool

        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            This method clears all properties and resets them to default values.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...


class ElementQuality:
    CLSID: Any
    AlternateTaperLimit: Any
    AlternateTaperOn: Any
    AspectRatioLimit: Any
    AspectRatioOn: Any
    CombinedLimit: Any
    CombinedOn: Any
    ExplicitTimeStepLimit: Any
    ExplicitTimeStepOn: Any
    InternalAngleLimit: Any
    InternalAngleOn: Any
    JacobianLimit: Any
    JacobianOn: Any
    NastranHexARLimit: Any
    NastranHexAROn: Any
    NastranHexDetJLimit: Any
    NastranHexDetJOn: Any
    NastranHexEPIALimit: Any
    NastranHexEPIAOn: Any
    NastranHexEPLRLimit: Any
    NastranHexEPLROn: Any
    NastranHexWarpLimit: Any
    NastranHexWarpOn: Any
    NastranPenARLimit: Any
    NastranPenAROn: Any
    NastranPenDetJLimit: Any
    NastranPenDetJOn: Any
    NastranPenEPIALimit: Any
    NastranPenEPIAOn: Any
    NastranPenEPLRLimit: Any
    NastranPenEPLROn: Any
    NastranPenWarpLimit: Any
    NastranPenWarpOn: Any
    NastranPyrARLimit: Any
    NastranPyrAROn: Any
    NastranPyrDetJLimit: Any
    NastranPyrDetJOn: Any
    NastranPyrEPIALimit: Any
    NastranPyrEPIAOn: Any
    NastranPyrEPLRLimit: Any
    NastranPyrEPLROn: Any
    NastranPyrWarpLimit: Any
    NastranPyrWarpOn: Any
    NastranQuadARLimit: Any
    NastranQuadAROn: Any
    NastranQuadIAMaxLimit: Any
    NastranQuadIAMaxOn: Any
    NastranQuadIAMinLimit: Any
    NastranQuadIAMinOn: Any
    NastranQuadSkewLimit: Any
    NastranQuadSkewOn: Any
    NastranQuadTaperLimit: Any
    NastranQuadTaperOn: Any
    NastranQuadWarpLimit: Any
    NastranQuadWarpOn: Any
    NastranTetraARLimit: Any
    NastranTetraAROn: Any
    NastranTetraDetJLimit: Any
    NastranTetraDetJOn: Any
    NastranTetraEPIALimit: Any
    NastranTetraEPIAOn: Any
    NastranTetraEPLRLimit: Any
    NastranTetraEPLROn: Any
    NastranTriaARLimit: Any
    NastranTriaAROn: Any
    NastranTriaEPLRLimit: Any
    NastranTriaEPLROn: Any
    NastranTriaIAMaxLimit: Any
    NastranTriaIAMaxOn: Any
    NastranTriaSkewLimit: Any
    NastranTriaSkewOn: Any
    NastranWarpingLimit: Any
    NastranWarpingOn: Any
    SkewLimit: Any
    SkewOn: Any
    TaperLimit: Any
    TaperOn: Any
    TetCollapseLimit: Any
    TetCollapseOn: Any
    WarpingLimit: Any
    WarpingOn: Any

    def AlternateTaper(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def AspectRatio(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**
            Once you use this method you can use the returned Sort object to sort the elements by quality and find the worst ones.
        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def CheckNastranQuality(self, nElemSet, bList, bGroup) -> Any:
        """
        **Description:**
            This function checks a set of elements to see if any of them are distorted based on the quality flags and limit values defined in the Quality Object properties for the NX Nastran Element Checks. A Femap Set object is returned filled with the element IDs that failed the selected quality checks.
        **Remarks/Usage:**
            This function is just like the Tools, Check, Distortion command when using the NX Nastran tab. The checks performed and the limit values are identical to that command.
        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **bList:** If True, distorted elements are listed in the Messages and Lists window.\n
            **bGroup:** If True, a group is made of the distorted elements.\n
        **Return Code:** True\n
        :type nElemSet: int

        :type bList: bool

        :type bGroup: bool

        """
        ...

    def CheckQuality(self, nElemSet, bList, bGroup) -> Any:
        """
        **Description:**
            This function checks a set of elements to see if any of them are distorted based on the quality flags and limit values defined in the Quality Object properties for the Femap Element Checks. A Femap Set object is returned filled with the element IDs that failed the selected quality checks.
        **Remarks/Usage:**
            This function is just like the Tools, Check, Distortion command when using the Femap tab. The checks performed and the limit values are identical to that command.
        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **bList:** If True, distorted elements are listed in the Messages and Lists window.\n
            **bGroup:** If True, a group is made of the distorted elements.\n
        **Return Code:** True\n
        :type nElemSet: int

        :type bList: bool

        :type bGroup: bool

        """
        ...

    def Combined(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def ExplicitTimeStep(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def GetAlternateTaper(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetAspectRatio(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value. \n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetCombined(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetExplicitTimeStep(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetInternalAngle(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetJacobian(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetModelDefaults(self) -> Any:
        """
        **Description:**
            This method loads the quality flags and limit values from the Femap model into the current Quality Object.
        **Remarks/Usage:**

        **Return Code:** False\n
        """
        ...

    def GetNastranHexAR(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranHexDetJ(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranHexEPIA(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranHexEPLR(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranHexWarp(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranPenAR(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranPenDetJ(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranPenEPIA(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranPenEPLR(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranPenWarp(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranPyrAR(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranPyrDetJ(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranPyrEPIA(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranPyrEPLR(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranPyrWarp(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranQuadAR(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranQuadIAMax(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranQuadIAMin(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranQuadSkew(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranQuadTaper(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranQuadWarp(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranTetraAR(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranTetraDetJ(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranTetraEPIA(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranTetraEPLR(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranTriaAR(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranTriaEPLR(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranTriaIAMax(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranTriaSkew(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetNastranWarping(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetSkew(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetTaper(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetTetCollapse(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def GetWarping(self, nElemID, pdValue) -> Any:
        """
        **Description:**
            This method calculates and returns the quality value for the desired element.
        **Remarks/Usage:**

        **Input:**
            **nElemID:** ID of element to check.\n
        **Output:**
            **pdValue:** Quality value.\n
        **Return Code:** False\n
        :type nElemID: int

        :type pdValue: float

        """
        ...

    def InternalAngle(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def Jacobian(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranHexAR(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranHexDetJ(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranHexEPIA(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranHexEPLR(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranHexWarp(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranPenAR(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranPenDetJ(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranPenEPIA(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranPenEPLR(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranPenWarp(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranPyrAR(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranPyrDetJ(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranPyrEPIA(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranPyrEPLR(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranPyrWarp(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranQuadAR(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranQuadIAMax(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranQuadIAMin(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranQuadSkew(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranQuadTaper(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranQuadWarp(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranTetraAR(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranTetraDetJ(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranTetraEPIA(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranTetraEPLR(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranTriaAR(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranTriaEPLR(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranTriaIAMax(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranTriaSkew(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def NastranWarping(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def SetModelDefaults(self) -> Any:
        """
        **Description:**
            This method update the quality flags and limit values of the Model with the values stored in the current Quality Object properties
        **Remarks/Usage:**

        **Return Code:** False\n
        """
        ...

    def Skew(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def Taper(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def TetCollapse(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def Warping(self, nElemSet, dLimitVal) -> Any:
        """
        **Description:**
            This method takes a element or set of elements and checks their quality against a limit value. A Femap Sort object is returned that contains the elements that have failed the check and their quality.
        **Remarks/Usage:**

        **Input:**
            **nElemSet:** The ID of a set that contains the IDs of elements to check. Specify a negative number to check a single element.\n
            **dLimitVal:** Limit value for check.\n
        **Return Code:** False\n
        :type nElemSet: int

        :type dLimitVal: float

        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            This method resets all check flags and clears all quality limit values.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...


class StressLinear:
    CLSID: Any
    bFullStressTensor: Any
    bNonlinearMode: Any
    dBendingStress: Any
    dMaxMemBend: Any
    dMaxStress: Any
    dMembraneStress: Any
    nElemType: Any
    nStressMode: Any
    ndID1: Any
    ndID2: Any
    ouSetID: Any

    def CalcSolidPrinStresses(self, vStressTensorIn, vPrinTrescaData) -> Any:
        """
        :type vStressTensorIn: Any
        :type vPrinTrescaData: Any
        """
        ...

    def CalcStressLinearization(self) -> Any:
        """
        **Description:**
            Calculates the ASME Stress Linearization, if successful, with a return code of FE_OK, the Calculated Stress Output values on the StressLinear Object will be updated
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Transform3DStress(self, cSysFromID, cSysToID, vStressTensorIn, vStressTensorOut) -> Any:
        """
        :type cSysFromID: Any
        :type cSysToID: Any
        :type vStressTensorIn: Any
        :type vStressTensorOut: Any
        """
        ...

    def clear(self) -> Any:
        """
        """
        ...


class DBase:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, ID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **ID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type ID: int

        """
        ...

    def Delete(self, ID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **ID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type ID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, ID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **ID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type ID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, ID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **ID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type ID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
            Calling this method with bIncludedID=False, is the same as calling GetTitleList( )
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, ID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **ID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type ID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class AnalysisCase:
    CLSID: Any
    AbaHistAnalysisType: Any
    AbaHistAutoContact: Any
    AbaHistEigenvectors: Any
    AbaHistInitTimeInc: Any
    AbaHistLinearPert: Any
    AbaHistMaxFreq: Any
    AbaHistMaxTimeInc: Any
    AbaHistMinFreq: Any
    AbaHistMinTimeInc: Any
    AbaHistNonlinGeom: Any
    AbaHistOn: Any
    AbaHistOutInterval: Any
    AbaHistOutZeroInc: Any
    AbaHistScaleFactor: Any
    AbaHistShiftFreq: Any
    AbaHistStabilize: Any
    AbaHistStepAmp: Any
    AbaHistStepConstr: Any
    AbaHistStepLoad: Any
    AbaHistTimePeriod: Any
    Active: Any
    AnsArclen: Any
    AnsAutots: Any
    AnsBisect: Any
    AnsBisectfactor: Any
    AnsBuckleLdmulte: Any
    AnsBuckleMethod: Any
    AnsBuckleNmode: Any
    AnsBuckleOptOn: Any
    AnsBuckleRangekey: Any
    AnsBuckleShift: Any
    AnsBuckleStrmck: Any
    AnsCnvtolDvol: Any
    AnsCnvtolF: Any
    AnsCnvtolHdsp: Any
    AnsCnvtolM: Any
    AnsCnvtolRot: Any
    AnsCnvtolU: Any
    AnsCrplimit: Any
    AnsCrplimitvalue: Any
    AnsDOFAutomatic: Any
    AnsDOFDoSet: Any
    AnsDOFNoRotation: Any
    AnsDOFNumber: Any
    AnsDOFOn: Any
    AnsDOFSetID: Any
    AnsDpplimit: Any
    AnsDpplimitvalue: Any
    AnsDsplimit: Any
    AnsDsplimitvalue: Any
    AnsDtime: Any
    AnsDtmax: Any
    AnsDtmin: Any
    AnsDvoltoler: Any
    AnsEqslv: Any
    AnsFtoler: Any
    AnsHarmonicClust: Any
    AnsHarmonicFreqb: Any
    AnsHarmonicFreqe: Any
    AnsHarmonicLogopt: Any
    AnsHarmonicMaxmode: Any
    AnsHarmonicMethod: Any
    AnsHarmonicMinmode: Any
    AnsHarmonicOptOn: Any
    AnsHarmonicReimky: Any
    AnsHdsptoler: Any
    AnsHeatEndTime: Any
    AnsHeatOn: Any
    AnsHeatOutputFreq: Any
    AnsHeatTimeStep: Any
    AnsKbc: Any
    AnsLdstepOn: Any
    AnsLnsrch: Any
    AnsMidtol: Any
    AnsModalBlocksize: Any
    AnsModalCompute: Any
    AnsModalFreqb: Any
    AnsModalFreqe: Any
    AnsModalMethod: Any
    AnsModalNmode: Any
    AnsModalNrmkey: Any
    AnsModalOptOn: Any
    AnsModalRangefact: Any
    AnsModalReusekey: Any
    AnsModalRobustlev: Any
    AnsModalStrmck: Any
    AnsModalSymmeth: Any
    AnsModesElemResults: Any
    AnsModesMaxFreq: Any
    AnsModesMinFreq: Any
    AnsModesModalMethod: Any
    AnsModesNumModes: Any
    AnsModesOn: Any
    AnsMtoler: Any
    AnsNeqit: Any
    AnsNewConstraint: Any
    AnsNewContact: Any
    AnsNewLoad: Any
    AnsNlOptOn: Any
    AnsNlgeom: Any
    AnsNropt: Any
    AnsNsbmn: Any
    AnsNsbmx: Any
    AnsNsbstep: Any
    AnsNsubs: Any
    AnsOutprAcc: Any
    AnsOutprAccFreq: Any
    AnsOutprAccNth: Any
    AnsOutprAll: Any
    AnsOutprAllFreq: Any
    AnsOutprAllNth: Any
    AnsOutprBasic: Any
    AnsOutprBasicFreq: Any
    AnsOutprBasicNth: Any
    AnsOutprEsol: Any
    AnsOutprEsolFreq: Any
    AnsOutprEsolNth: Any
    AnsOutprNsol: Any
    AnsOutprNsolFreq: Any
    AnsOutprNsolNth: Any
    AnsOutprRsol: Any
    AnsOutprRsolFreq: Any
    AnsOutprRsolNth: Any
    AnsOutprVel: Any
    AnsOutprVelFreq: Any
    AnsOutprVelNth: Any
    AnsOutputOn: Any
    AnsOutresAcc: Any
    AnsOutresAccFreq: Any
    AnsOutresAccNth: Any
    AnsOutresAll: Any
    AnsOutresAllFreq: Any
    AnsOutresAllNth: Any
    AnsOutresBasic: Any
    AnsOutresBasicFreq: Any
    AnsOutresBasicNth: Any
    AnsOutresEsol: Any
    AnsOutresEsolFreq: Any
    AnsOutresEsolNth: Any
    AnsOutresNsol: Any
    AnsOutresNsolFreq: Any
    AnsOutresNsolNth: Any
    AnsOutresRsol: Any
    AnsOutresRsolFreq: Any
    AnsOutresRsolNth: Any
    AnsOutresVel: Any
    AnsOutresVelFreq: Any
    AnsOutresVelNth: Any
    AnsPlslimit: Any
    AnsPlslimitvalue: Any
    AnsPred: Any
    AnsPredictor: Any
    AnsPstres: Any
    AnsResfq: Any
    AnsRottoler: Any
    AnsTime: Any
    AnsTimestepOn: Any
    AnsTolerb: Any
    AnsTransAlpha: Any
    AnsTransAlphad: Any
    AnsTransAlphaf: Any
    AnsTransAlpham: Any
    AnsTransBetad: Any
    AnsTransDelta: Any
    AnsTransDmprat: Any
    AnsTransDmpsfreq: Any
    AnsTransDmpstr: Any
    AnsTransGamma: Any
    AnsTransGammavalue: Any
    AnsTransLumpm: Any
    AnsTransMaxmode: Any
    AnsTransMethod: Any
    AnsTransMinmode: Any
    AnsTransOptOn: Any
    AnsTransTintopt: Any
    AnsUtoler: Any
    CaseLabel: Any
    CaseTitle: Any
    CaseType: Any
    ContactOption: Any
    ContactSetType: Any
    CornerOutput: Any
    Destination: Any
    DynHistBodyLoadGrp: Any
    DynHistGroupHistId: Any
    DynHistImplicit: Any
    DynHistMassDampOn: Any
    DynHistMsssDamp: Any
    DynHistOn: Any
    DynHistPlateIntgPts: Any
    DynHistPrintHistOutput: Any
    DynHistSpringback: Any
    DynHistStrainOutput: Any
    DynHistTimeHistOuput: Any
    DynHistTotalTime: Any
    Echo: Any
    EndText: Any
    ID: Any
    Imaginary: Any
    IntegrationOutput: Any
    MarCtblOn: Any
    MarCtblWrite: Any
    MarHistAnalCaseSol: Any
    MarHistAutoSwitch: Any
    MarHistBuckleNumModes: Any
    MarHistBucklePosEigen: Any
    MarHistChecking: Any
    MarHistContactProp: Any
    MarHistConvergeMeth: Any
    MarHistCtrlMaxRecycle: Any
    MarHistCtrlMaxStep: Any
    MarHistCtrlMethod: Any
    MarHistCtrlMinRecycle: Any
    MarHistMaxResidual: Any
    MarHistModalEigen: Any
    MarHistModalMaxFreq: Any
    MarHistModalMinFreq: Any
    MarHistNonPosDefinite: Any
    MarHistNonSymmetric: Any
    MarHistOn: Any
    MarHistSolverMeth: Any
    MarIncArcLenMeth: Any
    MarIncCtrlMaxRecycle: Any
    MarIncFracFirst: Any
    MarIncInitTimeInc: Any
    MarIncMaxFracForAll: Any
    MarIncMaxNumInc: Any
    MarIncMaxStep: Any
    MarIncMaxTimeInc: Any
    MarIncMinTimeInc: Any
    MarIncNumOutInc: Any
    MarIncOn: Any
    MarIncQuasiStatDamp: Any
    MarIncScaleFact: Any
    MarIncTimePeriod: Any
    MarIncTotalTime: Any
    NasCaeDynPressure: Any
    NasCaeMachNumber: Any
    NasCaeOn: Any
    NasCaeRigidTrim: Any
    NasCaeWrtieTrim: Any
    NasCaseAlternateTextLocation: Any
    NasCaseMonitorAeroEnabled: Any
    NasCaseMonitorEnabled: Any
    NasCaseMonitorLoadEnabled: Any
    NasCflDenID: Any
    NasCflEig: Any
    NasCflEps: Any
    NasCflFliMethod: Any
    NasCflMachFactID: Any
    NasCflMethod: Any
    NasCflOn: Any
    NasCflRfreqFactID: Any
    NasCflSdampID: Any
    NasCflWriteFlutter: Any
    NasCnlArcConstraintType: Any
    NasCnlArcDesiredIter: Any
    NasCnlArcLoadScale: Any
    NasCnlArcMaxAdjust: Any
    NasCnlArcMaxSteps: Any
    NasCnlArcMinAdjust: Any
    NasCnlBoundsRb: Any
    NasCnlCreep: Any
    NasCnlCtiffnessMethod: Any
    NasCnlDivergenceLimit: Any
    NasCnlDominantPeriodSteps: Any
    NasCnlFstress: Any
    NasCnlIncrements: Any
    NasCnlIntermediateOutput: Any
    NasCnlKstep: Any
    NasCnlLineSearchTolerance: Any
    NasCnlMaxAdjust: Any
    NasCnlMaxBisections: Any
    NasCnlMaxIter: Any
    NasCnlMaxLineSearch: Any
    NasCnlMaxRotation: Any
    NasCnlModnewtonBisection: Any
    NasCnlModnewtonLineSearch: Any
    NasCnlModnewtonQuasiNewton: Any
    NasCnlOn: Any
    NasCnlOutputInterval: Any
    NasCnlQuasiNewtonVectors: Any
    NasCnlSkipNLPARM: Any
    NasCnlSolutionOverrides: Any
    NasCnlSolutionStrategy: Any
    NasCnlStabilityTolerance: Any
    NasCnlStiffnessMethod: Any
    NasCnlTimeSkipAdjust: Any
    NasCnlTime_Increment: Any
    NasCnlUseLoadSet: Any
    NasCnlkDAMP: Any
    NasCnlkUPDATE: Any
    NasCurvatureStrain: Any
    NasDMIGB2GG: Any
    NasDMIGB2PP: Any
    NasDMIGK2GG: Any
    NasDMIGK2PP: Any
    NasDMIGK42GG: Any
    NasDMIGM2GG: Any
    NasDMIGM2PP: Any
    NasDMIGP2G: Any
    NasEnableDMIG: Any
    NasInlStepOptADJUST: Any
    NasInlStepOptCREEP: Any
    NasInlStepOptCTRLDEF: Any
    NasInlStepOptConvA: Any
    NasInlStepOptConvN: Any
    NasInlStepOptConvP: Any
    NasInlStepOptConvU: Any
    NasInlStepOptConvV: Any
    NasInlStepOptConvW: Any
    NasInlStepOptDAMP: Any
    NasInlStepOptDTINITF: Any
    NasInlStepOptDTINITFA: Any
    NasInlStepOptDTMAXF: Any
    NasInlStepOptDTMINF: Any
    NasInlStepOptEPSP: Any
    NasInlStepOptEPSU: Any
    NasInlStepOptEPSW: Any
    NasInlStepOptEnableCriteria: Any
    NasInlStepOptFSTRESS: Any
    NasInlStepOptGroupIDs: Any
    NasInlStepOptID: Any
    NasInlStepOptIDAMP: Any
    NasInlStepOptINTOUT: Any
    NasInlStepOptIPHYS: Any
    NasInlStepOptIncrements: Any
    NasInlStepOptKMETHOD: Any
    NasInlStepOptKSTEP: Any
    NasInlStepOptLIMTAR: Any
    NasInlStepOptLSTOL: Any
    NasInlStepOptLoadStepping: Any
    NasInlStepOptMAXALR: Any
    NasInlStepOptMAXBIS: Any
    NasInlStepOptMAXITER: Any
    NasInlStepOptMAXLS: Any
    NasInlStepOptMAXQN: Any
    NasInlStepOptMECH: Any
    NasInlStepOptMINALR: Any
    NasInlStepOptMINITER: Any
    NasInlStepOptMRCONV: Any
    NasInlStepOptMSTEP: Any
    NasInlStepOptMT1_i: Any
    NasInlStepOptMT2_i: Any
    NasInlStepOptMT3_i: Any
    NasInlStepOptMT4_i: Any
    NasInlStepOptNDESIR: Any
    NasInlStepOptNDESIRA: Any
    NasInlStepOptNINC: Any
    NasInlStepOptNO: Any
    NasInlStepOptNSMAX: Any
    NasInlStepOptNSMAXA: Any
    NasInlStepOptOn: Any
    NasInlStepOptRB: Any
    NasInlStepOptRBIG: Any
    NasInlStepOptRSMALL: Any
    NasInlStepOptSCALEA: Any
    NasInlStepOptSFACT: Any
    NasInlStepOptSkipNLSTEP: Any
    NasInlStepOptTOTTIM: Any
    NasInlStepOptTYPE: Any
    NasInlStepOptUTOL: Any
    NasInlStepOptYT1_i: Any
    NasInlStepOptYT2_i: Any
    NasInlStepOptYT3_i: Any
    NasInlStepOptYT4_i: Any
    NasModeDampOverall: Any
    NasModeDesiredRoots: Any
    NasModeEigrSet: Any
    NasModeEstRoots: Any
    NasModeMassForm: Any
    NasModeMethod: Any
    NasModeNormDOF: Any
    NasModeNormNode: Any
    NasModeNormOpt: Any
    NasModeOn: Any
    NasModeSolutionType: Any
    NasModeXYOn: Any
    NasModeXYRefNode: Any
    NasModesComplexConverge: Any
    NasModesComplexRegionWidth: Any
    NasModesSkipEigr: Any
    NasMsnlArcLenConstr: Any
    NasMsnlArcLenDIter: Any
    NasMsnlArcLenInitLdfac: Any
    NasMsnlArcLenMaxAlr: Any
    NasMsnlArcLenMaxR: Any
    NasMsnlArcLenMinAlr: Any
    NasMsnlArcLenMxInc: Any
    NasMsnlArcLenMxLdfac: Any
    NasMsnlArcLenOn: Any
    NasMsnlArcLenScale: Any
    NasMsnlArcLenSkipFac: Any
    NasMsnlCntALFA: Any
    NasMsnlCntAutotim: Any
    NasMsnlCntBETA: Any
    NasMsnlCntCntmdiv: Any
    NasMsnlCntCrcerat: Any
    NasMsnlCntCrcinc: Any
    NasMsnlCntCreep: Any
    NasMsnlCntCricoff: Any
    NasMsnlCntCrinfac: Any
    NasMsnlCntCrmfmn: Any
    NasMsnlCntCrmfmx: Any
    NasMsnlCntCrteabs: Any
    NasMsnlCntCrterel: Any
    NasMsnlCntDtinit: Any
    NasMsnlCntDtmax: Any
    NasMsnlCntDtmin: Any
    NasMsnlCntDtsbcdt: Any
    NasMsnlCntEpsbolt: Any
    NasMsnlCntEqmfmin: Any
    NasMsnlCntEqmfmx: Any
    NasMsnlCntFollowk: Any
    NasMsnlCntFsymtol: Any
    NasMsnlCntGAMA: Any
    NasMsnlCntINACCN: Any
    NasMsnlCntINERTIA: Any
    NasMsnlCntItrbolt: Any
    NasMsnlCntKsym: Any
    NasMsnlCntKsymtol: Any
    NasMsnlCntKupdate: Any
    NasMsnlCntLOADOFF: Any
    NasMsnlCntLvar: Any
    NasMsnlCntMSFAC: Any
    NasMsnlCntMSTAB: Any
    NasMsnlCntMaxbis: Any
    NasMsnlCntMaxdiv: Any
    NasMsnlCntMaxiter: Any
    NasMsnlCntMaxqn: Any
    NasMsnlCntMisfblt: Any
    NasMsnlCntMsglvl: Any
    NasMsnlCntMsglvlb: Any
    NasMsnlCntMsglvlc: Any
    NasMsnlCntNORMP: Any
    NasMsnlCntNORMU: Any
    NasMsnlCntOn: Any
    NasMsnlCntPLSHUT: Any
    NasMsnlCntPlastic: Any
    NasMsnlCntQuasiNewtonIter: Any
    NasMsnlCntREFP: Any
    NasMsnlCntREFU: Any
    NasMsnlCntRFVAR: Any
    NasMsnlCntRHOINF: Any
    NasMsnlCntSkipNLCNTL: Any
    NasMsnlCntSolver: Any
    NasMsnlCntSpink: Any
    NasMsnlCntStfoptn: Any
    NasMsnlCntStressk: Any
    NasMsnlCntTETA: Any
    NasMsnlCntTINTMTH: Any
    NasMsnlCntThrmst: Any
    NasMsnlCntTsccr: Any
    NasMsnlCntTsceq: Any
    NasMsnlCntTscumat: Any
    NasMsnlCntTstepk: Any
    NasMsnlCntTvar: Any
    NasMsnlCntUmfmin: Any
    NasMsnlCntUmfmx: Any
    NasMsnlCntUsolver: Any
    NasMsnlCntZerbolt: Any
    NasMsnlCntdCrteco: Any
    NasMsnlModalMassForm: Any
    NasMsnlTSEndTime: Any
    NasMsnlTSNumIncrements: Any
    NasMsnlTSOn: Any
    NasMsnlTSOutputFreq: Any
    NasMsnlTSSkipFactor: Any
    NasMsnlTSSkipTSTEP: Any
    NasMsnlkCnt2ALFA: Any
    NasMsnlkCnt2AMAX: Any
    NasMsnlkCnt2AMIN: Any
    NasMsnlkCnt2AUTOTIM: Any
    NasMsnlkCnt2BETA: Any
    NasMsnlkCnt2CIBL: Any
    NasMsnlkCnt2CREEP: Any
    NasMsnlkCnt2CRINFAC: Any
    NasMsnlkCnt2DCON: Any
    NasMsnlkCnt2DEFLIM: Any
    NasMsnlkCnt2DIPR: Any
    NasMsnlkCnt2DISLIM: Any
    NasMsnlkCnt2DTI0: Any
    NasMsnlkCnt2DTINIT: Any
    NasMsnlkCnt2DTMAX: Any
    NasMsnlkCnt2DTMIN: Any
    NasMsnlkCnt2EQMFMIN: Any
    NasMsnlkCnt2EQMFMX: Any
    NasMsnlkCnt2ERCD: Any
    NasMsnlkCnt2GAMA: Any
    NasMsnlkCnt2HMAX: Any
    NasMsnlkCnt2HMIN: Any
    NasMsnlkCnt2HPRCO: Any
    NasMsnlkCnt2IAR0: Any
    NasMsnlkCnt2ILNS: Any
    NasMsnlkCnt2IMPG: Any
    NasMsnlkCnt2IMPL: Any
    NasMsnlkCnt2IMPR: Any
    NasMsnlkCnt2IMPV: Any
    NasMsnlkCnt2INERTIA: Any
    NasMsnlkCnt2IT1K: Any
    NasMsnlkCnt2IT2K: Any
    NasMsnlkCnt2IT3K: Any
    NasMsnlkCnt2ITEREF: Any
    NasMsnlkCnt2ITMA: Any
    NasMsnlkCnt2LVAR: Any
    NasMsnlkCnt2MADI: Any
    NasMsnlkCnt2MATSYM: Any
    NasMsnlkCnt2NORM: Any
    NasMsnlkCnt2OTRE: Any
    NasMsnlkCnt2PLAS: Any
    NasMsnlkCnt2PLASTIC: Any
    NasMsnlkCnt2PLSHUT: Any
    NasMsnlkCnt2PRCE: Any
    NasMsnlkCnt2PRCF: Any
    NasMsnlkCnt2PRCO: Any
    NasMsnlkCnt2PRCQ: Any
    NasMsnlkCnt2PRCR: Any
    NasMsnlkCnt2PRCS: Any
    NasMsnlkCnt2PRED: Any
    NasMsnlkCnt2PRLN: Any
    NasMsnlkCnt2RDOW: Any
    NasMsnlkCnt2REFE: Any
    NasMsnlkCnt2REFP: Any
    NasMsnlkCnt2REFU: Any
    NasMsnlkCnt2RELC: Any
    NasMsnlkCnt2RJPN: Any
    NasMsnlkCnt2RJPZ: Any
    NasMsnlkCnt2ROTLIM: Any
    NasMsnlkCnt2RSUB: Any
    NasMsnlkCnt2RUP: Any
    NasMsnlkCnt2STAB: Any
    NasMsnlkCnt2TETA: Any
    NasMsnlkCnt2TINTMTH: Any
    NasMsnlkCnt2TSDYN: Any
    NasMsnlkCnt2TSVSC: Any
    NasMsnlkCnt2TVAR: Any
    NasMsnlkCnt2VSCOSN: Any
    NasMsnlkCnt2VSCOTE: Any
    NasMsnlkCnt2bSkipNLCNTL2: Any
    NasMsnlkCnt2on: Any
    NasOmodes: Any
    NasOmodesOn: Any
    NasRelEMotion: Any
    NasSELoad: Any
    NasStatsubBuckle: Any
    NasStatsubOn: Any
    NasStatsubPreload: Any
    SetID: Any
    SkipStandard: Any
    StartText: Any
    SubcaseAnalysisType: Any
    caseID: Any
    vBCSet: Any
    vMSCNasCnlConvergenceFlags: Any
    vNasCnlConvergenceFlags: Any
    vNasCnlConvergenceValue: Any
    vNasModeFreqRange: Any
    vNasModeImagFreqRange: Any
    vNasModeXYRequest: Any
    vNasMsnlCntConv_flags: Any
    vNasMsnlCntConv_value: Any
    vOutput: Any

    def ALPHAD(self, alpha) -> Any:
        """
        **Description:**
            This method sets the Mass value (Damping) on ANSYS Transient Analysis dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **alpha:** Mass value (Damping)\n
        **Return Code:** False\n
        :type alpha: float

        """
        ...

    def ARCLEN(self, key) -> Any:
        """
        **Description:**
            This method sets the Arc-Length option on ANSYS Nonlinear dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, enables Arc-Length option\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def AUTOTS(self, key) -> Any:
        """
        **Description:**
            This method sets the Automatic Time Stepping (AUTOTS) option on ANSYS Load Step Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, enables Automatic Time Stepping (AUTOTS) option\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def ActiveContactEntities(self, bContact, nConnectorSetID, nRegionSetID, nConPropSetID) -> Any:
        """
        **Description:**
            This method is used to populate Set Objects with the Connectors, Connection Regions, and Connection Properties that will be exported for Contact or Glue Contact by an analysis case. This method takes into consideration the settings in the Contact Sets or Glue Sets section of the Boundary Conditions dialog box for Simcenter SOL 401/402 or setting for Contact/Glue Sets of the Boundary Conditions dialog box for MSC Nastran
        **Remarks/Usage:**
            It is important to use three uniques Set Objects when using this method, otherwise the IDs of different entity types may contaminate a Set. Also, it is recommend to use empty sets to insure that only the Connection entities from a single analysis case populate the three sets.
        **Input:**
            **bContact:** If True, populates sets with connection entities for Contact. If False, populates sets with connection entities for Glued Contact\n
            **nConnectorSetID:** Set ID of Set Object to populate with Connectors which will be exported by this analysis case\n
            **nRegionSetID:** Set ID of Set Object to populate with Connection Regions which will be exported by this analysis case\n
            **nConPropSetID:** Set ID of Set Object to populate with Connection Properties which will be exported by this analysis case\n
        **Return Code:** False\n
        :type bContact: bool

        :type nConnectorSetID: int

        :type nRegionSetID: int

        :type nConPropSetID: int

        """
        ...

    def AllFreqOff(self) -> Any:
        """
        """
        ...

    def AllFreqOn(self) -> Any:
        """
        """
        ...

    def BCSet(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def BETAD(self, beta) -> Any:
        """
        **Description:**
            This method sets the Stiffness value (Damping) on ANSYS Transient Analysis dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **beta:** Stiffness value (Damping)\n
        **Return Code:** False\n
        :type beta: float

        """
        ...

    def BUCOPT(self, method, nMode, shift, ldmulte, rangekey) -> Any:
        """
        :type method: Any
        :type nMode: Any
        :type shift: Any
        :type ldmulte: Any
        :type rangekey: Any
        """
        ...

    def CNVTOL(self, lab, value, toler) -> Any:
        """
        :type lab: Any
        :type value: Any
        :type toler: Any
        """
        ...

    def CUTCONTROL(self, lab, value) -> Any:
        """
        :type lab: Any
        :type value: Any
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def DELTIM(self, dtime, dtmin, dtmax) -> Any:
        """
        :type dtime: Any
        :type dtmin: Any
        :type dtmax: Any
        """
        ...

    def DMPRAT(self, rat) -> Any:
        """
        **Description:**
            This method sets the Ratio value (Damping) on ANSYS Transient Analysis dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **rat:** Ratio value (Damping)\n
        **Return Code:** False\n
        :type rat: float

        """
        ...

    def DMPSTR(self, dmp) -> Any:
        """
        **Description:**
            This method sets the Struct value (Damping) on ANSYS Transient Analysis dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **dmp:** Struct value (Damping)\n
        **Return Code:** False\n
        :type dmp: float

        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteAnalysisCase(self, nSetID, nCaseID) -> Any:
        """
        **Description:**
            Use this method to delete an analysis case.
        **Remarks/Usage:**
            This method takes care of deleting any start/end text or Marc contact table records that referenced the case.
        **Input:**
            **nSetID:** The Analysis SetID containing the case to be deleted\n
            **nCaseID:** The Case ID to be deleted\n
        **Return Code:** False\n
        :type nSetID: int

        :type nCaseID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def DeleteStep(self, entID) -> Any:
        """
        **Description:**
            Use this method to delete an analysis step.
        **Remarks/Usage:**

        **Input:**
            **entID:** The Analysis Step to be deleted\n
        **Return Code:** False\n
        :type entID: int

        """
        ...

    def EQSLV(self, lab) -> Any:
        """
        :type lab: Any
        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetContactTable(self, Count, rowSeg, colSeg, tieType, distTol, sepForce, friction, interClose) -> Any:
        """
        **Description:**
            This method retrieves data from the Contact Table.
        **Remarks/Usage:**
            None
        **Output:**
            **Count:** The number of entries in each of the other vectors.\n
            **rowSeg:** The IDs of the contact segments referenced in rows of the table\n
            **colSeg:** The IDs of the contact segments referenced in columns of the table\n
            **tieType:** The tying type (0,1=None, 2=Touch, 3=Glue)\n
            **distTol:** The distance tolerance\n
            **sepForce:** The separation force\n
            **friction:** The friction values\n
            **interClose:** The interference closure\n
        **Return Code:** False\n
        :type Count: int

        :type rowSeg: tuple[int]

        :type colSeg: tuple[int]

        :type tieType: tuple[int]

        :type distTol: tuple[float]

        :type sepForce: tuple[float]

        :type friction: tuple[float]

        :type interClose: tuple[float]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetOptLimits(self, nSetID, bClear) -> Any:
        """
        **Description:**
            Gets Optimization Limits (Optimization Response objects) enabled for an analysis case
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of Set Object to be populated\n
            **bClear:** Clear existing entities\n
        **Return Code:** False\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def GetStandardTrim(self, useTrim, TrimID, TrimVal) -> Any:
        """
        **Description:**
            This method retrieves data from the standard trim definition.
        **Remarks/Usage:**
            Valid TrimID values:
        **Output:**
            **useTrim:** 0=Off,1=Use, 2= Fixed. See Remarks for array index value\n
            **TrimID:** Not currently used\n
            **TrimVal:** Magnitude value when UseTrim[i] = Fixed. See Remarks for array index value\n
        **Return Code:** False\n
        :type useTrim: tuple[int]

        :type TrimID: tuple[int]

        :type TrimVal: tuple[float]

        """
        ...

    def GetStep(self, entID) -> Any:
        """
        **Description:**
            This method creates and returns an AnalysisStep object that is loaded with the options referenced by an analysis step.
        **Remarks/Usage:**
            The current AnalysisCase object must be loaded with the data from the case that contains the step that you want to retrieve. The AnalysisCase.ID property is used to define the case that you want to retrieve.
        **Return Code:** False\n
        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID,:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTrimControlSurf(self, useTrim, TrimID, TrimVal) -> Any:
        """
        **Description:**
            This method retrieves data from the trim definition for user defined Aero Control Surfaces
        **Remarks/Usage:**

        **Output:**
            **useTrim:** 0=Off,1=Use, 2= Fixed\n
            **TrimID:** ID of the Femap Aero Control Surface Entity\n
            **TrimVal:** magnitude\n
        **Return Code:** False\n
        :type useTrim: tuple[int]

        :type TrimID: tuple[int]

        :type TrimVal: tuple[float]

        """
        ...

    def GetUsedFREQS(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def HARFRQ(self, freqb, freqe, logopt) -> Any:
        """
        :type freqb: Any
        :type freqe: Any
        :type logopt: Any
        """
        ...

    def HROPT(self, method, maxmode, minmode) -> Any:
        """
        :type method: Any
        :type maxmode: Any
        :type minmode: Any
        """
        ...

    def HROUT(self, reimky, clust) -> Any:
        """
        :type reimky: Any
        :type clust: Any
        """
        ...

    def InitAnalysisCase(self, nSetID, nCaseID) -> Any:
        """
        **Description:**
            This method initializes the default values for an analysis case
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** The Analysis SetID containing the case to be initialized\n
            **nCaseID:** The Case ID to be initialized\n
        **Return Code:** False\n
        :type nSetID: int

        :type nCaseID: int

        """
        ...

    def KBC(self, key) -> Any:
        """
        **Description:**
            This method sets the Amplitude (KBC) option on ANSYS Load Step Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, enables Amplitude (KBC) option\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def LANBOPTION(self, strmck) -> Any:
        """
        **Description:**
            This method sets the Strum Sequence Check option on ANSYS Modal Analysis dialog box for use the Block Lanczos mode extraction method
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def LNSRCH(self, key) -> Any:
        """
        **Description:**
            This method sets the Line Search option on ANSYS Nonlinear dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, enables Line Search option\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def LUMPM(self, key) -> Any:
        """
        **Description:**
            This method sets the Lumper option on ANSYS Transient Dynamics dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, enables Lumped option\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def MIDTOL(self, key, tolerb, resfq) -> Any:
        """
        :type key: Any
        :type tolerb: Any
        :type resfq: Any
        """
        ...

    def MODOPT(self, method, nMode, freqb, freqe, cpxmod, nrmkey) -> Any:
        """
        :type method: Any
        :type nMode: Any
        :type freqb: Any
        :type freqe: Any
        :type cpxmod: Any
        :type nrmkey: Any
        """
        ...

    def MSCNasCnlConvergenceFlags(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NEQIT(self, NEQIT) -> Any:
        """
        **Description:**
            This method sets the Max Iterations value on ANSYS Nonlinear dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **NEQIT:** Max Iterations value\n
        **Return Code:** False\n
        :type NEQIT: int

        """
        ...

    def NLGEOM(self, key) -> Any:
        """
        **Description:**
            This method sets the Nonlinear Geometry option on ANSYS Nonlinear dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, enables Nonlinear Geometry option\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def NROPT(self, option1) -> Any:
        """
        :type option1: Any
        """
        ...

    def NSUBST(self, nsbst, nsbmx, nsbmn) -> Any:
        """
        :type nsbst: Any
        :type nsbmx: Any
        :type nsbmn: Any
        """
        ...

    def NasCnlConvergenceFlags(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasCnlConvergenceValue(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasModeFreqRange(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasModeImagFreqRange(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasModeXYRequest(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasSubseqCase(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasSubseqFactor(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def OUTPR(self, item, FREQ, nth, cname) -> Any:
        """
        :type item: Any
        :type FREQ: Any
        :type nth: Any
        :type cname: Any
        """
        ...

    def OUTRES(self, item, FREQ, nth, cname) -> Any:
        """
        :type item: Any
        :type FREQ: Any
        :type nth: Any
        :type cname: Any
        """
        ...

    def Output(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def PCGOPT(self, strmck) -> Any:
        """
        **Description:**
            This method sets the Strum Sequence Check option on ANSYS Modal Analysis dialog box for the PCG Lanczos mode extraction method
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def PFACT(self, tblno, excit) -> Any:
        """
        **Description:**
            This method sets the PSD table on the ANSYS Random Vibration Analysis Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **tblno:** ID of the function, 0=DISP, 1=VEL, 2=ACEL (Acc2/Hz), 3=ACCG (g2/Hz), 4=FORC, 5=PRES.\n
            **excit:** Sets the Mode Factors, True = Node, False = Base.\n
        **Return Code:** False\n
        :type tblno: int

        :type excit: bool

        """
        ...

    def PRED(self, sskey) -> Any:
        """
        **Description:**
            This method sets the Predictor option on ANSYS Nonlinear dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **sskey:** When True, enables Predictor option\n
        **Return Code:** False\n
        :type sskey: bool

        """
        ...

    def PSDCOM(self, signif, comode, forcetype) -> Any:
        """
        **Description:**
            This method sets the Mode Combinations options on the ANSYS Random Vibration Analysis Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **signif:** Sets the Significance value. \n
        **Return Code:** False\n
        :type signif: float

        """
        ...

    def PSDUNIT(self, tblno, type) -> Any:
        """
        **Description:**
            This method sets the PSD table on the ANSYS Random Vibration Analysis Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **tblno:** ID of the function, 0=DISP, 1=VEL, 2=ACEL (Acc2/Hz), 3=ACCG (g2/Hz), 4=FORC, 5=PRES.\n
            **type:** Specifies the PSD type.\n
        **Return Code:** False\n
        :type tblno: int

        :type type: int

        """
        ...

    def PSTRES(self, key) -> Any:
        """
        **Description:**
            This method sets the Include Prestress Effects (PSTRES) option on ANSYS Load Step Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, enables Include Prestress Effects (PSTRES) option\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutContactTable(self, Count, rowSeg, colSeg, tieType, distTol, sepForce, friction, interClose) -> Any:
        """
        **Description:**
            This method replaces data in the Contact Table
        **Remarks/Usage:**
            This function completely replaces the contact table - it does not add to data that is already there.
        **Input:**
            **Count:** The number of entries in each of the other vectors.\n
            **rowSeg:** The IDs of the contact segments referenced in rows of the table\n
            **colSeg:** The IDs of the contact segments referenced in columns of the table\n
            **tieType:** The tying type (0,1=None, 2=Touch, 3=Glue)\n
            **distTol:** The distance tolerance\n
            **sepForce:** The separation force\n
            **friction:** The friction values\n
            **interClose:** The interference closure\n
        **Return Code:** False\n
        :type Count: int

        :type rowSeg: tuple[int]

        :type colSeg: tuple[int]

        :type tieType: tuple[int]

        :type distTol: tuple[float]

        :type sepForce: tuple[float]

        :type friction: tuple[float]

        :type interClose: tuple[float]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def PutOptLimits(self, nSetID, bClear) -> Any:
        """
        **Description:**
            Sets Optimization Limits (Optimization Response objects) enabled for an analysis case
        **Remarks/Usage:**

        **Input:**
            **nSetID:** ID of Set Object containing Optimization Limits (Response) IDs. Alternatively, specify a negative number to put a single optimization variable\n
            **bClear:** Clear existing entities\n
        **Return Code:** False\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def PutStandardTrim(self, useTrim, TrimID, TrimVal) -> Any:
        """
        **Description:**
            This method loads standard trim data into the trim definition.
        **Remarks/Usage:**
            Valid index values:
        **Input:**
            **useTrim:** 0=Off, 1=Use, 2= Fixed. See Remarks for array index value\n
            **TrimID:** Not currently used\n
            **TrimVal:** Magnitude value when UseTrim[i] = Fixed. See Remarks for array index value\n
        **Return Code:** False\n
        :type useTrim: tuple[int]

        :type TrimID: tuple[int]

        :type TrimVal: tuple[float]

        """
        ...

    def PutStep(self, pDispatch) -> Any:
        """
        **Description:**
            Saves a fully populated AnalysisStep Object to the database
        **Remarks/Usage:**
            This can be used in conjunction with GetStep to create a fully populated AnalysisStep object, make changes to the object, then save the changes to the database.
        **Input:**
            **pDispatch:** AnalysisStep Object to save to the database\n
        **Return Code:** False\n
        :type pDispatch: Any

        """
        ...

    def PutTrimControlSurf(self, useTrim, TrimID, TrimVal) -> Any:
        """
        **Description:**
            This method loads user defined Aero Control Surface data into the Trim definition
        **Remarks/Usage:**

        **Input:**
            **useTrim:** 0=Off,1=Use, 2= Fixed\n
            **TrimID:** ID of the Femap Aero Control Surface Entity\n
            **TrimVal:** magnitude\n
        **Return Code:** False\n
        :type useTrim: tuple[int]

        :type TrimID: tuple[int]

        :type TrimVal: tuple[float]

        """
        ...

    def PutUsedFREQS(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def QRDOPT(self, reusekey, symmeth) -> Any:
        """
        :type reusekey: Any
        :type symmeth: Any
        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SNOPTION(self, rangefact, blocksize, robustlev, compute) -> Any:
        """
        :type rangefact: Any
        :type blocksize: Any
        :type robustlev: Any
        :type compute: Any
        """
        ...

    def SPOPT(self, sptype, nMode, elcalc) -> Any:
        """
        **Description:**
            This method sets the Spectrum options on ANSYS Random Vibration Analysis Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **sptype:** ID of the spectrum type option.\n
            **nMode:** Specifies the number of modes.\n
            **elcalc:** When True, Element Results is on. \n
        **Return Code:** False\n
        :type sptype: int

        :type nMode: int

        :type elcalc: bool

        """
        ...

    def SUBOPT(self, strmck) -> Any:
        """
        **Description:**
            This method sets the Strum Sequence Check option on ANSYS Modal Analysis dialog box for use the Subspace mode extraction method
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetBCSet(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetMSCNasCnlConvergenceFlags(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasCnlConvergenceFlags(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasCnlConvergenceValue(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasModeFreqRange(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasModeImagFreqRange(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasModeXYRequest(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasSubseqCase(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasSubseqFactor(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetOutput(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def TIME(self, TIME) -> Any:
        """
        **Description:**
            This method sets the Time Duration value on ANSYS Time Step Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **TIME:** Time Duration value\n
        **Return Code:** False\n
        :type TIME: float

        """
        ...

    def TINTP(self, gamma, alpha, delta, theta, oslm, tol, avsmooth, alphaf, alpham) -> Any:
        """
        :type gamma: Any
        :type alpha: Any
        :type delta: Any
        :type theta: Any
        :type oslm: Any
        :type tol: Any
        :type avsmooth: Any
        :type alphaf: Any
        :type alpham: Any
        """
        ...

    def TRNOUT(self, method, maxmode, minmode, mcout, tintopt, vaout, dmpsfreq) -> Any:
        """
        :type method: Any
        :type maxmode: Any
        :type minmode: Any
        :type mcout: Any
        :type tintopt: Any
        :type vaout: Any
        :type dmpsfreq: Any
        """
        ...

    def TurnOffFreq(self, freqID) -> Any:
        """
        :type freqID: Any
        """
        ...

    def TurnOnFreq(self, freqID) -> Any:
        """
        :type freqID: Any
        """
        ...


class Node:
    CLSID: Any
    Active: Any
    ID: Any
    NumberOfConstraints: Any
    NumberOfElements: Any
    NumberOfLoads: Any
    NumberOfMatrices: Any
    SetID: Any
    color: Any
    defCSys: Any
    layer: Any
    outCSys: Any
    superelementID: Any
    type: Any
    vpermBC: Any
    x: Any
    xyz: Any
    y: Any
    z: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetAll(self, entID, x, y, z, nlayer, nColor, ntype, defCSys, outCSys, permBC) -> Any:
        """
        **Description:**
            This method retrieves an entity with the specified ID.
        **Remarks/Usage:**
            Unlike the standard Get method, this function returns all of the properties as arguments. If you need to get all of the property data anyway, calling this will be faster than multiple calls to retrieve each property individually.
        **Input:**
            **entID:** ID of the entity to retrieve.\n
        **Output:**
            **y:** REAL8 z\n
            **z:** INT4 layer\n
            **y:** INT4 color\n
            **nColor:** INT4 type\n
            **y:** INT4 defCSys\n
            **y:** INT4 outCSys\n
            **y:** INT4 permBC[0..5]\n
            **permBC:** Return Code:\n
        **Return Code:** True\n
        :type entID: int

        :type y: float

        :type z: float

        :type y: int

        :type nColor: int

        :type y: int

        :type y: int

        :type y: int

        :type permBC: tuple[int]

        """
        ...

    def GetAllArray(self, SetID, numNode, entID, xyz, layer, color, ndType, defCSys, outCSys, permBC) -> Any:
        """
        **Description:**
            This method retrieves arrays of values for a set of nodes.
        **Remarks/Usage:**
            This method is the fastest way to retrieve information about a large number of nodes. If a retrieved node ID does not exist, then all of the values for that node ID will be 0.
        **Input:**
            **SetID:** ID of the set that contains the node IDs to retrieve. If 0, retrieve all nodes in the model.\n
        **Output:**
            **numNode:** The number of nodes for which data is being returned.\n
            **entID:** Each entry is the ID of the associated node.\n
            **xyz:** The coordinates of the node. There are 3 entries, x, y, z for each node.\n
            **layer:** The ID of the layer for the node.\n
            **color:** The color of the node.\n
            **ndType:** The type of the node.\n
            **defCSys:** The definition coordinate system of the node.\n
            **outCSys:** The output coordinate system of the node.\n
            **permBC:** Flags indicating the permanent constraints on the node. 0=off, 1=on. There are 6 entries, corresponding to the degrees of freedom for each node.\n
        **Return Code:** True\n
        :type SetID: int

        :type numNode: int

        :type entID: tuple[int]

        :type xyz: tuple[float]

        :type layer: tuple[int]

        :type color: tuple[int]

        :type ndType: tuple[int]

        :type defCSys: tuple[int]

        :type outCSys: tuple[int]

        :type permBC: tuple[int]

        """
        ...

    def GetAllArray2(self, SetID, numNode, entID, Exist, xyz, layer, color, ndType, defCSys, outCSys, permBC) -> Any:
        """
        **Description:**
            This method retrieves arrays of values for a set of nodes, including if a node exists in the database
        **Remarks/Usage:**
            This method is the fastest way to retrieve information about a large number of nodes. If a retrieved node ID does not exist, then all of the values for that node ID will be 0. If it is known that all of the nodes in the node set exist, use GetAllArray.
        **Input:**
            **SetID:** ID of the set that contains the node IDs to retrieve. If 0, retrieve all nodes in the model.\n
        **Output:**
            **numNode:** The number of nodes for which data is being returned.\n
            **entID:** Each entry is the ID of the associated node.\n
            **Exist:** Node existence, True=Node exists, False=Node does not exist\n
            **xyz:** The coordinates of the node. There are 3 entries, x, y, z for each node.\n
            **layer:** The ID of the layer for the node.\n
            **color:** The color of the node.\n
            **ndType:** The type of the node.\n
            **defCSys:** The definition coordinate system of the node.\n
            **outCSys:** The output coordinate system of the node.\n
            **permBC:** Flags indicating the permanent constraints on the node. 0=off, 1=on. There are 6 entries, corresponding to the degrees of freedom for each node.\n
        **Return Code:** True\n
        :type SetID: int

        :type numNode: int

        :type entID: tuple[int]

        :type Exist: tuple[bool]

        :type xyz: tuple[float]

        :type layer: tuple[int]

        :type color: tuple[int]

        :type ndType: tuple[int]

        :type defCSys: tuple[int]

        :type outCSys: tuple[int]

        :type permBC: tuple[int]

        """
        ...

    def GetClosest(self, vXYZ) -> Any:
        """
        **Description:**
            This method finds the Node closest to the desired location and loads it into the current object
        **Remarks/Usage:**
            None
        **Input:**
            **vXYZ:** The coordinates of the location of interest.\n
        **Return Code:** True\n
        :type vXYZ: tuple[float]

        """
        ...

    def GetCoordArray(self, SetID) -> tuple[int, int, tuple[int], tuple[float]]:
        """
        **Description:**
            This method retrieves arrays of coordinates for a set of Nodes
        **Remarks/Usage:**
            This is a simpler form of GetAllArray, if you simply need the nodal coordinates. If a retrieved node ID does not exist, then all of the values for that node ID will be 0.
        **Input:**
            **SetID:** ID of the set that contains the node IDs to retrieve. If 0, retrieve all nodes in the model\n
        **Output:**
            **numNode:** The number of nodes for which data is being returned.\n
            **entID:** Each entry is the ID of the associated node\n
            **xyz:** The coordinates of the node. There are 3 entries, x, y, z for each node.\n
        **Return Code:** True\n
        :param SetID: ID of the set that contains the node IDs to retrieve. If 0, retrieve all nodes in the model
        :return: Return Code, numNode, entID, xyz\n

        :type SetID: int
        :type numNode: int
        :type entID: tuple[int]
        :type xyz: tuple[float]
        """
        ...

    def GetCoordArray2(self, SetID, numNode, entID, Exist, xyz) -> Any:
        """
        **Description:**
            This method retrieves arrays of coordinates for a set of Nodes and an additional array designating if a node exists in the database
        **Remarks/Usage:**
            This is a simpler form of GetAllArray2, if you simply need the nodal coordinates and also want to know if a node exists in the database. If a retrieved node ID does not exist, then all of the values for that node ID will be 0.
        **Input:**
            **SetID:** ID of the set that contains the node IDs to retrieve. If 0, retrieve all nodes in the model\n
        **Output:**
            **numNode:** The number of nodes for which data is being returned.\n
            **entID:** Each entry is the ID of the associated node\n
            **Exist:** Node existence, True=Node exists, False=Node does not exist\n
            **xyz:** The coordinates of the node. There are 3 entries, x, y, z for each node.\n
        **Return Code:** True\n
        :type SetID: int

        :type numNode: int

        :type entID: tuple[int]

        :type Exist: tuple[bool]

        :type xyz: tuple[float]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetSuperelementIDArray(self, SetID, numNode, entID, superelementID) -> Any:
        """
        **Description:**
            This method retrieves
		 arrays of Node IDs and Superelement IDs for a set of Nodes
        **Remarks/Usage:**
            If a retrieved node
		 ID does not exist, then all of the values for that node ID will
		 be 0.
        **Return Code:** True\n
        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def IsMidsideNode(self, elemSET) -> Any:
        """
        **Description:**
            This method determines if the current Node is used as a midside node on any elements
        **Remarks/Usage:**
            If you are going to call this method repeatedly for multiple nodes performance may not be as good as using the AddMidsideNodes() method on the Set Object to find all midside nodes and then testing if this node is in the Set.
        **Input:**
            **elemSET:** The ID of a Set Object used to limit the elements to consider when determining if the current Node is a midside node. Set this to 0 if you simply want to consider all elements.\n
        **Return Code:** True\n
        :type elemSET: int

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutAll(self, entID, x, y, z, layer, color, ndType, defCSys, outCSys, permBC) -> Any:
        """
        **Description:**
            This method stores an entity with the specified ID.
        **Remarks/Usage:**
            Unlike the standard Put method, this function loads all of the properties as arguments. If you are updating all of the properties before storing an entity, this function will be faster than multiple calls to load each property individually.
        **Input:**
            **entID:** The ID of the entity to store.\n
            **x, y, z, layer, color, ndType, defCSys, outCSys, permBC:** Refer to the property descriptions for each of these items. permBC is loaded in an integer array, even though it contains only True/False values.\n

        **Return Code:** True\n
        :type entID: int
        :type x: float
        :type y: int
        :type z: float
        :type color: int
        :type ndType: int
        :type defCSys: int
        :type outCSys: int
        :type permBC: tuple[int]

        """
        ...

    def PutAllArray(self, numNode, entID, xyz, layer, color, ndType, defCSys, outCSys, permBC) -> Any:
        """
        **Description:**
            This method stores multiple node entities with the specified data.
        **Remarks/Usage:**
            This is the fastest Put method if you have a large number of nodes to create. All data can be accumulated in arrays and then transferred in one call.
        **Input:**
            **numNode:** The number of nodes to create (i.e. the number of entries in the arrays)\n
            **entID:** The IDs of the nodes to store.\n
            **xyz, layer, color, ndType, defCSys, outCSys, permBC:** Refer to the property descriptions for each of these items. xyz is an array of the nodal coordinates, there are 3 entries for each node (must be in global rectangular coordinates). permBC is loaded in an integer array, even though it contains only True/False values. It contains six values per node.\n

        **Return Code:** True\n
        :type numNode: int
        :type entID: tuple[int]
        :type xyz: tuple[float]
        :type layer: tuple[int]
        :type color: tuple[int]
        :type ndType: tuple[int]
        :type defCSys: tuple[int]
        :type outCSys: tuple[int]
        :type permBC: tuple[int]

        """
        ...

    def PutCoordArray(self, numNode, entID, xyz) -> Any:
        """
        **Description:**
            This is a simpler version of PutAllArray that allows multiple node entities to be stored with the specified data.
        **Remarks/Usage:**
            This method is even faster than PutAllArray, and requires less memory, it does not however give you full control. The same layer, color... are used for every entity - only the coordinates are input as an array.
        **Input:**
            **numNode:** The number of nodes to create (i.e. the number of entries in the arrays)\n
            **entID:** The IDs of the nodes to store.\n
        **Return Code:** True\n
        :type numNode: int

        :type entID: tuple[int]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def PutSuperelementIDArray(self, numNode, entID, superelementID) -> Any:
        """
        **Description:**
            This method stores
		 multiple node entities with the specified Superelement ID data.
        **Remarks/Usage:**
            This is the fastest
		 Put method if you have a large number of nodes to create with
		 a Superelement ID, as all data can be accumulated in arrays and
		 then transferred in one call.
        **Return Code:** True\n
        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetpermBC(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def permBC(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class AnalysisMgr:
    CLSID: Any
    AbaHistAnalysisType: Any
    AbaHistAutoContact: Any
    AbaHistEigenvectors: Any
    AbaHistInitTimeInc: Any
    AbaHistLinearPert: Any
    AbaHistMaxFreq: Any
    AbaHistMaxTimeInc: Any
    AbaHistMinFreq: Any
    AbaHistMinTimeInc: Any
    AbaHistNonlinGeom: Any
    AbaHistOn: Any
    AbaHistOutInterval: Any
    AbaHistOutZeroInc: Any
    AbaHistScaleFactor: Any
    AbaHistShiftFreq: Any
    AbaHistStabilize: Any
    AbaHistStepAmp: Any
    AbaHistStepConstr: Any
    AbaHistStepLoad: Any
    AbaHistTimePeriod: Any
    AbaModCbushAsMatrix: Any
    AbaModEndText: Any
    AbaModGroupsAsSets: Any
    AbaModOn: Any
    AbaModSkipStandard: Any
    AbaModStartText: Any
    AbaModTitleSetNames: Any
    AbaModVersion: Any
    Active: Any
    AnalysisType: Any
    AnsArclen: Any
    AnsAutots: Any
    AnsBisect: Any
    AnsBisectfactor: Any
    AnsBuckleLdmulte: Any
    AnsBuckleMethod: Any
    AnsBuckleNmode: Any
    AnsBuckleOptOn: Any
    AnsBuckleRangekey: Any
    AnsBuckleShift: Any
    AnsBuckleStrmck: Any
    AnsCmlDBmem: Any
    AnsCmlDir: Any
    AnsCmlJobname: Any
    AnsCmlList: Any
    AnsCmlOn: Any
    AnsCmlPid: Any
    AnsCmlProd: Any
    AnsCmlUser: Any
    AnsCmlVersion: Any
    AnsCmlWSmem: Any
    AnsCnvtolDvol: Any
    AnsCnvtolF: Any
    AnsCnvtolHdsp: Any
    AnsCnvtolM: Any
    AnsCnvtolRot: Any
    AnsCnvtolU: Any
    AnsCrplimit: Any
    AnsCrplimitvalue: Any
    AnsDOFAutomatic: Any
    AnsDOFDoSet: Any
    AnsDOFNoRotation: Any
    AnsDOFNumber: Any
    AnsDOFOn: Any
    AnsDOFSetID: Any
    AnsDpplimit: Any
    AnsDpplimitvalue: Any
    AnsDsplimit: Any
    AnsDsplimitvalue: Any
    AnsDtime: Any
    AnsDtmax: Any
    AnsDtmin: Any
    AnsDvoltoler: Any
    AnsEqslv: Any
    AnsFtoler: Any
    AnsHarmonicClust: Any
    AnsHarmonicFreqb: Any
    AnsHarmonicFreqe: Any
    AnsHarmonicLogopt: Any
    AnsHarmonicMaxmode: Any
    AnsHarmonicMethod: Any
    AnsHarmonicMinmode: Any
    AnsHarmonicOptOn: Any
    AnsHarmonicReimky: Any
    AnsHdsptoler: Any
    AnsHeatEndTime: Any
    AnsHeatOn: Any
    AnsHeatOutputFreq: Any
    AnsHeatTimeStep: Any
    AnsKbc: Any
    AnsLdstepOn: Any
    AnsLnsrch: Any
    AnsMidtol: Any
    AnsModEndText: Any
    AnsModGroupsAsSets: Any
    AnsModMemory: Any
    AnsModOn: Any
    AnsModSkipPreprocessCMD: Any
    AnsModSkipStandard: Any
    AnsModStartText: Any
    AnsModTitle: Any
    AnsModTitleSetNames: Any
    AnsModVersion: Any
    AnsModWriteIter: Any
    AnsModWriteLargeDef: Any
    AnsModWriteSolCmd: Any
    AnsModalBlocksize: Any
    AnsModalCompute: Any
    AnsModalFreqb: Any
    AnsModalFreqe: Any
    AnsModalMethod: Any
    AnsModalNmode: Any
    AnsModalNrmkey: Any
    AnsModalOptOn: Any
    AnsModalRangefact: Any
    AnsModalReusekey: Any
    AnsModalRobustlev: Any
    AnsModalStrmck: Any
    AnsModalSymmeth: Any
    AnsModelGroupID: Any
    AnsModelRSTcomp: Any
    AnsModelSkipCsys: Any
    AnsModelSkipElem: Any
    AnsModelSkipGroup: Any
    AnsModelSkipMatl: Any
    AnsModelSkipMisc: Any
    AnsModelSkipNode: Any
    AnsModelSkipProp: Any
    AnsModesElemResults: Any
    AnsModesMaxFreq: Any
    AnsModesMinFreq: Any
    AnsModesModalMethod: Any
    AnsModesNumModes: Any
    AnsModesOn: Any
    AnsMtoler: Any
    AnsNeqit: Any
    AnsNewConstraint: Any
    AnsNewContact: Any
    AnsNewLoad: Any
    AnsNlOptOn: Any
    AnsNlgeom: Any
    AnsNropt: Any
    AnsNsbmn: Any
    AnsNsbmx: Any
    AnsNsbstep: Any
    AnsNsubs: Any
    AnsOutprAcc: Any
    AnsOutprAccFreq: Any
    AnsOutprAccNth: Any
    AnsOutprAll: Any
    AnsOutprAllFreq: Any
    AnsOutprAllNth: Any
    AnsOutprBasic: Any
    AnsOutprBasicFreq: Any
    AnsOutprBasicNth: Any
    AnsOutprEsol: Any
    AnsOutprEsolFreq: Any
    AnsOutprEsolNth: Any
    AnsOutprNsol: Any
    AnsOutprNsolFreq: Any
    AnsOutprNsolNth: Any
    AnsOutprRsol: Any
    AnsOutprRsolFreq: Any
    AnsOutprRsolNth: Any
    AnsOutprVel: Any
    AnsOutprVelFreq: Any
    AnsOutprVelNth: Any
    AnsOutputOn: Any
    AnsOutresAcc: Any
    AnsOutresAccFreq: Any
    AnsOutresAccNth: Any
    AnsOutresAll: Any
    AnsOutresAllFreq: Any
    AnsOutresAllNth: Any
    AnsOutresBasic: Any
    AnsOutresBasicFreq: Any
    AnsOutresBasicNth: Any
    AnsOutresEsol: Any
    AnsOutresEsolFreq: Any
    AnsOutresEsolNth: Any
    AnsOutresNsol: Any
    AnsOutresNsolFreq: Any
    AnsOutresNsolNth: Any
    AnsOutresRsol: Any
    AnsOutresRsolFreq: Any
    AnsOutresRsolNth: Any
    AnsOutresVel: Any
    AnsOutresVelFreq: Any
    AnsOutresVelNth: Any
    AnsPlslimit: Any
    AnsPlslimitvalue: Any
    AnsPred: Any
    AnsPredictor: Any
    AnsPstres: Any
    AnsRandAccel: Any
    AnsRandAccelRelative: Any
    AnsRandDisp: Any
    AnsRandDispRelative: Any
    AnsRandOn: Any
    AnsRandVel: Any
    AnsRandVelRelative: Any
    AnsResfq: Any
    AnsRottoler: Any
    AnsTime: Any
    AnsTimestepOn: Any
    AnsTolerb: Any
    AnsTransAlpha: Any
    AnsTransAlphad: Any
    AnsTransAlphaf: Any
    AnsTransAlpham: Any
    AnsTransBetad: Any
    AnsTransDelta: Any
    AnsTransDmprat: Any
    AnsTransDmpsfreq: Any
    AnsTransDmpstr: Any
    AnsTransGamma: Any
    AnsTransGammavalue: Any
    AnsTransLumpm: Any
    AnsTransMaxmode: Any
    AnsTransMethod: Any
    AnsTransMinmode: Any
    AnsTransOptOn: Any
    AnsTransTintopt: Any
    AnsUtoler: Any
    CaseLabel: Any
    CaseTitle: Any
    CaseType: Any
    ContactOption: Any
    ContactSetType: Any
    CornerOutput: Any
    Destination: Any
    DynHistBodyLoadGrp: Any
    DynHistGroupHistId: Any
    DynHistImplicit: Any
    DynHistMassDampOn: Any
    DynHistMsssDamp: Any
    DynHistOn: Any
    DynHistPlateIntgPts: Any
    DynHistPrintHistOutput: Any
    DynHistSpringback: Any
    DynHistStrainOutput: Any
    DynHistTimeHistOuput: Any
    DynHistTotalTime: Any
    DynModEndText: Any
    DynModExportRigidNodes: Any
    DynModGroupsAsSets: Any
    DynModMatlBasedParts: Any
    DynModOn: Any
    DynModSkipStandard: Any
    DynModStartText: Any
    DynModelGroupID: Any
    DynModelSkipCsys: Any
    DynModelSkipElem: Any
    DynModelSkipGroup: Any
    DynModelSkipMatl: Any
    DynModelSkipMisc: Any
    DynModelSkipNode: Any
    DynModelSkipProp: Any
    Echo: Any
    EndText: Any
    FStDynFreqMethod: Any
    FStDynIterVec: Any
    FStDynMassDir: Any
    FStDynMassForm: Any
    FStDynMassTol: Any
    FStDynMaxIter: Any
    FStDynModalDamp: Any
    FStDynModalNorm: Any
    FStDynNumModes: Any
    FStDynOn: Any
    FStDynRigidModes: Any
    FStDynSigDigits: Any
    FStDynSolMethod: Any
    FStFilEchoLogFile: Any
    FStFilHyper1: Any
    FStFilHyper2: Any
    FStFilKeepHyper: Any
    FStFilKeepLogFile: Any
    FStFilLogFile: Any
    FStFilOn: Any
    FStFilScratch1: Any
    FStFilScratch2: Any
    FStHeatConvergeType: Any
    FStHeatMaxIter: Any
    FStHeatOn: Any
    FStHeatTempTol: Any
    FStSolElemGroup: Any
    FStSolIter: Any
    FStSolIterConvTol: Any
    FStSolIterMaxIter: Any
    FStSolMemAppPct: Any
    FStSolMemFortranPct: Any
    FStSolMemIterMax: Any
    FStSolMemVirtMax: Any
    FStSolNodeGroup: Any
    FStSolOn: Any
    FStSolShellAuto: Any
    FStSolShellAutoAng: Any
    FStSolSingCriteria: Any
    FStSolSingularity: Any
    FStSolSpinSoft: Any
    FStSolStiffSoftLoad: Any
    FStSolStressStiff: Any
    FStSolVerification: Any
    ID: Any
    Imaginary: Any
    IntegrationOutput: Any
    LinkedSolverOption: Any
    MarCtblOn: Any
    MarCtblWrite: Any
    MarHistAnalCaseSol: Any
    MarHistAutoSwitch: Any
    MarHistBuckleNumModes: Any
    MarHistBucklePosEigen: Any
    MarHistChecking: Any
    MarHistContactProp: Any
    MarHistConvergeMeth: Any
    MarHistCtrlMaxRecycle: Any
    MarHistCtrlMaxStep: Any
    MarHistCtrlMethod: Any
    MarHistCtrlMinRecycle: Any
    MarHistMaxResidual: Any
    MarHistModalEigen: Any
    MarHistModalMaxFreq: Any
    MarHistModalMinFreq: Any
    MarHistNonPosDefinite: Any
    MarHistNonSymmetric: Any
    MarHistOn: Any
    MarHistSolverMeth: Any
    MarIncArcLenMeth: Any
    MarIncCtrlMaxRecycle: Any
    MarIncFracFirst: Any
    MarIncInitTimeInc: Any
    MarIncMaxFracForAll: Any
    MarIncMaxNumInc: Any
    MarIncMaxStep: Any
    MarIncMaxTimeInc: Any
    MarIncMinTimeInc: Any
    MarIncNumOutInc: Any
    MarIncOn: Any
    MarIncQuasiStatDamp: Any
    MarIncScaleFact: Any
    MarIncTimePeriod: Any
    MarIncTotalTime: Any
    MarModBWOpt: Any
    MarModConstDil: Any
    MarModCoreVal: Any
    MarModDistLoadElem: Any
    MarModDistLoadList: Any
    MarModDistLoadNode: Any
    MarModDistLoadOn: Any
    MarModEchoInput: Any
    MarModElasIs: Any
    MarModElasOn: Any
    MarModElasTotal: Any
    MarModEndText: Any
    MarModExtInput: Any
    MarModFinite: Any
    MarModFolOn: Any
    MarModFolOpt: Any
    MarModLgDisp: Any
    MarModMaxConstrain: Any
    MarModNoCpu: Any
    MarModOn: Any
    MarModOutOfCore: Any
    MarModParallel: Any
    MarModPlasOn: Any
    MarModPlasOpt: Any
    MarModPltIntegPt: Any
    MarModProcessors: Any
    MarModShlTrShear: Any
    MarModSkipStandard: Any
    MarModStartText: Any
    MarModTitle: Any
    MarModTyingCe: Any
    MarModTyingOn: Any
    MarModTyingServoLk: Any
    MarModTyingServoNd: Any
    MarModTyingType: Any
    MarModUpdate: Any
    MarModVecLength: Any
    MarModWorkSpVec: Any
    MarModWriteGroupSet: Any
    NasAeroAeunit: Any
    NasAeroAeunitVal: Any
    NasAeroCsID: Any
    NasAeroDampMethod: Any
    NasAeroMkFuID: Any
    NasAeroModesKeep: Any
    NasAeroOn: Any
    NasAeroRefArea: Any
    NasAeroRefCsID: Any
    NasAeroRefDens: Any
    NasAeroRefLength: Any
    NasAeroRefSpan: Any
    NasAeroSymXY: Any
    NasAeroSymxz: Any
    NasAeroVelo: Any
    NasAerobOPPHIPA: Any
    NasAerobPARAMfzero: Any
    NasAerodPARAMfzero: Any
    NasAppSpecClose: Any
    NasAppSpecDamp: Any
    NasAppSpecFunction: Any
    NasAppSpecMethod: Any
    NasAppSpecOn: Any
    NasAppSpecScale: Any
    NasAppSpecSuport: Any
    NasAppSpecType: Any
    NasAutoCt2D: Any
    NasAutoCtBEAMCAP: Any
    NasAutoCtBEAMCNT: Any
    NasAutoCtBodyVal: Any
    NasAutoCtCTYPE: Any
    NasAutoCtConProp: Any
    NasAutoCtDISTANCE: Any
    NasAutoCtEDGECNT: Any
    NasAutoCtESET: Any
    NasAutoCtEnabled: Any
    NasAutoCtFRIC: Any
    NasAutoCtFRICTABLE: Any
    NasAutoCtFRICVal: Any
    NasAutoCtFTYPE: Any
    NasAutoCtIGNTHK: Any
    NasAutoCtINISTF: Any
    NasAutoCtOn: Any
    NasAutoCtPropSet: Any
    NasAutoCtRegion: Any
    NasAutoCtRigidSet: Any
    NasAutoCtSeedESet: Any
    NasAutoCtSeedGSet: Any
    NasAutoCtSelfCont: Any
    NasBulkAlpha1: Any
    NasBulkAlpha2: Any
    NasBulkAutompc: Any
    NasBulkAutospc: Any
    NasBulkAutospcType: Any
    NasBulkBoltFact: Any
    NasBulkBoltFactVal: Any
    NasBulkCntAset: Any
    NasBulkDdrmmOff: Any
    NasBulkDynLdAsLOADSET: Any
    NasBulkEndText: Any
    NasBulkEndTextOutsideBulk: Any
    NasBulkEnfmotn: Any
    NasBulkEnfmotnOpt: Any
    NasBulkGapConnectionProp: Any
    NasBulkGapsAsContact: Any
    NasBulkGrdpnt: Any
    NasBulkGrdpntVal: Any
    NasBulkGroupID: Any
    NasBulkInrel: Any
    NasBulkInrelVal: Any
    NasBulkK6rot: Any
    NasBulkK6rotVal: Any
    NasBulkLangle: Any
    NasBulkLargeField: Any
    NasBulkLgdisp: Any
    NasBulkLgstrn: Any
    NasBulkMatnl: Any
    NasBulkMaxratio: Any
    NasBulkMaxratioVal: Any
    NasBulkMdofVal: Any
    NasBulkMgrid: Any
    NasBulkMgridID: Any
    NasBulkModacc: Any
    NasBulkNdamp: Any
    NasBulkNdampVal: Any
    NasBulkNofisr: Any
    NasBulkOgeom: Any
    NasBulkOn: Any
    NasBulkPARAMBailout: Any
    NasBulkPARAMBuckle: Any
    NasBulkPrgpst: Any
    NasBulkQuadr: Any
    NasBulkResVec: Any
    NasBulkResVecOn: Any
    NasBulkResViner: Any
    NasBulkRigidMethod: Any
    NasBulkRigidThermalExp: Any
    NasBulkSecomb: Any
    NasBulkSkipBeamShape: Any
    NasBulkSkipStandard: Any
    NasBulkSrcomps: Any
    NasBulkStartText: Any
    NasBulkSwpangle: Any
    NasBulkSwpangleVal: Any
    NasBulkTENSOQD: Any
    NasBulkTENSOQDval: Any
    NasBulkWriteAllLoadBCSets: Any
    NasBulkWtmass: Any
    NasBulkWtmassVal: Any
    NasCaeDynPressure: Any
    NasCaeMachNumber: Any
    NasCaeOn: Any
    NasCaeRigidTrim: Any
    NasCaeWrtieTrim: Any
    NasCflDenID: Any
    NasCflEig: Any
    NasCflEps: Any
    NasCflFliMethod: Any
    NasCflMachFactID: Any
    NasCflMethod: Any
    NasCflOn: Any
    NasCflRfreqFactID: Any
    NasCflSdampID: Any
    NasCflWriteFlutter: Any
    NasCnlArcConstraintType: Any
    NasCnlArcDesiredIter: Any
    NasCnlArcLoadScale: Any
    NasCnlArcMaxAdjust: Any
    NasCnlArcMaxSteps: Any
    NasCnlArcMinAdjust: Any
    NasCnlBoundsRb: Any
    NasCnlCreep: Any
    NasCnlCtiffnessMethod: Any
    NasCnlDivergenceLimit: Any
    NasCnlDominantPeriodSteps: Any
    NasCnlFstress: Any
    NasCnlIncrements: Any
    NasCnlIntermediateOutput: Any
    NasCnlKstep: Any
    NasCnlLineSearchTolerance: Any
    NasCnlMaxAdjust: Any
    NasCnlMaxBisections: Any
    NasCnlMaxIter: Any
    NasCnlMaxLineSearch: Any
    NasCnlMaxRotation: Any
    NasCnlModnewtonBisection: Any
    NasCnlModnewtonLineSearch: Any
    NasCnlModnewtonQuasiNewton: Any
    NasCnlOn: Any
    NasCnlOutputInterval: Any
    NasCnlQuasiNewtonVectors: Any
    NasCnlSkipNLPARM: Any
    NasCnlSolutionOverrides: Any
    NasCnlSolutionStrategy: Any
    NasCnlStabilityTolerance: Any
    NasCnlStiffnessMethod: Any
    NasCnlTimeSkipAdjust: Any
    NasCnlTime_Increment: Any
    NasCnlUseLoadSet: Any
    NasCnlkDAMP: Any
    NasCnlkUPDATE: Any
    NasCurvatureStrain: Any
    NasDMIGB2GG: Any
    NasDMIGB2PP: Any
    NasDMIGK2GG: Any
    NasDMIGK2PP: Any
    NasDMIGK42GG: Any
    NasDMIGM2GG: Any
    NasDMIGM2PP: Any
    NasDMIGP2G: Any
    NasDdamAccelConversion: Any
    NasDdamDirectionSequence: Any
    NasDdamElasticPlastic: Any
    NasDdamEnabled: Any
    NasDdamEquationType: Any
    NasDdamEquipmentLocation: Any
    NasDdamFileUnit: Any
    NasDdamForceConversion: Any
    NasDdamForeAftDirection: Any
    NasDdamGCutoff: Any
    NasDdamIncludePath: Any
    NasDdamIsDDAM: Any
    NasDdamMassToWeight: Any
    NasDdamOn: Any
    NasDdamSelModeMethod: Any
    NasDdamSelModeVal: Any
    NasDdamSpdirCOMP: Any
    NasDdamSpdirCSID: Any
    NasDdamSpecCoeffFile: Any
    NasDdamSurfaceShip: Any
    NasDdamUseBuiltInCoeff: Any
    NasDdamVerticalDirection: Any
    NasDdamWeightCutoffPct: Any
    NasDynDampModalMethod: Any
    NasDynDampModalTbl: Any
    NasDynDampOverall: Any
    NasDynDampW3: Any
    NasDynDampW4: Any
    NasDynFreqID: Any
    NasDynFreqTbl: Any
    NasDynFzero: Any
    NasDynFzeroVal: Any
    NasDynKeepModes: Any
    NasDynOn: Any
    NasDynRespSpect: Any
    NasDynTranDT: Any
    NasDynTranTimeSteps: Any
    NasDynTransOutInt: Any
    NasDynUseLoadSet: Any
    NasDynWmodal: Any
    NasEnableDMIG: Any
    NasExecAllowDuplicateNodes: Any
    NasExecAnalyzeFilename: Any
    NasExecDiag: Any
    NasExecDuplicateTolerance: Any
    NasExecEndText: Any
    NasExecExtendedMessages: Any
    NasExecGPU: Any
    NasExecGPUOpt: Any
    NasExecIterSolve: Any
    NasExecIterSolve2: Any
    NasExecMaxTime: Any
    NasExecMemory: Any
    NasExecNumCPU: Any
    NasExecOn: Any
    NasExecOutDir: Any
    NasExecProblem: Any
    NasExecRestart: Any
    NasExecRestartDB: Any
    NasExecRestartReadOnly: Any
    NasExecRestartSubcase: Any
    NasExecRestartVersion: Any
    NasExecSaveDB: Any
    NasExecScratchDir1: Any
    NasExecScratchDir2: Any
    NasExecScratchSize1: Any
    NasExecScratchSize2: Any
    NasExecSkipStandard: Any
    NasExecSolName: Any
    NasExecSolutionMonitor: Any
    NasExecSolutionMonitorOpt: Any
    NasExecStartText: Any
    NasExecSystemCell: Any
    NasExecUserCmdLine: Any
    NasExecVersion: Any
    NasExecWriteSERefPath: Any
    NasExtSEOutAssignForm: Any
    NasExtSEOutAssignTitle: Any
    NasExtSEOutExtID: Any
    NasExtSEOutMatK4damp: Any
    NasExtSEOutMatLoads: Any
    NasExtSEOutMatMass: Any
    NasExtSEOutMatStiffness: Any
    NasExtSEOutOn: Any
    NasExtSEOutOptAsmbulk: Any
    NasExtSEOutOptExtbulk: Any
    NasExtSEOutOptGeom: Any
    NasExtSEOutTo: Any
    NasExtSEOutUnitID: Any
    NasGCheckMsgLimit: Any
    NasGCheckNone: Any
    NasGCheckOn: Any
    NasGCheckSummary: Any
    NasGenSpecAbsolute: Any
    NasGenSpecNodeGroup: Any
    NasGenSpecOn: Any
    NasInlStepOptADJUST: Any
    NasInlStepOptCREEP: Any
    NasInlStepOptCTRLDEF: Any
    NasInlStepOptConvA: Any
    NasInlStepOptConvN: Any
    NasInlStepOptConvP: Any
    NasInlStepOptConvU: Any
    NasInlStepOptConvV: Any
    NasInlStepOptConvW: Any
    NasInlStepOptDAMP: Any
    NasInlStepOptDTINITF: Any
    NasInlStepOptDTINITFA: Any
    NasInlStepOptDTMAXF: Any
    NasInlStepOptDTMINF: Any
    NasInlStepOptEPSP: Any
    NasInlStepOptEPSU: Any
    NasInlStepOptEPSW: Any
    NasInlStepOptEnableCriteria: Any
    NasInlStepOptFSTRESS: Any
    NasInlStepOptGroupIDs: Any
    NasInlStepOptID: Any
    NasInlStepOptIDAMP: Any
    NasInlStepOptINTOUT: Any
    NasInlStepOptIPHYS: Any
    NasInlStepOptIncrements: Any
    NasInlStepOptKMETHOD: Any
    NasInlStepOptKSTEP: Any
    NasInlStepOptLIMTAR: Any
    NasInlStepOptLSTOL: Any
    NasInlStepOptLoadStepping: Any
    NasInlStepOptMAXALR: Any
    NasInlStepOptMAXBIS: Any
    NasInlStepOptMAXITER: Any
    NasInlStepOptMAXLS: Any
    NasInlStepOptMAXQN: Any
    NasInlStepOptMECH: Any
    NasInlStepOptMINALR: Any
    NasInlStepOptMINITER: Any
    NasInlStepOptMRCONV: Any
    NasInlStepOptMSTEP: Any
    NasInlStepOptMT1_i: Any
    NasInlStepOptMT2_i: Any
    NasInlStepOptMT3_i: Any
    NasInlStepOptMT4_i: Any
    NasInlStepOptNDESIR: Any
    NasInlStepOptNDESIRA: Any
    NasInlStepOptNINC: Any
    NasInlStepOptNO: Any
    NasInlStepOptNSMAX: Any
    NasInlStepOptNSMAXA: Any
    NasInlStepOptOn: Any
    NasInlStepOptRB: Any
    NasInlStepOptRBIG: Any
    NasInlStepOptRSMALL: Any
    NasInlStepOptSCALEA: Any
    NasInlStepOptSFACT: Any
    NasInlStepOptSkipNLSTEP: Any
    NasInlStepOptTOTTIM: Any
    NasInlStepOptTYPE: Any
    NasInlStepOptUTOL: Any
    NasInlStepOptYT1_i: Any
    NasInlStepOptYT2_i: Any
    NasInlStepOptYT3_i: Any
    NasInlStepOptYT4_i: Any
    NasLicenseType: Any
    NasMCheckDataRec: Any
    NasMCheckDataTol: Any
    NasMCheckGrndRefNode: Any
    NasMCheckMaxStrnEn: Any
    NasMCheckOn: Any
    NasMCheckWtCG: Any
    NasMCheckWtRefNode: Any
    NasMCheckWtUnits: Any
    NasModeDampOverall: Any
    NasModeDesiredRoots: Any
    NasModeEigrSet: Any
    NasModeEstRoots: Any
    NasModeMassForm: Any
    NasModeMethod: Any
    NasModeNormDOF: Any
    NasModeNormNode: Any
    NasModeNormOpt: Any
    NasModeOn: Any
    NasModeSel: Any
    NasModeSelInc: Any
    NasModeSelOn: Any
    NasModeSolutionType: Any
    NasModeXYOn: Any
    NasModeXYRefNode: Any
    NasModesComplexConverge: Any
    NasModesComplexRegionWidth: Any
    NasModesSkipEigr: Any
    NasMonitorAeroEnabled: Any
    NasMonitorEnabled: Any
    NasMonitorLoadEnabled: Any
    NasMptSetID: Any
    NasMsNLKGlobalBOLTMETH: Any
    NasMsNLKGlobalEXEFROM: Any
    NasMsNLKGlobalINLY: Any
    NasMsNLKGlobalIREF: Any
    NasMsNLKGlobalMDLVAL: Any
    NasMsNLKGlobalMODEVERS: Any
    NasMsNLKGlobalNKINE: Any
    NasMsNLKGlobalOn: Any
    NasMsNLKGlobalPLSHSOL: Any
    NasMsNLKGlobalPRECPIVO: Any
    NasMsNLKGlobalRESO: Any
    NasMsNLKGlobalRESXTRP: Any
    NasMsNLKGlobalRSTFROM: Any
    NasMsNLKGlobalRSTGEN: Any
    NasMsNLKGlobalRSTUNIT: Any
    NasMsNLKGlobalSTRCONV: Any
    NasMsNLKGlobalSTRMEAS: Any
    NasMsNLKGlobalSTROUT: Any
    NasMscCtAUGDIST: Any
    NasMscCtAUGMENT: Any
    NasMscCtBEAMB: Any
    NasMscCtBIAS: Any
    NasMscCtDDULMT: Any
    NasMscCtERRBAS: Any
    NasMscCtERROR: Any
    NasMscCtEnable: Any
    NasMscCtFGCFLG: Any
    NasMscCtFGCNST: Any
    NasMscCtFGCNSTI: Any
    NasMscCtFGCNSTR: Any
    NasMscCtFGCRCEN: Any
    NasMscCtFGCTST: Any
    NasMscCtFGCTSTI: Any
    NasMscCtFGCTSTR: Any
    NasMscCtFNTOL: Any
    NasMscCtFTYPE: Any
    NasMscCtIBSEP: Any
    NasMscCtICSEP: Any
    NasMscCtLINCNT: Any
    NasMscCtMAXSEP: Any
    NasMscCtMETHOD: Any
    NasMscCtNLGLUE: Any
    NasMscCtNODSEP: Any
    NasMscCtOn: Any
    NasMscCtPENALT: Any
    NasMscCtRVCNST: Any
    NasMscCtSEGSYM: Any
    NasMscCtSFNPNLT: Any
    NasMscCtSFTPNLT: Any
    NasMscCtSLDLMT: Any
    NasMscCtSTKSLP: Any
    NasMscCtTAUGMNT: Any
    NasMscCtTHKOFF: Any
    NasMscCtTPENALT: Any
    NasMsnlCntALFA: Any
    NasMsnlCntAutotim: Any
    NasMsnlCntBETA: Any
    NasMsnlCntCntmdiv: Any
    NasMsnlCntCrcerat: Any
    NasMsnlCntCrcinc: Any
    NasMsnlCntCreep: Any
    NasMsnlCntCricoff: Any
    NasMsnlCntCrinfac: Any
    NasMsnlCntCrmfmn: Any
    NasMsnlCntCrmfmx: Any
    NasMsnlCntCrteabs: Any
    NasMsnlCntCrterel: Any
    NasMsnlCntDtinit: Any
    NasMsnlCntDtmax: Any
    NasMsnlCntDtmin: Any
    NasMsnlCntDtsbcdt: Any
    NasMsnlCntEpsbolt: Any
    NasMsnlCntEqmfmin: Any
    NasMsnlCntEqmfmx: Any
    NasMsnlCntFollowk: Any
    NasMsnlCntFsymtol: Any
    NasMsnlCntGAMA: Any
    NasMsnlCntINACCN: Any
    NasMsnlCntINERTIA: Any
    NasMsnlCntItrbolt: Any
    NasMsnlCntKsym: Any
    NasMsnlCntKsymtol: Any
    NasMsnlCntKupdate: Any
    NasMsnlCntLOADOFF: Any
    NasMsnlCntLvar: Any
    NasMsnlCntMSFAC: Any
    NasMsnlCntMSTAB: Any
    NasMsnlCntMaxbis: Any
    NasMsnlCntMaxdiv: Any
    NasMsnlCntMaxiter: Any
    NasMsnlCntMaxqn: Any
    NasMsnlCntMisfblt: Any
    NasMsnlCntMsglvl: Any
    NasMsnlCntMsglvlb: Any
    NasMsnlCntMsglvlc: Any
    NasMsnlCntNORMP: Any
    NasMsnlCntNORMU: Any
    NasMsnlCntOn: Any
    NasMsnlCntPLSHUT: Any
    NasMsnlCntPlastic: Any
    NasMsnlCntQuasiNewtonIter: Any
    NasMsnlCntREFP: Any
    NasMsnlCntREFU: Any
    NasMsnlCntRFVAR: Any
    NasMsnlCntRHOINF: Any
    NasMsnlCntSkipNLCNTL: Any
    NasMsnlCntSolver: Any
    NasMsnlCntSpink: Any
    NasMsnlCntStfoptn: Any
    NasMsnlCntStressk: Any
    NasMsnlCntTETA: Any
    NasMsnlCntTINTMTH: Any
    NasMsnlCntThrmst: Any
    NasMsnlCntTsccr: Any
    NasMsnlCntTsceq: Any
    NasMsnlCntTscumat: Any
    NasMsnlCntTstepk: Any
    NasMsnlCntTvar: Any
    NasMsnlCntUmfmin: Any
    NasMsnlCntUmfmx: Any
    NasMsnlCntUsolver: Any
    NasMsnlCntZerbolt: Any
    NasMsnlCntdCrteco: Any
    NasMsnlModalMassForm: Any
    NasMsnlTSEndTime: Any
    NasMsnlTSNumIncrements: Any
    NasMsnlTSOn: Any
    NasMsnlTSOutputFreq: Any
    NasMsnlTSSkipFactor: Any
    NasMsnlTSSkipTSTEP: Any
    NasMsnlkCnt2ALFA: Any
    NasMsnlkCnt2AMAX: Any
    NasMsnlkCnt2AMIN: Any
    NasMsnlkCnt2AUTOTIM: Any
    NasMsnlkCnt2BETA: Any
    NasMsnlkCnt2CIBL: Any
    NasMsnlkCnt2CREEP: Any
    NasMsnlkCnt2CRINFAC: Any
    NasMsnlkCnt2DCON: Any
    NasMsnlkCnt2DEFLIM: Any
    NasMsnlkCnt2DIPR: Any
    NasMsnlkCnt2DISLIM: Any
    NasMsnlkCnt2DTI0: Any
    NasMsnlkCnt2DTINIT: Any
    NasMsnlkCnt2DTMAX: Any
    NasMsnlkCnt2DTMIN: Any
    NasMsnlkCnt2EQMFMIN: Any
    NasMsnlkCnt2EQMFMX: Any
    NasMsnlkCnt2ERCD: Any
    NasMsnlkCnt2GAMA: Any
    NasMsnlkCnt2HMAX: Any
    NasMsnlkCnt2HMIN: Any
    NasMsnlkCnt2HPRCO: Any
    NasMsnlkCnt2IAR0: Any
    NasMsnlkCnt2ILNS: Any
    NasMsnlkCnt2IMPG: Any
    NasMsnlkCnt2IMPL: Any
    NasMsnlkCnt2IMPR: Any
    NasMsnlkCnt2IMPV: Any
    NasMsnlkCnt2INERTIA: Any
    NasMsnlkCnt2IT1K: Any
    NasMsnlkCnt2IT2K: Any
    NasMsnlkCnt2IT3K: Any
    NasMsnlkCnt2ITEREF: Any
    NasMsnlkCnt2ITMA: Any
    NasMsnlkCnt2LVAR: Any
    NasMsnlkCnt2MADI: Any
    NasMsnlkCnt2MATSYM: Any
    NasMsnlkCnt2NORM: Any
    NasMsnlkCnt2OTRE: Any
    NasMsnlkCnt2PLAS: Any
    NasMsnlkCnt2PLASTIC: Any
    NasMsnlkCnt2PLSHUT: Any
    NasMsnlkCnt2PRCE: Any
    NasMsnlkCnt2PRCF: Any
    NasMsnlkCnt2PRCO: Any
    NasMsnlkCnt2PRCQ: Any
    NasMsnlkCnt2PRCR: Any
    NasMsnlkCnt2PRCS: Any
    NasMsnlkCnt2PRED: Any
    NasMsnlkCnt2PRLN: Any
    NasMsnlkCnt2RDOW: Any
    NasMsnlkCnt2REFE: Any
    NasMsnlkCnt2REFP: Any
    NasMsnlkCnt2REFU: Any
    NasMsnlkCnt2RELC: Any
    NasMsnlkCnt2RJPN: Any
    NasMsnlkCnt2RJPZ: Any
    NasMsnlkCnt2ROTLIM: Any
    NasMsnlkCnt2RSUB: Any
    NasMsnlkCnt2RUP: Any
    NasMsnlkCnt2STAB: Any
    NasMsnlkCnt2SkipNLCNTL2: Any
    NasMsnlkCnt2TETA: Any
    NasMsnlkCnt2TINTMTH: Any
    NasMsnlkCnt2TSDYN: Any
    NasMsnlkCnt2TSVSC: Any
    NasMsnlkCnt2TVAR: Any
    NasMsnlkCnt2VSCOSN: Any
    NasMsnlkCnt2VSCOTE: Any
    NasMsnlkCnt2on: Any
    NasMsnlkJCON: Any
    NasNXStratAlpha: Any
    NasNXStratAtsdamp: Any
    NasNXStratAtsdfac: Any
    NasNXStratAtslows: Any
    NasNXStratAtsmass: Any
    NasNXStratAtsmxdt: Any
    NasNXStratAtsnext: Any
    NasNXStratAtssubd: Any
    NasNXStratAuto: Any
    NasNXStratBeama: Any
    NasNXStratBeamalg: Any
    NasNXStratBeame: Any
    NasNXStratBoltstp: Any
    NasNXStratConvcri: Any
    NasNXStratCstype: Any
    NasNXStratCtdamp: Any
    NasNXStratCtdampN: Any
    NasNXStratCtdampT: Any
    NasNXStratCtdisp: Any
    NasNXStratCvssval: Any
    NasNXStratDelta: Any
    NasNXStratDispopt: Any
    NasNXStratDmnorm: Any
    NasNXStratDnorm: Any
    NasNXStratDrillkf: Any
    NasNXStratDtdelay: Any
    NasNXStratDtol: Any
    NasNXStratElcv: Any
    NasNXStratElrescs: Any
    NasNXStratEnlsth: Any
    NasNXStratEpsia: Any
    NasNXStratEpsib: Any
    NasNXStratEpsii: Any
    NasNXStratEqrbar: Any
    NasNXStratEqrbe2: Any
    NasNXStratEtol: Any
    NasNXStratIcmode: Any
    NasNXStratImpact: Any
    NasNXStratIrint: Any
    NasNXStratItemax: Any
    NasNXStratLdccont: Any
    NasNXStratLdcdisp: Any
    NasNXStratLdcdmax: Any
    NasNXStratLdcdof: Any
    NasNXStratLdcgrid: Any
    NasNXStratLdcimax: Any
    NasNXStratLdcsubd: Any
    NasNXStratLoadopt: Any
    NasNXStratLsearch: Any
    NasNXStratLslower: Any
    NasNXStratLsupper: Any
    NasNXStratMasstyp: Any
    NasNXStratMaxDisp: Any
    NasNXStratMaxite: Any
    NasNXStratModexNew: Any
    NasNXStratMsfac: Any
    NasNXStratMstab: Any
    NasNXStratNposit: Any
    NasNXStratNsubgrp: Any
    NasNXStratNsupp: Any
    NasNXStratOn: Any
    NasNXStratPlasalg: Any
    NasNXStratRblcrit: Any
    NasNXStratRconsm: Any
    NasNXStratRctol: Any
    NasNXStratRmnorm: Any
    NasNXStratRnorm: Any
    NasNXStratRtalg: Any
    NasNXStratRtol: Any
    NasNXStratSdofang: Any
    NasNXStratSkipFactor: Any
    NasNXStratSolver: Any
    NasNXStratSpringk: Any
    NasNXStratStol: Any
    NasNXStratTimeIncrement: Any
    NasNXStratTimeSteps: Any
    NasNXStratTint: Any
    NasNXStratTnslcf: Any
    NasNXStratTstart: Any
    NasNXStratUlform: Any
    NasNXStratUpform: Any
    NasNXStratXdtcal: Any
    NasNXStratXdtfac: Any
    NasNXStratXdtmin1: Any
    NasNXStratXdtmin2: Any
    NasNXStratXmscale: Any
    NasNXStratXstep: Any
    NasNXStratXtcurve: Any
    NasNonlinAdapt: Any
    NasNonlinBehaviorASSM: Any
    NasNonlinBehaviorCPROJ: Any
    NasNonlinBehaviorCreepExp: Any
    NasNonlinBehaviorCreepImp: Any
    NasNonlinBehaviorCreepOn: Any
    NasNonlinBehaviorCreepType: Any
    NasNonlinBehaviorDIRECT: Any
    NasNonlinBehaviorEnable: Any
    NasNonlinBehaviorIPRINT: Any
    NasNonlinBehaviorLRGSTRN: Any
    NasNonlinBehaviorOn: Any
    NasNonlinBehaviorPROPBEH: Any
    NasNonlinBehaviorPROPMAP: Any
    NasNonlinBehaviorTHICKOP: Any
    NasNonlinBehaviorTSHEAR: Any
    NasNonlinBehaviorVALD1: Any
    NasNonlinBehaviorVALD2: Any
    NasNonlinBehaviorVCOORD: Any
    NasNonlinDT: Any
    NasNonlinKDAMP: Any
    NasNonlinKUPDATE: Any
    NasNonlinMaxIter: Any
    NasNonlinNDT: Any
    NasNonlinNO: Any
    NasNonlinOn: Any
    NasOmodes: Any
    NasOmodesOn: Any
    NasOptimAnalysisType: Any
    NasOptimCycles: Any
    NasOptimDresp: Any
    NasOptimEcho: Any
    NasOptimGoal: Any
    NasOptimInterval: Any
    NasOptimIntervalVal: Any
    NasOptimIsTopology: Any
    NasOptimMCDelay: Any
    NasOptimMCDelayVal: Any
    NasOptimMinDesobj: Any
    NasOptimOn: Any
    NasOptimTrackModes: Any
    NasRandCorrLagInterval: Any
    NasRandCorrLagMax: Any
    NasRandCorrLagStart: Any
    NasRandCorrOn: Any
    NasRandXYAuto: Any
    NasRandXYElemGroup: Any
    NasRandXYNodeGroup: Any
    NasRandXYOn: Any
    NasRandXYPsdf: Any
    NasRandXYSummary: Any
    NasRandomOn: Any
    NasRelEMotion: Any
    NasRotorAsyncResponse: Any
    NasRotorComplexModeOutput: Any
    NasRotorDoCSV: Any
    NasRotorDoGPF: Any
    NasRotorEnabled: Any
    NasRotorExcitationOrder: Any
    NasRotorFixedRefSys: Any
    NasRotorForceExcitation: Any
    NasRotorIncludePath: Any
    NasRotorInputUnits: Any
    NasRotorModeSelection: Any
    NasRotorOn: Any
    NasRotorOutputUnits: Any
    NasRotorPrintedOutput: Any
    NasRotorSingleRotor: Any
    NasRotorSpeedNumSteps: Any
    NasRotorSpeedStart: Any
    NasRotorSpeedStep: Any
    NasRotorSteinerInertia: Any
    NasRotorWhirlThreshold: Any
    NasSELoad: Any
    SetID: Any
    SkipStandard: Any
    Solver: Any
    StartText: Any
    SubcaseAnalysisType: Any
    title: Any
    vBCSet: Any
    vFStDynFreqRange: Any
    vMSCNasCnlConvergenceFlags: Any
    vNasAeroFreqKeep: Any
    vNasBulkAlpha1Val: Any
    vNasBulkAlpha2Val: Any
    vNasCnlConvergenceFlags: Any
    vNasCnlConvergenceValue: Any
    vNasDdamCoeffOn: Any
    vNasDdamCoeffVal: Any
    vNasDynKeepFreq: Any
    vNasGCheckMsg: Any
    vNasGCheckMsg2: Any
    vNasGCheckTest: Any
    vNasGCheckTest2: Any
    vNasGCheckTol: Any
    vNasGCheckTol2: Any
    vNasGenSpecRequest: Any
    vNasMCheckGrndDOFSet: Any
    vNasMCheckWtDOFSet: Any
    vNasModeFreqRange: Any
    vNasModeImagFreqRange: Any
    vNasModeXYRequest: Any
    vNasMsnlCntConv_flags: Any
    vNasMsnlCntConv_value: Any
    vNasNonlinEps: Any
    vNasNonlinEpsFlag: Any
    vNasRandXYRequest: Any
    vNasRandXYRequest2: Any
    vNasRandomRequest: Any
    vOutput: Any

    def ALPHAD(self, alpha) -> Any:
        """
        **Description:**
            This method sets the Mass value (Damping) on ANSYS Transient Analysis dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **alpha:** Mass value (Damping)\n
        **Return Code:** False\n
        :type alpha: float

        """
        ...

    def ARCLEN(self, key) -> Any:
        """
        **Description:**
            This method sets the Arc-Length option on ANSYS Nonlinear dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, enables Arc-Length option\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def AUTOTS(self, key) -> Any:
        """
        **Description:**
            This method sets the Automatic Time Stepping (AUTOTS) option on ANSYS Load Step Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, enables Automatic Time Stepping (AUTOTS) option\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def ActiveContactEntities(self, bContact, nConnectorSetID, nRegionSetID, nConPropSetID) -> Any:
        """
        **Description:**
            This method is used to populate Set Objects with the Connectors, Connection Regions, and Connection Properties that will be exported for Contact or Glue Contact by an analysis set. This method takes into consideration the settings in the Contact Sets or Glue Sets section of the Boundary Conditions dialog box for Simcenter SOL 401/402 or setting for Contact/Glue Sets of the Boundary Conditions dialog box for MSC Nastran
        **Remarks/Usage:**
            It is important to use three uniques Set Objects when using this method, otherwise the IDs of different entity types may contaminate a Set. Also, it is recommend to use empty sets to insure that only the Connection entities from a single Analysis Set populate the three sets.
        **Input:**
            **bContact:** If True, populates sets with connection entities for Contact. If False, populates sets with connection entities for Glued Contact\n
            **nConnectorSetID:** Set ID of Set Object to populate with Connectors which will be exported by this analysis set\n
            **nRegionSetID:** Set ID of Set Object to populate with Connection Regions which will be exported by this analysis set\n
            **nConPropSetID:** Set ID of Set Object to populate with Connection Properties which will be exported by this analysis set\n
        **Return Code:** False\n
        :type bContact: bool

        :type nConnectorSetID: int

        :type nRegionSetID: int

        :type nConPropSetID: int

        """
        ...

    def AllFreqOff(self) -> Any:
        """
        **Description:**
            This method turns off all available lists of solution frequencies (FREQ and FREQi entries) in the Solution Frequencies tab of the NASTRAN Dynamic Analysis dialog box
        **Remarks/Usage:**
            This method applies only to the analysis set currently loaded into a AnalysisMgr object
        **Return Code:** False\n
        """
        ...

    def AllFreqOn(self) -> Any:
        """
        **Description:**
            This method turns on all available lists of solution frequencies (FREQ and FREQi entries) in the Solution Frequencies tab of the NASTRAN Dynamic Analysis dialog box
        **Remarks/Usage:**
            This method applies only to the analysis set currently loaded into a AnalysisMgr object
        **Return Code:** False\n
        """
        ...

    def Analyze(self, entID) -> Any:
        """
        **Description:**
            Selects and analyzes an Analysis Set.
        **Remarks/Usage:**
            This method can be used to select an analysis set and run the associated analysis program.
        **Input:**
            **entID:** The ID of the Analysis Set to be analyzed.\n
        **Return Code:** False\n
        :type entID: int

        """
        ...

    def AnalyzeMultiple(self, SetID) -> Any:
        """
        **Description:**
            Selects and sequentially analyzes one or more Analysis Sets.
        **Remarks/Usage:**
            This method can be used to select multiple analysis sets and run the associated analysis program.
        **Input:**
            **SetID:** The ID of a Set that contains the IDs of the Analysis Sets to be analyzed.\n
        **Return Code:** False\n
        :type SetID: int

        """
        ...

    def AnsRSTcomp(self, level) -> Any:
        """
        **Description:**
            This method specifies the File Compression Level option in the ANSYS Command and Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **level:** Specifies the value for File Compression Level.\n
        **Return Code:** False\n
        :type level: int

        """
        ...

    def AnsSkipCsys(self, key) -> Any:
        """
        **Description:**
            This method specifies setting for Skip CSys option in the ANSYS Command and Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, option is enabled. When False, option is disabled.\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def AnsSkipElem(self, key) -> Any:
        """
        **Description:**
            This method specifies setting for Skip Elem option in the ANSYS Command and Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, option is enabled. When False, option is disabled.\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def AnsSkipGroup(self, key) -> Any:
        """
        **Description:**
            This method specifies setting for Skip Group option in the ANSYS Command and Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, option is enabled. When False, option is disabled.\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def AnsSkipMatl(self, key) -> Any:
        """
        **Description:**
            This method specifies setting for Skip Matl option in the ANSYS Command and Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, option is enabled. When False, option is disabled.\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def AnsSkipMisc(self, key) -> Any:
        """
        **Description:**
            This method specifies setting for Skip Misc option in the ANSYS Command and Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, option is enabled. When False, option is disabled.\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def AnsSkipNode(self, key) -> Any:
        """
        **Description:**
            This method specifies setting for Skip Node option in the ANSYS Command and Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, option is enabled. When False, option is disabled.\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def AnsSkipProp(self, key) -> Any:
        """
        **Description:**
            This method specifies setting for Skip Prop option in the ANSYS Command and Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, option is enabled. When False, option is disabled.\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def AnsWriteGroup(self, group) -> Any:
        """
        **Description:**
            This method specifies a Group ID for the Portion of Model to Write option in the ANSYS Command and Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **group:** ID of Group to write to the input file. To write out the entire model, set this value to 0.\n
        **Return Code:** False\n
        :type group: int

        """
        ...

    def BCSet(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def BETAD(self, beta) -> Any:
        """
        **Description:**
            This method sets the Stiffness value (Damping) on ANSYS Transient Analysis dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **beta:** Stiffness value (Damping)\n
        **Return Code:** False\n
        :type beta: float

        """
        ...

    def BUCOPT(self, method, nMode, shift, ldmulte, rangekey) -> Any:
        """
        :type method: Any
        :type nMode: Any
        :type shift: Any
        :type ldmulte: Any
        :type rangekey: Any
        """
        ...

    def CNVTOL(self, lab, value, toler) -> Any:
        """
        :type lab: Any
        :type value: Any
        :type toler: Any
        """
        ...

    def CUTCONTROL(self, lab, value) -> Any:
        """
        :type lab: Any
        :type value: Any
        """
        ...

    def Case(self, entID) -> Any:
        """
        **Description:**
            This method creates and returns an AnalysisCase object that is loaded with the options referenced by a case.
        **Remarks/Usage:**
            The current AnalysisMgr object must be loaded with the data from the set that contains the case that you want to retrieve. The AnalysisMgr.ID property is used to define the set that you want to retrieve.
        **Input:**
            **entID:** The ID of the Analysis Case to load.\n
        **Return Code:** False\n
        :type entID: int

        """
        ...

    def ClearAnalysisQueue(self) -> Any:
        """
        **Description:**
            Clears the Analysis Job Queue of jobs.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def ClearFLXSLISet(self) -> Any:
        """
        **Description:**
            This method clears the array that contains the IDs of the Flexible Sliders currently enabled for analysis.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def ClearMptSet(self) -> Any:
        """
        **Description:**
            This method clears the array that contains the IDs of the Monitor Points currently enabled for analysis.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def DELTIM(self, dtime, dtmin, dtmax) -> Any:
        """
        :type dtime: Any
        :type dtmin: Any
        :type dtmax: Any
        """
        ...

    def DMPRAT(self, rat) -> Any:
        """
        **Description:**
            This method sets the Ratio value (Damping) on ANSYS Transient Analysis dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **rat:** Ratio value (Damping)\n
        **Return Code:** False\n
        :type rat: float

        """
        ...

    def DMPSTR(self, dmp) -> Any:
        """
        **Description:**
            This method sets the Struct value (Damping) on ANSYS Transient Analysis dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **dmp:** Struct value (Damping)\n
        **Return Code:** False\n
        :type dmp: float

        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteAnalysisCase(self, nSetID, nCaseID) -> Any:
        """
        **Description:**
            Use this method to delete an analysis case.
        **Remarks/Usage:**
            This method takes care of deleting any start/end text or Marc contact table records that referenced the case.
        **Input:**
            **nSetID:** The Analysis SetID containing the case to be deleted\n
            **nCaseID:** The Case ID to be deleted\n
        **Return Code:** False\n
        :type nSetID: int

        :type nCaseID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def DynSkipCsys(self, key) -> Any:
        """
        **Description:**
            This method specifies setting for Skip CSys option in the LS-DYNA Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, option is enabled. When False, option is disabled.\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def DynSkipElem(self, key) -> Any:
        """
        **Description:**
            This method specifies setting for Skip Elem option in the LS-DYNA Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, option is enabled. When False, option is disabled.\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def DynSkipGroup(self, key) -> Any:
        """
        **Description:**
            This method specifies setting for Skip Group option in the LS-DYNA Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, option is enabled. When False, option is disabled.\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def DynSkipMatl(self, key) -> Any:
        """
        **Description:**
            This method specifies setting for Skip Matl option in the LS-DYNA Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, option is enabled. When False, option is disabled.\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def DynSkipMisc(self, key) -> Any:
        """
        **Description:**
            This method specifies setting for Skip Misc option in the LS-DYNA Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, option is enabled. When False, option is disabled.\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def DynSkipNode(self, key) -> Any:
        """
        **Description:**
            This method specifies setting for Skip Node option in the LS-DYNA Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, option is enabled. When False, option is disabled.\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def DynSkipProp(self, key) -> Any:
        """
        **Description:**
            This method specifies setting for Skip Prop option in the LS-DYNA Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, option is enabled. When False, option is disabled.\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def DynWriteGroup(self, group) -> Any:
        """
        **Description:**
            This method specifies a Group ID for the Portion of Model to Write option in the LS-DYNA Model Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **group:** ID of Group to write to the input file. To write out the entire model, set this value to 0.\n
        **Return Code:** False\n
        :type group: int

        """
        ...

    def EQSLV(self, lab) -> Any:
        """
        :type lab: Any
        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def FStDynFreqRange(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetContactTable(self, Count, rowSeg, colSeg, tieType, distTol, sepForce, friction, interClose) -> Any:
        """
        **Description:**
            This method retrieves data from the Contact Table.
        **Remarks/Usage:**
            None
        **Output:**
            **Count:** The number of entries in each of the other vectors.\n
            **rowSeg:** The IDs of the contact segments referenced in rows of the table\n
            **colSeg:** The IDs of the contact segments referenced in columns of the table\n
            **tieType:** The tying type (0,1=None, 2=Touch, 3=Glue)\n
            **distTol:** The distance tolerance\n
            **sepForce:** The separation force\n
            **friction:** The friction values\n
            **interClose:** The interference closure\n
        **Return Code:** False\n
        :type Count: int

        :type rowSeg: tuple[int]

        :type colSeg: tuple[int]

        :type tieType: tuple[int]

        :type distTol: tuple[float]

        :type sepForce: tuple[float]

        :type friction: tuple[float]

        :type interClose: tuple[float]

        """
        ...

    def GetCorrelate(self, Count, excitedCase, appliedCase, realScale, imagScale, realFunc, imagFunc) -> Any:
        """
        **Description:**
            This method retrieves data from the Random Analysis Correlation Table.
        **Remarks/Usage:**
            This function has been replace by GetCorrelate2 in Femap 10.1. The AnalysisMgr object must be loaded with data from the associated set before this function can be used.
        **Output:**
            **Count:** The number of entries in each of the other vectors.\n
            **excitedCase:** The IDs of the analysis case being excited.\n
            **appliedCase:** The IDs of the analysis case where the PSD is applied.\n
            **realScale:** The scale factor for the real portion of the PSD.\n
            **imagScale:** The scale factor for the imaginary portion of the PSD.\n
            **realFunc:** The IDs of functions defining the real PSDs.\n
            **imagFunc:** The IDs of functions defining the imaginary PSDs.\n
        **Return Code:** False\n
        :type Count: int

        :type excitedCase: tuple[int]

        :type appliedCase: tuple[int]

        :type realScale: tuple[float]

        :type imagScale: tuple[float]

        :type realFunc: tuple[int]

        :type imagFunc: tuple[int]

        """
        ...

    def GetCorrelate2(self, Count, excitedCase, appliedCase, realScale, imagScale, realFunc, imagFunc, realInterp,
                      imagInterp) -> Any:
        """
        **Description:**
            This method retrieves data from the Random Analysis Correlation Table.
        **Remarks/Usage:**
            The AnalysisMgr object must be loaded with data from the associated set before this function can be used.
        **Output:**
            **Count:** The number of entries in each of the other vectors.\n
            **excitedCase:** The IDs of the analysis case being excited.\n
            **appliedCase:** The IDs of the analysis case where the PSD is applied.\n
            **realScale:** The scale factor for the real portion of the PSD.\n
            **imagScale:** The scale factor for the imaginary portion of the PSD.\n
            **realFunc:** The IDs of functions defining the real PSDs.\n
            **imagFunc:** The IDs of functions defining the imaginary PSDs.\n
            **imagInterp:** The IDs of Interpolation method defining the imaginary PSD. 0=Log Log, 1=Linear, 2=XLog YLin, 3=XLin YLog \n
        **Return Code:** False\n
        :type Count: int

        :type excitedCase: tuple[int]

        :type appliedCase: tuple[int]

        :type realScale: tuple[float]

        :type imagScale: tuple[float]

        :type realFunc: tuple[int]

        :type imagFunc: tuple[int]

        :type imagInterp: tuple[int]

        """
        ...

    def GetFLXSLISet(self, pSelectedFLXSLISet) -> Any:
        """
        **Description:**
            Gets Flexible Sliders enabled for an analysis
        **Remarks/Usage:**
            None
        **Output:**
            **pSelectedFLXSLISet:** Set object that contains the IDs of the Flexible Sliders enabled for analysis\n
        **Return Code:** False\n
        :type pSelectedFLXSLISet: Any

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetMptSet(self, pSelectedMptSet) -> Any:
        """
        **Description:**
            Gets Monitor Points enabled for an analysis
        **Remarks/Usage:**
            None
        **Output:**
            **pSelectedMptSet:** Set object that contains the IDs of the Monitor Points enabled for analysis\n
        **Return Code:** False\n
        :type pSelectedMptSet: Any

        """
        ...

    def GetOptLimits(self, nSetID, bClear) -> Any:
        """
        **Description:**
            Gets Optimization Limits (Optimization Response objects) enabled for an analysis
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of Set Object to be populated\n
            **bClear:** Clear existing entities\n
        **Return Code:** False\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def GetOptMCs(self, nSetID, bClear) -> Any:
        """
        **Description:**
            Gets Topology Optimization Manufacturing Constraints enabled for an analysis
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of Set Object to be populated\n
            **bClear:** Clear existing entities\n
        **Return Code:** False\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def GetOptVars(self, nSetID, bClear) -> Any:
        """
        **Description:**
            Gets Optimization Variables (Optimization Relationship objects) enabled for an analysis
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of Set to be populated\n
            **bClear:** Clear existing entities\n
        **Return Code:** False\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def GetStandardTrim(self, useTrim, TrimID, TrimVal) -> Any:
        """
        **Description:**
            This method retrieves data from the standard trim definition.
        **Remarks/Usage:**
            Valid TrimID values:
        **Output:**
            **useTrim:** 0=Off,1=Use, 2= Fixed. See Remarks for array index value\n
            **TrimID:** Not currently used\n
            **TrimVal:** Magnitude value when UseTrim[i] = Fixed. See Remarks for array index value\n
        **Return Code:** False\n
        :type useTrim: tuple[int]

        :type TrimID: tuple[int]

        :type TrimVal: tuple[float]

        """
        ...

    def GetText(self, textID, text) -> Any:
        """
        **Description:**
            This method returns a string containing the text associated with a specified textID.
        **Remarks/Usage:**
            Text IDs are returned from various AnalysisMgr properties. These properties have names ending with StartText or EndText.
        **Input:**
            **textID:** A textID returned from one of the text properties.\n
        **Output:**
            **text:** A string containing the text. This string will contain carriage control characters if there are multiple lines in the text.\n
        **Return Code:** True\n
        :type textID: int

        :type text: str

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTrimControlSurf(self, useTrim, TrimID, TrimVal) -> Any:
        """
        **Description:**
            This method retrieves data from the trim definition for user defined Aero Control Surfaces
        **Remarks/Usage:**

        **Output:**
            **useTrim:** 0=Off,1=Use, 2= Fixed\n
            **TrimID:** ID of the Femap Aero Control Surface Entity\n
            **TrimVal:** magnitude\n
        **Return Code:** False\n
        :type useTrim: tuple[int]

        :type TrimID: tuple[int]

        :type TrimVal: tuple[float]

        """
        ...

    def GetUsedFREQS(self, nSetID) -> Any:
        """
        **Description:**
            This method fills a set object with the FREQS that are turned on in the specified analysis set.
        **Remarks/Usage:**
            This method applies only to the analysis set currently loaded into a AnalysisMgr object
        **Return Code:** True\n
        """
        ...

    def HARFRQ(self, freqb, freqe, logopt) -> Any:
        """
        :type freqb: Any
        :type freqe: Any
        :type logopt: Any
        """
        ...

    def HROPT(self, method, maxmode, minmode) -> Any:
        """
        :type method: Any
        :type maxmode: Any
        :type minmode: Any
        """
        ...

    def HROUT(self, reimky, clust) -> Any:
        """
        :type reimky: Any
        :type clust: Any
        """
        ...

    def InitAnalysisMgr(self, analysis_program, analysis_type, InitMasterCase) -> Any:
        """
        **Description:**
            This method initializes default options in the AnalysisMgr object
        **Remarks/Usage:**
            None
        **Input:**
            **analysis_program:** Refer to the Solver property\n
            **analysis_type:** Refer to the AnalysisType property\n
            **InitMasterCase:** If true, also initializes the Master Case in in the object\n
        **Return Code:** True\n
        :type analysis_program: int

        :type analysis_type: int

        :type InitMasterCase: bool

        """
        ...

    def KBC(self, key) -> Any:
        """
        **Description:**
            This method sets the Amplitude (KBC) option on ANSYS Load Step Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, enables Amplitude (KBC) option\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def LANBOPTION(self, strmck) -> Any:
        """
        **Description:**
            This method sets the Strum Sequence Check option on ANSYS Modal Analysis dialog box for use the Block Lanczos mode extraction method
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def LNSRCH(self, key) -> Any:
        """
        **Description:**
            This method sets the Line Search option on ANSYS Nonlinear dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, enables Line Search option\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def LUMPM(self, key) -> Any:
        """
        **Description:**
            This method sets the Lumper option on ANSYS Transient Dynamics dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, enables Lumped option\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def MIDTOL(self, key, tolerb, resfq) -> Any:
        """
        :type key: Any
        :type tolerb: Any
        :type resfq: Any
        """
        ...

    def MODOPT(self, method, nMode, freqb, freqe, cpxmod, nrmkey) -> Any:
        """
        :type method: Any
        :type nMode: Any
        :type freqb: Any
        :type freqe: Any
        :type cpxmod: Any
        :type nrmkey: Any
        """
        ...

    def MSCNasCnlConvergenceFlags(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NEQIT(self, NEQIT) -> Any:
        """
        **Description:**
            This method sets the Max Iterations value on ANSYS Nonlinear dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **NEQIT:** Max Iterations value\n
        **Return Code:** False\n
        :type NEQIT: int

        """
        ...

    def NLGEOM(self, key) -> Any:
        """
        **Description:**
            This method sets the Nonlinear Geometry option on ANSYS Nonlinear dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, enables Nonlinear Geometry option\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def NROPT(self, option1) -> Any:
        """
        :type option1: Any
        """
        ...

    def NSUBST(self, nsbst, nsbmx, nsbmn) -> Any:
        """
        :type nsbst: Any
        :type nsbmx: Any
        :type nsbmn: Any
        """
        ...

    def NasBulkAlpha1Val(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasBulkAlpha2Val(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasCnlConvergenceFlags(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasCnlConvergenceValue(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasDdamCoeffOn(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasDdamCoeffVal(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasDynKeepFreq(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasGCheckMsg(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasGCheckMsg2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasGCheckTest(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasGCheckTest2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasGCheckTol(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasGCheckTol2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasGenSpecRequest(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasMCheckGrndDOFSet(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasMCheckWtDOFSet(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasModeFreqRange(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasModeImagFreqRange(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasModeXYRequest(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasNonlinEps(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasNonlinEpsFlag(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasRandXYRequest(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NasRandomRequest(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def OUTPR(self, item, FREQ, nth, cname) -> Any:
        """
        :type item: Any
        :type FREQ: Any
        :type nth: Any
        :type cname: Any
        """
        ...

    def OUTRES(self, item, FREQ, nth, cname) -> Any:
        """
        :type item: Any
        :type FREQ: Any
        :type nth: Any
        :type cname: Any
        """
        ...

    def Output(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def PCGOPT(self, strmck) -> Any:
        """
        **Description:**
            This method sets the Strum Sequence Check option on ANSYS Modal Analysis dialog box for the PCG Lanczos mode extraction method
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def PFACT(self, tblno, excit) -> Any:
        """
        **Description:**
            This method sets the PSD table on the ANSYS Random Vibration Analysis Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **tblno:** ID of the function, 0=DISP, 1=VEL, 2=ACEL (Acc2/Hz), 3=ACCG (g2/Hz), 4=FORC, 5=PRES.\n
            **excit:** Sets the Mode Factors, True = Node, False = Base.\n
        **Return Code:** False\n
        :type tblno: int

        :type excit: bool

        """
        ...

    def PRED(self, sskey) -> Any:
        """
        **Description:**
            This method sets the Predictor option on ANSYS Nonlinear dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **sskey:** When True, enables Predictor option\n
        **Return Code:** False\n
        :type sskey: bool

        """
        ...

    def PSDCOM(self, signif, comode, forcetype) -> Any:
        """
        **Description:**
            This method sets the Mode Combinations options on the ANSYS Random Vibration Analysis Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **signif:** Sets the Significance value. \n
            **comode:** Sets the Mode Number value.\n
            **forcetype:** Sets the Combine Force, True = Static, False = Total.\n
        **Return Code:** False\n
        :type signif: float

        :type comode: int

        :type forcetype: bool

        """
        ...

    def PSDUNIT(self, tblno, type) -> Any:
        """
        **Description:**
            This method sets the PSD table on the ANSYS Random Vibration Analysis Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **tblno:** ID of the function, 0=DISP, 1=VEL, 2=ACEL (Acc2/Hz), 3=ACCG (g2/Hz), 4=FORC, 5=PRES.\n
            **type:** Specifies the PSD type.\n
        **Return Code:** False\n
        :type tblno: int

        :type type: int

        """
        ...

    def PSTRES(self, key) -> Any:
        """
        **Description:**
            This method sets the Include Prestress Effects (PSTRES) option on ANSYS Load Step Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **key:** When True, enables Include Prestress Effects (PSTRES) option\n
        **Return Code:** False\n
        :type key: bool

        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Preview(self, entID) -> Any:
        """
        **Description:**
            Calls Preview Input in the Analysis Set Manager
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutContactTable(self, Count, rowSeg, colSeg, tieType, distTol, sepForce, friction, interClose) -> Any:
        """
        **Description:**
            This method replaces data in the Contact Table
        **Remarks/Usage:**
            This function completely replaces the contact table - it does not add to data that is already there.
        **Input:**
            **Count:** The number of entries in each of the other vectors.\n
            **rowSeg:** The IDs of the contact segments referenced in rows of the table\n
            **colSeg:** The IDs of the contact segments referenced in columns of the table\n
            **tieType:** The tying type (0,1=None, 2=Touch, 3=Glue)\n
            **distTol:** The distance tolerance\n
            **sepForce:** The separation force\n
            **friction:** The friction values\n
            **interClose:** The interference closure\n
        **Return Code:** False\n
        :type Count: int

        :type rowSeg: tuple[int]

        :type colSeg: tuple[int]

        :type tieType: tuple[int]

        :type distTol: tuple[float]

        :type sepForce: tuple[float]

        :type friction: tuple[float]

        :type interClose: tuple[float]

        """
        ...

    def PutCorrelate(self, Count, excitedCase, appliedCase, realScale, imagScale, realFunc, imagFunc) -> Any:
        """
        **Description:**
            This method replaces data in the Random Analysis Correlation Table.
        **Remarks/Usage:**
            This function has been replace by PutCorrelate2 in Femap 10.1. The AnalysisMgr object must be loaded with data from the associated set before this function can be used. This function completely replaces the correlation table - it does not add to data that is already there.
        **Input:**
            **Count:** The number of entries in each of the other vectors.\n
            **excitedCase:** The IDs of the analysis case being excited.\n
            **appliedCase:** The IDs of the analysis case where the PSD is applied.\n
            **realScale:** The scale factor for the real portion of the PSD.\n
            **imagScale:** The scale factor for the imaginary portion of the PSD.\n
            **realFunc:** The IDs of functions defining the real PSDs.\n
            **imagFunc:** The IDs of functions defining the imaginary PSDs.\n
        **Return Code:** False\n
        :type Count: int

        :type excitedCase: tuple[int]

        :type appliedCase: tuple[int]

        :type realScale: tuple[float]

        :type imagScale: tuple[float]

        :type realFunc: tuple[int]

        :type imagFunc: tuple[int]

        """
        ...

    def PutCorrelate2(self, Count, excitedCase, appliedCase, realScale, imagScale, realFunc, imagFunc, realInterp,
                      imagInterp) -> Any:
        """
        **Description:**
            This method replaces data in the Random Analysis Correlation Table.
        **Remarks/Usage:**
            The AnalysisMgr object must be loaded with data from the associated set before this function can be used. This function completely replaces the correlation table - it does not add to data that is already there.
        **Input:**
            **Count:** The number of entries in each of the other vectors.\n
            **excitedCase:** The IDs of the analysis case being excited.\n
            **appliedCase:** The IDs of the analysis case where the PSD is applied.\n
            **realScale:** The scale factor for the real portion of the PSD.\n
            **imagScale:** The scale factor for the imaginary portion of the PSD.\n
            **realFunc:** The IDs of functions defining the real PSDs.\n
            **imagFunc:** The IDs of functions defining the imaginary PSDs.\n
            **imagInterp:** The IDs of Interpolation method defining the imaginary PSD. 0=Log Log, 1=Linear, 2=XLog YLin, 3=XLin YLog \n
        **Return Code:** False\n
        :type Count: int

        :type excitedCase: tuple[int]

        :type appliedCase: tuple[int]

        :type realScale: tuple[float]

        :type imagScale: tuple[float]

        :type realFunc: tuple[int]

        :type imagFunc: tuple[int]

        :type imagInterp: tuple[int]

        """
        ...

    def PutFLXSLISet(self, pSelectedFLXSLISet) -> Any:
        """
        **Description:**
            Sets Flexible Sliders enabled for an analysis
        **Remarks/Usage:**
            None
        **Input:**
            **pSelectedFLXSLISet:** Set Object containing the IDs of the flexible sliders to enable\n
        **Return Code:** False\n
        :type pSelectedFLXSLISet: Any

        """
        ...

    def PutFLXSLISetID(self, nSetID) -> Any:
        """
        **Description:**
            Alternative method for specifying Flexible Sliders enabled for an analysis
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of Set Object containing Flexible Slider IDs. Alternatively, specify a negative number to enable a single flexible slider.\n
        **Return Code:** False\n
        :type nSetID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def PutMptSet(self, pSelectedMptSet) -> Any:
        """
        **Description:**
            Sets Monitor Points enabled for an analysis
        **Remarks/Usage:**
            None
        **Input:**
            **pSelectedMptSet:** Set Object containing the IDs of the monitor points to enable\n
        **Return Code:** False\n
        :type pSelectedMptSet: Any

        """
        ...

    def PutMptSetID(self, nSetID) -> Any:
        """
        **Description:**
            Alternative method for specifying Monitor Points enabled for an analysis
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of Set Object containing Monitor Point IDs. Alternatively, specify a negative number to enable a single monitor point.\n
        **Return Code:** False\n
        :type nSetID: int

        """
        ...

    def PutOptLimits(self, nSetID, bClear) -> Any:
        """
        **Description:**
            Sets Optimization Limits (Optimization Response objects) enabled for an analysis
        **Remarks/Usage:**

        **Input:**
            **nSetID:** ID of Set Object containing Optimization Limits (Response) IDs. Alternatively, specify a negative number to put a single optimization variable\n
            **bClear:** Clear existing entities\n
        **Return Code:** False\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def PutOptMCs(self, nSetID, bClear) -> Any:
        """
        **Description:**
            Sets Topology Optimization Manufacturing Constraints enabled for an analysis
        **Remarks/Usage:**

        **Input:**
            **nSetID:** ID of Set Object containing Manufacturing Constraint IDs. Alternatively, specify a negative number to put a single manufacturing constraint.\n
            **bClear:** Clear existing entities\n
        **Return Code:** False\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def PutOptVars(self, nSetID, bClear) -> Any:
        """
        **Description:**
            Sets Optimization Variables (Optimization Relationship objects) enabled for an analysis
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of Set Object containing Optimization Variable (Relationship) IDs. Alternatively, specify a negative number to put a single optimization variable\n
            **bClear:** Clear existing entities\n
        **Return Code:** False\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def PutStandardTrim(self, useTrim, TrimID, TrimVal) -> Any:
        """
        **Description:**
            This method loads standard trim data into the trim definition.
        **Remarks/Usage:**
            Valid index values:
        **Input:**
            **useTrim:** 0=Off, 1=Use, 2= Fixed. See Remarks for array index value\n
            **TrimID:** Not currently used\n
            **TrimVal:** Magnitude value when UseTrim[i] = Fixed. See Remarks for array index value\n
        **Return Code:** False\n
        :type useTrim: tuple[int]

        :type TrimID: tuple[int]

        :type TrimVal: tuple[float]

        """
        ...

    def PutText(self, textID, text) -> Any:
        """
        **Description:**
            This method updates or creates text to associate with a text property.
        **Remarks/Usage:**
            Text IDs are returned from various AnalysisMgr properties. These properties have names ending with StartText or EndText.
        **Input:**
            **textID:** A textID used to store the text string. Specify the same value as the text property returned if you simply want to update the text. Specify 0 if you want to create a new text entity. In this case, the return value will be the textID that was created. You should set the text property to this value.\n
            **text:** A string containing the text. May contain carriage control to signify multiple lines.\n
        **Return Code:** False\n
        :type textID: int

        :type text: str

        """
        ...

    def PutTrimControlSurf(self, useTrim, TrimID, TrimVal) -> Any:
        """
        **Description:**
            This method loads user defined Aero Control Surface data into the Trim definition
        **Remarks/Usage:**

        **Input:**
            **useTrim:** 0=Off,1=Use, 2= Fixed\n
            **TrimID:** ID of the Femap Aero Control Surface Entity\n
            **TrimVal:** magnitude\n
        **Return Code:** False\n
        :type useTrim: tuple[int]

        :type TrimID: tuple[int]

        :type TrimVal: tuple[float]

        """
        ...

    def PutUsedFREQS(self, nSetID) -> Any:
        """
        **Description:**
            This method puts a set object filled with FREQ IDs to be turned on in the specified analysis set.
        **Remarks/Usage:**
            This method applies only to the analysis set currently loaded into a AnalysisMgr object
        **Return Code:** True\n
        """
        ...

    def QRDOPT(self, reusekey, symmeth) -> Any:
        """
        :type reusekey: Any
        :type symmeth: Any
        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SNOPTION(self, rangefact, blocksize, robustlev, compute) -> Any:
        """
        :type rangefact: Any
        :type blocksize: Any
        :type robustlev: Any
        :type compute: Any
        """
        ...

    def SPOPT(self, sptype, nMode, elcalc) -> Any:
        """
        **Description:**
            This method sets the Spectrum options on ANSYS Random Vibration Analysis Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **sptype:** ID of the spectrum type option.\n
            **nMode:** Specifies the number of modes.\n
            **elcalc:** When True, Element Results is on. \n
        **Return Code:** False\n
        :type sptype: int

        :type nMode: int

        :type elcalc: bool

        """
        ...

    def SUBOPT(self, strmck) -> Any:
        """
        **Description:**
            This method sets the Strum Sequence Check option on ANSYS Modal Analysis dialog box for use the Subspace mode extraction method
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetBCSet(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetFStDynFreqRange(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetMSCNasCnlConvergenceFlags(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasBulkAlpha1Val(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasBulkAlpha2Val(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasCnlConvergenceFlags(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasCnlConvergenceValue(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasDdamCoeffOn(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasDdamCoeffVal(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasDynKeepFreq(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasGCheckMsg(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasGCheckMsg2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasGCheckTest(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasGCheckTest2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasGCheckTol(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasGCheckTol2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasGenSpecRequest(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasMCheckGrndDOFSet(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasMCheckWtDOFSet(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasModeFreqRange(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasModeImagFreqRange(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasModeXYRequest(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasNonlinEps(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasNonlinEpsFlag(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasRandXYRequest(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNasRandomRequest(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetOutput(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def TIME(self, TIME) -> Any:
        """
        **Description:**
            This method sets the Time Duration value on ANSYS Time Step Options dialog box
        **Remarks/Usage:**
            None
        **Input:**
            **TIME:** Time Duration value\n
        **Return Code:** False\n
        :type TIME: float

        """
        ...

    def TINTP(self, gamma, alpha, delta, theta, oslm, tol, avsmooth, alphaf, alpham) -> Any:
        """
        :type gamma: Any
        :type alpha: Any
        :type delta: Any
        :type theta: Any
        :type oslm: Any
        :type tol: Any
        :type avsmooth: Any
        :type alphaf: Any
        :type alpham: Any
        """
        ...

    def TRNOUT(self, method, maxmode, minmode, mcout, tintopt, vaout, dmpsfreq) -> Any:
        """
        :type method: Any
        :type maxmode: Any
        :type minmode: Any
        :type mcout: Any
        :type tintopt: Any
        :type vaout: Any
        :type dmpsfreq: Any
        """
        ...

    def TurnOffFreq(self, freqID) -> Any:
        """
        **Description:**
            This method turns off any number of lists of solution frequencies (FREQ and FREQi entries) in the Solution Frequencies tab of the NASTRAN Dynamic Analysis dialog box
        **Remarks/Usage:**
            This method applies only to the analysis set currently loaded into a AnalysisMgr object
        **Return Code:** False\n
        """
        ...

    def TurnOnFreq(self, freqID) -> Any:
        """
        **Description:**
            This method turns on any number of lists of solution frequencies (FREQ and FREQi entries) in the Solution Frequencies tab of the NASTRAN Dynamic Analysis dialog box
        **Remarks/Usage:**
            This method applies only to the analysis set currently loaded into a AnalysisMgr object
        **Return Code:** False\n
        """
        ...


class BCEqn:
    CLSID: Any
    Active: Any
    BCDefinitionID: Any
    Count: Any
    ID: Any
    SetID: Any
    color: Any
    layer: Any
    vcoefficient: Any
    vdof: Any
    vnode: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetAll(self, nID, nSetID, pnDefID, pnCount, pvNode, pvDof, pvCoeff, peColor, pnLayer) -> Any:
        """
        **Description:**
            Retrieves all constraint equation properties in a single call
        **Remarks/Usage:**

        **Input:**
            **nID:** ID of Constraint equation\n
            **nSetID:** ID of Constraint set\n
        **Output:**
            **pnDefID:** ID of Constraint definition\n
            **pnCount:** Number of terms in constraint equation\n
            **peColor:** Color of constraint equation\n
        **Return Code:** True\n
        :type nID: int

        :type nSetID: int

        :type pnDefID: int

        :type pnCount: int

        :type peColor: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextOnNode(self, nodeSET) -> Any:
        """
        **Description:**
            Gets the next constraint equation that is defined on a selected set of nodes.
        **Remarks/Usage:**
            Before calling this method, the setID property of the object must be defined to search the desired Constraint Set. Also, you should call Reset before the first call to this method so it will retrieve the first available load.
        **Input:**
            **nodeSET:** The ID of a Set object that contains the IDs of the entities to be searched. Alternatively, if you specify a negative value, this is simply the ID of the single entity to search.\n
        **Return Code:** True\n
        :type nodeSET: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def Node(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutAll(self, nID, nSetID, nDefID, nCount, vnode, vdof, vCoeff, eColor, nlayer) -> Any:
        """
        **Description:**
            Sets all constraint equation properties in a single call,
        **Remarks/Usage:**

        **Input:**
            **nID:** ID of Constraint equation\n
            **nSetID:** ID of Constraint set. If non-existing, one is created\n
            **nDefID:** ID of Constraint definition. If non-existing, one is created. If existing, must be a nodal constraint equation definition\n
            **nCount:** Total number of terms in the constraint equation\n
            **eColor:** Color of constraint equation\n
        **Return Code:** True\n
        :type nID: int

        :type nSetID: int

        :type nDefID: int

        :type nCount: int

        :type eColor: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetNode(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setcoefficient(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setdof(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def coefficient(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def dof(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class BCGeom:
    CLSID: Any
    Active: Any
    BCDefinitionID: Any
    ID: Any
    SetID: Any
    color: Any
    dofvec: Any
    expanded: Any
    geomID: Any
    geomTYPE: Any
    layer: Any
    outCSys: Any
    type: Any
    vdirection: Any
    vdof: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetSearch(self, geomTYPE, geomID) -> Any:
        """
        **Description:**
            This method searches for and retrieves an entity that is constraining a specified geometric entity.
        **Remarks/Usage:**
            Since BCGeom objects are not stored by a specified ID, but rather in sequential order, the normal Get method may not be useful if you are trying to find the constraints on a specific geometric entity. The only way to do that would be to Get every constraint and check for the geometry that you want. This method does that for you. You specify the geometry you want to search for, and it returns the constraints on that entity. Be aware that this method does still search the entire set. If you are going to retrieve constraints on a large number of geometry entities, it could be faster to retrieve them all using Get, and discard the ones you do not want.
        **Input:**
            **geomTYPE:** Type of geometry being constrained: 3=Point, 4=Curve, 5=Surface.\n
            **geomID:** ID of geometry being constrained.\n
        **Return Code:** True\n
        :type geomTYPE: int

        :type geomID: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextOnEntity(self, geomTYPE, geomSET) -> Any:
        """
        **Description:**
            Gets the next constraint that is defined on a selected set of geometric entities.
        **Remarks/Usage:**
            Before calling this method, the setID property of the object must be defined to search the desired Constraint Set. Also, you should call Reset before the first call to this method so it will retrieve the first available load.
        **Input:**
            **geomTYPE:** The type of geometry where the constraints are defined. Must be Point, Curve, or Surface. For entity information, see Section 3.3.6, "Entity Types".\n
        **Return Code:** True\n
        :type geomTYPE: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetArbitrary(self, geomTYPE, geomID, csysID, bDOF1, bDOF2, bDOF3, bDOF4, bDOF5, bDOF6) -> Any:
        """
        **Description:**
            This method initializes the current object to apply boundary conditions in a specified coordinate system, using the selected DOF, on a geometric entity of the specified type
        **Remarks/Usage:**
            This method does not store the constraint. You must still call Put to do that. It simply initializes the properties necessary to define this type of constraint.
        **Input:**
            **geomTYPE:** The type of entity to constrain. For entity information, see page179. Can be 3=Point (FT_POINT), 4=Curve (FT_CURVE), or 5=Surface (FT_SURFACE).\n
            **geomID:** The ID of the point, curve, or surface to constrain\n
            **csysID:** The ID of a coordinate system. Specify -1 to use the output coordinate of each node associated to the specified geometric entity.\n
            **bDOF1:** True = TX constrained in coordinate system specified in csysID\n
            **bDOF2:** True = TY constrained in coordinate system specified in csysID\n
            **bDOF3:** True = TZ constrained in coordinate system specified in csysID\n
            **bDOF4:** True = RX constrained in coordinate system specified in csysID\n
            **bDOF5:** True = RY constrained in coordinate system specified in csysID\n
            **bDOF6:** True = RZ constrained in coordinate system specified in csysID\n
        **Return Code:** True\n
        :type geomTYPE: int

        :type geomID: int

        :type csysID: int

        :type bDOF1: bool

        :type bDOF2: bool

        :type bDOF3: bool

        :type bDOF4: bool

        :type bDOF5: bool

        :type bDOF6: bool

        """
        ...

    def SetCylinder(self, surfID, radius, rotation, sliding) -> Any:
        """
        **Description:**
            This method initializes the current object to allow sliding of a surface in cylindrical directions.
        **Remarks/Usage:**
            This method does not store the constraint. You must still call Put to do that. It simply initializes the properties necessary to define this type of constraint.
        **Return Code:** True\n
        """
        ...

    def SetFixed(self, geomTYPE, geomID) -> Any:
        """
        **Description:**
            This method initializes the current object to apply Fixed boundary conditions (All 6 DOFs constrained) on a geometric entity of the specified type
        **Remarks/Usage:**
            This method does not store the constraint. You must still call Put to do that. It simply initializes the properties necessary to define this type of constraint.
        **Input:**
            **geomTYPE:** The type of entity to constrain. For entity information, see page179. Can be 3=Point (FT_POINT), 4=Curve (FT_CURVE), or 5=Surface (FT_SURFACE).\n
            **geomID:** The ID of the point, curve, or surface to constrain\n
        **Return Code:** True\n
        :type geomTYPE: int

        :type geomID: int

        """
        ...

    def SetNoRotation(self, geomTYPE, geomID) -> Any:
        """
        **Description:**
            This method initializes the current object to apply No Rotation boundary conditions (constrains the 3 rotational DOFs) on a geometric entity of the specified type
        **Remarks/Usage:**
            This method does not store the constraint. You must still call Put to do that. It simply initializes the properties necessary to define this type of constraint.
        **Input:**
            **geomTYPE:** The type of entity to constrain. For entity information, see page179. Can be 3=Point (FT_POINT), 4=Curve (FT_CURVE), or 5=Surface (FT_SURFACE).\n
            **geomID:** The ID of the point, curve, or surface to constrain\n
        **Return Code:** True\n
        :type geomTYPE: int

        :type geomID: int

        """
        ...

    def SetPinned(self, geomTYPE, geomID) -> Any:
        """
        **Description:**
            This method initializes the current object to apply Pinned boundary conditions (constrains the 3 translational DOFs) on a geometric entity of the specified type
        **Remarks/Usage:**
            This method does not store the constraint. You must still call Put to do that. It simply initializes the properties necessary to define this type of constraint.
        **Input:**
            **geomTYPE:** The type of entity to constrain. For entity information, see page179. Can be 3=Point (FT_POINT), 4=Curve (FT_CURVE), or 5=Surface (FT_SURFACE).\n
            **geomID:** The ID of the point, curve, or surface to constrain\n
        **Return Code:** True\n
        :type geomTYPE: int

        :type geomID: int

        """
        ...

    def SetSurfDirection(self, surfID, x, y, z) -> Any:
        """
        **Description:**
            This method initializes the current object to allow sliding of a surface in a specified direction.
        **Remarks/Usage:**
            This method does not store the constraint. You must still call Put to do that. It simply initializes the properties necessary to define this type of constraint.
        **Return Code:** False\n
        """
        ...

    def SetSurfNormal(self, surfID) -> Any:
        """
        **Description:**
            This method initializes the current object to allow movement normal to a surface.
        **Remarks/Usage:**
            This method does not store the constraint. You must still call Put to do that. It simply initializes the properties necessary to define this type of constraint.
        **Return Code:** False\n
        """
        ...

    def SetSurfSliding(self, surfID) -> Any:
        """
        **Description:**
            This method initializes the current object to allow sliding along a surface.
        **Remarks/Usage:**
            This method does not store the constraint. You must still call Put to do that. It simply initializes the properties necessary to define this type of constraint.
        **Return Code:** False\n
        """
        ...

    def Setdirection(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setdof(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def direction(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def dof(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class BCNode:
    CLSID: Any
    Active: Any
    BCDefinitionID: Any
    ID: Any
    NonZeroConstraint: Any
    SetID: Any
    color: Any
    dofvec: Any
    expanded: Any
    layer: Any
    vdof: Any
    vvalue: Any

    def Add(self, SetID, bDOF1, bDOF2, bDOF3, bDOF4, bDOF5, bDOF6) -> Any:
        """
        **Description:**
            This method creates nodal constraints on all selected nodes.
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the other parameters in the object - such as, color, layer and setID, and any other types required for your constraints. This method simply uses the data you specify here to overwrite specific values in the BCNode object, and create a new constraint for each entry in the set of nodes.
        **Input:**
            **SetID:** The ID of a Set object that contains the nodes to constrain. Alternatively, if you specify a negative value, this is simply the ID of the single node to constrain.\n
            **bDOF1, bDOF2, bDOF3, bDOF4, bDOF5, bDOF6:** The constraints to apply to the nodes. If True, the corresponding degree of freedom is constrained.\n

        **Return Code:** True\n
        :type SetID: int
        :type bDOF1: bool
        :type bDOF2: bool
        :type bDOF3: bool
        :type bDOF4: bool
        :type bDOF5: bool
        :type bDOF6: bool

        """
        ...

    def AddArray(self, Count, doDOF, NodeID, dof) -> Any:
        """
        **Description:**
            This method creates multiple nodal constraints. This method is obsolete and should be replaced by PutArray.
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the other parameters in the object - such as, color, layer and setID, and any other types required for your constraints. This method simply uses the data you specify here to overwrite specific values in the BCNode object, and create a new constraint for each entry in the arrays.
        **Input:**
            **Count:** The number of constraints to create, and the number of IDs in NodeID\n
            **doDOF:** If True, then the DOF array must contain degree-of-freedom flags to be used. If False, then whatever is specified in the current object is used and DOF is ignored\n
            **NodeID:** The Node IDs where constraints will be created. One constraint is created on each ID.\n
            **dof:** Flags specifying constraints on each specified node. 6 flags per node. Refer to dof property.\n
        **Return Code:** True\n
        :type Count: int

        :type doDOF: bool

        :type NodeID: tuple[int]

        :type dof: tuple[int]

        """
        ...

    def AddNonZero(self, SetID, bDOF1, dVal1, bDOF2, dVal2, bDOF3, dVal3, bDOF4, dVal4, bDOF5, dVal5, bDOF6,
                   dVal6) -> Any:
        """
        **Description:**
            This method creates non-zero nodal constraints on all selected nodes
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the other parameters in the object - such as, color, layer, and setID, and any other types required for your constraints. This method simply uses the data you specify here to overwrite specific values in the BCNode object, and create a new constraint for each entry in the set of nodes. Also, if a value is specified for a particular DOF which is not currently set to True, but then is set to True later, the value will then also be applied.
        **Input:**
            **SetID:** The ID of a Set object that contains the nodes to constrain. Alternatively, if you specify a negative value, this is simply the ID of the single node to constrain.\n
            **bDOF1:** If True, TX degree of freedom is constrained and corresponding non-zero value will be applied\n
            **dVal1:** Non-zero value for TX degree of freedom\n
            **bDOF2:** If True, TY degree of freedom is constrained and corresponding non-zero value will be applied\n
            **dVal2:** Non-zero value for TY degree of freedom\n
            **bDOF3:** If True, TZ degree of freedom is constrained and corresponding non-zero value will be applied\n
            **dVal3:** Non-zero value for TZ degree of freedom\n
            **bDOF4:** If True, RX degree of freedom is constrained and corresponding non-zero value will be applied\n
            **dVal4:** Non-zero value for RX degree of freedom\n
            **bDOF5:** If True, RY degree of freedom is constrained and corresponding non-zero value will be applied\n
            **dVal5:** Non-zero value for RY degree of freedom\n
            **bDOF6:** If True, RZ degree of freedom is constrained and corresponding non-zero value will be applied\n
            **dVal6:** Non-zero value for RZ degree of freedom\n
        **Return Code:** True\n
        :type SetID: int

        :type bDOF1: bool

        :type dVal1: float

        :type bDOF2: bool

        :type dVal2: float

        :type bDOF3: bool

        :type dVal3: float

        :type bDOF4: bool

        :type dVal4: float

        :type bDOF5: bool

        :type dVal5: float

        :type bDOF6: bool

        :type dVal6: float

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetAllArray(self, Count, ExpandedGeomBC, NodeID, layer, color, BCDefinitionID, bNonZeroBC, dof,
                    NonZeroValues) -> Any:
        """
        **Description:**
            This method finds information on nodal constraints.
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the setID parameter in the object.
        **Output:**
            **Count:** The number of constraints to create, and the number of IDs in NodeID\n
            **ExpandedGeomBC:** The Node IDs where constraints will be created. One constraint is created on each ID.\n
            **NodeID:** The IDs of the layers the loads are on.\n
            **layer:** The IDs of the load color.\n
            **color:** The ID of the constraint definition that contains this constraint (0=None)\n
            **BCDefinitionID:** True if constraint is a NonZero constraint\n
            **bNonZeroBC:** Flags specifying constraints on each specified node. 6 flags per node. Refer to dof property.\n
        **Return Code:** True\n
        :type Count: int

        :type ExpandedGeomBC: tuple[int]

        :type NodeID: tuple[int]

        :type layer: tuple[int]

        :type color: tuple[int]

        :type BCDefinitionID: tuple[bool]

        :type bNonZeroBC: tuple[int]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutAllArray(self, Count, ExpandedGeomBC, NodeID, layer, color, BCDefinitionID, bNonZeroBC, dof,
                    NonZeroValues) -> Any:
        """
        **Description:**
            This method creates multiple nodal constraints.
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the setID parameter in the object.
        **Input:**
            **Count:** The number of constraints to create, and the number of IDs in NodeID\n
            **ExpandedGeomBC:** The Node IDs where constraints will be created. One constraint is created on each ID.\n
            **NodeID:** The IDs of the layers the loads are on.\n
            **layer:** The IDs of the load color.\n
            **color:** The ID of the constraint definition that contains this constraint (0=None)\n
            **BCDefinitionID:** True if constraint is a NonZero constraint\n
            **bNonZeroBC:** Flags specifying constraints on each specified node. 6 flags per node. Refer to dof property.\n
        **Return Code:** True\n
        :type Count: int

        :type ExpandedGeomBC: tuple[int]

        :type NodeID: tuple[int]

        :type layer: tuple[int]

        :type color: tuple[int]

        :type BCDefinitionID: tuple[bool]

        :type bNonZeroBC: tuple[int]

        """
        ...

    def PutArray(self, Count, doDOF, NodeID, dof) -> Any:
        """
        **Description:**
            This method creates multiple nodal constraints.
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the setID parameter in the object.
        **Input:**
            **Count:** The number of constraints to create, and the number of IDs in NodeID\n
            **doDOF:** If True, then the DOF array must contain degree-of-freedom flags to be used. If False, then whatever is specified in the current object is used and DOF is ignored\n
            **NodeID:** The Node IDs where constraints will be created. One constraint is created on each ID.\n
            **dof:** Flags specifying constraints on each specified node. 6 flags per node. Refer to dof property.\n
        **Return Code:** True\n
        :type Count: int

        :type doDOF: bool

        :type NodeID: tuple[int]

        :type dof: tuple[int]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def Setdof(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setvalue(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def dof(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def value(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class BCSet:
    CLSID: Any
    Active: Any
    ID: Any
    IsCombination: Any
    SetID: Any
    title: Any

    def Compress(self) -> Any:
        """
        **Description:**
            This method compresses all of the geometric constraints in a selected constraint set.
        **Remarks/Usage:**
            This method takes the current constraint set object (uses the ID), and compresses (deletes) any expanded constraints. You are left with the unexpanded geometric constraints.
        **Return Code:** True\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Expand(self) -> Any:
        """
        **Description:**
            This method expands all of the geometric constraints in a selected constraint set.
        **Remarks/Usage:**
            This method takes the current constraint set object (uses the ID), and expands all of the geometric constraints in that set, so that they may be retrieved as normal mesh-based constraints. If you are using advanced geometric constraints (not just fixed and/or pinned), the resulting nodal output coordinate systems, and expanded constraints may depend on the sets you choose to expand. Expanding one set at a time may not yield the result that you expect.
        **Return Code:** True\n
        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetCombination(self, nCombo, nSetID) -> Any:
        """
        **Description:**
            This method returns the data for a Nastran SPCADD/MPCADD Combination Set.
        **Remarks/Usage:**
            None
        **Output:**
            **nCombo:** Number of entries in the combination.\n
        **Return Code:** True\n
        :type nCombo: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextBC(self, pDispatch) -> Any:
        """
        **Description:**
            This method returns the next available constraint that matches the criteria established by ResetNextBC
        **Remarks/Usage:**
            This method, coupled with ResetNextBC provides an easy way to retrieve all constraints from a Constraint Set.
        **Output:**
            **pDispatch:** The next constraint object. Depending on the options specified, this could be a BCNode, BCGeom or BCEqn object\n
        **Return Code:** True\n
        :type pDispatch: Any

        """
        ...

    def NextBCDef(self, pDispatch) -> Any:
        """
        **Description:**
            This method returns the next available constraint definition that matches the criteria established by ResetNextBCDef
        **Remarks/Usage:**
            This method, coupled with ResetNextBCDef provides an easy way to retrieve all constraint definitions from a Constraint Set.
        **Output:**
            **pDispatch:** The next constraint definition object. This is always a BCDefinition object.\n
        **Return Code:** True\n
        :type pDispatch: Any

        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NodesAsSet(self, bExpandedGeomBC, bNodalBC, bEquationBC, nNodeSetID, bClear) -> Any:
        """
        **Description:**
            This method adds the IDs of nodes constrained in the Constraint Set currently loaded in the BCSet Object to a specified Set. There are options to include nodes which are constrained after geometric constraints are expanded, individual nodes which are constrained, and/or nodes used in constraint equations
        **Remarks/Usage:**
            None
        **Input:**
            **bExpandedGeomBC:** When True, the IDs of any nodes which are constrained after geometric constraints are expanded will be added to the Set.\n
            **bNodalBC:** When True, the IDs of any individual nodes which are constrained will be added to the Set.\n
            **bEquationBC:** When True, the IDs of any nodes which are used in a constraint equation will be added to the Set\n
            **nNodeSetID:** ID of Set object to add node IDs\n
            **bClear:** When True, any IDs which are in the set are removed before adding the node IDs to the Set\n
        **Return Code:** False\n
        :type bExpandedGeomBC: bool

        :type bNodalBC: bool

        :type bEquationBC: bool

        :type nNodeSetID: int

        :type bClear: bool

        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutCombination(self, nCombo, nSetID) -> Any:
        """
        **Description:**
            This method sets the data in a Nastran SPCADD/MPCADD Combination Set.
        **Remarks/Usage:**

        **Input:**
            **nCombo:** Number of entries in the combination.\n
            **nSetID:** The IDs of the constraint sets in the combination.\n
        **Return Code:** True\n
        :type nCombo: int

        :type nSetID: tuple[int]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def ResetNextBC(self, enDataType, bOtherBCOnly, bIncludeExpanded) -> Any:
        """
        **Description:**
            This method initializes all options prior to calling the NextBC method below
        **Remarks/Usage:**
            This method is used prior to calling NextBC to specify which constraints will be retrieved. It also resets this object so that the next call to NextBC will return the first constraint available in the object.
        **Input:**
            **enDataType:** The type of constraint entities to be retrieved. For entity information, see Section 3.3.6, "Entity Types". Can be FT_BCO, FT_BCO_GEOM, or FT_BEQ.\n
            **bOtherBCOnly:** If true, then only constraints that are not part of a constraint definition will be retrieved. Otherwise all are available.\n
            **bIncludeExpanded:** If True, expanded geometric constraints (if any) will be returned along with normal constraints. Ignored if enDataType = FT_BCO_GEOM.\n
        **Return Code:** True\n
        :type enDataType: int

        :type bOtherBCOnly: bool

        :type bIncludeExpanded: bool

        """
        ...

    def ResetNextBCDef(self, bAllDataTypes, enDataType) -> Any:
        """
        **Description:**
            This method initializes all options prior to calling the NextBCDef method below
        **Remarks/Usage:**
            This method is used prior to calling NextBCDef to specify which constraint definitions will be retrieved. It also resets this object so that the next call to NextBCDef will return the first constraint definition available in the object.
        **Input:**
            **bAllDataTypes:** Used to limit the type of constraint definitions to be retrieved. If True, all selected constraint definitions will be returned. If False, only constraint definitions that contain constraints of the type specified in enDataType will be returned.\n
            **enDataType:** The type of constraint entities to be retrieved. For entity information, see Section 3.3.6, "Entity Types". Can be FT_BCO, FT_BCO_GEOM, or FT_BEQ.\n
        **Return Code:** True\n
        :type bAllDataTypes: bool

        :type enDataType: int

        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class Contact:
    CLSID: Any
    Active: Any
    AngVelFlag: Any
    AngVelTable: Any
    AngVelValue: Any
    AppAngVelVal: Any
    AppRotAxisVal: Any
    AppVelVal: Any
    BoltDir: Any
    BoltType: Any
    ContactCheck: Any
    ControlNode: Any
    Count: Any
    Disabled: Any
    DiscontinuityValue: Any
    FluidCharLength: Any
    FluidDensity: Any
    FluidExactIntegFact: Any
    FluidXZSymmetry: Any
    FluidYZSymmetry: Any
    FluidZFree: Any
    FluidZFreeOn: Any
    FrictionTable: Any
    FrictionType: Any
    FrictionValue: Any
    GrowthComp: Any
    GrowthTable: Any
    ID: Any
    MassNSM: Any
    MassType: Any
    MidNodeProjection: Any
    MotControlType: Any
    MotionFlag: Any
    MotionTable: Any
    MotionValue: Any
    Output: Any
    RotAxisFlag: Any
    RotAxisTable: Any
    RotAxisValue: Any
    RotControlNode: Any
    RotorLoadSet: Any
    RotorMatlDamp: Any
    RotorOverallDamp: Any
    RotorSpeed: Any
    SetID: Any
    SmoothingControl: Any
    SurfaceContactFlag: Any
    UseSolverAxes: Any
    color: Any
    layer: Any
    offset: Any
    refCSys: Any
    refNode: Any
    rigid: Any
    title: Any
    type: Any
    vbox: Any

    def AddContact(self, entityTYPE, entityID, faceID) -> Any:
        """
        **Description:**
            This method loads information into the contact list for a connection region. Unlike PutContactList, this method loads one entry at a time
        **Remarks/Usage:**
            This method stores information into the list of the current object. After using this function, you must call Put( ) if you want to store the updated list in the database.
        **Input:**
            **entityID:** The ID of the entity specified\n
            **faceID:** The ID of the face referenced by each entity (if applicable).\n
        **Return Code:** False\n
        :type entityID: int

        :type faceID: int

        """
        ...

    def BoundingBox(self, box) -> Any:
        """
        **Description:**
            This method returns the coordinates of a rectangular box that encloses a connection region.
        **Remarks/Usage:**
            This method always retrieves a box that is aligned with Global Rectangular coordinates, not an aligned box of minimum volume.
        **Output:**
            **box:** The dimensions of the bounding box, in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type box: tuple[float]

        """
        ...

    def BoundingBoxInCSys(self, nCSysID, box) -> Any:
        """
        **Description:**
            This method returns the coordinates of a rectangular box that encloses a connection region, in coordinates of the selected coordinate system
        **Remarks/Usage:**
            This method always retrieves a box that is aligned with the selected coordinate system, not an aligned box of minimum volume.
        **Input:**
            **nCSysID:** ID of coordinate system to return minimum and maximum \n
        **Output:**
            **box:** The dimensions of the bounding box, in coordinate system specified with nCSysID coordinates.\n
        **Return Code:** True\n
        :type nCSysID: int

        :type box: tuple[float]

        """
        ...

    def Compress(self) -> Any:
        """
        **Description:**
            This method compresses all of the geometric connection regions in the model.
        **Remarks/Usage:**
            This method compresses all connection regions, not just the one loaded into the current object.
        **Return Code:** True\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def ElementsAsSet(self, bExpandGeom, nElemSetID, bClear) -> Any:
        """
        **Description:**
            This method adds the IDs of elements referenced by the region (any Type other than Rotor) currently loaded in the ConnectionRegion Object to a specified Set. There is an option to include the IDs of elements which are referenced by a region after geometric portions of the region are expanded.
        **Remarks/Usage:**
            None
        **Input:**
            **nElemSetID:** ID of Set object to add element IDs\n
            **bClear:** When True, any IDs which are in the set are removed before adding the element IDs to the Set\n
        **Return Code:** False\n
        :type nElemSetID: int

        :type bClear: bool

        """
        ...

    def Enable(self, bEnable) -> Any:
        """
        **Description:**
            This method is used to enable or disable a Connection, Fluid, Bolt, NonStructrual Mass, or Rotor region.
        **Remarks/Usage:**
            None
        **Input:**
            **bEnable:** Flag to set the state of the connection region. \n
        **Return Code:** True\n
        :type bEnable: bool

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Expand(self) -> Any:
        """
        **Description:**
            This method expands all of the geometric connection regions in the model.
        **Remarks/Usage:**
            This method expands all connection regions, not just the one in the current object.
        **Return Code:** True\n
        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetAnalyticSurfaceType(self) -> Any:
        """
        **Description:**
            This method returns the Analytic Surface Type for the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def GetContactList(self, listcount, listTYPE, entityID, faceID, expanded) -> Any:
        """
        **Description:**
            This method retrieves information from the contact list in a connection region.
        **Remarks/Usage:**
            This method simply retrieves the information about the contact lists from the current object. You must first load that data - either using the Get( ) method, or by loading it yourself with PutContactList( ).
        **Output:**
            **listTYPE:** The type of entity in each list entry. Refer to Section 3.3.6, "Entity Types" for a list of types.\n
            **entityID:** The ID of the entity in each list entry.\n
            **faceID:** The ID of the face referenced by each entity (if applicable).\n
            **expanded:** Flag indicating that this is an expanded node/element entry from a geometry contact.\n
        **Return Code:** True\n
        :type listTYPE: tuple[int]

        :type entityID: tuple[int]

        :type faceID: tuple[int]

        :type expanded: tuple[int]

        """
        ...

    def GetEntities(self, entityTYPE, bGetExpanded) -> Any:
        """
        **Description:**
            This retrieves a Sort Object (SortSet) that contains all of the entities of a given type referenced by the region.
        **Remarks/Usage:**
            Once a Sort Object has been populated with entities, the entity ID can be accessed via the nInt1 property of the Sort Object, the FaceID via the nInt2 property, and the Expansion Status via the nInt3 property.
        **Input:**
            **bGetExpanded:** If True, the region is first expanded - any selected geometric entities will also select associated nodes or elements.\n
        **Return Code:** False\n
        :type bGetExpanded: bool

        """
        ...

    def GetEntitySet(self, entityTYPE, bGetExpanded) -> Any:
        """
        **Description:**
            This retrieves a set that contains all of the entity IDs of a given type referenced by the region.
        **Remarks/Usage:**
            None
        **Input:**
            **bGetExpanded:** If True, the region is first expanded - any selected geometric entities will also select associated nodes or elements.\n
        **Return Code:** False\n
        :type bGetExpanded: bool

        """
        ...

    def GetFriction(self, body_friction) -> Any:
        """
        **Description:**
            This method returns the friction for the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetOffset(self, offset) -> Any:
        """
        **Description:**
            This method returns the offset for the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def IsEmpty(self) -> Any:
        """
        **Description:**
            This method checks if a connection region has no entities selected, thus is empty.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def IsEnabled(self) -> Any:
        """
        **Description:**
            This method checks the state of the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def IsRigidType(self) -> Any:
        """
        **Description:**
            This method indicates whether a connection region is rigid.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NodesAsSet(self, bExpandGeom, nNodeSetID, bClear) -> Any:
        """
        **Description:**
            This method adds the IDs of nodes referenced by the region (Connection, Bolt, or Rotor only) currently loaded in the ConnectionRegion Object to a specified Set. There is an option to include the IDs of nodes which are referenced by a region after geometric portions of the region are expanded.
        **Remarks/Usage:**
            None
        **Input:**
            **bExpandGeom:** When True, the IDs of any nodes which are referenced by a region after geometric portions of the region are expanded will be added to the Set.\n
            **nNodeSetID:** ID of Set object to add node IDs\n
            **bClear:** When True, any IDs which are in the set are removed before adding the node IDs to the Set\n
        **Return Code:** False\n
        :type bExpandGeom: bool

        :type nNodeSetID: int

        :type bClear: bool

        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutContactList(self, listcount, listTYPE, entityID, faceID, expanded) -> Any:
        """
        **Description:**
            This method loads information into the contact list for a connection region.
        **Remarks/Usage:**
            This method stores information into the list of the current object. Any previous list information in that object is lost. This method does not store that information to the model database. After using this function, you must call Put( ) if you want to store the updated list in the database.
        **Input:**
            **listTYPE:** The type of entity specified in each entry. Refer to Section 3.3.6, "Entity Types" for a list of types.\n
            **entityID:** The ID of the entity specified in each entry.\n
            **faceID:** The ID of the face referenced by each entity (if applicable).\n
            **expanded:** Flag indicating whether each entry is an expanded node/element entry from a geometric contact.\n
        **Return Code:** False\n
        :type listTYPE: tuple[int]

        :type entityID: tuple[int]

        :type faceID: tuple[int]

        :type expanded: tuple[int]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def RemoveDuplicates(self) -> Any:
        """
        **Description:**
            This method removes any duplicate entities which exist in a region
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def Reverse(self) -> Any:
        """
        **Description:**
            This method reverses the direction of the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetAnalyticSurfaceType(self, aba_rigSurfType) -> Any:
        """
        **Description:**
            This method sets the Analytic Surface Type for the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def SetFriction(self, body_friction) -> Any:
        """
        **Description:**
            This method sets the friction for the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def SetOffset(self, offset) -> Any:
        """
        **Description:**
            This method sets the offset for the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def SetOutputType(self, entityTYPE) -> Any:
        """
        **Description:**
            This method sets the output type for the connection region.
        **Remarks/Usage:**
            For both Elements and Elements - No Faces, entityTYPE should be set to FT_ELEM. When Face ID = 0 for the element IDs, that indicates the region has output set to Elements - No Faces.
        **Return Code:** False\n
        """
        ...

    def SetRigidType(self, isRigid) -> Any:
        """
        **Description:**
            This method defines whether a connection region is rigid.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def Setbox(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def box(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            This method clears and resets the contents of the connection region
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...


class ConnectionRegion:
    CLSID: Any
    Active: Any
    AngVelFlag: Any
    AngVelTable: Any
    AngVelValue: Any
    AppAngVelVal: Any
    AppRotAxisVal: Any
    AppVelVal: Any
    BoltDir: Any
    BoltType: Any
    ContactCheck: Any
    ControlNode: Any
    Count: Any
    Disabled: Any
    DiscontinuityValue: Any
    FluidCharLength: Any
    FluidDensity: Any
    FluidExactIntegFact: Any
    FluidXZSymmetry: Any
    FluidYZSymmetry: Any
    FluidZFree: Any
    FluidZFreeOn: Any
    FrictionTable: Any
    FrictionType: Any
    FrictionValue: Any
    GrowthComp: Any
    GrowthTable: Any
    ID: Any
    MassNSM: Any
    MassType: Any
    MidNodeProjection: Any
    MotControlType: Any
    MotionFlag: Any
    MotionTable: Any
    MotionValue: Any
    Output: Any
    RotAxisFlag: Any
    RotAxisTable: Any
    RotAxisValue: Any
    RotControlNode: Any
    RotorLoadSet: Any
    RotorMatlDamp: Any
    RotorOverallDamp: Any
    RotorSpeed: Any
    SetID: Any
    SmoothingControl: Any
    SurfaceContactFlag: Any
    UseSolverAxes: Any
    color: Any
    layer: Any
    offset: Any
    refCSys: Any
    refNode: Any
    rigid: Any
    title: Any
    type: Any
    vbox: Any

    def AddContact(self, entityTYPE, entityID, faceID) -> Any:
        """
        **Description:**
            This method loads information into the contact list for a connection region. Unlike PutContactList, this method loads one entry at a time
        **Remarks/Usage:**
            This method stores information into the list of the current object. After using this function, you must call Put( ) if you want to store the updated list in the database.
        **Input:**
            **entityID:** The ID of the entity specified\n
            **faceID:** The ID of the face referenced by each entity (if applicable).\n
        **Return Code:** False\n
        :type entityID: int

        :type faceID: int

        """
        ...

    def BoundingBox(self, box) -> Any:
        """
        **Description:**
            This method returns the coordinates of a rectangular box that encloses a connection region.
        **Remarks/Usage:**
            This method always retrieves a box that is aligned with Global Rectangular coordinates, not an aligned box of minimum volume.
        **Output:**
            **box:** The dimensions of the bounding box, in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type box: tuple[float]

        """
        ...

    def BoundingBoxInCSys(self, nCSysID, box) -> Any:
        """
        **Description:**
            This method returns the coordinates of a rectangular box that encloses a connection region, in coordinates of the selected coordinate system
        **Remarks/Usage:**
            This method always retrieves a box that is aligned with the selected coordinate system, not an aligned box of minimum volume.
        **Input:**
            **nCSysID:** ID of coordinate system to return minimum and maximum \n
        **Output:**
            **box:** The dimensions of the bounding box, in coordinate system specified with nCSysID coordinates.\n
        **Return Code:** True\n
        :type nCSysID: int

        :type box: tuple[float]

        """
        ...

    def Compress(self) -> Any:
        """
        **Description:**
            This method compresses all of the geometric connection regions in the model.
        **Remarks/Usage:**
            This method compresses all connection regions, not just the one loaded into the current object.
        **Return Code:** True\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def ElementsAsSet(self, bExpandGeom, nElemSetID, bClear) -> Any:
        """
        **Description:**
            This method adds the IDs of elements referenced by the region (any Type other than Rotor) currently loaded in the ConnectionRegion Object to a specified Set. There is an option to include the IDs of elements which are referenced by a region after geometric portions of the region are expanded.
        **Remarks/Usage:**
            None
        **Input:**
            **nElemSetID:** ID of Set object to add element IDs\n
            **bClear:** When True, any IDs which are in the set are removed before adding the element IDs to the Set\n
        **Return Code:** False\n
        :type nElemSetID: int

        :type bClear: bool

        """
        ...

    def Enable(self, bEnable) -> Any:
        """
        **Description:**
            This method is used to enable or disable a Connection, Fluid, Bolt, NonStructrual Mass, or Rotor region.
        **Remarks/Usage:**
            None
        **Input:**
            **bEnable:** Flag to set the state of the connection region. \n
        **Return Code:** True\n
        :type bEnable: bool

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Expand(self) -> Any:
        """
        **Description:**
            This method expands all of the geometric connection regions in the model.
        **Remarks/Usage:**
            This method expands all connection regions, not just the one in the current object.
        **Return Code:** True\n
        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetAnalyticSurfaceType(self) -> Any:
        """
        **Description:**
            This method returns the Analytic Surface Type for the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def GetContactList(self, listcount, listTYPE, entityID, faceID, expanded) -> Any:
        """
        **Description:**
            This method retrieves information from the contact list in a connection region.
        **Remarks/Usage:**
            This method simply retrieves the information about the contact lists from the current object. You must first load that data - either using the Get( ) method, or by loading it yourself with PutContactList( ).
        **Output:**
            **listTYPE:** The type of entity in each list entry. Refer to Section 3.3.6, "Entity Types" for a list of types.\n
            **entityID:** The ID of the entity in each list entry.\n
            **faceID:** The ID of the face referenced by each entity (if applicable).\n
            **expanded:** Flag indicating that this is an expanded node/element entry from a geometry contact.\n
        **Return Code:** True\n
        :type listTYPE: tuple[int]

        :type entityID: tuple[int]

        :type faceID: tuple[int]

        :type expanded: tuple[int]

        """
        ...

    def GetEntities(self, entityTYPE, bGetExpanded) -> Any:
        """
        **Description:**
            This retrieves a Sort Object (SortSet) that contains all of the entities of a given type referenced by the region.
        **Remarks/Usage:**
            Once a Sort Object has been populated with entities, the entity ID can be accessed via the nInt1 property of the Sort Object, the FaceID via the nInt2 property, and the Expansion Status via the nInt3 property.
        **Input:**
            **bGetExpanded:** If True, the region is first expanded - any selected geometric entities will also select associated nodes or elements.\n
        **Return Code:** False\n
        :type bGetExpanded: bool

        """
        ...

    def GetEntitySet(self, entityTYPE, bGetExpanded) -> Any:
        """
        **Description:**
            This retrieves a set that contains all of the entity IDs of a given type referenced by the region.
        **Remarks/Usage:**
            None
        **Input:**
            **bGetExpanded:** If True, the region is first expanded - any selected geometric entities will also select associated nodes or elements.\n
        **Return Code:** False\n
        :type bGetExpanded: bool

        """
        ...

    def GetFriction(self, body_friction) -> Any:
        """
        **Description:**
            This method returns the friction for the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetOffset(self, offset) -> Any:
        """
        **Description:**
            This method returns the offset for the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def IsEmpty(self) -> Any:
        """
        **Description:**
            This method checks if a connection region has no entities selected, thus is empty.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def IsEnabled(self) -> Any:
        """
        **Description:**
            This method checks the state of the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def IsRigidType(self) -> Any:
        """
        **Description:**
            This method indicates whether a connection region is rigid.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NodesAsSet(self, bExpandGeom, nNodeSetID, bClear) -> Any:
        """
        **Description:**
            This method adds the IDs of nodes referenced by the region (Connection, Bolt, or Rotor only) currently loaded in the ConnectionRegion Object to a specified Set. There is an option to include the IDs of nodes which are referenced by a region after geometric portions of the region are expanded.
        **Remarks/Usage:**
            None
        **Input:**
            **bExpandGeom:** When True, the IDs of any nodes which are referenced by a region after geometric portions of the region are expanded will be added to the Set.\n
            **nNodeSetID:** ID of Set object to add node IDs\n
            **bClear:** When True, any IDs which are in the set are removed before adding the node IDs to the Set\n
        **Return Code:** False\n
        :type bExpandGeom: bool

        :type nNodeSetID: int

        :type bClear: bool

        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutContactList(self, listcount, listTYPE, entityID, faceID, expanded) -> Any:
        """
        **Description:**
            This method loads information into the contact list for a connection region.
        **Remarks/Usage:**
            This method stores information into the list of the current object. Any previous list information in that object is lost. This method does not store that information to the model database. After using this function, you must call Put( ) if you want to store the updated list in the database.
        **Input:**
            **listTYPE:** The type of entity specified in each entry. Refer to Section 3.3.6, "Entity Types" for a list of types.\n
            **entityID:** The ID of the entity specified in each entry.\n
            **faceID:** The ID of the face referenced by each entity (if applicable).\n
            **expanded:** Flag indicating whether each entry is an expanded node/element entry from a geometric contact.\n
        **Return Code:** False\n
        :type listTYPE: tuple[int]

        :type entityID: tuple[int]

        :type faceID: tuple[int]

        :type expanded: tuple[int]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def RemoveDuplicates(self) -> Any:
        """
        **Description:**
            This method removes any duplicate entities which exist in a region
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def Reverse(self) -> Any:
        """
        **Description:**
            This method reverses the direction of the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetAnalyticSurfaceType(self, aba_rigSurfType) -> Any:
        """
        **Description:**
            This method sets the Analytic Surface Type for the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def SetFriction(self, body_friction) -> Any:
        """
        **Description:**
            This method sets the friction for the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def SetOffset(self, offset) -> Any:
        """
        **Description:**
            This method sets the offset for the connection region.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def SetOutputType(self, entityTYPE) -> Any:
        """
        **Description:**
            This method sets the output type for the connection region.
        **Remarks/Usage:**
            For both Elements and Elements - No Faces, entityTYPE should be set to FT_ELEM. When Face ID = 0 for the element IDs, that indicates the region has output set to Elements - No Faces.
        **Return Code:** False\n
        """
        ...

    def SetRigidType(self, isRigid) -> Any:
        """
        **Description:**
            This method defines whether a connection region is rigid.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def Setbox(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def box(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            This method clears and resets the contents of the connection region
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...


class CSys:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    color: Any
    defCSys: Any
    layer: Any
    matrix: Any
    origin: Any
    rotation: Any
    rotx: Any
    roty: Any
    rotz: Any
    title: Any
    type: Any
    x: Any
    y: Any
    z: Any

    def Axis(self, nCSysType, nAxisDir, origin, Axis) -> Any:
        """
        **Description:**
            This method creates or updates a coordinate system by specifying a location on the X, Y, or Z Axis
        **Remarks/Usage:**
            When specifying a point on the X, Y or Z axes, a corresponding point on the XY, YZ, or ZX plane, respectively, is automatically determined by finding the closest orthogonal global axis. This method is best used when only the direction of the specified axis is of consequence. For additional control over the direction of the normal axis, use either or XYPoints (Section 5.20.2.1, "XYPoints") or TwoAxes (Section 5.20.2.3, "TwoAxes").
        **Input:**
            **nCSysType:** Coordinate system type. 0=Rectangular, 1=Cylindrical, 2=Spherical\n
            **nAxisDir:** Specifies which axis of the coordinate system will be aligned with the location specified in Axis\n
            **origin:** The origin of the coordinate system. Must be specified in Global Rectangular coordinates. Must be specified in Global Rectangular coordinates.\n
            **Axis:** The XYZ coordinates of a point along the Axis of the coordinate system specified by nAxisDir\n
        **Return Code:** True\n
        :type nCSysType: int

        :type nAxisDir: int

        :type origin: tuple[float]

        :type Axis: tuple[float]

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def TwoAxes(self, nCSysType, nNormalAxisDir, origin, axis1, axis2) -> Any:
        """
        **Description:**
            This method creates or updates a coordinate system by specifying two vectors which are used in a defined manner based on an option specified by the user.
        **Remarks/Usage:**
            None
        **Input:**
            **nCSysType:** Coordinate system type. 0=Rectangular, 1=Cylindrical, 2=Spherical\n
            **nNormalAxisDir:** Specifies the normal axis and how axis1 and axis2 will be used \n
            **origin:** The origin of the coordinate system. Must be specified in Global Rectangular coordinates.\n
            **axis1:** The XYZ components of the vector of Axis 1. Must be specified in Global Rectangular coordinates.\n
            **axis2:** The XYZ components of the vector of Axis 2. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nCSysType: int

        :type nNormalAxisDir: int

        :type origin: tuple[float]

        :type axis1: tuple[float]

        :type axis2: tuple[float]

        """
        ...

    def XYPoints(self, origin, xaxis, xyplane) -> Any:
        """
        **Description:**
            This method automatically updates the origin and rotations of a coordinate system based on three locations that you specify
        **Remarks/Usage:**
            None
        **Input:**
            **origin:** The origin of the coordinate system. This, and all other locations, must be specified in global rectangular coordinates.\n
            **xaxis:** The coordinates of a point along the X Axis of the coordinate system.\n
            **xyplane:** The coordinates of a point in the XY Plane of the coordinate system. This point does not need to lie along any of the coordinate axes.\n
        **Return Code:** True\n
        :type origin: tuple[float]

        :type xaxis: tuple[float]

        :type xyplane: tuple[float]

        """
        ...


class Curve:
    CLSID: Any
    Active: Any
    Address: Any
    BSplineClosed: Any
    BSplineNumPoints: Any
    BSplineOrder: Any
    BSplinePeriodic: Any
    BSplinePlanar: Any
    BSplineRational: Any
    BSplineT0: Any
    BSplineT1: Any
    Engine: Any
    HasCustomMesh: Any
    ID: Any
    InCombinedCurve: Any
    InternalToBoundary: Any
    ScaleFactor: Any
    SetID: Any
    Suppressed: Any
    attrOffsetType: Any
    attrOrientType: Any
    attrPID: Any
    attrTopology: Any
    color: Any
    layer: Any
    type: Any
    vBSplineKnot: Any
    vBSplinePoint: Any
    vBSplineWeight: Any
    vCenterBias: Any
    vGeometricBias: Any
    vLengthSpacing: Any
    vMeshBias: Any
    vMeshElem: Any
    vMeshMaxParam: Any
    vMeshPointID: Any
    vStdPoint: Any
    vattrOffset: Any
    vattrOrient: Any
    vattrRelease: Any

    def AddMeshLoc(self, s, numElem, spacing, biasMethod, bias, biasLoc) -> Any:
        """
        **Description:**
            This method adds a custom mesh size location at the specified parametric location.
        **Remarks/Usage:**
            The curve should be loaded prior to using this method. This will always result in a custom mesh size being defined for the curve. You must always Put the curve to the database after finishing for the mesh locations to be saved. To redefine a mesh location, simply call this method again with the same value for s.
        **Input:**
            **s:** The parametric location along the curve - must be between 0.0 and 1.0 - where the mesh location will be added.\n
            **numElem:** The number of elements between this location and the preceding one (at the next lower s value).\n
            **s:** If 0, then parametric spacing is used; otherwise, constant length spacing is used.\n
            **s:** 0=Equal length spacing, 1=Linear Bias, 2=Geometric Bias.\n
            **s:** The bias value - greater than or equal to 1.0. A value of 1.0 is not biased. A value of 2.0 means that the largest element is approximately 2.0 times the length of the smallest.\n
            **s:** 0=Small elements at start of curve, 1=Small elements at end of curve, 2=Small elements at center of curve, 3=Small elements at both ends of curve.\n
        **Return Code:** True\n
        :type s: float

        :type numElem: int

        :type s: int

        :type s: int

        :type s: float

        :type s: int

        """
        ...

    def AddMeshLocXYZ(self, xyz, numElem, spacing, biasMethod, bias, biasLoc) -> Any:
        """
        **Description:**
            This method adds a custom mesh size location at the specified coordinate location.
        **Remarks/Usage:**
            This method is essentially the same as AddMeshLoc, except that it uses a coordinate location instead of a parametric location.
        **Input:**
            **xyz:** The coordinates of the location for the mesh location. Must be in global rectangular. These coordinates are projected onto the curve to determine the corresponding parametric location.\n
            **numElem:** The number of elements between this location and the preceding one (at the next lower s value).\n
            **spacing:** If 0, then parametric spacing is used. Otherwise, constant length spacing is used.\n
            **biasMethod:** 0=Equal length spacing, 1=Linear Bias, 2=Geometric Bias.\n
            **bias:** The bias value - greater than or equal to 1.0. A value of 1.0 is not biased. A value of 2.0 means that the largest element is approximately 2.0 times the length of the smallest.\n
            **bias:** 0=Small elements at start of curve, 1=Small elements at end of curve, 2=Small elements at center of curve, 3=Small elements at both ends of curve.\n
        **Return Code:** True\n
        :type xyz: tuple[float]

        :type numElem: int

        :type spacing: int

        :type biasMethod: int

        :type bias: float

        :type bias: int

        """
        ...

    def ArcCircleInfo(self, center, normal, startloc, endloc, angle, radius) -> Any:
        """
        **Description:**
            This method retrieves information about arcs and circles.
        **Remarks/Usage:**
            This method will only work for arc and circle curve types - not for solids that represent those types.
        **Output:**
            **center:** The coordinates of the center of the circle.\n
            **normal:** The vector components of the arc/circle normal direction.\n
            **startloc:** The coordinates of the starting point of the curve.\n
            **endloc:** The coordinates of the ending point of the curve.\n
            **angle:** The subtended angle of the curve.\n
            **radius:** The radius of the curve.\n
        **Return Code:** True\n
        :type center: tuple[float]

        :type normal: tuple[float]

        :type startloc: tuple[float]

        :type endloc: tuple[float]

        :type angle: float

        :type radius: float

        """
        ...

    def BSplineKnot(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def BSplinePoint(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def BSplineWeight(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def BoundingBox(self, box) -> Any:
        """
        **Description:**
            This method returns the coordinates of a rectangular box the encloses this geometry.
        **Remarks/Usage:**
            This method always retrieves a box that is aligned with Global Rectangular coordinates, not an aligned box of minimum volume.
        **Output:**
            **box:** The dimensions of the bounding box, in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type box: tuple[float]

        """
        ...

    def BoundingBoxInCSys(self, nCSysID, box) -> Any:
        """
        **Description:**
            This method returns the coordinates of a rectangular box the encloses this geometry, in coordinates of the selected coordinate system.
        **Remarks/Usage:**
            This method always retrieves a box that is aligned with the selected coordinate system, not an aligned box of minimum volume.
        **Input:**
            **nCSysID:** ID of coordinate system to return minimum and maximum \n
        **Output:**
            **box:** The dimensions of the bounding box, in coordinate system specified with nCSysID coordinates.\n
        **Return Code:** True\n
        :type nCSysID: int

        :type box: tuple[float]

        """
        ...

    def CenterBias(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ClearMeshLoc(self) -> Any:
        """
        **Description:**
            Clears all previous mesh sizing on curve
        **Remarks/Usage:**
            The curve should be loaded prior to using this method. You must always Put the curve to the database after finishing for removal of assigned mesh sizing. Sets number of elements to 0.
        **Return Code:** True\n
        """
        ...

    def ClosestPointToCurve(self, nCurveID, pdX, pdY, pdZ, pdDistance, pdAngleOfTangents) -> Any:
        """
        **Description:**
            Finds the closest point on the curve to a selected curve
        **Remarks/Usage:**
            This method is only supported for Solid and Composite Curves.
        **Input:**
            **nCurveID:** The curve to test for closest approach\n
        **Output:**
            **pdX:** The coordinates of the closest location on the curve to the selected curve\n
            **pdY:** REAL8 pdZ\n
            **pdZ:** REAL8 pdDistance\n
            **pdDistance:** The distance from the point to the selected curve\n
            **pdAngleOfTangents:** The Angle between the Curve Tangent and the curve tangent of the selected curve at the location of closest approach\n
        **Return Code:** True\n
        :type nCurveID: int

        :type pdX: float

        :type pdY: float

        :type pdZ: float

        :type pdDistance: float

        :type pdAngleOfTangents: float

        """
        ...

    def ClosestPointToSurface(self, nSurfaceID, pdX, pdY, pdZ, pdDistance, pdAngleOfTangentToSurfNormal) -> Any:
        """
        **Description:**
            Finds the closest point on the curve to a selected surface
        **Remarks/Usage:**
            This method is only supported for Solid and Composite Curves.
        **Input:**
            **nSurfaceID:** The surface to test for closest approach\n
        **Output:**
            **pdX:** The coordinates of the closest location on the curve to the surface\n
            **pdY:** REAL8 pdZ\n
            **pdZ:** REAL8 pdDistance\n
            **pdDistance:** The distance from the point to the surface\n
        **Return Code:** True\n
        :type nSurfaceID: int

        :type pdX: float

        :type pdY: float

        :type pdZ: float

        :type pdDistance: float

        """
        ...

    def CombineCurves(self, nNumCurves, curveID) -> Any:
        """
        **Description:**
            Creates a combined curve from an array of underlying curves.
        **Remarks/Usage:**
            The curves supplied to this method must be properly ordered, connected and able to create a combined curve.
        **Input:**
            **nNumCurves:** The number of curves supplied in curveID\n
            **curveID:** The IDs of the curves used to define a combined curve. The curves in this array must be listed in the order they will be used along the combined curve - starting at the beginning of the curve. If you need to reverse a curve, then you must supply its ID as a negative number (i.e. -ID) - then the usage of the curve in the combined curve will be in the opposite direction from the original curve.\n
        **Return Code:** True\n
        :type nNumCurves: int

        :type curveID: tuple[int]

        """
        ...

    def CombinedCurvesAsSet(self, nSetID, bClear) -> Any:
        """
        **Description:**
            Returns the IDs of the curves used to define a combined curve
        **Remarks/Usage:**
            This method is similar to GetCombinedCurves, however there is no indication of forward/reverse direction when using this method. All IDs are positive and stored in the Set Object.
        **Input:**
            **nSetID:** The ID of a Set that will receive the curve IDs\n
            **bClear:** If True, the Set is cleared prior to loading the curve IDs\n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def CommonPoint(self, nOtherCurveID, nCommonPoint, bMultipleCommon) -> Any:
        """
        **Description:**
            The method returns the ID of a common point found between the curve currently loaded in the object and another specified curve. In addition, it can also be used to determine if multiple points are common between the curves.
        **Remarks/Usage:**
            None
        **Input:**
            **nOtherCurveID:** ID of curved used to determine if there are any common points\n
        **Output:**
            **nCommonPoint:** ID of point common between curve currently loaded in object and OtherCurveID\n
            **bMultipleCommon:** If True, more than one point is common between the curve currently loaded in the object and OtherCurveID. If False, then only ID of CommonPoint is common between the curves.\n
        **Return Code:** True\n
        :type nOtherCurveID: int

        :type nCommonPoint: int

        :type bMultipleCommon: bool

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def CurvatureAcrossEdge(self, pdMinVal, pdMaxVal, pdAngleBetweenNormals) -> Any:
        """
        **Description:**
            Finds the minimum and maximum curvature along the curve and the maximum angle between normals of the adjacent surfaces
        **Remarks/Usage:**
            This method is only supported for Solid and Composite Curves.
        **Output:**
            **pdMinVal:** Minimum radius of curvature\n
            **pdMaxVal:** Maximum radius of curvature\n
        **Return Code:** True\n
        :type pdMinVal: float

        :type pdMaxVal: float

        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Elements(self, numElems, elemID) -> Any:
        """
        **Description:**
            This method returns the elements that are attached to this curve
        **Remarks/Usage:**
            Only elements that have all of their nodes on the curve will be returned by this method. Elements that simply touch the curve at one edge or one node will not be returned.
        **Output:**
            **numElems:** The number of elements returned.\n
            **elemID:** The IDs of the selected elements which are attached to the curve.\n
        **Return Code:** True\n
        :type numElems: int

        :type elemID: tuple[int]

        """
        ...

    def ElementsAsSet(self, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns the elements that are attached to this curve in a Set Object
        **Remarks/Usage:**
            Only elements that have all of their nodes on the curve will be returned by this method. Elements that simply touch the curve at one edge or one node will not be returned. Same as Elements method except that IDs are returned in a Set rather than an array.
        **Input:**
            **nSetID:** The ID of the Set Object that receives the Element IDs\n
            **bClear:** If True, the Set is cleared before it is loaded with Element IDs.\n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def ElementsWithFaces(self, numElems, elemID) -> Any:
        """
        **Description:**
            This method returns the elements that have faces which are attached to this curve
        **Remarks/Usage:**
            This will return elements that have any face on the curve - including planar elements that have one edge along the curve. Planar elements that simply touch the curve at one corner/node will not be returned.
        **Output:**
            **numElems:** The number of elements returned.\n
            **elemID:** The IDs of the selected elements which have faces attached to the curve.\n
        **Return Code:** True\n
        :type numElems: int

        :type elemID: tuple[int]

        """
        ...

    def EndPoints(self, startPt, endPt) -> Any:
        """
        **Description:**
            This method retrieves the IDs of the endpoints of the current curve.
        **Remarks/Usage:**
            This method works for any stored curve. You must first call Get to load the curve from the database. It will not work with data you have loaded into a curve object but not yet stored.
        **Output:**
            **startPt:** The IDs of the starting and ending points on the curve.\n
            **endPt:** Return Code:\n
        **Return Code:** True\n
        :type startPt: int

        :type endPt: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Facets(self, numPoints, xyzPoint) -> Any:
        """
        **Description:**
            Returns the global rectangular coordinates of the locations along the curve that are used to draw the curve
        **Remarks/Usage:**
            The curve is drawn by simply connecting these locations sequentially.
        **Output:**
            **numPoints:** The number of points returned in xyzPoint\n
            **xyzPoint:** The locations along the curve, stored [x0,y0,z0,x1,y1,z1,...]\n
        **Return Code:** True\n
        :type numPoints: int

        :type xyzPoint: tuple[float]

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def GeometricBias(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetCombinedCurves(self, nNumCurves, curveID) -> Any:
        """
        **Description:**
            Returns the IDs of the curves used to define a combined curve
        **Remarks/Usage:**
            None
        **Output:**
            **nNumCurves:** The number of curves returned in curveID\n
            **curveID:** The IDs of the curves used to define a combined curve. The curves in this array are listed in the order they are used along the combined curve - starting at the beginning of the curve. If the direction of the returned curve is opposite that of the composite curve, then the ID in the array will be negative (i.e. if you see an entry in curveID like -7, that means that curve 7 is used in its reversed direction)\n
        **Return Code:** True\n
        :type nNumCurves: int

        :type curveID: tuple[int]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetMeshLoc(self, numLoc, MeshParam) -> Any:
        """
        **Description:**
            Retrieves the parametric values along the curve of the mesh locations.
        **Remarks/Usage:**
            None
        **Output:**
            **numLoc:** The number of mesh locations on the curve\n
            **MeshParam:** The parametric locations\n
        **Return Code:** True\n
        :type numLoc: int

        :type MeshParam: tuple[float]

        """
        ...

    def GetMeshLocXYZ(self, numLoc, meshXYZ) -> Any:
        """
        **Description:**
            Retrieves the global coordinates of the mesh locations along the curve.
        **Remarks/Usage:**
            Similar to GetMeshLoc, but this method returns coordinate rather than parametric values.
        **Output:**
            **numLoc:** The number of mesh locations on the curve\n
        **Return Code:** True\n
        :type numLoc: int

        """
        ...

    def GetPrecision(self) -> Any:
        """
        **Description:**
            This method returns the current Parasolid precision of a curve
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def HasMeshSize(self) -> Any:
        """
        **Description:**
            Indicates if a curve has assigned mesh sizing.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def InitMeshAttributes(self, nPropID) -> Any:
        """
        **Description:**
            Initialize Mesh Attributes on the curve.
        **Remarks/Usage:**
            This method sets the default attrTopology = FTO_LINE2.
        **Input:**
            **nPropID:** Property ID used for mesh attributes on curve.\n
        **Return Code:** True\n
        :type nPropID: int

        """
        ...

    def IsArc(self) -> Any:
        """
        **Description:**
            Determines whether the curve is an arc
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def IsCombinedCurve(self) -> Any:
        """
        **Description:**
            Indicates whether or not the curve is a combined curve
        **Remarks/Usage:**
            You can also use the type property of the curve to determine whether a curve is a combined curve.
        **Return Code:** True\n
        """
        ...

    def IsFacet(self) -> Any:
        """
        **Description:**
            Indicates whether or not the curve is a curve on a faceted surface
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def IsFreeEdge(self) -> Any:
        """
        **Description:**
            Determines whether a curve is a free edge.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def IsGeneral(self) -> Any:
        """
        **Description:**
            Determines whether the curve is nonmanifold (on a general body) by querying Parasolid
        **Remarks/Usage:**
            Nonmanifold curves are ones that bound more than 2 surfaces. This command provides an alternate method to the IsNonManifold method.
        **Return Code:** True\n
        """
        ...

    def IsMergeable(self) -> Any:
        """
        **Description:**
            Determines whether a curve is mergeable, thus can be removed by geometry simplification and cleanup commands
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def IsNonManifold(self) -> Any:
        """
        **Description:**
            Determines whether the curve is nonmanifold
        **Remarks/Usage:**
            Nonmanifold curves are ones that bound more than 2 surfaces.
        **Return Code:** True\n
        """
        ...

    def IsOnSolidRegion(self) -> Any:
        """
        **Description:**
            Determines whether a curve is on a solid region.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def IsSmooth(self, dAngle) -> Any:
        """
        **Description:**
            Determines whether the surfaces bounded by this curve are tangent within a specified angle along the curve
        **Remarks/Usage:**
            None
        **Input:**
            **dAngle:** The maximum angle below which the curve is considered to be a smooth connection between the adjoining surfaces.\n
        **Return Code:** True\n
        :type dAngle: float

        """
        ...

    def IsSmoothEdge(self, dAngle, nConvexityType) -> Any:
        """
        **Description:**
            Determines whether the adjacent surfaces of a solid meet smoothly at this curve
        **Remarks/Usage:**
            None
        **Input:**
            **dAngle:** The maximum angle that will be considered as smooth\n
        **Output:**
            **nConvexityType:** 0=Smooth and Flat, 1=Smooth and Convex, 2=Smooth and Concave, 3=Smooth with Inflection, 4=Smooth and Variable Convex/Concave\n
        **Return Code:** True\n
        :type dAngle: float

        :type nConvexityType: int

        """
        ...

    def IsStraight(self) -> Any:
        """
        **Description:**
            Determines whether the curve is a straight line
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def IsSuppressed(self) -> Any:
        """
        **Description:**
            Indicates whether or not the curve is suppressed
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Length(self) -> Any:
        """
        **Description:**
            This method returns the length of a curve.
        **Remarks/Usage:**
            This method will only work for any curve type.
        **Return Code:** True\n
        """
        ...

    def LengthSpacing(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ManifoldType(self, pnType) -> Any:
        """
        **Description:**
            This method is used to determine the type of surface connectivity for a curve. Types are:
        **Remarks/Usage:**
            None
        **Output:**
            **pnType:** Type of Curve Connectivity. Use enum zCurveManifoldType\n
        **Return Code:** True\n
        :type pnType: int

        """
        ...

    def MeshBias(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def MeshCount(self, numElem, CustomSize) -> Any:
        """
        **Description:**
            This method returns the number of elements specified via mesh sizing on a curve and if custom mesh sizing has been assigned.
        **Remarks/Usage:**
            None
        **Output:**
            **numElem:** Number of elements assigned via mesh sizing on curve\n
            **CustomSize:** If True, the curve has custom mesh sizing assigned. If False, standard mesh sizing has been assigned.\n
        **Return Code:** False\n
        :type numElem: int

        :type CustomSize: bool

        """
        ...

    def MeshElem(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def MeshMaxParam(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def MeshParam(self, numParam, MeshParam) -> Any:
        """
        **Description:**
            This method returns an array of parametric locations along the curve that are currently established as mesh locations, based on the mesh size specifications that are defined.
        **Remarks/Usage:**
            This method will only work for any curve type. The curve must however be Put to the database after any changes have been made to mesh sizing or this command may not return the proper locations.
        **Input:**
            **numParam:** The number of parametric locations in meshParam.\n
            **MeshParam:** The parametric locations along the curve where nodes will be meshed.\n
        **Return Code:** True\n
        :type numParam: int

        :type MeshParam: tuple[float]

        """
        ...

    def MeshPointID(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Midpoint(self, Midpoint) -> Any:
        """
        **Description:**
            This method returns the coordinates of the midpoint of a curve or combined curve
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def MinRadius(self, pdMinRadius) -> Any:
        """
        **Description:**
            Finds the minimum radius of a Solid curve or a Composite curve.
        **Remarks/Usage:**
            This method is only supported for Solid and Composite Curves.
        **Output:**
            **pdMinRadius:** Minimum radius of curve\n
        **Return Code:** True\n
        :type pdMinRadius: float

        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def Nodes(self, getBoundary, getInterior, numNodes, NodeID) -> Any:
        """
        **Description:**
            This method returns the nodes that are attached to this curve
        **Remarks/Usage:**
            None
        **Input:**
            **getBoundary:** If True, the nodes attached to the curve endpoints are selected\n
            **getInterior:** If True, the nodes attached to the interior of the curve (not the endpoints) are selected\n
        **Output:**
            **numNodes:** The number of nodes returned.\n
            **NodeID:** The IDs of the selected nodes which are attached to the curve.\n
        **Return Code:** True\n
        :type getBoundary: bool

        :type getInterior: bool

        :type numNodes: int

        :type NodeID: tuple[int]

        """
        ...

    def NodesAsSet(self, getBoundary, getInterior, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns the nodes that are attached to this curve in a Set Object
        **Remarks/Usage:**
            Same as Nodes, except that the IDs are returned in a Set Object rather than an array.
        **Input:**
            **getBoundary:** If True, the nodes attached to the curve endpoints are selected\n
            **getInterior:** If True, the nodes attached to the interior of the curve (not the endpoints) are selected\n
            **nSetID:** The ID of a Set Object to receive the Node IDs\n
            **bClear:** If True, the Set is cleared prior to loading the Node IDs\n
        **Return Code:** True\n
        :type getBoundary: bool

        :type getInterior: bool

        :type nSetID: int

        :type bClear: bool

        """
        ...

    def ParamAtLength(self, fromstart, Length) -> Any:
        """
        **Description:**
            This method returns the parameter value at a specified distance from the end of a curve.
        **Remarks/Usage:**
            This method will only work for any curve type. The lengthmust be less than the total length of the curve.
        **Input:**
            **fromstart:** If True, length is measured from the start of the curve. If False, it is measured from the end.\n
            **Length:** The distance along the curve where the parameter value is determined.\n
        **Return Code:** True\n
        :type fromstart: bool

        :type Length: float

        """
        ...

    def ParamOnCombinedCurve(self, s, curveID) -> Any:
        """
        **Description:**
            This method returns the ID of the underlying curve of a composite curve at a specified parametric location.
        **Remarks/Usage:**
            This method is only supported for Composite Curves.
        **Input:**
            **s:** Parametric location along composite curve from 0.0 to 1.0\n
        **Output:**
            **curveID:** Curve ID of underlying curve at specified parametric location\n
        **Return Code:** True\n
        :type s: float

        :type curveID: int

        """
        ...

    def ParamToXYZ(self, s, xyz) -> Any:
        """
        **Description:**
            This method retrieves the coordinates along the curve of a specified parametric location.
        **Remarks/Usage:**
            This method will only work for any curve type.
        **Input:**
            **s:** The parametric value (0<=s<=1) along the curve. 0=Start, 1=End.\n
        **Output:**
            **xyz:** The coordinates of the parametric value along the curve.\n
        **Return Code:** True\n
        :type s: float

        :type xyz: tuple[float]

        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def PartialLength(self, s0, s1) -> Any:
        """
        **Description:**
            This method returns the length of a curve between two parametric locations.
        **Remarks/Usage:**
            This method will only work for any curve type. The values for s0 and s1 must be between 0.0 and 1.0. s1 must be greater than s0.
        **Input:**
            **s0:** The starting parametric location.\n
            **s1:** The ending parametric location.\n
        **Return Code:** True\n
        :type s0: float

        :type s1: float

        """
        ...

    def PartialLengthNode(self, nNode0, nNode1) -> Any:
        """
        **Description:**
            This method returns the length of a curve between the Node locations that are closest to the curve.
        **Remarks/Usage:**
            This method will work for any curve type.
        **Input:**
            **nNode0:** The ID of the first Node.\n
            **nNode1:** The ID of the second Node\n
        **Return Code:** True\n
        :type nNode0: int

        :type nNode1: int

        """
        ...

    def PartialLengthXYZ(self, xyz0, xyz1) -> Any:
        """
        **Description:**
            This method returns the length of a curve between two XYZ locations.
        **Remarks/Usage:**
            This method will only work for any curve type.
        **Input:**
            **xyz0:** The coordinates of the location of interest.\n
            **xyz1:** The coordinates of the location of interest.\n
        **Return Code:** True\n
        :type xyz0: tuple[float]

        :type xyz1: tuple[float]

        """
        ...

    def PointsAsSet(self, nSetID, bClear) -> Any:
        """
        **Description:**
            This method adds the end points of a curve into the specified Set object with the option to clear the set before adding the end points
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of Set object to add end points\n
            **bClear:** If True, the Set object will be cleared before the end points are added. If False, the end points are simply added to the specified Set object.\n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Project(self, fromxyz, toxyz) -> Any:
        """
        **Description:**
            This method projects a location onto a curve (This method is OBSOLETE, use ProjectToClosest method for access to all functionality of the Modify, Project... commands)
        **Remarks/Usage:**
            This method will only work for any curve type.
        **Input:**
            **fromxyz:** The coordinates of the initial location.\n
        **Output:**
            **toxyz:** The coordinates of the projected location.\n
        **Return Code:** True\n
        :type fromxyz: tuple[float]

        :type toxyz: tuple[float]

        """
        ...

    def ProjectAlongVector(self, vAlong, vOrig, vProj) -> Any:
        """
        **Description:**
            This method projects a location along a specified vector to a location that lies on a curve (i.e., user supplies vector used for projection)
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def ProjectToClosest(self, bExtendCurve, vOrig, vProj) -> Any:
        """
        **Description:**
            This method projects a location to the closest location that lies on a curve (i.e., FEMAP determines vector used for projection)
        **Remarks/Usage:**
            This method will only work for any curve type.
        **Input:**
            **bExtendCurve:** If True, a straight curve will be extended infinitely in both directions and a circular curve will be extended a full 360 degrees. The closest location will then be determined using the extended curve (i.e., the projected location could lie outside the end points of the curve). If False, the location will be forced onto the curve itself and in some cases this will result in the location being coincident with one of the curves end points.\n
            **vOrig:** The coordinates of the initial location.\n
        **Return Code:** True\n
        :type bExtendCurve: bool

        :type vOrig: tuple[float]

        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def ResetPrecision(self) -> Any:
        """
        **Description:**
            This method resets the Parasolid precision of a curve to a value equal to 5.0E-9*current Solid Geometry Scale Factor.
        **Remarks/Usage:**
            If Solid Geometry Scale Factor is equal to 39.37 (Inches), then this value will be 1.9685E-7
        **Return Code:** True\n
        """
        ...

    def Reverse(self) -> Any:
        """
        **Description:**
            This method reverses the direction of a curve.
        **Remarks/Usage:**
            This method will not work for solid curves.
        **Return Code:** True\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetBSplineKnot(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetBSplinePoint(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetBSplineWeight(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetCenterBias(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetGeometricBias(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetLengthSpacing(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetMeshBias(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetMeshElem(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetMeshMaxParam(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetMeshPointID(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetSimpleMeshLoc(self, numElem, spacing, biasMethod, bias, biasLoc) -> Any:
        """
        **Description:**
            This method sets mesh sizing on a curve using only Number of Elements and Node Spacing options. Similar to using Mesh, Mesh Control, Size Along Curve menu command.
        **Remarks/Usage:**
            The curve should be loaded prior to using this method. You must always Put the curve to the database after finishing for the mesh locations to be saved.
        **Input:**
            **numElem:** The number of elements on the curve\n
            **spacing:** If 0, then parametric spacing is used; otherwise, constant length spacing is used.\n
            **biasMethod:** 0=Equal length spacing, 1=Linear Bias, 2=Geometric Bias.\n
            **bias:** The bias value - greater than or equal to 1.0. A value of 1.0 is not biased. A value of 2.0 means that the largest element is approximately 2.0 times the length of the smallest.\n
            **bias:** 0=Small elements at start of curve, 1=Small elements at end of curve, 2=Small elements at center of curve, 3=Small elements at both ends of curve.\n
        **Return Code:** True\n
        :type numElem: int

        :type spacing: int

        :type biasMethod: int

        :type bias: float

        :type bias: int

        """
        ...

    def SetStdPoint(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetattrOffset(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def SetattrOrient(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetattrRelease(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def Solid(self, pnSolidID) -> Any:
        """
        **Description:**
            This method returns the ID of the Solid that contains the current Curve
        **Remarks/Usage:**
            This method will only work with a Curve and Combined Curve that is defined on a Solid.
        **Output:**
            **pnSolidID:** The ID of the Solid that references the current Curve\n
        **Return Code:** True\n
        :type pnSolidID: int

        """
        ...

    def StdPoint(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Surfaces(self, nCombinedMode, numSurfaces, surfaceID) -> Any:
        """
        **Description:**
            Returns an array of surfaces that reference this curve
        **Remarks/Usage:**
            This function only works for Solid or Composite Curves that are defined on Solids. Same as SurfacesAsSet except IDs are returned in an Array rather than in a Set.
        **Input:**
            **nCombinedMode:** 0=List contains the basic surfaces that are adjacent to the curve, 1=Any surfaces that are adjacent that are in a Combined Surface are replaced by the ID of the Combined Surface, 2=List contains both the underlying and combined surfaces.\n
        **Output:**
            **numSurfaces:** The number of surfaces in the returned array\n
            **surfaceID:** The IDs of the surfaces.\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type numSurfaces: int

        :type surfaceID: tuple[int]

        """
        ...

    def SurfacesAsSet(self, nCombinedMode, nSetID, bClear) -> Any:
        """
        **Description:**
            Returns surfaces that reference this curve in a Set Object
        **Remarks/Usage:**
            This function only works for Solid or Composite Curves that are defined on Solids. Same as Surfaces, except that IDs are returned in the Set rather than in an array.
        **Input:**
            **nCombinedMode:** 0=List contains the basic surfaces that are adjacent to the curve, 1=Any surfaces that are adjacent that are in a Combined Surface are replaced by the ID of the Combined Surface, 2=List contains both the underlying and combined surfaces.\n
            **nSetID:** ID of the Set Object to receive the Surface IDs\n
            **bClear:** If True, the Set is cleared before loading the surfaces\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type nSetID: int

        :type bClear: bool

        """
        ...

    def Tangent(self, outward, fromxyz, Tangent) -> Any:
        """
        **Description:**
            This method finds the tangent to a curve at a specified location.
        **Remarks/Usage:**
            This method will only work for any curve type.
        **Input:**
            **outward:** If True, the tangent along the first half of the curve (s<0.5) is computed in the opposite direction from the curve. If False, all tangents are computed in the curve direction from start to end.\n
            **fromxyz:** The coordinates of the initial location.\n
        **Output:**
            **Tangent:** The vector components of the tangent.\n
        **Return Code:** True\n
        :type outward: bool

        :type fromxyz: tuple[float]

        :type Tangent: tuple[float]

        """
        ...

    def TangentAtEnds(self, outward, pvEnd1Tan, pvEnd2Tan) -> Any:
        """
        **Description:**
            Determines whether the surfaces bounded by this curve are tangent within a specified angle along the curve
        **Remarks/Usage:**
            This method is only supported for Solid and Composite Curves.
        **Input:**
            **outward:** If true, the outward pointing tangents are computed at each end. If False, tangents along the curve in the parametric direction of the curve are computed.\n
        **Output:**
            **pvEnd1Tan:** The tangent at the start of the curve\n
            **pvEnd2Tan:** The tangent at the end of the curve\n
        **Return Code:** True\n
        :type outward: bool

        :type pvEnd1Tan: tuple[float]

        :type pvEnd2Tan: tuple[float]

        """
        ...

    def XYZToParam(self, xyz, s) -> Any:
        """
        **Description:**
            This method retrieves the parametric location along a curve closest to the specified coordinates.
        **Remarks/Usage:**
            This method will only work for any curve type.
        **Input:**
            **xyz:** The coordinates of the location of interest.\n
        **Output:**
            **s:** The parametric value (0<=s<=1) along the curve. 0=Start, 1=End.\n
        **Return Code:** True\n
        :type xyz: tuple[float]

        :type s: float

        """
        ...

    def attrOffset(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def attrOrient(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def attrRelease(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def center(self, center) -> Any:
        """
        **Description:**
            This method returns the coordinates of the center point of a circular arc (curve or combined curve)
        **Remarks/Usage:**

        **Output:**
            **center:** The coordinates of the center point of the current curve or combined curve. Always returned in the global rectangular coordinate system\n
        **Return Code:** True\n
        :type center: tuple[float]

        """
        ...

    def normal(self, xyz, vNormal) -> Any:
        """
        **Description:**
            Returns the average of the surface normals at a specified location along the curve
        **Remarks/Usage:**
            This function finds all of the surfaces adjoining the curve and computes a normal to each surface at the specified location. The returned normal is simply the average of those surface normals.
        **Input:**
            **xyz:** The Global Rectangular coordinates of a location along the curve where you want to find the normal\n
        **Output:**
            **vNormal:** The average surface normal at that location\n
        **Return Code:** True\n
        :type xyz: tuple[float]

        :type vNormal: tuple[float]

        """
        ...


class UserData:
    CLSID: Any
    ID: Any
    SetID: Any
    Size: Any
    title: Any

    def AtEOF(self) -> Any:
        """
        **Description:**
            Indicates whether the current position for reading/writing is at the end of the data in the object.
        **Remarks/Usage:**
            You can use this check to determine when you reach the end of the data in an object.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, ID) -> Any:
        """
        **Description:**
            This method checks to see if a specific UserData is deletable
        **Remarks/Usage:**
            This method is currently not used. It will always return FE_OK.
        **Input:**
            **ID:** The ID of the UserData to check. \n
        **Return Code:** False\n
        :type ID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            Deletes the data object from the database with the specified ID.
        **Remarks/Usage:**
            Deleting a data object is permanent. The data is removed from the database; however, the data can return if you undo past the point of the deletion.
        **Input:**
            **entID:** The ID of the object to delete.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteTitle(self, title) -> Any:
        """
        **Description:**
            Deletes the data object from the database with the specified title.
        **Remarks/Usage:**
            Deleting a data object is permanent. The data is removed from the database; however, the data can return if you undo past the point of the deletion.
        **Input:**
            **title:** The title of the object to delete.\n
        **Return Code:** True\n
        :type title: tuple[str]

        """
        ...

    def Exist(self, ID) -> Any:
        """
        **Description:**
            This method checks to see if a specific UserData exists
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the UserData exists, and FE_FAIL if it does not.
        **Input:**
            **ID:** The ID of the UserData to check. \n
        **Return Code:** True\n
        :type ID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available UserData.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            Loads a data object that was previously stored with this entID.
        **Remarks/Usage:**
            You must call this function, or GetTitle( ), to reload objects that have been stored in the model.
        **Input:**
            **entID:** The entity ID of the data object that will be loaded.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetTitle(self, title) -> Any:
        """
        **Description:**
            Loads a data object that was previously stored with this title.
        **Remarks/Usage:**
            To use this method to retrieve an object, it must have had its title property defined prior to being Put to the database. The title specified here must be an exact match, including case, to the title specified when the object was stored. Using titles to store and retrieve data objects can eliminate conflicts between data stored from various programs.
        **Input:**
            **title:** The title of the object to load.\n
        **Return Code:** True\n
        :type title: tuple[str]

        """
        ...

    def Jump(self, jumpto) -> Any:
        """
        **Description:**
            Repositions the location in the data object where the next read or write will occur.
        **Remarks/Usage:**
            You should only specify jumpto as a value that you previously retrieved from a call to Position. Computing numbers yourself is prone to error because of extra data need to store arrays and certain data types.
        **Input:**
            **jumpto:** The position to move to. Specify jumpto=-1 to move to the end of the object, or jumpto=0 to move to the beginning of the object.\n
        **Return Code:** True\n
        :type jumpto: int

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available UserData.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available UserData with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available UserData with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next empty UserData object.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next setID that does not contain any UserData.
        **Return Code:** True\n
        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next existing UserData object.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def Position(self) -> Any:
        """
        **Description:**
            Returns the current location in the data object where you are reading or writing.
        **Remarks/Usage:**
            This function can be used with Jump to reposition to a specific object location for rereading or rewriting.
        **Return Code:** True\n
        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available UserData with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available UserData with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous empty UserData object.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the previous setID that does not contain any UserData.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous existing UserData object.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next UserData with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            Stores data from the current data object.
        **Remarks/Usage:**
            You must set the titleproperty prior to using this method if you want to use GetTitle to retrieve the object. You do not have to set the title if you plan on using Get to retrieve the object. Using this method will always overwrite any data that was previously stored with the same entID - even if it was not from your program - for that reason we recommend using PutTitle - with unique titles - whenever possible.
        **Input:**
            **entID:** The ID of the object to store.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutTitle(self, title) -> Any:
        """
        **Description:**
            Stores data from the current data object.
        **Remarks/Usage:**
            There is no need to set the title property prior to using this method - that is done automatically. This method will automatically find and overwrite any previous data with the same title - you should always specify a unique title to avoid this possibility - or use GetTitle to test if there is other data using the same title. If no data object exists in the database with a matching title, this method simply finds an unused ID and stores the object.
        **Input:**
            **title:** The title of the object to store.\n
        **Return Code:** True\n
        :type title: tuple[str]

        """
        ...

    def ReadBool(self, val) -> Any:
        """
        **Description:**
            Reads a single bool value from the current object.
        **Remarks/Usage:**
            The specified value will be read from the object at the current position. You can change this position with the Position method prior to calling this method. Data can be read from an object after a call to Get, or after data has been added to the object with one or more Write calls (and the position has been relocated before the data).
        **Output:**
            **val:** The value to read from the current object.\n
        **Return Code:** True\n
        :type val: bool

        """
        ...

    def ReadBoolArray(self, num, val) -> Any:
        """
        **Description:**
            Reads an array of bool values from the current object.
        **Remarks/Usage:**
            The specified values will be read from the object at the current position. You can change this position with the Position method prior to calling this method. Data can be read from an object after a call to Get, or after data has been added to the object with one or more Write calls (and the position has been relocated before the data).
        **Output:**
            **num:** The number of items in the array that is read.\n
            **val:** The values from the current object.\n
        **Return Code:** True\n
        :type num: int

        :type val: tuple[bool]

        """
        ...

    def ReadDouble(self, val) -> Any:
        """
        **Description:**
            Reads a single double value from the current object.
        **Remarks/Usage:**
            The specified value will be read from the object at the current position. You can change this position with the Position method prior to calling this method. Data can be read from an object after a call to Get, or after data has been added to the object with one or more Write calls (and the position has been relocated before the data).
        **Output:**
            **val:** The value to read from the current object\n
        **Return Code:** True\n
        :type val: float

        """
        ...

    def ReadDoubleArray(self, num, val) -> Any:
        """
        **Description:**
            Reads an array of double values from the current object.
        **Remarks/Usage:**
            The specified values will be read from the object at the current position. You can change this position with the Position method prior to calling this method. Data can be read from an object after a call to Get, or after data has been added to the object with one or more Write calls (and the position has been relocated before the data).
        **Output:**
            **num:** The number of items in the array that is read.\n
            **val:** The values from the current object.\n
        **Return Code:** True\n
        :type num: int

        :type val: tuple[float]

        """
        ...

    def ReadFloat(self, val) -> Any:
        """
        **Description:**
            Reads a single float value from the current object.
        **Remarks/Usage:**
            The specified value will be read from the object at the current position. You can change this position with the Position method prior to calling this method. Data can be read from an object after a call to Get, or after data has been added to the object with one or more Write calls (and the position has been relocated before the data).
        **Output:**
            **val:** The value to read from the current object.\n
        **Return Code:** True\n
        :type val: float

        """
        ...

    def ReadLong(self, val) -> Any:
        """
        **Description:**
            Reads a single long value from the current object.
        **Remarks/Usage:**
            The specified value will be read from the object at the current position. You can change this position with the Position method prior to calling this method. Data can be read from an object after a call to Get, or after data has been added to the object with one or more Write calls (and the position has been relocated before the data).
        **Output:**
            **val:** The value to read from the current object.\n
        **Return Code:** True\n
        :type val: int

        """
        ...

    def ReadLongArray(self, num, val) -> Any:
        """
        **Description:**
            Reads an array of long values from the current object.
        **Remarks/Usage:**
            The specified values will be read from the object at the current position. You can change this position with the Position method prior to calling this method. Data can be read from an object after a call to Get, or after data has been added to the object with one or more Write calls (and the position has been relocated before the data).
        **Output:**
            **num:** The number of items in the array that is read.\n
            **val:** The values from the current object.\n
        **Return Code:** True\n
        :type num: int

        :type val: tuple[int]

        """
        ...

    def ReadShort(self, val) -> Any:
        """
        **Description:**
            Reads a single short value from the current object.
        **Remarks/Usage:**
            The specified value will be read from the object at the current position. You can change this position with the Position method prior to calling this method. Data can be read from an object after a call to Get, or after data has been added to the object with one or more Write calls (and the position has been relocated before the data).
        **Output:**
            **val:** The value to read from the current object.\n
        **Return Code:** True\n
        :type val: int

        """
        ...

    def ReadString(self, val) -> Any:
        """
        **Description:**
            Reads a text string from the current object.
        **Remarks/Usage:**
            The specified values will be read from the object at the current position. You can change this position with the Position method prior to calling this method. Data can be read from an object after a call to Get, or after data has been added to the object with one or more Write calls (and the position has been relocated before the data).
        **Output:**
            **val:** The string to read from the current object.\n
        **Return Code:** True\n
        :type val: tuple[str]

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) UserData.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) UserData.
        **Return Code:** False\n
        """
        ...

    def Truncate(self, fsize) -> Any:
        """
        **Description:**
            Deletes all data in an object after the specified position.
        **Remarks/Usage:**
            Truncating data in an object only changes the current object. Changes must be Put to the database to be made permanent. The current reading/writing position is moved to the end of the object (position) following this method.
        **Input:**
            **fsize:** The position to truncate the data in the object. Essentially the size of the data in the remaining object.\n
        **Return Code:** True\n
        :type fsize: int

        """
        ...

    def WriteBool(self, val) -> Any:
        """
        **Description:**
            Writes a single bool value to the current object.
        **Remarks/Usage:**
            The specified value will be added to the object at the current position. You can change this position with the Position method prior to calling this method. Data that is added to the object, with any of the write methods, is not be saved to the model database until you call Put or PutTitle.
        **Input:**
            **val:** The value to add to the current object.\n
        **Return Code:** True\n
        :type val: bool

        """
        ...

    def WriteBoolArray(self, num, val) -> Any:
        """
        **Description:**
            Writes an array of bool values to the current object.
        **Remarks/Usage:**
            The specified values will be added to the object at the current position. You can change this position with the Position method prior to calling this method. Data that is added to the object, with any of the write methods, is not be saved to the model database until you call Put or PutTitle.
        **Input:**
            **num:** The number of entries in the val array that you want to write.\n
            **val:** The values to add to the current object.\n
        **Return Code:** True\n
        :type num: int

        :type val: tuple[bool]

        """
        ...

    def WriteDouble(self, val) -> Any:
        """
        **Description:**
            Writes a single double value to the current object.
        **Remarks/Usage:**
            The specified value will be added to the object at the current position. You can change this position with the Position method prior to calling this method. Data that is added to the object, with any of the write methods, is not be saved to the model database until you call Put or PutTitle.
        **Input:**
            **val:** The value to add to the current object.\n
        **Return Code:** True\n
        :type val: float

        """
        ...

    def WriteDoubleArray(self, num, val) -> Any:
        """
        **Description:**
            Writes an array of double values to the current object.
        **Remarks/Usage:**
            The specified values will be added to the object at the current position. You can change this position with the Position method prior to calling this method. Data that is added to the object, with any of the write methods, is not be saved to the model database until you call Put or PutTitle.
        **Input:**
            **num:** The number of entries in the val array that you want to write.\n
            **val:** The values to add to the current object.\n
        **Return Code:** True\n
        :type num: int

        :type val: tuple[float]

        """
        ...

    def WriteFloat(self, val) -> Any:
        """
        **Description:**
            Writes a single float value to the current object.
        **Remarks/Usage:**
            The specified value will be added to the object at the current position. You can change this position with the Position method prior to calling this method. Data that is added to the object, with any of the write methods, is not be saved to the model database until you call Put or PutTitle.
        **Input:**
            **val:** The value to add to the current object.\n
        **Return Code:** True\n
        :type val: float

        """
        ...

    def WriteLong(self, val) -> Any:
        """
        **Description:**
            Writes a single long value to the current object.
        **Remarks/Usage:**
            The specified value will be added to the object at the current position. You can change this position with the Position method prior to calling this method. Data that is added to the object, with any of the write methods, is not be saved to the model database until you call Put or PutTitle.
        **Input:**
            **val:** The value to add to the current object.\n
        **Return Code:** True\n
        :type val: int

        """
        ...

    def WriteLongArray(self, num, val) -> Any:
        """
        **Description:**
            Writes an array of long values to the current object.
        **Remarks/Usage:**
            The specified values will be added to the object at the current position. You can change this position with the Position method prior to calling this method. Data that is added to the object, with any of the write methods, is not be saved to the model database until you call Put or PutTitle.
        **Input:**
            **num:** The number of entries in the val array that you want to write.\n
            **val:** The values to add to the current object.\n
        **Return Code:** True\n
        :type num: int

        :type val: tuple[int]

        """
        ...

    def WriteShort(self, val) -> Any:
        """
        **Description:**
            Writes a single short value to the current object.
        **Remarks/Usage:**
            The specified value will be added to the object at the current position. You can change this position with the Position method prior to calling this method. Data that is added to the object, with any of the write methods, is not be saved to the model database until you call Put or PutTitle.
        **Input:**
            **val:** The value to add to the current object.\n
        **Return Code:** True\n
        :type val: int

        """
        ...

    def WriteString(self, val) -> Any:
        """
        **Description:**
            Writes a character string to the current object.
        **Remarks/Usage:**
            The specified values will be added to the object at the current position. You can change this position with the Position method prior to calling this method. Data that is added to the object, with any of the write methods, is not be saved to the model database until you call Put or PutTitle.
        **Input:**
            **val:** The string to add to the current object.\n
        **Return Code:** True\n
        :type val: tuple[str]

        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            This function simply removes all data from the current UserData object.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...


class Layup:
    CLSID: Any
    Active: Any
    ID: Any
    LayupThickness: Any
    NumberOfPlys: Any
    SetID: Any
    title: Any
    vAInvMatrix: Any
    vAMatrix: Any
    vBInvMatrix: Any
    vBMatrix: Any
    vBendingProp: Any
    vBendingPropExcMemBend: Any
    vDInvMatrix: Any
    vDMatrix: Any
    vInPlaneProp: Any
    vInPlanePropExcMemBend: Any
    vangle: Any
    vfailuretheory: Any
    vglobalply: Any
    vmatlID: Any
    vthickness: Any

    def AInvMatrix(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def AMatrix(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def AddPly(self, nMatlID, dThickness, dAngle, nGlobalPly) -> Any:
        """
        :type nMatlID: Any
        :type dThickness: Any
        :type dAngle: Any
        :type nGlobalPly: Any
        """
        ...

    def AddPly2(self, nMatlID, dThickness, dAngle, nGlobalPly, nFailureTheory) -> Any:
        """
        :type nMatlID: Any
        :type dThickness: Any
        :type dAngle: Any
        :type nGlobalPly: Any
        :type nFailureTheory: Any
        """
        ...

    def BInvMatrix(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def BMatrix(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def BendingProp(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def BendingPropExcMemBend(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Compute2(self, nOption) -> Any:
        """
        :type nOption: Any
        """
        ...

    def CountSet(self) -> Any:
        """
        """
        ...

    def DInvMatrix(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def DMatrix(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        :type nID: Any
        """
        ...

    def Delete(self, nID) -> Any:
        """
        :type nID: Any
        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        :type libINDEX: Any
        :type libFILE: Any
        """
        ...

    def DeletePly(self, nPlyID) -> Any:
        """
        :type nPlyID: Any
        """
        ...

    def Exist(self, nID) -> Any:
        """
        :type nID: Any
        """
        ...

    def First(self) -> Any:
        """
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def Get(self, entID) -> Any:
        """
        :type entID: Any
        """
        ...

    def GetAllPly(self, nNumPly, nMatlID, dThickness, dAngle, nGlobalPly) -> Any:
        """
        :type nNumPly: Any
        :type nMatlID: Any
        :type dThickness: Any
        :type dAngle: Any
        :type nGlobalPly: Any
        """
        ...

    def GetAllPly2(self, nNumPly, nMatlID, dThickness, dAngle, nGlobalPly, nFailureTheory) -> Any:
        """
        :type nNumPly: Any
        :type nMatlID: Any
        :type dThickness: Any
        :type dAngle: Any
        :type nGlobalPly: Any
        :type nFailureTheory: Any
        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        :type libINDEX: Any
        :type libFILE: Any
        """
        ...

    def GetPly(self, nPlyID, nMatlID, dThickness, dAngle, nGlobalPly) -> Any:
        """
        :type nPlyID: Any
        :type nMatlID: Any
        :type dThickness: Any
        :type dAngle: Any
        :type nGlobalPly: Any
        """
        ...

    def GetPly2(self, nPlyID, nMatlID, dThickness, dAngle, nGlobalPly, nFailureTheory) -> Any:
        """
        :type nPlyID: Any
        :type nMatlID: Any
        :type dThickness: Any
        :type dAngle: Any
        :type nGlobalPly: Any
        :type nFailureTheory: Any
        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        :type bIncludeID: Any
        :type minID: Any
        :type maxID: Any
        :type Count: Any
        :type listID: Any
        :type listTITLE: Any
        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        :type minID: Any
        :type maxID: Any
        :type Count: Any
        :type listID: Any
        :type listTITLE: Any
        """
        ...

    def HasFullGlobalPly(self) -> Any:
        """
        """
        ...

    def HasGlobalPly(self, nGlobalPlyID, bIndex, nPlyNum) -> Any:
        """
        :type nGlobalPlyID: Any
        :type bIndex: Any
        :type nPlyNum: Any
        """
        ...

    def HasMaterial(self, nMatlID) -> Any:
        """
        :type nMatlID: Any
        """
        ...

    def InPlaneProp(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def InPlanePropExcMemBend(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def InsertPly(self, nPlyID, nMatlID, dThickness, dAngle, nGlobalPly) -> Any:
        """
        :type nPlyID: Any
        :type nMatlID: Any
        :type dThickness: Any
        :type dAngle: Any
        :type nGlobalPly: Any
        """
        ...

    def InsertPly2(self, nPlyID, nMatlID, dThickness, dAngle, nGlobalPly, nFailureTheory) -> Any:
        """
        :type nPlyID: Any
        :type nMatlID: Any
        :type dThickness: Any
        :type dAngle: Any
        :type nGlobalPly: Any
        :type nFailureTheory: Any
        """
        ...

    def Last(self) -> Any:
        """
        """
        ...

    def Next(self) -> Any:
        """
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextSet(self) -> Any:
        """
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        :type sTitleIDStr: Any
        """
        ...

    def Prev(self) -> Any:
        """
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        """
        ...

    def PrevID(self) -> Any:
        """
        """
        ...

    def PrevSet(self) -> Any:
        """
        """
        ...

    def Put(self, entID) -> Any:
        """
        :type entID: Any
        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        :type libINDEX: Any
        :type libFILE: Any
        """
        ...

    def Reset(self) -> Any:
        """
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        :type sTitle: Any
        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        :type sTitle: Any
        """
        ...

    def SetAInvMatrix(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def SetAMatrix(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def SetAllPly(self, nNumPly, nMatlID, dThickness, dAngle, nGlobalPly) -> Any:
        """
        :type nNumPly: Any
        :type nMatlID: Any
        :type dThickness: Any
        :type dAngle: Any
        :type nGlobalPly: Any
        """
        ...

    def SetAllPly2(self, nNumPly, nMatlID, dThickness, dAngle, nGlobalPly, nFailureTheory) -> Any:
        """
        :type nNumPly: Any
        :type nMatlID: Any
        :type dThickness: Any
        :type dAngle: Any
        :type nGlobalPly: Any
        :type nFailureTheory: Any
        """
        ...

    def SetBInvMatrix(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def SetBMatrix(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def SetBendingProp(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetBendingPropExcMemBend(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetDInvMatrix(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def SetDMatrix(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def SetInPlaneProp(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInPlanePropExcMemBend(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPly(self, nPlyID, nMatlID, dThickness, dAngle, nGlobalPly) -> Any:
        """
        :type nPlyID: Any
        :type nMatlID: Any
        :type dThickness: Any
        :type dAngle: Any
        :type nGlobalPly: Any
        """
        ...

    def SetPly2(self, nPlyID, nMatlID, dThickness, dAngle, nGlobalPly, nFailureTheory) -> Any:
        """
        :type nPlyID: Any
        :type nMatlID: Any
        :type dThickness: Any
        :type dAngle: Any
        :type nGlobalPly: Any
        :type nFailureTheory: Any
        """
        ...

    def Setangle(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setfailuretheory(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setglobalply(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetmatlID(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setthickness(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def TotalThickness(self, dThickness) -> Any:
        """
        :type dThickness: Any
        """
        ...

    def angle(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def clear(self) -> Any:
        """
        """
        ...

    def compute(self, dynamic) -> Any:
        """
        :type dynamic: Any
        """
        ...

    def failuretheory(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def globalply(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def matlID(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def thickness(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class Matl:
    CLSID: Any
    Active: Any
    Alphaxx: Any
    Alphaxy: Any
    Alphayy: Any
    Alphayz: Any
    Alphazx: Any
    Alphazz: Any
    CompressionLimit1: Any
    CompressionLimit2: Any
    Cp: Any
    Damping: Any
    Density: Any
    Ex: Any
    Ey: Any
    Ez: Any
    Gx: Any
    Gy: Any
    Gz: Any
    ID: Any
    Kxx: Any
    Kxy: Any
    Kyy: Any
    Kyz: Any
    Kzx: Any
    Kzz: Any
    Nuxy: Any
    Nuxz: Any
    Nuyz: Any
    RefTemp: Any
    SetID: Any
    ShearLimit: Any
    TensionLimit1: Any
    TensionLimit2: Any
    TsaiWu: Any
    color: Any
    fmat: Any
    imat: Any
    layer: Any
    mmat: Any
    subtype: Any
    title: Any
    tmat: Any
    type: Any
    vbval: Any
    vfval: Any
    vival: Any
    vmval: Any
    vtval: Any

    def AreDuplicate(self, nMatl1, nMatl2, ignoretitle) -> Any:
        """
        **Description:**
            This method determines if two materials have identical values and includes an option to also consider the titles of the two materials
        **Remarks/Usage:**
            Returns TRUE or FALSE instead of FEMAP Return Code.
        **Input:**
            **nMatl1:** ID of a material\n
            **nMatl2:** ID of a material to compare to the material specified in nMatl1\n
            **ignoretitle:** Should title be ignored when determining if the 2 materials are duplicates (True=titles ignored, False=titles considered)\n
        **Return Code:** True\n
        :type nMatl1: int

        :type nMatl2: int

        :type ignoretitle: bool

        """
        ...

    def AutoComplete(self) -> Any:
        """
        **Description:**
            This method automatically fills out additional properties in the material object.
        **Remarks/Usage:**
            Often you want to define a material using a particular type - for example, orthotropic. In some cases however FEMAP will need to use that material as another type - for example, anisotropic. To do this successfully, all of the properties, not just the ones for the defined type need to be completed. This method will automatically compute, using the standard definitions in FEMAP, the required properties. Only standard structural properties are supported - E, G, NU, GMATRIX_2D, GMATRIX_3D, THERMAL_EXPANSION, and THERMAL_CONDUCTIVITY, and the TENSION_LIMIT and COMPRESSION_LIMIT are currently supported.
        **Return Code:** False\n
        """
        ...

    def CopyArray(self, bUpdateReferences, bCopyToStartID, nCopyToStartID, numID, nOrigID, pnNewID) -> Any:
        """
        **Description:**
            This method copies any number of materials and allows you to select a starting ID for the copies or provide all IDs for all copies. It also allows you to choose if the new material should replace the original material anywhere the original material was referenced (i.e., property n would now reference copied material instead of original material)
        **Remarks/Usage:**

        **Input:**
            **bUpdateReferences:** Flag to indicate if copied material should replace original material anywhere the original material was referenced. True = original material references are replaced with copied material.\n
            **bCopyToStartID:** Flag controls IDs of copied materials. When True, uses value of nCopyToStartID as the first ID of the copies. If a material ID already exists in the range where new materials will be created, that ID is skipped and the material will be placed in the next empty ID. When False, then pnNewID becomes an input instead of an output and must be populated with the same number of entries as nOrigID and cannot contain any IDs of materials which already exist.\n
            **nCopyToStartID:** Starting ID for copied materials\n
            **numID:** Number of original material IDs in nOrig array\n
            **nOrigID:** The IDs of the original materials\n
        **Output:**
            **pnNewID:** The IDs of the newly created (copied) materials. If bCopyToStartID is False, this is treated as an input instead of an output, which contains the new IDs off all copied materials. It must have the same number of entries as nOrigID and cannot contain any IDs of existing materials.\n
        **Return Code:** True\n
        :type bUpdateReferences: bool

        :type bCopyToStartID: bool

        :type nCopyToStartID: int

        :type numID: int

        :type nOrigID: tuple[int]

        :type pnNewID: tuple[int]

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, ID, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **ID:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type ID: int

        """
        ...

    def GetLibraryOfType(self, libINDEX, libTYPE, libFILE) -> Any:
        """
        **Description:**
            This method retrieves a material of a specified type from the Material library.
        **Remarks/Usage:**
            This method can be used instead of specifying the Active Material Type before using the GetLibrary method to load a material from the Material library.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first material of the specified type stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all materials of the specified type in the library, and will allow the user to select the material to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetValueArray(self, numValue, nMatlID, nMatlIndex, dValue) -> Any:
        """
        **Description:**
            This method returns an array of material property values using any combination of material IDs and material array index values.
        **Remarks/Usage:**
            See Section 5.50.1.1, "Accessing Material Properties"and Section 5.50.1.2, "Material Array Index Values" for more information about accessing material property values using the material array index values.
        **Input:**
            **numValue:** The number of entries in nMatlID and nMatlIndex\n
            **nMatlID:** The IDs of the materials\n
            **nMatlIndex:** The ID(s) of the material array index value(s). \n
        **Output:**
            **dValue:** The array of all the material property values\n
        **Return Code:** True\n
        :type numValue: int

        :type nMatlID: tuple[int]

        :type nMatlIndex: tuple[int]

        :type dValue: tuple[float]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def PutValue(self, nMatlSetID, nMatlIndex, dValue) -> Any:
        """
        **Description:**
            This method updates a single material property value on any number of materials
        **Remarks/Usage:**
            See Section 5.50.1.1, "Accessing Material Properties"and Section 5.50.1.2, "Material Array Index Values"for more information about accessing material property values using the material array index values.
        **Input:**
            **nMatlSetID:** The ID of set of material IDs\n
            **nMatlIndex:** The ID of the material array index value. \n
            **dValue:** The material property value\n
        **Return Code:** True\n
        :type nMatlSetID: int

        :type nMatlIndex: int

        :type dValue: float

        """
        ...

    def PutValueArray(self, numValue, nMatlID, nMatlIndex, dValue) -> Any:
        """
        **Description:**
            This method updates any number of material property values on any number of materials
        **Remarks/Usage:**
            See Section 5.50.1.1, "Accessing Material Properties"and Section 5.50.1.2, "Material Array Index Values" for more information about accessing material property values using the material array index values.
        **Input:**
            **numValue:** The number of entries in nMatlID, nMatlIndex, and dValue\n
            **nMatlID:** The IDs of the materials\n
            **nMatlIndex:** The IDs of the material array index value(s). \n
            **dValue:** The material property values\n
        **Return Code:** True\n
        :type numValue: int

        :type nMatlID: tuple[int]

        :type nMatlIndex: tuple[int]

        :type dValue: tuple[float]

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetbVal(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setfval(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setival(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setmval(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Settval(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def bVal(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def fval(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ival(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def mval(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def tval(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class Prop:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    cbush: Any
    color: Any
    extramat: Any
    layer: Any
    layupID: Any
    matlID: Any
    numOutline: Any
    outline: Any
    pmat: Any
    refCS: Any
    title: Any
    type: Any
    vExtraMatlID: Any
    vflag: Any
    vflagI: Any
    vpval: Any

    def AreDuplicate(self, nProp1, nProp2, ignoretitle) -> Any:
        """
        **Description:**
            This function determines if two properties have identical values and includes an option to also consider the titles of the two properties
        **Remarks/Usage:**

        **Input:**
            **nProp1:** ID of a property\n
            **nProp2:** ID of a property to compare to the property specified in nProp1\n
            **ignoretitle:** Should title be ignored when determining if the 2 properties are duplicates (True=titles ignored, False=titles considered)\n
        **Return Code:** True\n
        :type nProp1: int

        :type nProp2: int

        :type ignoretitle: bool

        """
        ...

    def Area(self, dAreaA, dAreaB) -> Any:
        """
        **Description:**
            This method returns the area at EndA and EndB of the line element property.
        **Remarks/Usage:**
            None
        **Output:**
            **dAreaA:** The area at EndA.\n
            **dAreaB:** The area at EndB.\n
        **Return Code:** True\n
        :type dAreaA: float

        :type dAreaB: float

        """
        ...

    def ComputeGeneralShape(self, surfaceID, vecDIR, sOrient, EvalMethod, shear_center_offset, Warping,
                            stress_recovery) -> Any:
        """
        **Description:**
            This method computes the properties for a general shape.
        **Remarks/Usage:**
            The Nastran PBEAML evaluator is not available for the general section
        **Input:**
            **surfaceID:** ID of a surface to be used to compute the general shape\n
            **vecDIR:** A vector that defines the original surface Y axis\n
            **shear_center_offset:** If True, the shear center offset is computed.\n
        **Return Code:** True\n
        :type surfaceID: int

        :type vecDIR: tuple[float]

        :type shear_center_offset: bool

        """
        ...

    def ComputeGeneralShape2(self, bAtEndAOrOverall, surfaceID, vecDIR, sOrient, EvalMethod, shear_center_offset,
                             Warping, stress_recovery) -> Any:
        """
        **Description:**
            This method computes the properties for a general shape at either End A or End B of a beam.
        **Remarks/Usage:**
            The Nastran PBEAML evaluator is not available for the general section
        **Input:**
            **bAtEndAOrOverall:** If True, only computes End A values. If False, only computes End B values and sets the Tapered flag.\n
            **surfaceID:** ID of a surface to be used to compute the general shape\n
            **vecDIR:** A vector that defines the original surface Y axis\n
            **sOrient:** The orientation direction (0=Right, 1=Up, 2=Left, 3=Down). Ignored for the Nastran shapes - for these orientation is always Up\n
            **EvalMethod:** The method used to evaluate the section properties (0=Auto, 1=Original, 2=Alternate)\n
            **shear_center_offset:** If True, the shear center offset is computed.\n
            **Warping:** If True, the warping constants are computed.\n
            **stress_recovery:** If True, the stress recovery locations and cross section orientation that are currently defined in the object are used for the computation. If False, default stress recovery locations and orientation are used.\n
        **Return Code:** True\n
        :type bAtEndAOrOverall: bool

        :type surfaceID: int

        :type vecDIR: tuple[float]

        :type sOrient: int

        :type EvalMethod: int

        :type shear_center_offset: bool

        :type Warping: bool

        :type stress_recovery: bool

        """
        ...

    def ComputeShape(self, shear_center_offset, Warping, stress_recovery) -> Any:
        """
        **Description:**
            NOTE: This method is obsolete - for new applications you should use either ComputeStdShape() or ComputeGeneralShape(). If values for End B of a tapered beam must be calculated, then ComputeStdShape2() or ComputeGeneralShape2() must be used.
        **Remarks/Usage:**
            To use this method, the property must be a type that uses a shape - Bar, Beam... Prior to using this method, you must load the appropriate properties (as shown in the table above) to define the type of shape and its dimensions. This method will not work with general shapes.
        **Input:**
            **shear_center_offset:** If True, the shear center offset is computed.\n
            **Warping:** If True, the warping constants are computed.\n
            **stress_recovery:** If True, the stress recovery locations and cross section orientation that are currently defined in the object are used for the computation. If False, default stress recovery locations and orientation are used.\n
        **Return Code:** False\n
        :type shear_center_offset: bool

        :type Warping: bool

        :type stress_recovery: bool

        """
        ...

    def ComputeStdShape(self, shapeID, dimensions, sOrient, EvalMethod, shear_center_offset, Warping,
                        stress_recovery) -> Any:
        """
        **Description:**
            This method computes the properties for a standard shape.
        **Remarks/Usage:**
            The General shape is not available with this method. Use ComputeGeneralShape() instead.
        **Input:**
            **shapeID:** ID of one of the...\n
            **dimensions:** The dimensions that define the shape. Values are in the same order that they are shown in the shape dialog box.\n
            **sOrient:** The orientation direction (0=Right, 1=Up, 2=Left, 3=Down). Ignored for the Nastran shapes - for these orientation is always Right\n
            **EvalMethod:** The method used to evaluate the section properties (0=Auto, 1=Original, 2=Alternate, 3=Nastran PBEAML)\n
            **shear_center_offset:** If True, the shear center offset is computed.\n
            **Warping:** If True, the warping constants are computed.\n
        **Return Code:** True\n
        :type shapeID: int

        :type dimensions: tuple[float]

        :type sOrient: int

        :type EvalMethod: int

        :type shear_center_offset: bool

        :type Warping: bool

        """
        ...

    def ComputeStdShape2(self, bAtEndAOrOverall, shapeID, dimensions, sOrient, EvalMethod, shear_center_offset, Warping,
                         stress_recovery) -> Any:
        """
        **Description:**
            This method computes the properties for a standard shape at either End A or End B of a beam.
        **Remarks/Usage:**
            The General shape is not available with this method. Use ComputeGeneralShape() or ComputeGeneralShape2(), if End B values are needed, instead.
        **Input:**
            **bAtEndAOrOverall:** If True, only computes End A values. If False, only computes End B values and sets the Tapered flag.\n
            **shapeID:** ID of one of the...\n
            **dimensions:** The dimensions that define the shape. Values are in the same order that they are shown in the shape dialog box.\n
            **sOrient:** The orientation direction (0=Right, 1=Up, 2=Left, 3=Down). Ignored for the Nastran shapes - for these orientation is always Right \n
            **EvalMethod:** The method used to evaluate the section properties (0=Auto, 1=Original, 2=Alternate, 3=Nastran PBEAML)\n
            **shear_center_offset:** If True, the shear center offset is computed.\n
            **Warping:** If True, the warping constants are computed.\n
            **stress_recovery:** If True, the stress recovery locations and cross section orientation that are currently defined in the object are used for the computation. If False, default stress recovery locations and orientation are used.\n
        **Return Code:** True\n
        :type bAtEndAOrOverall: bool

        :type shapeID: int

        :type dimensions: tuple[float]

        :type sOrient: int

        :type EvalMethod: int

        :type shear_center_offset: bool

        :type Warping: bool

        :type stress_recovery: bool

        """
        ...

    def CopyArray(self, bUpdateReferences, bCopyToStartID, nCopyToStartID, numID, nOrigID, pnNewID) -> Any:
        """
        **Description:**
            This function copies any number of properties and allows you to select a starting ID for the copies or provide all IDs for all copies. It also allows you to choose if the new property should replace the original property anywhere the original property was referenced (i.e., element n would now reference copied property instead of original property)
        **Remarks/Usage:**

        **Input:**
            **bUpdateReferences:** Flag to indicate if copied property should replace original property anywhere the original property was referenced. True = original property references are replaced with copied property.\n
            **bCopyToStartID:** Flag controls IDs of copied properties. When True, uses value of nCopyToStartID as the first ID of the copies. If a property ID already exists in the range where new properties will be created, that ID is skipped and the property will be placed in the next empty ID. When False, then pnNewID becomes an input instead of an output and must be populated with the same number of entries as nOrigID and cannot contain any IDs of properties which already exist.\n
            **nCopyToStartID:** Starting ID for copied properties\n
            **numID:** Number of original property IDs in nOrig array\n
            **nOrigID:** The IDs of the original properties\n
        **Output:**
            **pnNewID:** The IDs of the newly created (copied) properties. If bCopyToStartID is False, this is treated as an input instead of an output, which contains the new IDs off all copied properties. It must have the same number of entries as nOrigID and cannot contain any IDs of existing properties.\n
        **Return Code:** True\n
        :type bUpdateReferences: bool

        :type bCopyToStartID: bool

        :type nCopyToStartID: int

        :type numID: int

        :type nOrigID: tuple[int]

        :type pnNewID: tuple[int]

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def ExtraMatlID(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetLibraryOfType(self, libINDEX, libTYPE, libFILE) -> Any:
        """
        **Description:**
            This function retrieves a property of a specified type from the Property library.
        **Remarks/Usage:**
            This method can be used instead of specifying the Active Element Type before using the GetLibrary method to load a property from the Property library.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first property of the specified type stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all properties of the specified type in the library, and will allow the user to select the property to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetValueArray(self, numValue, nPropID, nPropIndex, dValue) -> Any:
        """
        **Description:**
            This function returns an array of property values using any combination of property IDs and property array index values.
        **Remarks/Usage:**
            See Section 5.63.2, "Accessing Property Properties"and Section 5.63.2.1, "Property Array Index Values"for more information about accessing property values using the property array index values.
        **Input:**
            **numValue:** The number of entries in nPropID and nPropIndex\n
        **Output:**
            **dValue:** The array of all the property values\n
        **Return Code:** True\n
        :type numValue: int

        :type dValue: tuple[float]

        """
        ...

    def HasMatl(self) -> Any:
        """
        **Description:**
            This function returns whether the property has an associated material.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def Inertia(self, dI1A, dI2A, dI12A, dJA, dI1B, dI2B, dI12B, dJB) -> Any:
        """
        **Description:**
            This function returns the Inertia properties of the line property.
        **Remarks/Usage:**
            None
        **Output:**
            **dI1A:** Area Moment of Inertia for plane 1 EndA\n
            **dI2A:** Area Moment of Inertia for plane 2 EndA\n
            **dI12A:** Cross product of inertia at EndA\n
            **dI1B:** Area Moment of Inertia for plane 1 EndB\n
            **dI2B:** Area Moment of Inertia for plane 2 EndB\n
            **dI12B:** Cross product of inertia at EndB\n
        **Return Code:** True\n
        :type dI1A: float

        :type dI2A: float

        :type dI12A: float

        :type dI1B: float

        :type dI2B: float

        :type dI12B: float

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Layup(self) -> Any:
        """
        **Description:**

        **Remarks/Usage:**
            This method loads the layup that is referenced by the currently loaded property object.
        **Return Code:** False\n
        """
        ...

    def Matl(self) -> Any:
        """
        **Description:**

        **Remarks/Usage:**
            This method loads the material that is referenced by the currently loaded property object.
        **Return Code:** False\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def PutValue(self, nPropSetID, nPropIndex, dValue) -> Any:
        """
        **Description:**
            This function updates a single property value on any number of properties
        **Remarks/Usage:**
            See Section 5.63.2, "Accessing Property Properties"and Section 5.63.2.1, "Property Array Index Values"for more information about accessing property values using the property array index values.
        **Input:**
            **nPropSetID:** The ID of set of property IDs\n
            **nPropIndex:** The ID of the property array index value. \n
            **dValue:** The property value\n
        **Return Code:** True\n
        :type nPropSetID: int

        :type nPropIndex: int

        :type dValue: float

        """
        ...

    def PutValueArray(self, numValue, nPropID, nPropIndex, dValue) -> Any:
        """
        **Description:**
            This function updates any number of property values on any number of properties
        **Remarks/Usage:**
            See Section 5.63.2, "Accessing Property Properties"and Section 5.63.2.1, "Property Array Index Values"for more information about accessing property values using the property array index values.
        **Input:**
            **numValue:** The number of entries in nPropID, nPropIndex, and dValue\n
            **nPropID:** The IDs of the properties\n
            **nPropIndex:** The IDs of the property array index value(s). \n
            **dValue:** The property values\n
        **Return Code:** True\n
        :type numValue: int

        :type nPropID: tuple[int]

        :type nPropIndex: tuple[int]

        :type dValue: tuple[float]

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetExtraMatlID(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setflag(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetflagI(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setpval(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def flag(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def flagI(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def pval(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def thickness(self, dAvgOrAtC1, dAtC2, dAtC3, dAtC4) -> Any:
        """
        **Description:**
            This method returns the thickness of the property.
        **Remarks/Usage:**
            None
        **Output:**
            **dAvgOrAtC1:** The thickness or alternately the thickness at corner 1. \n
            **dAtC2:** The thickness at corner 2.\n
            **dAtC3:** The thickness at corner 3.\n
            **dAtC4:** The thickness at corner 4.\n
        **Return Code:** True\n
        :type dAvgOrAtC1: float

        :type dAtC2: float

        :type dAtC3: float

        :type dAtC4: float

        """
        ...


class Elem:
    CLSID: Any
    Active: Any
    ID: Any
    MaterialAngle: Any
    MaterialAngleFlag: Any
    MaterialCSys: Any
    MaterialOrientType: Any
    Nodes: Any
    PlateOffset: Any
    RigidInterpolate: Any
    RigidInterpolationFactor: Any
    RigidThermalExpansion: Any
    SetID: Any
    SpringCID: Any
    SpringLocation: Any
    SpringNoOrient: Any
    SpringUseCID: Any
    SpringUseLocation: Any
    SpringUsePropCID: Any
    SpringUsePropLocation: Any
    color: Any
    geomID: Any
    layer: Any
    orientID: Any
    propID: Any
    topology: Any
    type: Any
    vconnectSEG: Any
    vconnectTYPE: Any
    vformulation: Any
    vkeyopt: Any
    vnode: Any
    voffset: Any
    vorient: Any
    vrelease: Any
    vwarping: Any

    def Area(self, dAreaA, dAreaB) -> Any:
        """
        **Description:**
            This method returns the area at EndA and EndB of Line Element.
        **Remarks/Usage:**
            None
        **Output:**
            **dAreaA:** The element area at EndA.\n
            **dAreaB:** The element area at EndB.\n
        **Return Code:** True\n
        :type dAreaA: float

        :type dAreaB: float

        """
        ...

    def ClearNodeList(self, listINDEX) -> Any:
        """
        **Description:**
            This method clears node lists on rigid and slide line elements.
        **Remarks/Usage:**
            If there are node lists in the object, either because you added them with PutNodeList(), or because you called Get() on an element that had lists, this method will simply erase the selected list. You can use this if you want to clear the lists because you want to reuse the object for a different element type.
        **Return Code:** False\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def ElementHasThickness(self) -> Any:
        """
        **Description:**
            This method indicates if the loaded element has corner thickness values defined on the element.
        **Remarks/Usage:**
            It may be beneficial to use this call before using the Thickness method to determine if the corner thickness values being returned are coming from the element or the property referenced by the element.
        **Return Code:** True\n
        """
        ...

    def ElementalCSys(self, bCreateCSys, nCSysType, bUsePlateMatlDirection, nCSysID, vOrigin, vRotation) -> Any:
        """
        **Description:**
            This method creates a coordinate system along the element axis or material direction. This method can also return element orientation values.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetAllArray(self, SetID, numElem, entID, propID, elemTYPE, topology, layer, color, formulation, orient, offset,
                    release, orientSET, orientID, Nodes, connectTYPE, connectSEG) -> Any:
        """
        **Description:**
            This method retrieves arrays of values for a set of elements.
        **Remarks/Usage:**
            This method is the fastest way to retrieve information about a large number of elements. If a retrieved element ID does not exist, then all of the values for that element ID will be 0.
        **Input:**
            **SetID:** ID of the set that contains the element IDs to retrieve. If 0, retrieve all elements in the model.\n
        **Output:**
            **numElem:** The number of elements for which data is being returned.\n
            **entID:** Each entry is the ID of the associated element.\n
            **propID:** The property ID of the element.\n
            **elemTYPE:** The element type.\n
            **topology:** The element topology/shape.\n
            **layer:** The ID of the layer for the element.\n
            **color:** The color of the element.\n
            **formulation:** The element formulation. There are 2 values per element.\n
            **orient:** The element orientation vector (3 values per line element) or Material Angle (1 value per element, stored in the first of the three slots per element)\n
            **offset:** The element offset vectors, 6 values per element. The first 3 at end 1, the second 3 at end 2.\n
            **release:** Flags indicating end releases. 12 values per element. The first 6 correspond to the elemental degrees of freedom at the first end of the element. The final 6 to the second end.\n
            **orient:** Flag indicating whether material orientation is on for this element.\n
            **entID:** The ID of the third/orientation node for the element.\n
            **Nodes:** The node IDs used to define the element. Stored 20 values per element. Unused nodes are 0. Element types that reference lists of nodes (like rigid, slide lines or contact), will not have the nodes from their node lists in this array - you must use other methods to retrieve those nodes.\n
            **connectTYPE:** There are 2 values per element.\n
            **connectSEG:** There are 2 values per element. Node, Element or Property ID for weld patch A and B respectivelyfor individual of weld types. \n
        **Return Code:** False\n
        :type SetID: int

        :type numElem: int

        :type entID: tuple[int]

        :type propID: tuple[int]

        :type elemTYPE: tuple[int]

        :type topology: tuple[int]

        :type layer: tuple[int]

        :type color: tuple[int]

        :type formulation: tuple[int]

        :type orient: tuple[float]

        :type offset: tuple[float]

        :type release: tuple[int]

        :type orient: tuple[int]

        :type entID: tuple[int]

        :type Nodes: tuple[int]

        :type connectTYPE: tuple[int]

        :type connectSEG: tuple[int]

        """
        ...

    def GetAllArray2(self, SetID, numElem, entID, Exist, propID, elemTYPE, topology, layer, color, formulation, orient,
                     offset, release, orientSET, orientID, Nodes, connectTYPE, connectSEG) -> Any:
        """
        **Description:**
            This method retrieves arrays of values for a set of elements, including if an element exists in database
        **Remarks/Usage:**
            This method is the fastest way to retrieve information about a large number of elements. If a retrieved element ID does not exist, then all of the values for that element ID will be 0. If it is known that all of the elements in the element set exist, use GetAllArray.
        **Input:**
            **SetID:** ID of the set that contains the element IDs to retrieve. If 0, retrieve all elements in the model.\n
        **Output:**
            **numElem:** The number of elements for which data is being returned.\n
            **entID:** Each entry is the ID of the associated element.\n
            **Exist:** Element existence, True=Element exists, False=Element does not exist\n
            **propID:** The property ID of the element.\n
            **elemTYPE:** The element type.\n
            **topology:** The element topology/shape.\n
            **layer:** The ID of the layer for the element.\n
            **color:** The color of the element.\n
            **formulation:** The element formulation. There are 2 values per element.\n
            **orient:** The element orientation vector (3 values per line element) or Material Angle (1 value per element, stored in the first of the three slots per element)\n
            **offset:** The element offset vectors, 6 values per element. The first 3 at end 1, the second 3 at end 2.\n
            **release:** Flags indicating end releases. 12 values per element. The first 6 correspond to the elemental degrees of freedom at the first end of the element. The final 6 to the second end.\n
            **orient:** Flag indicating whether material orientation is on for this element.\n
            **entID:** The ID of the third/orientation node for the element.\n
            **Nodes:** The node IDs used to define the element. Stored 20 values per element. Unused nodes are 0. Element types that reference lists of nodes (like rigid, slide lines or contact), will not have the nodes from their node lists in this array - you must use other methods to retrieve those nodes.\n
        **Return Code:** False\n
        :type SetID: int

        :type numElem: int

        :type entID: tuple[int]

        :type Exist: tuple[bool]

        :type propID: tuple[int]

        :type elemTYPE: tuple[int]

        :type topology: tuple[int]

        :type layer: tuple[int]

        :type color: tuple[int]

        :type formulation: tuple[int]

        :type orient: tuple[float]

        :type offset: tuple[float]

        :type release: tuple[int]

        :type orient: tuple[int]

        :type entID: tuple[int]

        :type Nodes: tuple[int]

        """
        ...

    def GetAllArray3(self, SetID, numElem, entID, Exist, propID, elemTYPE, topology, layer, color, formulation, orient,
                     offset, release, orientSET, orientID, Nodes, connectTYPE, connectSEG, MaterialOrientType,
                     MaterialCSys, warpingID, SpringLocation) -> Any:
        """
        **Description:**
            This method retrieves arrays of values for a set of elements, including if an element exists in database
        **Remarks/Usage:**
            This method is the fastest way to retrieve information about a large number of elements. If a retrieved element ID does not exist, then all of the values for that element ID will be 0. If it is known that all of the elements in the element set exist, use GetAllArray.
        **Return Code:** False\n
        """
        ...

    def GetAnsysFormulationArray(self, SetID, numElem, entID, Exist, formulation) -> Any:
        """
        **Description:**
            Gets the ANSYS formulations of a given set of elements.
        **Remarks/Usage:**
            None
        **Input:**
            **SetID:** The ID of the set object containing the elements. \n
        **Output:**
            **numElem:** The number of elements returned. \n
            **entID:** An array of the IDs of the elements returned. \n
            **Exist:** An array of the elements that indicated if the formulation exists. \n
            **formulation:** An array of the element formulation values.\n
        **Return Code:** True\n
        :type SetID: int

        :type numElem: int

        :type entID: tuple[int]

        :type Exist: tuple[int]

        :type formulation: tuple[int]

        """
        ...

    def GetAnsysKeyoptArray(self, SetID, numElem, entID, Exist, keyopt) -> Any:
        """
        **Description:**
            Gets the ANSYS keyopts for a given set of elements.
        **Remarks/Usage:**
            None
        **Output:**
            **SetID:** The number of elements returned. \n
            **numElem:** An array of the IDs of the elements returned. \n
            **entID:** An array of the elements that indicated if the formulation exists. \n
            **Exist:** An array of the element formulation values.\n
        **Return Code:** True\n
        :type SetID: int

        :type numElem: tuple[int]

        :type entID: tuple[int]

        :type Exist: tuple[int]

        """
        ...

    def GetCentroid(self, cgXYZ) -> Any:
        """
        **Description:**
            This method returns the centroid of the current element
        **Remarks/Usage:**
            None
        **Output:**
            **cgXYZ:** The coordinates of the centroid of the element. Always reported in Global Rectangular coordinates.\n
        **Return Code:** False\n
        :type cgXYZ: tuple[float]

        """
        ...

    def GetCentroidArray(self, SetID, numElem, entID, vCG) -> Any:
        """
        **Description:**
            This method retrieves arrays of centroid values for a set of elements.
        **Remarks/Usage:**
            This method is the fastest way to retrieve centroid information about a large number of elements. If a retrieved element ID does not exist, then all of the values for that element ID will be 0.
        **Input:**
            **SetID:** ID of the set that contains the element IDs to retrieve. If 0, retrieve all elements in the model.\n
        **Output:**
            **numElem:** The number of elements for which data is being returned.\n
            **entID:** Each entry is the ID of the associated element.\n
            **vCG:** The coordinates of the centroid of the element. Always reported in Global Rectangular coordinates.\n
        **Return Code:** False\n
        :type SetID: int

        :type numElem: int

        :type entID: tuple[int]

        :type vCG: tuple[float]

        """
        ...

    def GetEdgeNodes(self, nEdge, n1, n2, nmid) -> Any:
        """
        **Description:**
            This method returns the nodes on the selected edge of the element.
        **Remarks/Usage:**
            This method only works for Line (Line2 and Line3), Planar (Tria3, Tria6, Quad4 and Quad8) and Solid (Tetra4, Tetra10, Pyramid5, Pyramid13, Wedge6, Wedge15, Brick8 and Brick20) shaped elements.
        **Input:**
            **nEdge:** The identifier of the edge that you want to select.\n
        **Output:**
            **n1:** The first node used to define the edge\n
            **n2:** The last node used to define the edge\n
            **nmid:** The midside node on the edge (0 if edge has no midside node)\n
        **Return Code:** False\n
        :type nEdge: int

        :type n1: int

        :type n2: int

        :type nmid: int

        """
        ...

    def GetFaceArea(self, nFace, dArea) -> Any:
        """
        **Description:**
            This method returns the area of a selected element face.
        **Remarks/Usage:**
            The face identifiers are the same as the face numbers used when applying elemental loads. These are shown in the Element Reference in the User Manual. Only planar or solid elements can be used, but the edges of planar elements are valid. If the element has thickness, its average thickness is used along with the edge length to compute edge area. For axisymmetric elements, a thickness of 1.0 is used.
        **Input:**
            **nFace:** The identifier of the face that you want to select.\n
        **Output:**
            **dArea:** The area of the element face. \n
        **Return Code:** False\n
        :type nFace: int

        :type dArea: float

        """
        ...

    def GetFaceCentroid(self, nFace, cgXYZ) -> Any:
        """
        **Description:**
            This method returns the centroid of a selected element face.
        **Remarks/Usage:**
            The face identifiers are the same as the face numbers used when applying elemental loads. These are shown in the Element Reference in the User Manual. Only planar or solid elements can be used, but the edges of planar elements are valid.
        **Input:**
            **nFace:** The identifier of the face that you want to select.\n
        **Output:**
            **cgXYZ:** The coordinates of the centroid of the element face. Always reported in Global Rectangular coordinates.\n
        **Return Code:** False\n
        :type nFace: int

        :type cgXYZ: tuple[float]

        """
        ...

    def GetFaceNodes(self, nFace, Nodes) -> Any:
        """
        **Description:**
            This method returns the nodes which define the selected element face.
        **Remarks/Usage:**
            This method only desinged for Planar (Tria3, Tria6, Quad4 and Quad8) and Solid (Tetra4, Tetra10, Pyramid5, Pyramid13, Wedge6, Wedge15, Brick8 and Brick20) shaped elements.
        **Input:**
            **nFace:** The identifier of the face that you want to select.\n
        **Output:**
            **Nodes:** The nodes used to define the selected face. Corner nodes always come first, followed by midside nodes. Most faces use less than 8 nodes, and the final node IDs will all be 0.\n
        **Return Code:** False\n
        :type nFace: int

        :type Nodes: tuple[int]

        """
        ...

    def GetFaceNodes2(self, bCornerPressureOrder, nFace, Nodes) -> Any:
        """
        **Description:**
            Similar to GetFaceNodes, this method returns the nodes which define the selected element face, which can optionally be returned in the order used to apply pressure loads on element corners.
        **Remarks/Usage:**
            This method is only designed for Planar (Tria3, Tria6, Quad4 and Quad8) and Solid (Tetra4, Tetra10, Pyramid5, Pyramid13, Wedge6, Wedge15, Brick8 and Brick20) shaped elements.
        **Input:**
            **bCornerPressureOrder:** If False, nodes are returned in the same order as GetFaceNodes, and is described in the Remarks/Usage section. If True, Planar element node order follows the right-hand rule around the element normal for both Face 1 and Face2. For Solid Elements, node order always follows the right-hand rule around an outward facing normal.\n
            **nFace:** The identifier of the face that you want to select.\n
        **Output:**
            **Nodes:** The nodes used to define the selected face. Corner nodes always come first, followed by midside nodes. Most faces use less than 8 nodes, and the final node IDs will all be 0.\n
        **Return Code:** False\n
        :type bCornerPressureOrder: bool

        :type nFace: int

        :type Nodes: tuple[int]

        """
        ...

    def GetFaceNormal(self, nFace, normalXYZ) -> Any:
        """
        **Description:**
            This method returns the normal vector of a selected element face.
        **Remarks/Usage:**
            The face identifiers are the same as the face numbers used when applying elemental loads. These are shown in the Element Reference in the User Manual. Only planar or solid elements can be used, but the edges of planar elements are valid.
        **Input:**
            **nFace:** The identifier of the face that you want to select.\n
        **Output:**
            **normalXYZ:** The vector components of the normal of the element face. Always reported in Global Rectangular coordinates. These vector components are always normalized.\n
        **Return Code:** False\n
        :type nFace: int

        :type normalXYZ: tuple[float]

        """
        ...

    def GetGeomPropArray(self, SetID, numElem, entID, propID, matlID, elemTYPE, topology, vCG, Length, Area,
                         volume) -> Any:
        """
        **Description:**
            This method returns various geometric properties for a selected set of elements.
        **Remarks/Usage:**
            This method is the fastest way to retrieve information about a large number of elements. If a retrieved element ID does not exist, then all of the values for that element ID will be 0.
        **Input:**
            **SetID:** ID of the set that contains the element IDs to retrieve. If 0, retrieve all elements in the model.\n
        **Output:**
            **numElem:** The number of elements for which data is being returned.\n
            **entID:** Each entry is the ID of the associated element.\n
            **propID:** The property ID of the element.\n
            **matlID:** The material ID of the element.\n
            **elemTYPE:** The element type.\n
            **topology:** The element topology/shape.\n
            **vCG:** The coordinates of the centroid of the element. Always reported in Global Rectangular coordinates\n
            **Length:** The length of each element. Only nonzero for line elements.\n
            **Area:** The area of each element.\n
            **volume:** The volume of each element.\n
        **Return Code:** False\n
        :type SetID: int

        :type numElem: int

        :type entID: tuple[int]

        :type propID: tuple[int]

        :type matlID: tuple[int]

        :type elemTYPE: tuple[int]

        :type topology: tuple[int]

        :type vCG: tuple[float]

        :type Length: tuple[float]

        :type Area: tuple[float]

        :type volume: tuple[float]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetMatlOrientVec(self, vMatOrientVec) -> Any:
        """
        **Description:**
            This method returns the vector that is the material orientation direction.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def GetMinMaxEdgeLength(self, dMinLen, dMaxLen) -> Any:
        """
        **Description:**
            Finds the minimum and maximum length of edges in the element
        **Remarks/Usage:**
            None
        **Output:**
            **dMinLen:** The minimum edge length\n
            **dMaxLen:** The maximum edge length\n
        **Return Code:** True\n
        :type dMinLen: float

        :type dMaxLen: float

        """
        ...

    def GetMultiFaceInfoArray(self, nNumFaces, nElemIDs, nFaceIDs, faceOK, cgXYZ, normalXYZ, dArea) -> Any:
        """
        **Description:**
            This method returns arrays of centroid, normal, and area values on different faces specified in an array
        **Remarks/Usage:**
            The face identifiers are the same as the face numbers used when applying elemental loads. These are shown in the Element Reference in the User Manual. Only planar or solid elements can be used, but the edges of planar elements are valid.
        **Input:**
            **nNumFaces:** The number of face entries in the nFaceIDs array.\n
            **nElemIDs:** Each entry is the ID of the associated element.\n
            **nFaceIDs:** Each entry is the ID of the face to query.\n
        **Return Code:** True\n
        :type nNumFaces: int

        :type nElemIDs: int

        :type nFaceIDs: int

        """
        ...

    def GetNodeList(self, listINDEX, nodecount, Node, face, weight, dof) -> Any:
        """
        **Description:**
            This method retrieves information from the node lists on rigid and slide line elements.
        **Remarks/Usage:**
            This method simply retrieves the information about the node lists from the current object. You must first load that data - either using the Get( ) method, or by loading it yourself with PutNodeList( ).
        **Output:**
            **nodecount:** The number of entries in the other arrays (except dof, which has 6*nodecount entries).\n
            **Node:** The IDs of the nodes in the list.\n
            **face:** The face numbers of any elements (not used).\n
            **weight:** The weighting factors associated with the nodes for interpolation elements.\n
            **dof:** The degree of freedom flags associated with the nodes. This array has six sequential entries for each node. For example, node[0] has entries dof[0]..dof[5] as its degree of freedom flags. node[1] has dof[6]..dof[11], and so on.\n
        **Return Code:** True\n
        :type nodecount: int

        :type Node: tuple[int]

        :type face: tuple[int]

        :type weight: tuple[float]

        :type dof: tuple[int]

        """
        ...

    def GetSingleFaceInfoArray(self, SetID, nFace, numElem, entID, cgXYZ, normalXYZ, dArea) -> Any:
        """
        **Description:**
            This method returns arrays of centroid, normal, and area values of an identical element face
        **Remarks/Usage:**
            The face identifiers are the same as the face numbers used when applying elemental loads. These are shown in the Element Reference in the User Manual. Only planar or solid elements can be used, but the edges of planar elements are valid.
        **Input:**
            **SetID:** ID of the set that contains the element IDs to retrieve. If 0, retrieve all elements in the model.\n
            **nFace:** The identifier of the face that you want to select. Information on this face is returned for all elements.\n
        **Output:**
            **numElem:** The number of element faces for which data is being returned.\n
            **entID:** Each entry is the ID of the associated element.\n
        **Return Code:** True\n
        :type SetID: int

        :type nFace: int

        :type numElem: int

        :type entID: tuple[int]

        """
        ...

    def GetSpringOffset(self, enOffset, dVec1, dVec2, dVec3) -> Any:
        """
        **Description:**
            Returns the offset for spring/damper element
        **Remarks/Usage:**

        **Output:**
            **dVec1:** Offset vector X component in global rectangular (FESL_OFFSET). Location for FESL_ELLOC or FESL_PRLOC\n
            **dVec2:** Offset vector Y component in global rectangular (FESL_OFFSET)\n
            **dVec3:** Offset vector Z component in global rectangular (FESL_OFFSET)\n
        **Return Code:** True\n
        :type dVec1: float

        :type dVec2: float

        :type dVec3: float

        """
        ...

    def GetSpringOrient(self, enOrient, nOrient, dVec1, dVec2, dVec3) -> Any:
        """
        **Description:**
            Returns the orientation for the spring/damper element
        **Remarks/Usage:**

        **Output:**
            **nOrient:** Spring/damper orientation. 0=None (FESO_NONE), 1=Node (FESO_NODE), 2=Vector (FESO_VECTOR), 3=Coordinate System on Element (FESO_ELCID), 4=Coordinate System on Property (FESO_PRCID)\n
            **nOrient:** Orientation entity for FESO_NODE (node ID), FESO_ELCID (CSys ID), FESO_PRCID (CSys ID from property)\n
            **dVec1:** Vector X orientation in global coordinate system (FESO_VECTOR)\n
            **dVec2:** Vector Y orientation in global coordinate system (FESO_VECTOR)\n
            **dVec3:** Vector Z orientation in global coordinate system (FESO_VECTOR)\n
        **Return Code:** True\n
        :type nOrient: int

        :type nOrient: int

        :type dVec1: float

        :type dVec2: float

        :type dVec3: float

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def HasMatl(self) -> Any:
        """
        **Description:**
            Return if the element has an associated material.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def HasProp(self) -> Any:
        """
        **Description:**
            Returns if the element has an associated property.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Inertia(self, dI1A, dI2A, dI12A, dJA, dI1B, dI2B, dI12B, dJB) -> Any:
        """
        **Description:**
            This method returns line element properties at EndA and EndB.
        **Remarks/Usage:**
            None
        **Output:**
            **dI1A:** Area Moment of Inertia for plane 1 EndA\n
            **dI2A:** Area Moment of Inertia for plane 2 EndA\n
            **dI12A:** Cross product of inertia at EndA\n
            **dI1B:** Area Moment of Inertia for plane 1 EndB\n
            **dI2B:** Area Moment of Inertia for plane 2 EndB\n
            **dI12B:** Cross product of inertia at EndB\n
        **Return Code:** True\n
        :type dI1A: float

        :type dI2A: float

        :type dI12A: float

        :type dI1B: float

        :type dI2B: float

        :type dI12B: float

        """
        ...

    def IsParabolic(self) -> Any:
        """
        **Description:**
            This method indicates if the loaded element is parabolic or not
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Length(self, dLength) -> Any:
        """
        **Description:**
            This method returns the length of a Line Element.
        **Remarks/Usage:**
            None
        **Output:**
            **dLength:** The element Length\n
        **Return Code:** True\n
        :type dLength: float

        """
        ...

    def Matl(self) -> Any:
        """
        **Description:**
            This method creates and returns a Material object that is loaded with the material data referenced by an element.
        **Remarks/Usage:**

        **Return Code:** False\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def Node(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Prop(self) -> Any:
        """
        **Description:**
            This method creates and returns a Property object that is loaded with the property data referenced by an element.
        **Remarks/Usage:**

        **Return Code:** False\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutAllArray(self, numElem, entID, propID, elemTYPE, topology, layer, color, formulation, orient, offset,
                    release, orientSET, orientID, Nodes, connectTYPE, connectSEG) -> Any:
        """
        **Description:**
            This method stores/creates multiple elements based on the values passed in various arrays.
        **Remarks/Usage:**
            This method is the fastest way to create a large number of elements.
        **Input:**
            **numElem:** The number of elements to create - the number of entries in the arrays\n
            **entID:** Each entry is the ID of the associated element to be created\n
            **propID:** The property ID of the element.\n
            **elemTYPE:** The element type.\n
            **topology:** The element topology/shape.\n
            **layer:** The ID of the layer for the element.\n
            **color:** The color of the element.\n
            **formulation:** The element formulation. There are 2 values per element.\n
            **orient:** The element orientation vector, 3 values per element.\n
            **offset:** The element offset vectors, 6 values per element. The first 3 at end 1, the second 3 at end 2.\n
            **release:** Flags indicating end releases. 12 values per element. The first 6 correspond to the elemental degrees of freedom at the first end of the element. The final 6 to the second end.\n
            **orient:** Flag indicating whether material orientation is on for this element.\n
            **entID:** The ID of the third/orientation node for the element.\n
            **Nodes:** The node IDs used to define the element. Stored 20 values per element. Unused nodes are 0. Element types that reference lists of nodes (like rigid, slide lines or contact), can not be created using this method - you must use Put to create those element types.\n
            **connectTYPE:** There are 2 values per element.\n
            **connectSEG:** There are 2 values per element. Node, Element or Property ID for weld patch A and B respectivelyfor individual of weld types. \n
        **Return Code:** False\n
        :type numElem: int

        :type entID: tuple[int]

        :type propID: tuple[int]

        :type elemTYPE: tuple[int]

        :type topology: tuple[int]

        :type layer: tuple[int]

        :type color: tuple[int]

        :type formulation: tuple[int]

        :type orient: tuple[float]

        :type offset: tuple[float]

        :type release: tuple[int]

        :type orient: tuple[int]

        :type entID: tuple[int]

        :type Nodes: tuple[int]

        :type connectTYPE: tuple[int]

        :type connectSEG: tuple[int]

        """
        ...

    def PutAnsysFormulationArray(self, numElem, entID, formulation) -> Any:
        """
        **Description:**
            Sets the ANSYS formulations for a given array of elements.
        **Remarks/Usage:**
            None
        **Input:**
            **numElem:** The number of elements to put.\n
            **entID:** An array with the element IDs to put.\n
            **formulation:** An array with the ANSYS formulations to put.\n
        **Return Code:** True\n
        :type numElem: int

        :type entID: tuple[int]

        :type formulation: tuple[int]

        """
        ...

    def PutAnsysKeyoptArray(self, numElem, entID, keyopt) -> Any:
        """
        **Description:**
            Sets the ANSYS keyopts for a given array of elements.
        **Remarks/Usage:**
            None
        **Input:**
            **numElem:** The number of elements to put.\n
            **entID:** An array with the element IDs to put.\n
            **keyopt:** An array with the ANSYS keyopts to put.\n
        **Return Code:** True\n
        :type numElem: int

        :type entID: tuple[int]

        :type keyopt: tuple[int]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def PutNodeList(self, listINDEX, nodecount, Node, face, weight, dof) -> Any:
        """
        **Description:**
            This method loads information into the node lists on rigid and slide line elements.
        **Remarks/Usage:**
            This method stores information into the lists of the current object. Any previous list information in that object is lost. This method does not store that information to the model database. After using this function, you must call Put( ) if you want to store the updated lists in the database.
        **Input:**
            **nodecount:** The number of entries in the other arrays (except dof, which has 6*nodecount entries).\n
            **Node:** The IDs of the nodes in the list.\n
            **face:** The face numbers of any elements (not used - must be NULL)\n
            **weight:** The weighting factors associated with the nodes for interpolation elements.\n
            **dof:** The degree of freedom flags associated with the nodes. This array has six sequential entries for each node. For example, node[0] has entries dof[0]..dof[5] as its degree of freedom flags. node[1] has dof[6]..dof[11], and so on.\n
        **Return Code:** True\n
        :type nodecount: int

        :type Node: tuple[int]

        :type face: tuple[int]

        :type weight: tuple[float]

        :type dof: tuple[int]

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetNode(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPlateThickness(self, dAtC1, dAtC2, dAtC3, dAtC4) -> Any:
        """
        **Description:**
            Sets the element corner thickness on Plate elements
        **Remarks/Usage:**
            None
        **Input:**
            **dAtC1:** The element thickness at corner 1\n
            **dAtC2:** The element thickness at corner 2\n
            **dAtC3:** The element thickness at corner 3\n
            **dAtC4:** The element thickness at corner 4\n
        **Return Code:** True\n
        :type dAtC1: float

        :type dAtC2: float

        :type dAtC3: float

        :type dAtC4: float

        """
        ...

    def SetSpringOffset(self, enOffset, dVec1, dVec2, dVec3) -> Any:
        """
        **Description:**
            Set offset for spring/damper element
        **Remarks/Usage:**
            Use of this method is recommended over setting individual spring/damper offset properties on the element object as it ensures all the correct flags will be set for the selected offset
        **Input:**
            **dVec1:** Offset vector X component in global rectangular (FESL_OFFSET). Location for FESL_ELLOC or FESL_PRLOC\n
            **dVec2:** Offset vector Y component in global rectangular (FESL_OFFSET)\n
            **dVec3:** Offset vector Z component in global rectangular (FESL_OFFSET)\n
        **Return Code:** True\n
        :type dVec1: float

        :type dVec2: float

        :type dVec3: float

        """
        ...

    def SetSpringOrient(self, enOrient, nOrient, dVec1, dVec2, dVec3) -> Any:
        """
        **Description:**
            Set orientation for spring/damper element
        **Remarks/Usage:**
            Use of this method is recommended over setting individual spring orientation properties on the element object as it ensures all the correct flags will be set for the selected orientation
        **Input:**
            **nOrient:** Spring/damper orientation. 0=None (FESO_NONE), 1=Node (FESO_NODE), 2=Vector (FESO_VECTOR), 3=Coordinate System on Element (FESO_ELCID), 4=Coordinate System on Property (FESO_PRCID)\n
            **nOrient:** Orientation entity for FESO_NODE (node ID), FESO_ELCID (CSys ID), FESO_PRCID (CSys ID from property)\n
            **dVec1:** Vector X orientation in global coordinate system (FESO_VECTOR)\n
            **dVec2:** Vector Y orientation in global coordinate system (FESO_VECTOR)\n
            **dVec3:** Vector Z orientation in global coordinate system (FESO_VECTOR)\n
        **Return Code:** True\n
        :type nOrient: int

        :type nOrient: int

        :type dVec1: float

        :type dVec2: float

        :type dVec3: float

        """
        ...

    def SetWarping(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetconnectSEG(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetconnectTYPE(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setformulation(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setoffset(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def Setorient(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setrelease(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def Warping(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def connectSEG(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def connectTYPE(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def formulation(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def offset(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def orient(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def release(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def thickness(self, dAvg, dAtC1, dAtC2, dAtC3, dAtC4) -> Any:
        """
        **Description:**
            This method returns the thickness of the element.
        **Remarks/Usage:**
            None
        **Output:**
            **dAvg:** The average thickness of the element. \n
            **dAtC1:** The element thickness at corner 1. \n
            **dAtC2:** The element thickness at corner 2.\n
            **dAtC3:** The element thickness at corner 3.\n
            **dAtC4:** The element thickness at corner 4.\n
        **Return Code:** True\n
        :type dAvg: float

        :type dAtC1: float

        :type dAtC2: float

        :type dAtC3: float

        :type dAtC4: float

        """
        ...


class Function:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    title: Any
    type: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetFunctionList(self, listcount, x, y) -> Any:
        """
        **Description:**
            This method retrieves function pair information.
        **Remarks/Usage:**
            This method simply retrieves the information about the function pairs from the current object. You must first load that data - either using the Get( ) method, or by loading it yourself with PutFunctionList( ). Data retrieved from the database using Get, will always be in order of ascending X values.
        **Output:**
            **x:** The x and y values for the function..\n
            **y:** Return Code:\n
        **Return Code:** True\n
        :type x: tuple[float]

        :type y: tuple[float]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetValue(self, nMethod, x, y) -> Any:
        """
        **Description:**
            This method evaluates the function to find a y value given an x value.
        **Remarks/Usage:**
            The Closest method returns one of the endpoints of the function if you specify an x value that is outside the defined range of the function. The Interpolate method uses the first/last two points in the function and linearly extrapolates to find values beyond the defined range of the function. If you attempt to interpolate on a function with only one defined value, you will simply get that value for every location.
        **Input:**
            **x:** The location where the function is evaluated\n
        **Output:**
            **y:** The function value at the specified x location\n
        **Return Code:** True\n
        :type x: float

        :type y: float

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutFunctionList(self, listcount, x, y) -> Any:
        """
        **Description:**
            This method saves function pair information.
        **Remarks/Usage:**
            This method stores information into the list of the current object. Any previous list information in that object is lost. This method does not store that information to the model database. After using this function, you must call Put( ) if you want to store the updated list in the database. Data to be stored in the database will be sorted into order of increasing x values. It is not required, however, Put performance will be improved if you provide the x,y pairs in sorted order.
        **Input:**
            **listcount:** The number of entries in the other arrays.\n
            **x, y:** The x and y values for the function.\n
        **Return Code:** False\n
        :type listcount: int
        :type x: tuple[float]

        :type y: tuple[float]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class group:
    CLSID: Any
    Active: Any
    Condense: Any
    CoordClipCSys: Any
    CoordClipDir: Any
    CoordClipMax: Any
    CoordClipMin: Any
    CoordClipMode: Any
    CoordClipOn: Any
    EvalAlways: Any
    ID: Any
    LayerMax: Any
    LayerMin: Any
    LayerMode: Any
    NeedEval: Any
    PlaneClipInside: Any
    PlaneClipMode: Any
    SetID: Any
    renumber: Any
    title: Any
    vPlaneClipBase: Any
    vPlaneClipDir: Any
    vPlaneClipNeg: Any
    vPlaneClipOn: Any

    def Add(self, entityTYPE, nEntityID) -> Any:
        """
        **Description:**
            This method adds a single entity to a group.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** Type of entity in the selected set. For more information, see Section 3.3.6, "Entity Types". \n
            **nEntityID:** The ID of the entity to add to the group.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type nEntityID: int

        """
        ...

    def Add2(self, entityTYPE, nEntityID) -> Any:
        """
        **Description:**
            This method adds a single entity of a specific Group Data Type to a group.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def AddOpt2(self, entityTYPE, nEntityID, addOpt) -> Any:
        """
        **Description:**
            This method adds (or removes) all entities in a set to a group, based on the specified Group Data Type.
        **Remarks/Usage:**
            This method works just like the Add method except that you can choose to Add, Remove, or Exclude instead of only being able to Add.
        **Return Code:** True\n
        """
        ...

    def AddRelated(self) -> Any:
        """
        **Description:**
            This method adds entities related to the entities already in the group currently in the object.
        **Remarks/Usage:**
            Performs the same function as the Group, Operations, Add Related Entities command.
        **Return Code:** True\n
        """
        ...

    def CountList(self, listTYPE) -> Any:
        """
        **Description:**
            This method returns the number of entities selected in the specified Group list.
        **Remarks/Usage:**
            None
        **Input:**
            **listTYPE:** The type of group list that you want to retrieve. Refer to Section 5.38.1.2, "Group List Types" for allowable list types.\n
        **Return Code:** True\n
        :type listTYPE: int

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetList(self, listTYPE, SetID) -> Any:
        """
        **Description:**
            This method is similar to the List method, but instead of returning a new Set object, it simply adds the contents of the list into a Set object that already exists
        **Remarks/Usage:**
            None
        **Input:**
            **listTYPE:** The type of group list that you want to retrieve. Refer to Section 5.38.1.2, "Group List Types" for allowable list types.\n
            **SetID:** The ID of the Set object to fill.\n
        **Return Code:** False\n
        :type listTYPE: int

        :type SetID: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def HasList(self, listTYPE) -> Any:
        """
        **Description:**
            This method is used to determine if a list is present in the current Group
        **Remarks/Usage:**
            None
        **Input:**
            **listTYPE:** The type of group list that you want to retrieve. Refer to Section 5.38.1.2, "Group List Types" for allowable list types.\n
        **Return Code:** True\n
        :type listTYPE: int

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def List(self, listTYPE) -> Any:
        """
        **Description:**
            This method returns a Set object that contains all of the entities currently in the selected group list.
        **Remarks/Usage:**
            None
        **Input:**
            **listTYPE:** The type of group list that you want to retrieve. Refer to Section 5.38.1.2, "Group List Types" for allowable list types.\n
        **Return Code:** False\n
        :type listTYPE: int

        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def PlaneClipBase(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def PlaneClipDir(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def PlaneClipNeg(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def PlaneClipOn(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Range(self, rangeType) -> Any:
        """
        **Description:**
            This method returns a Set object that contains all of the entities currently selected by the specified rangeType.
        **Remarks/Usage:**
            None
        **Input:**
            **rangeType:** The type of group range list that you want to retrieve. Refer to Section 5.38.1.1, "Group Range Types" for allowable rangeTypes\n
        **Return Code:** False\n
        :type rangeType: int

        """
        ...

    def RangeAdd(self, rangeType, startID, stopID, increment, inClude) -> Any:
        """
        **Description:**
            This method adds a range selection to the end of a selected list.
        **Remarks/Usage:**
            If the entities that you want to add to the group are in a set, you can use the SetAdd method.
        **Input:**
            **rangeType:** This is the type of range that you are creating.\n
            **stopID:** The ending ID in the range. This should be 0 for single entry ranges.\n
            **increment:** The increment to count by between startID and stopID, usually 1.\n
            **inClude:** The include flag :0=Remove, 1=Add, Exclude=-1.\n
        **Return Code:** True\n
        :type rangeType: int

        :type stopID: int

        :type increment: int

        :type inClude: int

        """
        ...

    def RangeDelete(self, rangeType) -> Any:
        """
        **Description:**
            This method deletes a single range from the selected list.
        **Remarks/Usage:**
            This function deletes the range at the current location. To use this function, you must use the RangeNext function to retrieve ranges until you retrieve the one you want to delete, then call RangeDelete and that range will be removed.
        **Input:**
            **rangeType:** This is the type of range that you are deleting.\n
        **Return Code:** True\n
        :type rangeType: int

        """
        ...

    def RangeDeleteAll(self, rangeType) -> Any:
        """
        **Description:**
            This method deletes all ranges from the selected list.
        **Remarks/Usage:**
            Deleting all ranges of all types (rangeType=-1) is equivalent to the Group, Operations, Reset Rules command.
        **Input:**
            **rangeType:** This is the type of range that you are deleting. Specify -1 to delete all ranges of all types.\n
        **Return Code:** True\n
        :type rangeType: int

        """
        ...

    def RangeGetAll(self, rangeType, rangeCount, startID, stopID, increment, inClude) -> Any:
        """
        **Description:**
            This method returns all of the ranges of a specific type in the form of arrays.
        **Remarks/Usage:**
            Use the Reset method to go to the beginning of the lists of ranges, then keep calling RangeNext to retrieve entries from a list of ranges one-by-one. Alternatively, you can call RangeGetAll to get all of the entries in one call.
        **Input:**
            **rangeType:** This is the type of range that you are retrieving.\n
        **Output:**
            **rangeCount:** The number of entries in each of the other arrays. That is, the number of ranges that are returned.\n
            **startID:** The starting ID in the range.\n
            **stopID:** The ending ID in the range. This will be 0 for single entry ranges.\n
            **increment:** The increment to count by between startID and stopID\n
            **inClude:** The include flag 0=Remove, 1=Add, Exclude=-1.\n
        **Return Code:** True\n
        :type rangeType: int

        :type rangeCount: int

        :type startID: tuple[int]

        :type stopID: tuple[int]

        :type increment: tuple[int]

        :type inClude: tuple[int]

        """
        ...

    def RangeNext(self, rangeType, startID, stopID, increment, inClude) -> Any:
        """
        **Description:**
            This method returns the values from the next range of a specific type.
        **Remarks/Usage:**
            Use the Reset method to go to the beginning of the lists of ranges, then keep calling RangeNext to retrieve entries from a list of ranges one-by-one. Alternatively, you can call RangeGetAll to get all of the entries in one call.
        **Input:**
            **rangeType:** This is the type of range that you are retrieving.\n
        **Output:**
            **stopID:** The ending ID in the range. This will be 0 for single entry ranges.\n
            **increment:** The increment to count by between startID and stopID.\n
            **inClude:** The include flag: 0=Remove, 1=Add, Exclude=-1.\n
        **Return Code:** True\n
        :type rangeType: int

        :type stopID: int

        :type increment: int

        :type inClude: int

        """
        ...

    def RangeReset(self) -> Any:
        """
        **Description:**
            This method resets the nextpointer so that the next call to RangeNext will return the first (lowest ID) range.
        **Remarks/Usage:**
            This method does not change the nextpointer for the Group object, just for the ranges within the group. The next method will still return the next group.
        **Return Code:** False\n
        """
        ...

    def ReferencedGroups(self) -> Any:
        """
        **Description:**
            This method creates and returns a Set object that contains the IDs of all sub-groups that are referenced by this group.
        **Remarks/Usage:**
            The Set object is returned in place of the return code.
        **Return Code:** False\n
        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectAllOnLayer(self, startLayer, endLayer) -> Any:
        """
        **Description:**
            This method selects all of the entities in the current model that are on layers startLayer thru endLayer.
        **Remarks/Usage:**
            This is like the Group, Operations, Generate Entities On Layercommand, except the entities are selected into the current Group object.
        **Input:**
            **startLayer:** The ID of the lowest layer to select.\n
            **endLayer:** The ID of the highest layer to select (If 0, then just entities on startLayer are selected)\n
        **Return Code:** False\n
        :type startLayer: int

        :type endLayer: int

        """
        ...

    def SelectContact(self, contactSET) -> Any:
        """
        **Description:**
            This method creates a group that contains all of the entities referenced by a selected set of contact segments/surfaces.
        **Remarks/Usage:**
            This is like the Group, Operations, Contact Segment/Surfacecommand. The group must be Put to the database before these selections will take effect.
        **Input:**
            **contactSET:** The set of contact segments/surfaces used to generate the group.\n
        **Return Code:** False\n
        :type contactSET: int

        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectMesh(self, elemSET) -> Any:
        """
        **Description:**
            This method creates a group that contains all of the nodes, properties, materials, coordinate systems, loads, and constraints that are referenced by the selected elements.
        **Remarks/Usage:**
            This is like the Group, Operations, Select Meshcommand. The group must be Put to the database before these selections will take effect.
        **Input:**
            **elemSET:** The set of elements to use to compute the desired subset of the model.\n
        **Return Code:** False\n
        :type elemSET: int

        """
        ...

    def SelectModel(self) -> Any:
        """
        **Description:**
            This method creates rules that select all possible entities in a model.
        **Remarks/Usage:**
            This method is like the Group, Operations, Select Model command. The group must be Put to the database before these selections will take effect.
        **Return Code:** False\n
        """
        ...

    def SetAdd(self, entityTYPE, SetID) -> Any:
        """
        **Description:**
            This method adds all entities in a set to a group.
        **Remarks/Usage:**
            This method creates one or more entity ID range type rules to select the entities into the group.
        **Input:**
            **entityTYPE:** Type of entity in the selected set. For more information, see Section 3.3.6, "Entity Types". \n
            **SetID:** The ID of the set containing the entities to add to the group\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type SetID: int

        """
        ...

    def SetAdd2(self, entityTYPE, SetID) -> Any:
        """
        **Description:**
            This method adds all entities in a set to a group, based on the specified Group Data Type.
        **Remarks/Usage:**
            This method creates one or more entity ID range type rules to select the entities into the group.
        **Return Code:** True\n
        """
        ...

    def SetAddOpt(self, entityTYPE, SetID, addOpt) -> Any:
        """
        **Description:**
            This method adds (or removes) all entities in a set to a group.
        **Remarks/Usage:**
            This method works just like the RangeAdd method except that all entities in the set are either added or removed.
        **Input:**
            **entityTYPE:** Type of entity in the selected set. For more information, see Section 3.3.6, "Entity Types". \n
            **SetID:** The ID of the set containing the entities to add to, remove from, or exclude from the group\n
            **addOpt:** 0=Remove, 1=Add, -1= Exclude\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type SetID: int

        :type addOpt: int

        """
        ...

    def SetAddOpt2(self, entityTYPE, SetID, addOpt) -> Any:
        """
        **Description:**
            This method adds (or removes) all entities in a set to a group, based on the specified Group Data Type.
        **Remarks/Usage:**
            This method works just like the RangeAdd method except that all entities in the set are either added or removed.
        **Return Code:** True\n
        """
        ...

    def SetPlaneClipBase(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def SetPlaneClipDir(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def SetPlaneClipNeg(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPlaneClipOn(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def addOpt(self, entityTYPE, nEntityID, addOpt) -> Any:
        """
        :type entityTYPE: Any
        :type nEntityID: Any
        :type addOpt: Any
        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            This function simply removes all rules and entities from the Group object
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...


class layer:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    color: Any
    title: Any

    def ClearLayerInfo(self) -> Any:
        """
        **Description:**
            This method clears the layer information from a Layer Object.
        **Remarks/Usage:**
            This method only needs to be used to clear information from the Layer Object which was placed there by the InitAllLayerInfo method (Section 5.40.2.1, "InitAllLayerInfo") or any combination of the individual InitLayerContentsInfo (Section 5.40.2.2, "InitLayerContentsInfo"), InitLayerGroupReferences (Section 5.40.2.3, "InitLayerGroupReferenceInfo"), and/or InitLayerViewReferenceInfo (Section 5.40.2.4, "InitLayerViewReferenceInfo") methods.
        **Return Code:** False\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def FindAllReferencedLayers(self, nLayerSetID) -> Any:
        """
        **Description:**
            This method fills the Set Object of the specified ID with all the layers which reference any information currently loaded in the Layer Object.
        **Remarks/Usage:**
            This method requires information to be loaded into the Layer Object by the InitAllLayerInfo method (Section 5.40.2.1, "InitAllLayerInfo") or any combination of the individual InitLayerContentsInfo (Section 5.40.2.2, "InitLayerContentsInfo"), InitLayerGroupReferences (Section 5.40.2.3, "InitLayerGroupReferenceInfo"), and/or InitLayerViewReferenceInfo (Section 5.40.2.4, "InitLayerViewReferenceInfo") methods. If this is not done, prior to using this method, a return code of FE_INVALID will be returned.
        **Input:**
            **nLayerSetID:** ID of an existing set object to fill with the IDs of all the layers which currently have information loaded into the Layer Object. See Remarks/Usage section.\n
        **Return Code:** True\n
        :type nLayerSetID: int

        """
        ...

    def FindEmptyLayers(self, nLayerSetID) -> Any:
        """
        **Description:**
            This method fills the Set Object of the specified ID with all the layers in the model which are currently empty, based on the information currently loaded in the Layer Object.
        **Remarks/Usage:**
            This method requires information to be loaded into the Layer Object by the InitAllLayerInfo method (Section 5.40.2.1, "InitAllLayerInfo") or any combination of the individual InitLayerContentsInfo (Section 5.40.2.2, "InitLayerContentsInfo"), InitLayerGroupReferences (Section 5.40.2.3, "InitLayerGroupReferenceInfo"), and/or InitLayerViewReferenceInfo (Section 5.40.2.4, "InitLayerViewReferenceInfo") methods If this is not done, prior to using this method, a return code of FE_INVALID will be returned.
        **Input:**
            **nLayerSetID:** ID of an existing set object to fill with the IDs of the layers which are currently empty based on the information currently loaded into in the Layer Object by the Init methods. See Remarks/Usage section.\n
        **Return Code:** True\n
        :type nLayerSetID: int

        """
        ...

    def FindLayerInfo(self, nLayerID, nDataType, nInSetID, nOnType, nEntitySetID, bClearEntitySet) -> Any:
        """
        **Description:**
            This method fills a Set Object with the entities in a load or constraint on a specify layer.
        **Remarks/Usage:**
            This method requires information to be loaded into the Layer Object by the InitAllLayerInfo method (Section 5.40.2.1, "InitAllLayerInfo") or any combination of the individual InitLayerContentsInfo (Section 5.40.2.2, "InitLayerContentsInfo"), InitLayerGroupReferences (Section 5.40.2.3, "InitLayerGroupReferenceInfo"), and/or InitLayerViewReferenceInfo (Section 5.40.2.4, "InitLayerViewReferenceInfo") methods If this is not done, prior to using this method, a return code of FE_INVALID will be returned.
        **Input:**
            **nLayerID:** The ID of the layer to retrieve information on.\n
            **nDataType:** The enum of the data type the Set Object was filled with. 13 = FT_SURF_LOAD, 14 = FT_GEOM_LOAD, 15 = FT_NTHERM_LOAD, 16 = FT_ETHERM_LOAD, 18 = FT_BCO, 19 = FT_BC_GEOM, 20 = FT_BEQ.\n
            **nInSetID:** The ID of the Set Object to fill. \n
            **nOnType:** The enum of the data type the entities in nEntitySet are associated to. For example, nInSetID would be the ID of the load/constraint set, and nOnType would be the data type the load or constraint is on, FT_NODE, FT_ELEM, FT_CURVE, etc. \n
            **nEntitySetID:** The ID of the Set Object to fill. \n
            **bClearEntitySet:** If True, nEntitySet will be cleared of all entities beforehand.\n
        **Return Code:** True\n
        :type nLayerID: int

        :type nDataType: int

        :type nInSetID: int

        :type nOnType: int

        :type nEntitySetID: int

        :type bClearEntitySet: bool

        """
        ...

    def FindMissingLayers(self, nLayerSetID) -> Any:
        """
        **Description:**
            This method fills the Set Object of the specified ID with all the layers in the model which have entities assigned to them, but do not currently exist in the model.
        **Remarks/Usage:**
            This method requires information to be loaded into the Layer Object by the InitAllLayerInfo method (Section 5.40.2.1, "InitAllLayerInfo") or any combination of the individual InitLayerContentsInfo (Section 5.40.2.2, "InitLayerContentsInfo"), InitLayerGroupReferences (Section 5.40.2.3, "InitLayerGroupReferenceInfo"), and/or InitLayerViewReferenceInfo (Section 5.40.2.4, "InitLayerViewReferenceInfo") methods If this is not done, prior to using this method, a return code of FE_INVALID will be returned.
        **Input:**
            **nLayerSetID:** ID of an existing set object to fill with the IDs of the layers which have entities assigned to them, based on the information currently loaded into in the Layer Object by the Init methods, but do not currently exist in the model. See Remarks/Usage section.\n
        **Return Code:** True\n
        :type nLayerSetID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def InitAllLayerInfo(self, bContents, bGroupReference, bViewReference) -> Any:
        """
        **Description:**
            This method scans the model and builds the data structure for the Contents, Group References, and/or View References for a layer, then loads this data into the Layer Object. This method is the same as using a combination of the InitLayerContentsInfo, InitLayerGroupReferenceInfo, and/or InitLayerViewReferenceInfo methods with some specific values specified.
        **Remarks/Usage:**
            This method or a combination of the InitLayerContentsInfo, InitLayerGroupReferences, and/or InitLayerViewReferenceInfo methods set to the following values:
        **Input:**
            **bContents:** When True, builds the data structure for contents (entities) of the layer\n
            **bGroupReference:** When True, builds the data structure for group references of the layer\n
            **bViewReference:** When True, builds the data structure for view references of the layer\n
        **Return Code:** False\n
        :type bContents: bool

        :type bGroupReference: bool

        :type bViewReference: bool

        """
        ...

    def InitLayerContentsInfo(self, nLayerSetID, nNumEntityTypes, EntityTypes, nSetSetID) -> Any:
        """
        **Description:**
            This method scans the model and builds the data structure for Contents (entities) for a layer, then loads this data into the Layer Object
        **Remarks/Usage:**
            This method, when used with these values:
        **Input:**
            **nLayerSetID:** ID of a Set Object containing IDs of layers. Entering a value of 0 will consider all layers. Alternatively, entering a negative value will only consider a single layer.\n
            **nNumEntityTypes:** Number of entity types in EntityTypes. Entering a value of 0 will consider all entity types.\n
            **EntityTypes:** Array of entity type IDs. If a value of 0 has been entered for nNumEntityTypes, this argument can be set to NULL.\n
            **nSetSetID:** ID of a Set Object containing IDs of Load/Constraint Sets. Entering a value of 0 will consider all Load/Constraint Sets. Alternatively, entering a negative value will only consider a single Load/Constraint Set.\n
        **Return Code:** False\n
        :type nLayerSetID: int

        :type nNumEntityTypes: int

        :type EntityTypes: Any

        :type nSetSetID: int

        """
        ...

    def InitLayerGroupReferenceInfo(self, nLayerSetID, nGroupSetID) -> Any:
        """
        **Description:**
            This method scans the model and builds the data structure for groups that reference the layers, then loads this data into the Layer Object
        **Remarks/Usage:**
            This method, when used with these values:
        **Input:**
            **nLayerSetID:** ID of a Set Object containing IDs of layers. Entering a value of 0 will consider all layers. Alternatively, entering a negative value will only consider a single layer.\n
            **nGroupSetID:** ID of a Set Object containing IDs of groups. Entering a value of 0 will consider all groups. Alternatively, entering a negative value will only consider a single group.\n
        **Return Code:** False\n
        :type nLayerSetID: int

        :type nGroupSetID: int

        """
        ...

    def InitLayerViewReferenceInfo(self, nLayerSetID, nViewSetID) -> Any:
        """
        **Description:**
            This method scans the model and builds the data structure for layers displayed on views, then loads this data into the Layer Object
        **Remarks/Usage:**
            This method, when used with these values:
        **Input:**
            **nLayerSetID:** ID of a Set Object containing IDs of layers. Entering a value of 0 will consider all layers. Alternatively, entering a negative value will only consider a single layer.\n
            **nViewSetID:** ID of a Set Object containing IDs of views. Entering a value of 0 will consider all views. Alternatively, entering a negative value will only consider a single view.\n
        **Return Code:** False\n
        :type nLayerSetID: int

        :type nViewSetID: int

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextLayerInfo(self, nDesiredLayerID, nEntitySetID, nDataType, nInSetID, nOnType) -> Any:
        """
        **Description:**
            This method fills a Set Object with the next type of entity in the data structure of the desired layer.
        **Remarks/Usage:**
            This method requires information to be loaded into the Layer Object by the InitAllLayerInfo method (Section 5.40.2.1, "InitAllLayerInfo") or any combination of the individual InitLayerContentsInfo (Section 5.40.2.2, "InitLayerContentsInfo"), InitLayerGroupReferences (Section 5.40.2.3, "InitLayerGroupReferenceInfo"), and/or InitLayerViewReferenceInfo (Section 5.40.2.4, "InitLayerViewReferenceInfo") methods If this is not done, prior to using this method, a return code of FE_INVALID will be returned.
        **Input:**
            **nDesiredLayerID:** The ID of the layer to retrieve information on.\n
            **nEntitySetID:** The ID of the Set Object to fill. \n
        **Output:**
            **nDataType:** The enum of the data type the Set Object was filled with. For all data types, see Section 3.3.6, "Entity Types".\n
            **nInSetID:** The ID of the load or constraint set associated to nDataType. All data types other than loads or constraints nInSetID = 1. \n
            **nOnType:** The enum of the data type the entities in nEntitySet are associated to. For example, nInSetID would be the ID of the load/constraint set, and nOnType would be the data type the load or constraint is on, FT_NODE, FT_ELEM, FT_CURVE, etc. All data types other than loads or constraints nOnType = nType.\n
        **Return Code:** True\n
        :type nDesiredLayerID: int

        :type nEntitySetID: int

        :type nDataType: int

        :type nInSetID: int

        :type nOnType: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def ResetNextLayerInfo(self) -> Any:
        """
        **Description:**
            This method resets the data structure with the information and contents of a layer.
        **Remarks/Usage:**
            None.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class LoadETemp:
    CLSID: Any
    Active: Any
    Function: Any
    ID: Any
    LoadDefinitionID: Any
    SetID: Any
    color: Any
    expanded: Any
    gradient: Any
    layer: Any
    phase: Any
    temp: Any

    def AddArray(self, Count, doValues, doFunctions, elemID, Values, FunctionID) -> Any:
        """
        **Description:**
            This method creates multiple elemental temperatures. This method is obsolete and should be replaced by PutArray.
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the other parameters in the object - such as, color and setID, and any other types required for your loads. This method simply uses the data you specify here to overwrite specific values in the LoadETemp object, and create a new temperature for each entry in the arrays. This method puts data directly into the database, so there is no need to call Put after using this method.
        **Input:**
            **Count:** The number of temperatures to create, and the number of IDs in ElemID\n
            **doValues:** If True, then the Values array must contain load values to be used. If False, then whatever is specified in the current object is used and Values is ignored\n
            **doFunctions:** If True, then the FunctionID array must contain Function IDs to be used. If False, then whatever is specified in the current object is used and FunctionID is ignored.\n
            **elemID:** The Element IDs where temperatures will be created. One temperature is created on each ID.\n
            **Values:** Temperature Values. Refer to temp property.\n
            **FunctionID:** IDs of functions associated with each temperature. Specify 0 for constant values. Refer to function property.\n
        **Return Code:** True\n
        :type Count: int

        :type doValues: bool

        :type doFunctions: bool

        :type elemID: tuple[int]

        :type Values: tuple[float]

        :type FunctionID: tuple[int]

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetAllArray(self, Count, ExpandedGeomLoad, elemID, layer, color, LoadDefinitionID, Temperature, TempGradient,
                    FunctionID) -> Any:
        """
        **Description:**
            This method finds all nodal temperatures
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the setID parameter in the object.
        **Output:**
            **Count:** The number of temperatures, and the number of IDs in NodeID\n
            **elemID:** The IDs of the nodes found.\n
            **layer:** The IDs of the layers the loads are on.\n
            **color:** The IDs of the load color.\n
            **Temperature:** The nodal temperature.\n
            **TempGradient:** The ID of a function that defines time dependency of the temperature.\n
        **Return Code:** True\n
        :type Count: int

        :type elemID: tuple[int]

        :type layer: tuple[int]

        :type color: tuple[int]

        :type Temperature: tuple[float]

        :type TempGradient: tuple[int]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutAllArray(self, Count, ExpandedGeomLoad, elemID, layer, color, LoadDefinitionID, Temperature, TempGradient,
                    FunctionID) -> Any:
        """
        **Description:**
            This method creates multiple elemental temperatures
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the setID parameter in the object. For more information on how to create loads, see Section 2.8, "Working with Loads and Constraints".
        **Input:**
            **Count:** The number of temperatures to create, and the number of IDs in ElemID\n
            **elemID:** The IDs of the nodes found.\n
            **layer:** The IDs of the layers the loads are on.\n
            **color:** The IDs of the load color.\n
            **Temperature:** The elemental temperature.\n
            **FunctionID:** The ID of a function that defines time dependency of the temperature.\n
        **Return Code:** True\n
        :type Count: int

        :type elemID: tuple[int]

        :type layer: tuple[int]

        :type color: tuple[int]

        :type Temperature: tuple[float]

        :type FunctionID: tuple[int]

        """
        ...

    def PutArray(self, Count, doValues, doFunctions, elemID, Values, FunctionID) -> Any:
        """
        **Description:**
            This method creates multiple elemental temperatures
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the other parameters in the object - such as, color and setID, and any other types required for your loads. This method simply uses the data you specify here to overwrite specific values in the LoadETemp object, and create a new temperature for each entry in the arrays. This method puts data directly into the database, so there is no need to call Put after using this method. For more information on how to create loads, see Section 2.8, "Working with Loads and Constraints".
        **Input:**
            **Count:** The number of temperatures to create, and the number of IDs in ElemID\n
            **doValues:** If True, then the Values array must contain load values to be used. If False, then whatever is specified in the current object is used and Values is ignored\n
            **doFunctions:** If True, then the FunctionID array must contain Function IDs to be used. If False, then whatever is specified in the current object is used and FunctionID is ignored.\n
            **elemID:** The Element IDs where temperatures will be created. One temperature is created on each ID.\n
            **Values:** Temperature Values. Refer to temp property.\n
            **FunctionID:** IDs of functions associated with each temperature. Specify 0 for constant values. Refer to function property.\n
        **Return Code:** True\n
        :type Count: int

        :type doValues: bool

        :type doFunctions: bool

        :type elemID: tuple[int]

        :type Values: tuple[float]

        :type FunctionID: tuple[int]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class LoadGeom:
    CLSID: Any
    Absorptivity: Any
    AbsorptivityVsTemp: Any
    Active: Any
    CSys: Any
    CanBeShaded: Any
    CanShade: Any
    CavityNumber: Any
    ConvectionCoeff: Any
    CornerPressure: Any
    Emissivity: Any
    EmissivityFunc: Any
    EnclosureRadiation: Any
    FCDisableAdvection: Any
    FCDisableConvection: Any
    FaceNumber: Any
    FlowAreaFactor: Any
    FlowDiameter: Any
    FlowRate: Any
    FluidValue: Any
    ForcedConvection: Any
    HeatFlux: Any
    HeatGen: Any
    ID: Any
    LoadDefinitionID: Any
    LoadFunction: Any
    LoadValue: Any
    PeriodicDirection: Any
    PeriodicMaster: Any
    PhaseVsFreq: Any
    Pressure: Any
    SetID: Any
    TempVsTime: Any
    VectorFlux: Any
    ViewFactor: Any
    ViewFactorVsTime: Any
    XOn: Any
    YOn: Any
    ZOn: Any
    color: Any
    dirID: Any
    dirmode: Any
    expanded: Any
    geomID: Any
    geomTYPE: Any
    layer: Any
    midside: Any
    phase: Any
    subtype: Any
    temp: Any
    type: Any
    vDataSurface: Any
    vaddlID: Any
    vaddl_ptID: Any
    vareqn: Any
    varfunction: Any
    variation: Any
    varname: Any
    vdirbase: Any
    vdirection: Any
    vdof: Any
    vflag: Any
    vfluxdir: Any
    vfunction: Any
    vload: Any
    vvarlocate: Any
    vvarvalue: Any
    x: Any
    y: Any
    z: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def DataSurface(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Function(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetSearch(self, loadType, geomID) -> Any:
        """
        **Description:**
            This method searches for and retrieves an entity that is loading a specified geometric entity.
        **Remarks/Usage:**
            Since LoadGeom objects are not stored by a specified ID, but rather in sequential order, the normal Get method may not be useful if you are trying to find the loads on a specific curve or surface. The only way to do that would be to Get every load and check for the references that you want. This method does that for you. You specify the load type and point/curve/surface you want to search for, and it returns the loads on that entity. Be aware that this method does still search the entire set. If you are going to retrieve loads on a large number of geometry entities, it could be faster to retrieve them all using Get, and discard the ones you do not want.
        **Input:**
            **loadType:** Type of load being applied. For values, see Section 5.45.3, "LoadGeom Load Types". \n
            **geomID:** ID of geometry loaded. The loadType determines whether this should be a point, curve or surface ID.\n
        **Return Code:** True\n
        :type loadType: int

        :type geomID: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextOnEntity(self, geomTYPE, geomSET) -> Any:
        """
        **Description:**
            Gets the next load that is defined on a selected set of geometric entities.
        **Remarks/Usage:**
            Before calling this method, the setID property of the object must be defined to search the desired Load Set. Also, you should call Reset before the first call to this method so it will retrieve the first available load.
        **Input:**
            **geomTYPE:** The type of geometry where the loads are defined. Must be Point, Curve, or Surface. For entity information, see Section 3.3.6, "Entity Types".\n
        **Return Code:** True\n
        :type geomTYPE: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetDataSurface(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetFunction(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetaddlID(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setaddl_ptID(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setdirbase(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setdirection(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setdof(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setflag(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setfluxdir(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setload(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setvarlocate(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def Setvarvalue(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def addlID(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def addl_ptID(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def dirbase(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def direction(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def dof(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def flag(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def fluxdir(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def load(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def varlocate(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def varvalue(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class LoadMesh:
    CLSID: Any
    Absorptivity: Any
    AbsorptivityVsTemp: Any
    Active: Any
    CSys: Any
    CanBeShaded: Any
    CanShade: Any
    CavityNumber: Any
    ConvectionCoeff: Any
    CornerPressure: Any
    Emissivity: Any
    EmissivityFunc: Any
    EnclosureRadiation: Any
    FCDisableAdvection: Any
    FCDisableConvection: Any
    FaceNumber: Any
    FlowAreaFactor: Any
    FlowDiameter: Any
    FlowRate: Any
    FluidValue: Any
    ForcedConvection: Any
    HeatFlux: Any
    HeatGen: Any
    ID: Any
    LoadDefinitionID: Any
    LoadFunction: Any
    LoadValue: Any
    PeriodicDirection: Any
    PeriodicMaster: Any
    PhaseVsFreq: Any
    Pressure: Any
    SetID: Any
    TempVsTime: Any
    VectorFlux: Any
    VectorPressure: Any
    ViewFactor: Any
    ViewFactorVsTime: Any
    XOn: Any
    YOn: Any
    ZOn: Any
    color: Any
    expanded: Any
    layer: Any
    meshID: Any
    phase: Any
    subtype: Any
    temp: Any
    type: Any
    vPressureDirection: Any
    vaddlID: Any
    vdof: Any
    vflag: Any
    vfluxdir: Any
    vfunction: Any
    vload: Any
    x: Any
    y: Any
    z: Any

    def Add(self, SetID, loadType, nCSys, dof, Values, FunctionID) -> Any:
        """
        **Description:**
            This method creates multiple nodal or elemental loads
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the other parameters in the object - such as, color, setID, and any other types required for your loads. This method simply uses the data you specify here to overwrite specific values in the loadmesh object, and create a new load for each entry in the set.
        **Input:**
            **SetID:** The ID of a Set object that contains the nodes or elements where loads will be applied. Alternatively, if you specify a negative value, this is simply the ID of the single node or element to load.\n
            **loadType:** The type of load being defined. Refer to type property.\n
            **nCSys:** The ID of the Coordinate System where load values are being defined.\n
            **dof:** Degree of Freedom flags for forces (True=On, False=Off). For Pressures and other face-based loads the first DOF for each element is the faceID (1-6) for the load. Refer to dof property.\n
            **Values:** Load Values, 5 per load. Refer to load property.\n
            **FunctionID:** IDs of functions associated with each load value. Specify 0 for constant values. 5 per load. Refer to function property.\n
        **Return Code:** True\n
        :type SetID: int

        :type loadType: int

        :type nCSys: int

        :type dof: tuple[int]

        :type Values: tuple[float]

        :type FunctionID: tuple[int]

        """
        ...

    def AddArray(self, Count, doDOF, doValues, doFunctions, NodeElemID, dof, Values, FunctionID) -> Any:
        """
        **Description:**
            This method creates multiple nodal or elemental loads. This method is obsolete and should be replaced by PutArray.
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the other parameters in the object - such as, load type, color, setID, and any other types required for your loads. This method simply uses the data you specify here to overwrite specific values in the loadmesh object, and create a new load for each entry in the arrays.
        **Input:**
            **Count:** The number of loads to create, and the number of IDs in NodeElemID\n
            **doDOF:** If True, then the DOF array must contain the DOF flags/Face IDs to be used. If False, then whatever is specified in the current object is used, and DOF is ignored.\n
            **doValues:** If True, then the Values array must contain load values to be used. If False, then whatever is specified in the current object is used and Values is ignored\n
            **doFunctions:** If True, then the FunctionID array must contain Function IDs to be used. If False, then whatever is specified in the current object is used and FunctionID is ignored.\n
            **NodeElemID:** The Node or Element IDs where loads will be created. One load is created on each ID.\n
            **dof:** Degree of Freedom flags for forces (True=On, False=Off). For Pressures and other face-based loads the first DOF for each element is the faceID (1-6) for the load. There are three entries per load. Refer to dof property.\n
            **Values:** Load Values, 5 per load. Refer to load property.\n
            **FunctionID:** IDs of functions associated with each load value. Specify 0 for constant values. 5 per load. Refer to function property.\n
        **Return Code:** True\n
        :type Count: int

        :type doDOF: bool

        :type doValues: bool

        :type doFunctions: bool

        :type NodeElemID: tuple[int]

        :type dof: tuple[int]

        :type Values: tuple[float]

        :type FunctionID: tuple[int]

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Function(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetAllArray(self, Count, ExpandedGeomLoad, loadType, loadSubType, NodeElemID, layer, color, LoadDefinitionID,
                    nCSysID, DOFFace, Values, FunctionID, NodeElemAddlID, flag, direction) -> Any:
        """
        **Description:**
            This method fills information about all of the LoadMesh objects in a Load Set.
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the setID parameter in the object.
        **Output:**
            **Count:** The number of loads to create, and the number of IDs in NodeElemID\n
            **loadType:** The type of load being defined. Refer to the load type table for values. For all load types, see Section 5.46.3, "LoadMesh Load Types".\n
            **loadSubType:** An additional flag specifying more information about the type of load. Used for nonlinear transient force loads.\n
            **NodeElemID:** The IDs of the nodes or elements found.\n
            **layer:** The IDs of the layers the loads are on.\n
            **color:** The IDs of the load color.\n
            **nCSysID:** The ID of the coordinate system used to define the load. Regardless of this value, all loads that are vector-based are stored in global rectangular coordinates.\n
            **DOFFace:** Array containing the face number (0) for face based loads, or flags indicating which components are enabled for vector loads. Also, dof[0] is used to specify the Distributed Load Direction for a Distributed Load on a line element (type = 41, eLineLoad): 1 = Element X, 2 = Element Y, 3 = Element Z, 4 = Global X, 5 = Global Y, 6 = Global Z\n
            **Values:** The load values. The location of specific values varies for each type of load, but generally follows the order of the values in the load creation dialog box.\n
            **NodeElemAddlID:** [0..count-1]\n
            **flag:** Flags specifying various load options.\n
        **Return Code:** True\n
        :type Count: int

        :type loadType: tuple[int]

        :type loadSubType: tuple[int]

        :type NodeElemID: tuple[int]

        :type layer: tuple[int]

        :type color: tuple[int]

        :type nCSysID: tuple[int]

        :type DOFFace: tuple[int]

        :type Values: tuple[float]

        :type NodeElemAddlID: int

        :type flag: tuple[bool]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetSearch(self, loadType, meshID, faceID) -> Any:
        """
        **Description:**
            This method searches for and retrieves an entity that is loading a specified node or element entity and loads the LoadMesh Object with that entity.
        **Remarks/Usage:**
            Since LoadMesh objects are not stored by a specified ID, but rather in sequential order, the normal Get method may not be useful if you are trying to find the loads on a specific node or element. The only way to do that would be to Get every load and check for the references that you want. This method does that for you. You specify the load type and node/element you want to search for, and it returns the loads on that entity. Be aware that this method does still search the entire set. If you are going to retrieve loads on a large number of mesh entities, it could be faster to retrieve them all using Get, and discard the ones you do not want.
        **Input:**
            **loadType:** Type of load being applied. For values, see Section 5.46.3, "LoadMesh Load Types".\n
            **meshID:** ID of node or element being loaded. The loadTypedetermines whether this should be a node ID or an element ID.\n
            **faceID:** For certain face-based elemental loads (pressure, flux, etc.) you must also specify the element face that is being loaded. For all other load types, this option is ignored.\n
        **Return Code:** True\n
        :type loadType: int

        :type meshID: int

        :type faceID: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextOnEntity(self, entityTYPE, meshSET) -> Any:
        """
        **Description:**
            Gets the next load that is defined on a selected set of nodes or elements
        **Remarks/Usage:**
            Before calling this method, the setID property of the object must be defined to search the desired Load Set. Also, you should call Reset before the first call to this method so it will retrieve the first available load.
        **Input:**
            **entityTYPE:** The type of geometry where the loads are defined. Must be Node or Element. For entity information, see Section 3.3.6, "Entity Types".\n
        **Return Code:** True\n
        :type entityTYPE: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def PressureDirection(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutAllArray(self, bDeleteAllExistingLoads, Count, ExpandedGeomLoad, loadType, loadSubType, NodeElemID, layer,
                    color, LoadDefinitionID, nCSysID, DOFFace, Values, FunctionID, NodeElemAddlID, flag,
                    direction) -> Any:
        """
        **Description:**
            This method creates multiple nodal or elemental loads
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the setID parameter in the object. For more information on how to create loads, see Section 2.8, "Working with Loads and Constraints".
        **Input:**
            **Count:** The number of loads to create, and the number of IDs in NodeElemID\n
            **loadType:** The type of load being defined. Refer to the load type table for values. For all load types, see Section 5.46.3, "LoadMesh Load Types".\n
            **loadSubType:** An additional flag specifying more information about the type of load. Used for nonlinear transient force loads.\n
            **NodeElemID:** The IDs of the nodes or elements found.\n
            **layer:** The IDs of the layers the loads are on.\n
            **color:** The IDs of the load color.\n
            **nCSysID:** The ID of the coordinate system used to define the load. Regardless of this value, all loads that are vector-based are stored in global rectangular coordinates.\n
            **DOFFace:** Array containing the face number (0) for face based loads, or flags indicating which components are enabled for vector loads. Also, dof[0] is used to specify the Distributed Load Direction for a Distributed Load on a line element (type = 41, eLineLoad): 1 = Element X, 2 = Element Y, 3 = Element Z, 4 = Global X, 5 = Global Y, 6 = Global Z\n
            **Values:** The load values. The location of specific values varies for each type of load, but generally follows the order of the values in the load creation dialog box.\n
            **flag:** Flags specifying various load options.\n
        **Return Code:** True\n
        :type Count: int

        :type loadType: tuple[int]

        :type loadSubType: tuple[int]

        :type NodeElemID: tuple[int]

        :type layer: tuple[int]

        :type color: tuple[int]

        :type nCSysID: tuple[int]

        :type DOFFace: tuple[int]

        :type Values: tuple[float]

        :type flag: tuple[bool]

        """
        ...

    def PutArray(self, Count, doDOF, doValues, doFunctions, NodeElemID, dof, Values, FunctionID) -> Any:
        """
        **Description:**
            This method creates multiple nodal or elemental loads
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the other parameters in the object - such as, load type, color, setID, and any other types required for your loads. This method simply uses the data you specify here to overwrite specific values in the loadmesh object, and create a new load for each entry in the arrays. For more information on how to create loads, see Section 2.8, "Working with Loads and Constraints".
        **Input:**
            **Count:** The number of loads to create, and the number of IDs in NodeElemID\n
            **NodeElemID:** If True, then the DOF array must contain the DOF flags/Face IDs to be used. If False, then whatever is specified in the current object is used, and DOF is ignored.\n
            **dof:** If True, then the Values array must contain load values to be used. If False, then whatever is specified in the current object is used and Values is ignored\n
            **doValues:** If True, then the FunctionID array must contain Function IDs to be used. If False, then whatever is specified in the current object is used and FunctionID is ignored.\n
            **doFunctions:** The Node or Element IDs where loads will be created. One load is created on each ID.\n
            **NodeElemID:** Degree of Freedom flags for forces (True=On, False=Off). For Pressures and other face-based loads the first DOF for each element is the faceID (1-6) for the load. There are three entries per load. Refer to dof property.\n
            **dof:** Load Values, 5 per load. Refer to load property.\n
            **Values:** IDs of functions associated with each load value. Specify 0 for constant values. 5 per load. Refer to function property.\n
        **Return Code:** True\n
        :type Count: int

        :type NodeElemID: bool

        :type dof: bool

        :type doValues: bool

        :type doFunctions: tuple[int]

        :type NodeElemID: tuple[int]

        :type dof: tuple[float]

        :type Values: tuple[int]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetFunction(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPressureDirection(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetaddlID(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setdof(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setflag(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setfluxdir(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setload(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def addlID(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def dof(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def flag(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def fluxdir(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def load(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class LoadNTemp:
    CLSID: Any
    Active: Any
    Function: Any
    ID: Any
    LoadDefinitionID: Any
    SetID: Any
    color: Any
    expanded: Any
    layer: Any
    phase: Any
    temp: Any

    def AddArray(self, Count, doValues, doFunctions, NodeID, Values, FunctionID) -> Any:
        """
        **Description:**
            This method creates multiple nodal temperatures. This method is obsolete and should be replaced by PutArray.
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the other parameters in the object - such as, color and setID, and any other types required for your loads. This method simply uses the data you specify here to overwrite specific values in the LoadNTemp object, and create a new temperature for each entry in the arrays. This method puts data directly into the database, so there is no need to call Put after using this method.
        **Input:**
            **Count:** The number of temperatures to create, and the number of IDs in NodeID\n
            **doValues:** If True, then the Values array must contain load values to be used. If False, then whatever is specified in the current object is used and Values is ignored\n
            **doFunctions:** If True, then the FunctionID array must contain Function IDs to be used. If False, then whatever is specified in the current object is used and FunctionID is ignored.\n
            **NodeID:** The Node IDs where temperatures will be created. One temperature is created on each ID.\n
            **Values:** Temperature Values. Refer to temp property.\n
            **FunctionID:** IDs of functions associated with each temperature. Specify 0 for constant values. Refer to function property.\n
        **Return Code:** True\n
        :type Count: int

        :type doValues: bool

        :type doFunctions: bool

        :type NodeID: tuple[int]

        :type Values: tuple[float]

        :type FunctionID: tuple[int]

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetAllArray(self, Count, ExpandedGeomLoad, NodeID, layer, color, LoadDefinitionID, Temperature,
                    FunctionID) -> Any:
        """
        **Description:**
            This method finds all nodal temperatures
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the setID parameter in the object.
        **Output:**
            **Count:** The number of temperatures, and the number of IDs in NodeID\n
            **NodeID:** The IDs of the nodes found.\n
            **layer:** The IDs of the layers the loads are on.\n
            **color:** The IDs of the load color.\n
            **Temperature:** The nodal temperature.\n
            **FunctionID:** The ID of a function that defines time dependency of the temperature.\n
        **Return Code:** True\n
        :type Count: int

        :type NodeID: tuple[int]

        :type layer: tuple[int]

        :type color: tuple[int]

        :type Temperature: tuple[float]

        :type FunctionID: tuple[int]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutAllArray(self, Count, ExpandedGeomLoad, NodeID, layer, color, LoadDefinitionID, Temperature,
                    FunctionID) -> Any:
        """
        **Description:**
            This method creates multiple nodal temperatures
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the setID parameter in the object. For more information on how to create loads, see Section 2.8, "Working with Loads and Constraints".
        **Input:**
            **Count:** The number of temperatures to create, and the number of IDs in NodeID\n
            **NodeID:** The IDs of the nodes found.\n
            **layer:** The IDs of the layers the loads are on.\n
            **color:** The IDs of the load color.\n
            **LoadDefinitionID:** [0..count-1]\n
            **Temperature:** The nodal temperature.\n
            **FunctionID:** The ID of a function that defines time dependency of the temperature.\n
        **Return Code:** True\n
        :type Count: int

        :type NodeID: tuple[int]

        :type layer: tuple[int]

        :type color: tuple[int]

        :type LoadDefinitionID: int

        :type Temperature: tuple[float]

        :type FunctionID: tuple[int]

        """
        ...

    def PutArray(self, Count, doValues, doFunctions, NodeID, Values, FunctionID) -> Any:
        """
        **Description:**
            This method creates multiple nodal temperatures
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the other parameters in the object - such as, color and setID, and any other types required for your loads. This method simply uses the data you specify here to overwrite specific values in the LoadNTemp object, and create a new temperature for each entry in the arrays. This method puts data directly into the database, so there is no need to call Put after using this method. For more information on how to create loads, see Section 2.8, "Working with Loads and Constraints".
        **Input:**
            **Count:** The number of temperatures to create, and the number of IDs in NodeID\n
            **doValues:** If True, then the Values array must contain load values to be used. If False, then whatever is specified in the current object is used and Values is ignored\n
            **doFunctions:** If True, then the FunctionID array must contain Function IDs to be used. If False, then whatever is specified in the current object is used and FunctionID is ignored.\n
            **NodeID:** The Node IDs where temperatures will be created. One temperature is created on each ID.\n
            **Values:** Temperature Values. Refer to temp property.\n
            **FunctionID:** IDs of functions associated with each temperature. Specify 0 for constant values. Refer to function property.\n
        **Return Code:** True\n
        :type Count: int

        :type doValues: bool

        :type doFunctions: bool

        :type NodeID: tuple[int]

        :type Values: tuple[float]

        :type FunctionID: tuple[int]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class LoadSet:
    CLSID: Any
    Active: Any
    BodyAccelOn: Any
    BodyDefTemp: Any
    BodyDefTempOn: Any
    BodyLoadCSys: Any
    BodyRefTemp: Any
    BodyRefTempOn: Any
    BodyVaryingAccelAxis: Any
    BodyVaryingAccelFunction: Any
    BodyVaryingAccelOn: Any
    BodyVelocityOn: Any
    CombinedScaleFactor: Any
    DYNAddlFreqLogInterp: Any
    DYNAddlFreqMax: Any
    DYNAddlFreqMin: Any
    DYNAddlFreqNumFreq: Any
    DYNAddlFreqSpread: Any
    DYNAddlFreqType: Any
    DYNDampingTable: Any
    DYNDataRecovery: Any
    DYNElemFreqDamp: Any
    DYNFrequencyTable: Any
    DYNMassFormulation: Any
    DYNModalMethod: Any
    DYNOn: Any
    DYNPSDInterp: Any
    DYNPSDType: Any
    DYNRandomPSD: Any
    DYNResponseMaxFreq: Any
    DYNResponseMinFreq: Any
    DYNResponseModes: Any
    DYNSolFreqLogInterp: Any
    DYNSolFreqMax: Any
    DYNSolFreqMin: Any
    DYNSolFreqNumFreq: Any
    DYNSolFreqSpread: Any
    DYNSolFreqType: Any
    DYNStructDamp: Any
    DYNSystemFreqDamp: Any
    DYNTransOutputInterval: Any
    DYNTransTimePerStep: Any
    DYNTransTimeSteps: Any
    DYNType: Any
    FCAlternateForm: Any
    FCConstantCoeff: Any
    FCExcludeConvective: Any
    FCFluidConductivity: Any
    FCFluidConductivityFunc: Any
    FCFluidDensity: Any
    FCFluidDensityFunc: Any
    FCFluidHeatCapacity: Any
    FCFluidHeatCapacityFunc: Any
    FCFluidViscosity: Any
    FCFluidViscosityFunc: Any
    FCPrandtlIn: Any
    FCPrandtlOut: Any
    FCReynoldsExp: Any
    FreeConvAlternateForm: Any
    FreeConvExponent: Any
    ID: Any
    IsCombination: Any
    IsSequence: Any
    NLArcConstraintType: Any
    NLArcDesiredIter: Any
    NLArcLengthMethod: Any
    NLArcMaxAdjust: Any
    NLArcMaxIncrement: Any
    NLArcMinAdjust: Any
    NLArcScaleConstLoad: Any
    NLIncrements: Any
    NLIntermediateOutput: Any
    NLLineSearchTolerance: Any
    NLMaxAdjusted: Any
    NLMaxBisection: Any
    NLMaxDivergeCond: Any
    NLMaxIterPerStep: Any
    NLMaxLineSearch: Any
    NLMaxRotation: Any
    NLNewtRaphBisection: Any
    NLNewtRaphLineSearch: Any
    NLNewtRaphQuasiNewton: Any
    NLOn: Any
    NLOutputInterval: Any
    NLQuasiNewtonVec: Any
    NLSolutionOverride: Any
    NLStiffnessIter: Any
    NLStiffnessMethod: Any
    NLStressFraction: Any
    NLTimeIncrement: Any
    NLTransBoundsMaintain: Any
    NLTransDominantSteps: Any
    NLTransStabilityTol: Any
    NLTransStepSkipFactor: Any
    RadViewFactorZTOL: Any
    RadiationAmbientElem: Any
    SetID: Any
    StefanBoltzmann: Any
    TempOffset: Any
    bRadViewFactorZTOL: Any
    layer: Any
    title: Any
    vBodyAccel: Any
    vBodyAccelFunction: Any
    vBodyOrigin: Any
    vBodyVaryingAccel: Any
    vBodyVelocity: Any
    vBodyVelocityFunction: Any
    vNLConvergenceFlag: Any
    vNLConvergenceVal: Any

    def BodyAccel(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def BodyAccelFunction(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def BodyOrigin(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def BodyVaryingAccel(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def BodyVelocity(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def BodyVelocityFunction(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Compress(self) -> Any:
        """
        **Description:**
            This method compresses all of the geometric loads in a selected load set.
        **Remarks/Usage:**
            This method takes the current load set object (uses the ID), and compresses (deletes) any expanded loads. You are left with the unexpanded geometric loads.
        **Return Code:** True\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def ElementsAsSet(self, bExpandedGeomLoads, bNodeElemLoads, bTemperatures, nElemSetID, bClear) -> Any:
        """
        **Description:**
            This method adds the IDs of elements loaded in the Load Set currently loaded in the LoadSet Object to a specified Set. There are options to include elements which are loaded after geometric loads are expanded, elements which have non-temperature loads applied, and/or elements which have temperature loads applied.
        **Remarks/Usage:**
            If Temperature loads are applied as geometric loads and bTemperature is set to False, then those element IDs will NOT be added to the Set. If non-Temperature loads are applied as geometric loads and bNodeElemLoads is set to False, then those element IDs will NOT be added to the Set.
        **Input:**
            **bExpandedGeomLoads:** When True, the IDs of any elements which are loaded after geometric constraints are expanded will be added to the Set.\n
            **bNodeElemLoads:** When True, the IDs of any individual elements which have non-Temperature loads applied will be added to the Set. If bExpandedGeomLoads is True, then this also controls if element IDs which are loaded with non-Temperature loads after geometric loads have been expanded will be added to the Set.\n
            **bTemperatures:** When True, the IDs of any individual elements which have Temperature loads applied will be added to the Set. If bExpandedGeomLoads is True, then this also controls if element IDs which are loaded with Temperature loads after geometric loads have been expanded will be added to the Set.\n
            **nElemSetID:** ID of Set object to add element IDs\n
            **bClear:** When True, any IDs which are in the set are removed before adding the element IDs to the Set\n
        **Return Code:** False\n
        :type bExpandedGeomLoads: bool

        :type bNodeElemLoads: bool

        :type bTemperatures: bool

        :type nElemSetID: int

        :type bClear: bool

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Expand(self) -> Any:
        """
        **Description:**
            This method expands all of the geometric loads in a selected load set.
        **Remarks/Usage:**
            This method takes the current load set object (uses the ID), and expands all of the geometric loads in that set, so that they may be retrieved as normal mesh-based loads.
        **Return Code:** True\n
        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetCombination(self, dOverallScale, nCombo, dScale, nSetID) -> Any:
        """
        **Description:**
            This method returns the data for a Nastran LOAD Combination Set.
        **Remarks/Usage:**

        **Output:**
            **dOverallScale:** Overall Scale Factor for Nastran LOAD Combination.\n
            **nCombo:** Number of entries in the LOAD Combination.\n
            **dScale:** The Scale Factor for the load sets in the Combination.\n
            **nSetID:** The IDs of the load sets in the Nastran LOAD Combination.\n
        **Return Code:** True\n
        :type dOverallScale: float

        :type nCombo: int

        :type dScale: tuple[float]

        :type nSetID: tuple[int]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def NLConvergenceFlag(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NLConvergenceVal(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextLoad(self, pDispatch) -> Any:
        """
        **Description:**
            This method returns the next available load that matches the criteria established by ResetNextLoad
        **Remarks/Usage:**
            This method, coupled with ResetNextLoad provides an easy way to retrieve all loads from a Load Set.
        **Output:**
            **pDispatch:** The next load object. Depending on the options specified, this could be a LoadGeom, LoadMesh, LoadNTemp or LoadGeom object\n
        **Return Code:** True\n
        :type pDispatch: Any

        """
        ...

    def NextLoadDef(self, pDispatch) -> Any:
        """
        **Description:**
            This method returns the next available load definition that matches the criteria established by ResetNextLoadDef
        **Remarks/Usage:**
            This method, coupled with ResetNextLoadDef provides an easy way to retrieve all load definitions from a Load Set.
        **Output:**
            **pDispatch:** The next load definition object. This is always a LoadDefinition object.\n
        **Return Code:** True\n
        :type pDispatch: Any

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NodesAsSet(self, bExpandedGeomLoads, bNodeElemLoads, bTemperatures, nNodeSetID, bClear) -> Any:
        """
        **Description:**
            This method adds the IDs of nodes loaded in the Load Set currently loaded in the LoadSet Object to a specified Set. There are options to include nodes which are loaded after geometric loads are expanded, nodes which have non-temperature loads applied, and/or nodes which have temperature loads applied.
        **Remarks/Usage:**
            If Temperature loads are applied as geometric loads and bTemperature is set to False, then those node IDs will NOT be added to the Set. If non-Temperature loads are applied as geometric loads and bNodeElemLoads is set to False, then those node IDs will NOT be added to the Set.
        **Input:**
            **bExpandedGeomLoads:** When True, the IDs of any nodes which are loaded after geometric constraints are expanded will be added to the Set.\n
            **bNodeElemLoads:** When True, the IDs of any individual nodes which have non-Temperature loads applied will be added to the Set. If bExpandedGeomLoads is True, then this also controls if node IDs which are loaded with non-Temperature loads after geometric loads have been expanded will be added to the Set.\n
            **bTemperatures:** When True, the IDs of any individual nodes which have Temperature loads applied will be added to the Set. If bExpandedGeomLoads is True, then this also controls if node IDs which are loaded with Temperature loads after geometric loads have been expanded will be added to the Set.\n
            **nNodeSetID:** ID of Set object to add node IDs\n
            **bClear:** When True, any IDs which are in the set are removed before adding the node IDs to the Set\n
        **Return Code:** False\n
        :type bExpandedGeomLoads: bool

        :type bNodeElemLoads: bool

        :type bTemperatures: bool

        :type nNodeSetID: int

        :type bClear: bool

        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutCombination(self, dOverallScale, nCombo, dScale, nSetID) -> Any:
        """
        **Description:**
            This method sets the data in a Load Combination Set.
        **Remarks/Usage:**

        **Input:**
            **dOverallScale:** Overall Scale Factor for Nastran LOAD Combination.\n
            **nCombo:** Number of entries in the LOAD Combination.\n
            **dScale:** The Scale Factor for the load sets in the Combination.\n
            **nSetID:** The IDs of the load sets in the Nastran LOAD Combination.\n
        **Return Code:** True\n
        :type dOverallScale: float

        :type nCombo: int

        :type dScale: tuple[float]

        :type nSetID: tuple[int]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def ResetNextLoad(self, enDataType, bAllLoadTypes, enLoadType, bOtherLoadsOnly, bIncludeExpanded) -> Any:
        """
        **Description:**
            This method initializes all options prior to calling the NextLoad method below
        **Remarks/Usage:**
            This method is used prior to calling NextLoad to specify which loads will be retrieved. It also resets this object so that the next call to NextLoad will return the first load available in the object.
        **Input:**
            **enDataType:** The type of load entities to be retrieved. For entity information, see Section 3.3.6, "Entity Types". Can be FT_SURF_LOAD, FT_GEOM_LOAD (default), FT_NTHERM_LOAD, or FT_ETHERM_LOAD\n
            **bAllLoadTypes:** Used to limit the type of loads to be retrieved. If True, all selected loads will be returned. If False, only loads that match the type specified in enLoadType will be returned.\n
            **enLoadType:** The type of loads to return. Only used if bAllLoadTypes is False. Refer to the Load Types table in Section 3.3.7, "FEMAP Constants"for more information.\n
            **bOtherLoadsOnly:** If true, then only loads that are not part of a load definition will be retrieved. Otherwise all are available.\n
            **bIncludeExpanded:** If True, expanded geometric loads (if any) will be returned along with normal loads. Ignored if enDataType=FT_GEOM_LOAD.\n
        **Return Code:** True\n
        :type enDataType: int

        :type bAllLoadTypes: bool

        :type enLoadType: int

        :type bOtherLoadsOnly: bool

        :type bIncludeExpanded: bool

        """
        ...

    def ResetNextLoadDef(self, bAllDataTypes, enDataType, bAllLoadTypes, enLoadType) -> Any:
        """
        **Description:**
            This method initializes all options prior to calling the NextLoadDef method below
        **Remarks/Usage:**
            This method is used prior to calling NextLoadDef to specify which load definitions will be retrieved. It also resets this object so that the next call to NextLoadDef will return the first load definition available in the object.
        **Input:**
            **bAllDataTypes:** Used to limit the type of load definitions to be retrieved. If True, all selected load definitions will be returned. If False, only load definitions that contain loads of the type specified in enDataType will be returned.\n
            **enDataType:** The type of load entities to be retrieved. For entity information, see Section 3.3.6, "Entity Types". Can be FT_SURF_LOAD, FT_GEOM_LOAD (default), FT_NTHERM_LOAD, or FT_ETHERM_LOAD\n
            **bAllLoadTypes:** Used to limit the type of load definitions to be retrieved. If True, all selected load definitions will be returned. If False, only load definitions that contain loads of the type specified in enLoadType will be returned.\n
            **enLoadType:** The type of loads to return. Only used if bAllLoadTypes is False. Refer to the Load Types table in Section 3.3.7, "FEMAP Constants"for more information.\n
        **Return Code:** True\n
        :type bAllDataTypes: bool

        :type enDataType: int

        :type bAllLoadTypes: bool

        :type enLoadType: int

        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetBodyAccel(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetBodyAccelFunction(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetBodyOrigin(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetBodyVaryingAccel(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetBodyVelocity(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetBodyVelocityFunction(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNLConvergenceFlag(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNLConvergenceVal(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...


class Optim:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    cycles: Any
    goal: Any
    limit: Any
    respID: Any
    respMax: Any
    respMin: Any
    respType: Any
    type: Any
    vary: Any
    varyDelta: Any
    varyExtraID: Any
    varyID: Any
    varyMax: Any
    varyMin: Any
    varyPct: Any
    varyType: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class Output:
    CLSID: Any


class OutputSet:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    analysis: Any
    combination_type: Any
    nas_case: Any
    nas_revision: Any
    notes: Any
    program: Any
    study: Any
    title: Any
    value: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def ExpandCombination(self, bSetTitles) -> Any:
        """
        **Description:**
            This method can be used in conjunction with SetCombination to create a new processed output set in the next available output set ID. Also, it is used update the values in a Create All Immediately type of processed output set after using SetCombination.
        **Remarks/Usage:**
            This method deletes all existing output in an existing Create All Immediately processed output set, then recreates all of the output. Also, after using this method, the output data for the expanded output set will be stored in the database.
        **Input:**
            **bSetTitles:** When True, an descriptive title based on the process type and output sets used in the combination will be applied to the new processed output set. When False, a default title will be created. If modifying an existing output set, this option does nothing, as the title will not be changed.\n
        **Return Code:** False\n
        :type bSetTitles: bool

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def OutputVectorsV2(self, nVectorSetID) -> Any:
        """
        **Description:**
            This method replaces OutputVectors. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above". This method fills a Set object with the IDs of all Output vectors that are in the currently selected Output Set
        **Remarks/Usage:**
            You must set the ID property of the current object to match the Output Set where you want to retrieve the vectors - this happens automatically if you Get the Output Set object.
        **Input:**
            **nVectorSetID:** The ID of a Set Object that will receive the IDs of the Output vectors\n
        **Return Code:** False\n
        :type nVectorSetID: int

        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetCombination(self, enProcessType, nNumFactors, vnSetIDArray, vdFactorArray) -> Any:
        """
        **Description:**
            This method sets the output processing operation, output set IDs, and scale factors to create a new processed output set or for an existing output set currently in the OutputSet object
        **Remarks/Usage:**
            If using this method to create a new processed output set, call ExpandCombination immediately after this method to create a new output set (i.e. a Put is not needed).
        **Input:**
            **nNumFactors:** Number of output set and scale factor pairs in the combination\n
            **vnSetIDArray:** The IDs of the output sets used in the combination.\n
        **Return Code:** False\n
        :type nNumFactors: int

        :type vnSetIDArray: tuple[int]

        """
        ...

    def SetComplexOptions(self, bExpandComplex, dComplexPhase) -> Any:
        """
        **Description:**
            Used to control the output returned when using the OutputVectors method. This method sets a phase angle to use for any complex output (magnitude, phase, real or imaginary) which will cause the output to be returned in OutputVectors as the expanded complex magnitude at the specified phase angle.
        **Remarks/Usage:**
            This method MUST be called before the Get call in order for the expanded complex output to be loaded into the output set object
        **Input:**
            **bExpandComplex:** When True, complex expansion will occur\n
            **dComplexPhase:** Value of phase angle to use for complex expansion\n
        **Return Code:** False\n
        :type bExpandComplex: bool

        :type dComplexPhase: float

        """
        ...

    def SetStudyCombination(self, enProcessType, nStudyID) -> Any:
        """
        **Description:**
            This method sets the output processing operation for an analysis study
        **Remarks/Usage:**

        **Input:**
            **nStudyID:** ID of Analysis Study\n
        **Return Code:** False\n
        :type nStudyID: int

        """
        ...

    def VectorV2(self, entID) -> Any:
        """
        **Description:**
            This method replaces Vector. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above". This method creates and returns an Output object that is loaded with the data for a specific output vector.
        **Remarks/Usage:**
            The current OutputSet must be loaded with the Set data from the set where you want to retrieve the vector prior to calling this method. The OutputSet ID property is used to define the set where the vector is retrieved.
        **Return Code:** False\n
        """
        ...


class Point:
    CLSID: Any
    Active: Any
    Address: Any
    Engine: Any
    ID: Any
    InCombinedCurve: Any
    MeshSize: Any
    ScaleFactor: Any
    SetID: Any
    attrPID: Any
    color: Any
    defCSys: Any
    layer: Any
    type: Any
    x: Any
    xyz: Any
    y: Any
    z: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Curves(self, nCombinedMode, numCurves, curveID) -> Any:
        """
        **Description:**
            This method returns the curves that are attached to this point
        **Remarks/Usage:**
            Only points that are on Solids/Sheet Solids can be used with this method.
        **Input:**
            **nCombinedMode:** 0=List contains the basic curves that are adjacent to the point, 1=Any curves that are adjacent that are in a Combined Curve are replaced by the ID of the Combined Curve, 2=List contains both the underlying and combined curves.\n
        **Output:**
            **numCurves:** The number of curves in the returned array\n
            **curveID:** The IDs of the curves.\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type numCurves: int

        :type curveID: tuple[int]

        """
        ...

    def CurvesAsSet(self, nCombinedMode, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns the curves that are attached to this point in a Set Object
        **Remarks/Usage:**
            Similar to Curves, except that the attached curves are returned in a Set Object instead of an array. Only points that are on Solids/Sheet Solids can be used with this method.
        **Input:**
            **nCombinedMode:** 0=List contains the basic curves that are adjacent to the point, 1=Any curves that are adjacent that are in a Combined Curve are replaced by the ID of the Combined Curve, 2=List contains both the underlying and combined curves.\n
            **nSetID:** ID of the Set Object to receive the Curve IDs\n
            **bClear:** If True, the Set is cleared before loading the curves\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type nSetID: int

        :type bClear: bool

        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetAllArray(self, SetID, numPoint, entID, Exist, xyz, layer, color, ptType, defCSys) -> Any:
        """
        **Description:**
            This method retrieves arrays of values for a set of points, including if a point exists in the database
        **Remarks/Usage:**
            This method is the fastest way to retrieve information about a large number of points. If a retrieved point ID does not exist, then all of the values for that point ID will be 0.
        **Input:**
            **SetID:** ID of the set that contains the point IDs to retrieve. If 0, retrieve all points in the model.\n
        **Output:**
            **numPoint:** The number of points for which data is being returned.\n
            **entID:** Each entry is the ID of the associated point.\n
            **Exist:** Point existence, True=Point exists, False=Point does not exist\n
            **xyz:** The coordinates of the point. There are 3 entries, x, y, z for each point.\n
            **layer:** The ID of the layer for the point.\n
            **color:** The color of the point.\n
            **ptType:** The type of the point.\n
            **defCSys:** The definition coordinate system of the point.\n
        **Return Code:** True\n
        :type SetID: int

        :type numPoint: int

        :type entID: tuple[int]

        :type Exist: tuple[bool]

        :type xyz: tuple[float]

        :type layer: tuple[int]

        :type color: tuple[int]

        :type ptType: tuple[int]

        :type defCSys: tuple[int]

        """
        ...

    def GetClosest(self, vXYZ) -> Any:
        """
        **Description:**
            This method finds the Point closest to the desired location and loads it into the current object
        **Remarks/Usage:**
            None
        **Input:**
            **vXYZ:** The coordinates of the location of interest.\n
        **Return Code:** True\n
        :type vXYZ: tuple[float]

        """
        ...

    def GetCoordArray(self, SetID, numPoint, entID, Exist, xyz) -> Any:
        """
        **Description:**
            This method retrieves arrays of coordinates for a set of Points
        **Remarks/Usage:**
            This is a simpler form of GetAllArray, if you simply need the point coordinates. If a retrieved point ID does not exist, then all of the values for that point ID will be 0.
        **Input:**
            **SetID:** ID of the set that contains the point IDs to retrieve. If 0, retrieve all points in the model\n
        **Output:**
            **numPoint:** The number of points for which data is being returned.\n
            **entID:** Each entry is the ID of the associated point\n
            **Exist:** Point existence, True=Point exists, False=Point does not exist\n
            **xyz:** The coordinates of the point. There are 3 entries, x, y, z for each point.\n
        **Return Code:** True\n
        :type SetID: int

        :type numPoint: int

        :type entID: tuple[int]

        :type Exist: tuple[bool]

        :type xyz: tuple[float]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def Nodes(self, numNodes, NodeID) -> Any:
        """
        **Description:**
            This method returns the nodes that are attached to this point
        **Remarks/Usage:**
            None
        **Output:**
            **numNodes:** The number of nodes returned.\n
            **NodeID:** The IDs of the selected nodes which are attached to the point.\n
        **Return Code:** True\n
        :type numNodes: int

        :type NodeID: tuple[int]

        """
        ...

    def NodesAsSet(self, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns the nodes that are attached to this point in a Set Object
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** The ID of the Set Object which receives the Node IDs.\n
            **bClear:** If True, the Set is cleared before loading the Node IDs.\n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutAllArray(self, numPoint, entID, xyz, layer, color, ndType, defCSys) -> Any:
        """
        **Description:**
            This method stores multiple point entities with the specified data.\n
        **Remarks/Usage:**
            This is the fastest Put method if you have a large number of points to create. All data can be accumulated in arrays and transferred is one call.\n
        **Input:**
            **numPoint:** The number of points to create.\n
            **entID:** Each entry is the ID of the point to create\n
            **xyz:** The coordinates of the point. There are 3 entries, x, y, z for each point\n
            **layer:** The ID of the layer for the point.\n
            **color:** The color of the point\n
            **ndType:** The type of the point\n
            **defCSys:** The definition coordinate system of the point\n
        **Return Code:** True\n
        **Example**
            point = app.fePoint\n
            point.PutAllArray(1, (1, ), (0, 0, 0), (1, ), (32, ), (0, ), (1, ))

        :type numPoint: int
        :type entID: tuple[int]
        :type xyz: tuple[float]
        :type layer: tuple[int]
        :type color: tuple[int]
        :type ndType: tuple[int]
        :type defCSys: tuple[int]
        """
        ...

    def PutCoordArray(self, numPoint, entID, xyz) -> Any:
        """
        :type numPoint: Any
        :type entID: Any
        :type xyz: Any
        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
            **libFILE:** Use zLibraryFile enumeration. Alternatively, enter value for Type of library: 0=Open Dialog Box, 1=Personal, 2=Shared, 3=Femap Standard Libraries\n
        **Return Code:** True\n
        :type libINDEX: int

        :type libFILE: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def Solid(self, pnSolidID) -> Any:
        """
        **Description:**
            This method returns the ID of the Solid that contains the current point
        **Remarks/Usage:**
            This method will only work with a point that is defined on a Solid.
        **Output:**
            **pnSolidID:** The ID of the Solid that references the current Point\n
        **Return Code:** True\n
        :type pnSolidID: int

        """
        ...

    def SurfacesAsSet(self, nCombinedMode, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns the surfaces that are attached to this point in a Set Object
        **Remarks/Usage:**
            Only points that are on Solids/Sheet Solids can be used with this method.
        **Input:**
            **nCombinedMode:** 0=List contains the basic surfaces that are adjacent to the curve, 1=Any surfaces that are adjacent that are in a Combined Surface are replaced by the ID of the Combined Surface, 2=List contains both the underlying and combined surfaces.\n
            **nSetID:** ID of the Set Object to receive the Surface IDs\n
            **bClear:** If True, the Set is cleared before loading the surfaces\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type nSetID: int

        :type bClear: bool

        """
        ...


class Report:
    CLSID: Any
    Active: Any
    CenterHeader1: Any
    CenterHeader2: Any
    ColumnHeader: Any
    Data1: Any
    Data2: Any
    Data3: Any
    Data4: Any
    DataType: Any
    DbSpHeader1: Any
    DbSpHeader2: Any
    Header1: Any
    Header2: Any
    ID: Any
    SetID: Any
    title: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class Solid:
    CLSID: Any
    Active: Any
    Address: Any
    Engine: Any
    ID: Any
    ScaleFactor: Any
    SetID: Any
    VolColor: Any
    VolLayer: Any
    VolType: Any
    attrMaxMidsideAngle: Any
    attrMidsideOnGeometry: Any
    attrPID: Any
    attrTopology: Any
    color: Any
    layer: Any
    title: Any
    type: Any
    vVolReverse: Any
    vVolSurface: Any

    def BoundingBox(self, box) -> Any:
        """
        **Description:**
            This method returns the coordinates of a rectangular box the encloses this geometry.
        **Remarks/Usage:**
            This method always retrieves a box that is aligned with Global Rectangular coordinates, not an aligned box of minimum volume.
        **Output:**
            **box:** The dimensions of the bounding box, in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type box: tuple[float]

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Curves(self, nCombinedMode, numCurves, curveID) -> Any:
        """
        **Description:**
            This method returns a list of all of the curves used to define this solid/volume.
        **Remarks/Usage:**
            This method will work with any solid/volume, but it uses the data stored in the database, not any changes made in the current object (until it is Put to the database). The ID field must be properly specified.
        **Input:**
            **nCombinedMode:** 0=List contains the basic curves that are on the solid, 1=Any curves that are on the solid that are in a Combined Curve are replaced by the ID of the Combined Curve, 2=List contains both the underlying and combined curves.\n
        **Output:**
            **numCurves:** The number of curves in the curveID list.\n
            **curveID:** The IDs of the curves on the solid.\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type numCurves: int

        :type curveID: tuple[int]

        """
        ...

    def CurvesAsSet(self, nCombinedMode, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns all of the curves used to define this solid/volume in a Set object.
        **Remarks/Usage:**
            This method will work with any solid/volume, but it uses the data stored in the database, not any changes made in the current object (until it is Put to the database). The ID field must be properly specified.
        **Input:**
            **nCombinedMode:** 0=List contains the basic curves that are on the solid, 1=Any curves that are on the solid that are in a Combined Curve are replaced by the ID of the Combined Curve, 2=List contains both the underlying and combined curves.\n
            **nSetID:** The ID of the Set Object that will contain the IDs of the Curves\n
            **bClear:** If True, the Set is cleared prior to loading the Curve IDs\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type nSetID: int

        :type bClear: bool

        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, ID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **ID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type ID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Elements(self, numElems, elemID) -> Any:
        """
        **Description:**
            This method returns the elements that are attached to this solid
        **Remarks/Usage:**
            Only elements that have all of their nodes in the solid will be returned by this method. Elements that simply touch the solid at one edge or one node will not be returned.
        **Output:**
            **numElems:** The number of elements returned.\n
            **elemID:** The IDs of the selected elements which are attached to the solid.\n
        **Return Code:** True\n
        :type numElems: int

        :type elemID: tuple[int]

        """
        ...

    def ElementsAsSet(self, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns the elements that are attached to this solid in a Set
        **Remarks/Usage:**
            Only elements that have all of their nodes in the solid will be returned by this method. Elements that simply touch the solid at one edge or one node will not be returned.
        **Input:**
            **nSetID:** The ID of the Set Object that will contain the IDs of the Elements\n
            **bClear:** If True, the Set is cleared prior to loading the Element IDs\n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def ElementsAsSet2(self, bInSolid, bOnSurfaces, bOnCurves, bOnPoints, nSetID, bClear) -> Any:
        """
        :type bInSolid: Any
        :type bOnSurfaces: Any
        :type bOnCurves: Any
        :type bOnPoints: Any
        :type nSetID: Any
        :type bClear: Any
        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Export(self, fName) -> Any:
        """
        **Description:**
            This function writes the current solid to an export (SAT or X_T) file.
        **Remarks/Usage:**
            This method will only work with solids. Furthermore, it uses the data stored in the database, not any changes made in the current object (until it is Put to the database). The ID field must be properly specified.
        **Input:**
            **fName:** The name of the file to create.\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def Facets(self, numFacets, xyzFacet) -> Any:
        """
        **Description:**
            This method returns the triangular facets used for display of solids.
        **Remarks/Usage:**
            This method will only work with solid faces that have facetting information. The surface information must be in the database. Only the ID from the current object is used.
        **Output:**
            **numFacets:** The number of facets returned.\n
            **xyzFacet:** The coordinates of the corners of the facets. Each facet is a triangle, and therefore has 9 coordinates. They are arranged in xyzFacet as [X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3....] for the first facet, followed by the second and so on.\n
        **Return Code:** True\n
        :type numFacets: int

        :type xyzFacet: tuple[float]

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def FreeCurvesAsSet(self, nCombinedMode, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns all of the free curves used to define this Solid in a Set object. Free curves are curves on a sheet solid that are only attached to one surface - the free edges of the sheet
        **Remarks/Usage:**
            This method will work with any solid/volume, but it uses the data stored in the database, not any changes made in the current object (until it is Put to the database). The ID field must be properly specified.
        **Input:**
            **nCombinedMode:** 0=List contains the basic curves that are on the solid, 1=Any curves that are on the solid that are in a Combined Curve are replaced by the ID of the Combined Curve, 2=List contains both the underlying and combined curves.\n
            **nSetID:** The ID of the Set Object that will contain the IDs of the Curves\n
            **bClear:** If True, the Set is cleared prior to loading the Curve IDs\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type nSetID: int

        :type bClear: bool

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def InitMeshAttributes(self, nPropID) -> Any:
        """
        **Description:**
            This method initializes a mesh attribute of a solid to a specific property.
        **Remarks/Usage:**

        **Input:**
            **nPropID:** The ID of the property to initialize mesh attribute to.\n
        **Return Code:** True\n
        :type nPropID: int

        """
        ...

    def Inside(self, vXYZ, nInsideCode) -> Any:
        """
        **Description:**
            This method finds if a coordinate location lies inside, outside, or on a point, curve, or surface of the specified solid.
        **Remarks/Usage:**
            To check if locations are in multiple solids being considered as a single combined solid, see Section 3.6.10.38, "feSolidInsideMulti".
        **Output:**
            **nInsideCode:** 0=Location is outside, 1=Location is inside, 2=Location is on a point, curve, or surface of the specified solid.\n
        **Return Code:** True\n
        :type nInsideCode: int

        """
        ...

    def IsAllFacet(self) -> Any:
        """
        **Description:**
            This method indicates if all the surfaces of the solid are facet-based surfaces
        **Remarks/Usage:**
            This method will only work with Parasolid solids, not volumes.
        **Return Code:** True\n
        """
        ...

    def IsFacet(self) -> Any:
        """
        **Description:**
            This method indicates if the solid has any facet-based surfaces
        **Remarks/Usage:**
            This method will only work with Parasolid solids, not volumes.
        **Return Code:** True\n
        """
        ...

    def IsGeneral(self) -> Any:
        """
        **Description:**
            This function indicates whether a solid is a general body.
        **Remarks/Usage:**
            This method will only work with solids, not volumes. Returns FE_OK if current object is a general body.
        **Return Code:** True\n
        """
        ...

    def IsSheet(self) -> Any:
        """
        **Description:**
            This function indicates whether a solid is a sheet solid.
        **Remarks/Usage:**
            This method will only work with solids, not volumes. Returns FE_OK if current object is a sheet solid. A sheet solid is a collection of surfaces, possibly stitched, but which do not enclose a closed volume.
        **Return Code:** True\n
        """
        ...

    def IsSolid(self) -> Any:
        """
        **Description:**
            This function indicates whether a solid is a true, valid solid.
        **Remarks/Usage:**
            This method will only work with solids, not volumes. Returns FE_OK if current object is a solid.
        **Return Code:** True\n
        """
        ...

    def IsWire(self) -> Any:
        """
        **Description:**
            This function indicates whether a solid is a wire solid.
        **Remarks/Usage:**
            This method will only work with solids, not volumes. Returns FE_OK if current object is a wire solid. A wire solid is a collection of curves, without surfaces.
        **Return Code:** True\n
        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def MassProp(self, Area, volume, cg, Inertia) -> Any:
        """
        **Description:**
            This function computes the mass properties of a solid.
        **Remarks/Usage:**
            The cg and inertia terms are in global rectangular coordinates.
        **Output:**
            **Area:** The total surface area of the solid.\n
            **volume:** The volume of the solid (if closed).\n
            **cg:** The location of the center of gravity of the solid.\n
            **Inertia:** The 3x3 inertia matrix stored in row order [0][0], [0][1], [0][2], [1][0]...[2][2].\n
        **Return Code:** True\n
        :type Area: float

        :type volume: float

        :type cg: tuple[float]

        :type Inertia: tuple[float]

        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def Nodes(self, getBoundary, getInterior, numNodes, NodeID) -> Any:
        """
        **Description:**
            This method returns the nodes that are attached to this solid
        **Remarks/Usage:**
            None
        **Input:**
            **getBoundary:** If True, the nodes attached to the solid boundary (the surfaces, curves and points) are selected\n
            **getInterior:** If True, the nodes attached to the interior of the solid (not on the surfaces, curves or points) are selected\n
        **Output:**
            **numNodes:** The number of nodes returned.\n
            **NodeID:** The IDs of the selected nodes which are attached to the solid.\n
        **Return Code:** True\n
        :type getBoundary: bool

        :type getInterior: bool

        :type numNodes: int

        :type NodeID: tuple[int]

        """
        ...

    def NodesAsSet(self, getBoundary, getInterior, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns the nodes that are attached to this solid in a Set
        **Remarks/Usage:**
            None
        **Input:**
            **getBoundary:** If True, the nodes attached to the solid boundary (the surfaces, curves and points) are selected\n
            **getInterior:** If True, the nodes attached to the interior of the solid (not on the surfaces, curves or points) are selected\n
            **nSetID:** The ID of the Set Object that will contain the IDs of the Nodes\n
            **bClear:** If True, the Set is cleared prior to loading the Node IDs\n
        **Return Code:** True\n
        :type getBoundary: bool

        :type getInterior: bool

        :type nSetID: int

        :type bClear: bool

        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Points(self, numPoints, pointID) -> Any:
        """
        **Description:**
            This method returns a list of all of the points used to define this solid/volume.
        **Remarks/Usage:**
            This method will work with any solid/volume, but it uses the data stored in the database, not any changes made in the current object (until it is Put to the database). The ID field must be properly specified.
        **Output:**
            **numPoints:** The number of points in the pointID list.\n
            **pointID:** The IDs of the points on the solid.\n
        **Return Code:** True\n
        :type numPoints: int

        :type pointID: tuple[int]

        """
        ...

    def PointsAsSet(self, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns all of the points used to define this solid/volume in a Set object.
        **Remarks/Usage:**
            This method will work with any solid/volume, but it uses the data stored in the database, not any changes made in the current object (until it is Put to the database). The ID field must be properly specified.
        **Input:**
            **nSetID:** The ID of the Set Object that will contain the IDs of the Points\n
            **bClear:** If True, the Set is cleared prior to loading the Point IDs\n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetVolReverse(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def SetVolSurface(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SheetFacesAsSet(self, nSetID, nInsideSolidSetID) -> Any:
        """
        **Description:**
            This method returns a list of all of the surfaces which are sheet faces on a sheet solid or general body and also returns a list of all of the surfaces which are sheet faces inside a general body.
        **Remarks/Usage:**

        **Input:**
            **nSetID:** The ID of the Set Object that will contain the IDs of the Surfaces which are sheet faces of a sheet solid or general body\n
            **nInsideSolidSetID:** The ID of the Set Object that will contain the IDs of the Surfaces which are sheet faces found on the interior (inside) of a general body\n
        **Return Code:** True\n
        :type nSetID: int

        :type nInsideSolidSetID: int

        """
        ...

    def Surfaces(self, nCombinedMode, numSurfs, surfaceID) -> Any:
        """
        **Description:**
            This method returns a list of all of the surfaces used to define this solid/volume.
        **Remarks/Usage:**
            This method will work with any solid/volume, but it uses the data stored in the database, not any changes made in the current object (until it is Put to the database). The ID field must be properly specified.
        **Input:**
            **nCombinedMode:** 0=List contains the basic surfaces that are on the solid, 1=Any surfaces that are on the solid that are in a Combined Surface are replaced by the ID of the Combined Surface, 2=List contains both the underlying and combined surfaces.\n
        **Output:**
            **numSurfs:** The number of surfaces in the surfaceID list.\n
            **surfaceID:** The IDs of the surfaces on the solid.\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type numSurfs: int

        :type surfaceID: tuple[int]

        """
        ...

    def SurfacesAsSet(self, nCombinedMode, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns a list of all of the surfaces used to define this solid/volume.
        **Remarks/Usage:**
            This method will work with any solid/volume, but it uses the data stored in the database, not any changes made in the current object (until it is Put to the database). The ID field must be properly specified.
        **Input:**
            **nCombinedMode:** 0=List contains the basic surfaces that are on the solid, 1=Any surfaces that are on the solid that are in a Combined Surface are replaced by the ID of the Combined Surface, 2=List contains both the underlying and combined surfaces.\n
            **nSetID:** The ID of the Set Object that will contain the IDs of the Surfaces\n
            **bClear:** If True, the Set is cleared prior to loading the Surface IDs\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type nSetID: int

        :type bClear: bool

        """
        ...

    def VolReverse(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def VolSurface(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def WireCurvesAsSet(self, nSetID, nInsideSolidSetID) -> Any:
        """
        **Description:**
            This method returns a list of all of the curves which are wire solids on a general body and also returns a list of all of the curves which are wire solids inside a general body.
        **Remarks/Usage:**

        **Input:**
            **nSetID:** The ID of the Set Object that will contain the IDs of the Curves which are wire solids of a general body\n
            **nInsideSolidSetID:** The ID of the Set Object that will contain the IDs of the Curves which are wire solids found inside a general body\n
        **Return Code:** True\n
        :type nSetID: int

        :type nInsideSolidSetID: int

        """
        ...

    def volume(self, volume) -> Any:
        """
        **Description:**
            This method returns the volume of the solid.
        **Remarks/Usage:**

        **Output:**
            **volume:** The volume of the solid.\n
        **Return Code:** False\n
        :type volume: float

        """
        ...


class Surface:
    CLSID: Any
    Active: Any
    Address: Any
    BoundaryMode: Any
    BoundaryOnSurface: Any
    Engine: Any
    ID: Any
    InternalToBoundary: Any
    MeshSizeChord: Any
    MeshSizeInterior: Any
    QuadMeshLayers: Any
    ScaleFactor: Any
    SetID: Any
    Suppressed: Any
    approach: Any
    attrConnectEdgeNodeTol: Any
    attrConnectEdgeNodes: Any
    attrInitialized: Any
    attrMapAltTri: Any
    attrMapAngleDeviation: Any
    attrMapEqualOnly: Any
    attrMapMinCornerAngle: Any
    attrMapRightBias: Any
    attrMapSplitQuads: Any
    attrMapSubdivisions: Any
    attrMappedLevel: Any
    attrMaxAspect: Any
    attrMaxQuads: Any
    attrMesher: Any
    attrMidsideAngle: Any
    attrMidsideGeom: Any
    attrMinBetween: Any
    attrOffset: Any
    attrOffsetFrom: Any
    attrPID: Any
    attrPostMeshCleanup: Any
    attrQuadCutAngle: Any
    attrQuickCutNodes: Any
    attrSmoothIter: Any
    attrSmoothLaplacian: Any
    attrSmoothTolerance: Any
    attrTopology: Any
    attrVertexLoopsAsHardPoints: Any
    color: Any
    layer: Any
    type: Any
    vBoundaryCurve: Any
    vBoundaryFlag: Any
    vDivisions: Any
    vMeshPoint: Any
    vStdCurve: Any
    vStdCurveReverse: Any
    vapproachData: Any

    def AddMeshPoint(self, nPointID) -> Any:
        """
        **Description:**
            Adds a mesh point to a surface using the ID of the point
        **Remarks/Usage:**
            None
        **Input:**
            **nPointID:** ID of point to add as a mesh point on surface.\n
        **Return Code:** True\n
        :type nPointID: int

        """
        ...

    def AdjacentSurfaces(self, nCombinedMode, numSurfaces, surfaceID) -> Any:
        """
        **Description:**
            This method returns a list of all of the surfaces that are adjacent to the current surface.
        **Remarks/Usage:**
            This method will only work with Solid Surfaces or Combined Surfaces on Solids. It finds all of the curves on the current surface and then finds and returns all of the other surfaces that use one or more of those curves.
        **Input:**
            **nCombinedMode:** 0=List contains the basic surfaces that are adjacent (FCC_OFF), 1=Any surfaces that are adjacent that are in a Combined Surface are replaced by the ID of the Combined Surface (FCC_ON), 2=List contains both the underlying and combined surfaces (FCC_BOTH).\n
        **Output:**
            **numSurfaces:** The number of surfaces in the surfID list.\n
            **surfaceID:** The IDs of the adjacent surfaces \n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type numSurfaces: int

        :type surfaceID: tuple[int]

        """
        ...

    def AdjacentSurfacesAsSet(self, nCombinedMode, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns a list of all of the surfaces that are adjacent to the current surface in a Set object.
        **Remarks/Usage:**
            This method will only work with Solid Surfaces or Combined Surfaces on Solids. It finds all of the curves on the current surface and then finds and returns all of the other surfaces that use one or more of those curves.
        **Input:**
            **nCombinedMode:** 0=List contains the basic surfaces that are adjacent (FCC_OFF), 1=Any surfaces that are adjacent that are in a Combined Surface are replaced by the ID of the Combined Surface (FCC_ON), 2=List contains both the underlying and combined surfaces (FCC_BOTH).\n
            **nSetID:** The ID of the Set Object that will contain the IDs of the Surfaces\n
            **bClear:** If True, the Set is cleared prior to loading the Surface IDs\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type nSetID: int

        :type bClear: bool

        """
        ...

    def AngleAtPoint(self, nPtID, dAngle, vBisector, vNormal) -> Any:
        """
        **Description:**
            This method retrieves the internal angle, the surface normal vector, and a surface tangent vector that bisects the angle at a point on a surface boundary
        **Remarks/Usage:**
            None
        **Input:**
            **nPtID:** The ID of the point to check\n
        **Output:**
            **dAngle:** The angle, in the surface, formed by the edges meeting at the selected point\n
            **vBisector:** The surface tangent vector that bisects the angle\n
            **vNormal:** The surface normal at the point\n
        **Return Code:** True\n
        :type nPtID: int

        :type dAngle: float

        :type vBisector: tuple[float]

        :type vNormal: tuple[float]

        """
        ...

    def ApproximateArea(self, Area) -> Any:
        """
        **Description:**
            This method is similar to Area( ), however the area is not computed as precisely to improve performance
        **Remarks/Usage:**
            This method will only work for solid surfaces. Furthermore, the surface must be Put to the model. The data in the current object is not used.
        **Output:**
            **Area:** The area of the surface.\n
        **Return Code:** True\n
        :type Area: float

        """
        ...

    def Area(self, Area) -> Any:
        """
        **Description:**
            This method finds the area of a surface.
        **Remarks/Usage:**
            This method will only work for solid surfaces. Furthermore, the surface must be Put to the model. The data in the current object is not used.
        **Output:**
            **Area:** The area of the surface.\n
        **Return Code:** True\n
        :type Area: float

        """
        ...

    def BoundaryCurve(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def BoundaryFlag(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def BoundarySurfaces(self, numSurf, surfID) -> Any:
        """
        **Description:**
            For a combined surface, this method returns a list of all of the surfaces used to define this surface.
        **Remarks/Usage:**
            This method will only work with Combined Surfaces.
        **Output:**
            **numSurf:** The number of surfaces in the surfID list.\n
            **surfID:** The IDs of the surfaces used to define the Combined Surface\n
        **Return Code:** True\n
        :type numSurf: int

        :type surfID: tuple[int]

        """
        ...

    def BoundarySurfacesAsSet(self, nSetID, bClear) -> Any:
        """
        **Description:**
            For a combined surface, this method returns a list of all of the surfaces used to define this surface in a Set object
        **Remarks/Usage:**
            This method will only work with Combined Surfaces.
        **Input:**
            **nSetID:** The ID of the Set Object that will contain the IDs of the Surfaces\n
            **bClear:** If True, the Set is cleared prior to loading the Surface IDs\n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def BoundingBox(self, box) -> Any:
        """
        **Description:**
            This method returns the coordinates of a rectangular box the encloses this geometry.
        **Remarks/Usage:**
            This method always retrieves a box that is aligned with Global Rectangular coordinates, not an aligned box of minimum volume.
        **Output:**
            **box:** The dimensions of the bounding box, in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type box: tuple[float]

        """
        ...

    def BoundingBoxInCSys(self, nCSysID, box) -> Any:
        """
        **Description:**
            This method returns the coordinates of a rectangular box the encloses this geometry, in coordinates of the selected coordinate system.
        **Remarks/Usage:**
            This method always retrieves a box that is aligned with the selected coordinate system, not an aligned box of minimum volume.
        **Input:**
            **nCSysID:** ID of coordinate system to return minimum and maximum \n
        **Output:**
            **box:** The dimensions of the bounding box, in coordinate system specified with nCSysID coordinates.\n
        **Return Code:** True\n
        :type nCSysID: int

        :type box: tuple[float]

        """
        ...

    def BoundingSize(self, pvDim, pvLongDir, pvNormalDir) -> Any:
        """
        **Description:**
            This method finds the sizes of the smallest box that encloses the surface and the direction of the longest side and the shortest side
        **Remarks/Usage:**
            This method will only work for solid surfaces. Furthermore, the surface must be Put to the model. The data in the current object is not used.
        **Output:**
            **pvDim:** The dimensions of the bounding box\n
            **pvLongDir:** The direction along the longest side\n
            **pvNormalDir:** The direction along the shortest side of the box (normal to a planar surface)\n
        **Return Code:** True\n
        :type pvDim: tuple[Any]

        :type pvLongDir: tuple[Any]

        :type pvNormalDir: tuple[Any]

        """
        ...

    def CommonCurvesAsSet(self, nCombinedMode, nOtherSurfaceID, nSetID, bClear) -> Any:
        """
        **Description:**
            This method adds all curves which are common between the surface currently in the Surface object and another specified surface to a specified Set object. There are options to clear the set before adding the common curves and whether or not regular curves, combined curves, or both types should be added to the Set object.
        **Remarks/Usage:**
            None
        **Input:**
            **nCombinedMode:** When finding common curves, this method limits which curves on the surfaces will be considered.\n
            **nSetID:** ID of set to add common curves\n
            **bClear:** If True, the Set object will be cleared before the common curves are added. If False, the common curves are simply added to the specified Set object.\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type nSetID: int

        :type bClear: bool

        """
        ...

    def Conical(self, radius, angle, base, Axis) -> Any:
        """
        **Description:**
            This method returns information about conical surfaces
        **Remarks/Usage:**
            This method will only work with solid surfaces, not surfaces created with the FEMAP Standard geometry engine. It uses the data stored in the database, not any changes made in the current object (until it is Put to the database).
        **Output:**
            **radius:** The radius of the cone in the plane of the base location.\n
            **angle:** The half angle of the cone\n
            **base:** A location along the axis of the cone.\n
            **Axis:** The vector along the axis of the cone\n
        **Return Code:** False\n
        :type radius: float

        :type angle: float

        :type base: tuple[float]

        :type Axis: tuple[float]

        """
        ...

    def CountMeshPoint(self) -> Any:
        """
        **Description:**
            Returns the number of mesh points currently specified on a surface
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Curvature(self, vXYZ, pdRadius1, vCurveDir1, pdRadius2, vCurveDir2, vNormDir) -> Any:
        """
        **Description:**
            Returns curvature of surface in 2 directions based on specified coordinates
        **Remarks/Usage:**
            None
        **Output:**
            **pdRadius1:** Radius of curvature in Direction 1\n
            **vCurveDir1:** The vector in the direction of Direction 1.\n
            **vCurveDir1:** The vector in the direction of Direction 2.\n
        **Return Code:** True\n
        :type pdRadius1: float

        :type vCurveDir1: tuple[float]

        :type vCurveDir1: tuple[float]

        """
        ...

    def CurveLoops(self, nCombinedMode, numLoops, numCurves, curveID) -> Any:
        """
        **Description:**
            This method returns a list of all of the curves used to define this surface. Unlike Curves() this method returns the curves in their order around each surface loop.
        **Remarks/Usage:**
            The ID list in curveID list looks like outer c1, outer c2...outer cn, 0, inner1 c1...inner1 cn, 0, ... innerN c1...innerN cn, 0
        **Input:**
            **nCombinedMode:** 0=List contains the basic curves that are on the surface (FCC_OFF), 1=Any curves that are on the surface that are in a Combined Curve are replaced by the ID of the Combined Curve (FCC_ON), 2=List contains both the underlying and combined curves (FCC_BOTH).\n
        **Output:**
            **numLoops:** The number of loops on the surface and in the curveID list. A loop is a connected set of curves. Any surface with no interior holes or other features only has one loop. Each hole in the surface adds another loop.\n
            **numCurves:** The number of entries in the curveID list. This is not the number of curves since there is an extra 0 at the end of each loop.\n
            **curveID:** The IDs of the curves on the surface. Each loop ends with a 0. If the ID is negative, this indicates that the curve is used in the reverse direction.\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type numLoops: int

        :type numCurves: int

        :type curveID: tuple[int]

        """
        ...

    def Curves(self, nCombinedMode, numCurves, curveID) -> Any:
        """
        **Description:**
            This method returns a list of all of the curves used to define this surface.
        **Remarks/Usage:**
            This method will work with any surface, but it uses the data stored in the database, not any changes made in the current object (until it is Put to the database). The ID field must be properly specified.
        **Input:**
            **nCombinedMode:** 0=List contains the basic curves that are on the surface (FCC_OFF), 1=Any curves that are on the surface that are in a Combined Curve are replaced by the ID of the Combined Curve (FCC_ON), 2=List contains both the underlying and combined curves (FCC_BOTH).\n
        **Output:**
            **numCurves:** The number of curves in the curveID list.\n
            **curveID:** The IDs of the curves on the surface.\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type numCurves: int

        :type curveID: tuple[int]

        """
        ...

    def CurvesAsSet(self, nCombinedMode, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns a list of all of the curves used to define this surface in a Set object.
        **Remarks/Usage:**
            This method will work with any surface, but it uses the data stored in the database, not any changes made in the current object (until it is Put to the database). The ID field must be properly specified.
        **Input:**
            **nCombinedMode:** 0=List contains the basic curves that are on the surface (FCC_OFF), 1=Any curves that are on the surface that are in a Combined Curve are replaced by the ID of the Combined Curve (FCC_ON), 2=List contains both the underlying and combined curves (FCC_BOTH).\n
            **nSetID:** The ID of the Set Object that will contain the IDs of the Curves\n
            **bClear:** If True, the Set is cleared prior to loading the Curve IDs\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type nSetID: int

        :type bClear: bool

        """
        ...

    def CurvesAtPoint(self, nPtID, PrevCurveID, NextCurveID) -> Any:
        """
        **Description:**
            This method retrieves the curve before and after a specified point on a surface boundary
        **Remarks/Usage:**
            None
        **Input:**
            **nPtID:** The ID of the point to check\n
        **Output:**
            **PrevCurveID:** The angle, in the surface, formed by the edges meeting at the selected point\n
            **NextCurveID:** The surface tangent vector that bisects the angle\n
        **Return Code:** True\n
        :type nPtID: int

        :type PrevCurveID: int

        :type NextCurveID: int

        """
        ...

    def Cylindrical(self, radius, base, Axis) -> Any:
        """
        **Description:**
            This method returns information about cylindrical surfaces
        **Remarks/Usage:**
            This method will only work with solid surfaces, not surfaces created with the FEMAP Standard geometry engine. It uses the data stored in the database, not any changes made in the current object (until it is Put to the database).
        **Output:**
            **radius:** The radius of the cylinder.\n
            **base:** The coordinates of the center of the base of the cylinder.\n
            **Axis:** The components of the axis vector.\n
        **Return Code:** False\n
        :type radius: float

        :type base: tuple[float]

        :type Axis: tuple[float]

        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Divisions(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ElementFaces(self, getPlaneElem, getSolidElem, requireElemAttach, numFaces, elemID, faceID) -> Any:
        """
        **Description:**
            This method returns the element faces that are attached to this surface
        **Remarks/Usage:**
            The elemID and faceID arrays are stored in corresponding order . . . elemID[i] and faceID[i] together represent the element face that is actually attached to the surface.
        **Input:**
            **getPlaneElem:** If True, planar elements with faces on the surface will be returned.\n
            **getSolidElem:** If True, solid elements with faces on the surface will be returned.\n
            **requireElemAttach:** If True, planar elements must actually have been meshed on the surface, not just have all of its nodes on the surface.\n
        **Output:**
            **numFaces:** The number of elements and faces returned.\n
            **elemID:** The IDs of the selected elements which have faces that are attached to the surface.\n
            **faceID:** The IDs of the faces of the elements which are on the surface.\n
        **Return Code:** True\n
        :type getPlaneElem: bool

        :type getSolidElem: bool

        :type requireElemAttach: bool

        :type numFaces: int

        :type elemID: tuple[int]

        :type faceID: tuple[int]

        """
        ...

    def Elements(self, numElems, elemID) -> Any:
        """
        **Description:**
            This method returns the elements that are attached to this surface
        **Remarks/Usage:**
            Only elements that have all of their nodes on the surface will be returned by this method. Elements that simply touch the surface at one edge or one node will not be returned. Similarly, solid elements with one face on the surface will not be returned.
        **Output:**
            **numElems:** The number of elements returned.\n
            **elemID:** The IDs of the selected elements which are attached to the surface.\n
        **Return Code:** True\n
        :type numElems: int

        :type elemID: tuple[int]

        """
        ...

    def ElementsAsSet(self, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns the elements that are attached to this surface in a Set object
        **Remarks/Usage:**
            Only elements that have all of their nodes on the surface will be returned by this method. Elements that simply touch the surface at one edge or one node will not be returned. Similarly, solid elements with one face on the surface will not be returned.
        **Input:**
            **nSetID:** The ID of the Set Object that will contain the IDs of the Elements\n
            **bClear:** If True, the Set is cleared prior to loading the Element IDs\n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def ElementsWithFaces(self, numElems, elemID) -> Any:
        """
        **Description:**
            This method returns the elements that have faces which are attached to this surface
        **Remarks/Usage:**
            Only elements that have faces on the surface will be returned by this method. Solid elements with one face on the surface will be returned, as will planar elements meshed on the surface. Other elements that simply touch the surface at a corner, or solid elements touching just along an edge will not be returned.
        **Output:**
            **numElems:** The number of elements returned.\n
            **elemID:** The IDs of the selected elements which have faces that are attached to the surface.\n
        **Return Code:** True\n
        :type numElems: int

        :type elemID: tuple[int]

        """
        ...

    def EndPoints(self, numPoints, pointID) -> Any:
        """
        **Description:**
            This method returns a list of all of the points referenced by the surface at the ends of the defining curves.
        **Remarks/Usage:**
            This method will work with any surface, but it uses the data stored in the database, not any changes made in the current object (until it is Put to the database). The ID field must be properly specified.
        **Output:**
            **numPoints:** The number of points in the pointID list.\n
            **pointID:** The IDs of the points on the surface.\n
        **Return Code:** True\n
        :type numPoints: int

        :type pointID: tuple[int]

        """
        ...

    def EndPointsAsSet(self, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns a list of all of the points referenced by the surface at the ends of the defining curves in a Set object
        **Remarks/Usage:**
            This method will work with any surface, but it uses the data stored in the database, not any changes made in the current object (until it is Put to the database). The ID field must be properly specified.
        **Input:**
            **nSetID:** The ID of the Set Object that will contain the IDs of the Points\n
            **bClear:** If True, the Set is cleared prior to loading the Point IDs\n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Facets(self, numFacets, xyzFacet) -> Any:
        """
        **Description:**
            This method returns the triangular facets used for display of solid surfaces.
        **Remarks/Usage:**
            This method will only work with solid faces that have facetting information. The surface information must be in the database. Only the ID from the current object is used.
        **Output:**
            **numFacets:** The number of facets returned.\n
            **xyzFacet:** The coordinates of the corners of the facets. Each facet is a triangle, and therefore has 9 coordinates. They are arranged in xyzFacet as [X1,Y1,Z1,X2,Y2,Z2,X3,Y3,Z3....] for the first facet, followed by the second and so on.\n
        **Return Code:** True\n
        :type numFacets: int

        :type xyzFacet: tuple[float]

        """
        ...

    def FindMappedMeshingCorners(self, nNumDesired, pnNumFound, pnCornerList) -> Any:
        """
        **Description:**
            This method returns a list of corner points for used to specify a mapped meshing approach.
        **Remarks/Usage:**
            None
        **Input:**
            **nNumDesired:** Number of corners to attempt to locate. Should be set to 0 (Automatic), 3, or 4. \n
        **Output:**
            **pnNumFound:** Number of corners found which may be used to set a mapped meshing approach\n
        **Return Code:** False\n
        :type nNumDesired: int

        :type pnNumFound: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def HasPole(self) -> Any:
        """
        **Description:**
            This method indicates whether a surface contains a pole.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def InitMeshAttributes(self, nPropID) -> Any:
        """
        **Description:**
            This method initials the mesh attributes of a surface with a specified property.
        **Remarks/Usage:**
            None
        **Input:**
            **nPropID:** The ID of the property to initialize the mesh attributes of the surface. \n
        **Return Code:** False\n
        :type nPropID: int

        """
        ...

    def Inside(self, u, v) -> Any:
        """
        **Description:**
            This method finds if a parametric location lies inside the specified surface.
        **Remarks/Usage:**
            This method will work for any type of surface except combined boundary surfaces. Use InsideXYZ for those surfaces.
        **Input:**
            **u, v:** The parametric coordinates of the location to be tested.\n
        **Return Code:** True\n
        :type u: float
        :type v: float

        """
        ...

    def InsideXYZ(self, xyz) -> Any:
        """
        **Description:**
            This method finds if a location lies inside the specified surface.
        **Remarks/Usage:**
            This method will work for any type of surface including combined boundary surfaces.
        **Input:**
            **xyz:** The Global Rectangular coordinates of the location to be tested. \n
        **Return Code:** True\n
        :type xyz: tuple[float]

        """
        ...

    def IsBlend(self, blendtype, dRadius) -> Any:
        """
        **Description:**
            This method indicates whether a surface is a blend
        **Remarks/Usage:**
            This method will only work with solid surfaces, not surfaces created with the FEMAP Standard geometry engine. It uses the data stored in the database, not any changes made in the current object (until it is Put to the database).
        **Output:**
            **blendtype:** The Type of blend. 4002=cylinder, 4003=cone, 4004=sphere, \n
            **dRadius:** Blend Radius. For blends with two radii, it is always the smaller of the two. \n
        **Return Code:** False\n
        :type blendtype: int

        :type dRadius: float

        """
        ...

    def IsBoundingSolidRegion(self) -> Any:
        """
        **Description:**
            This method indicates whether a surface is part of a solid body definition.
        **Remarks/Usage:**
            This method will only work with solid surfaces, not surfaces created with the FEMAP Standard geometry engine. It uses the data stored in the database, not any changes made in the current object (until it is Put to the database).
        **Return Code:** False\n
        """
        ...

    def IsCone(self) -> Any:
        """
        **Description:**
            This method indicates whether a surface is conical
        **Remarks/Usage:**
            This method will only work with solid surfaces, not surfaces created with the FEMAP Standard geometry engine. It uses the data stored in the database, not any changes made in the current object (until it is Put to the database).
        **Return Code:** False\n
        """
        ...

    def IsCylinder(self) -> Any:
        """
        **Description:**
            This method indicates whether a surface is cylindrical
        **Remarks/Usage:**
            This method will only work with solid surfaces, not surfaces created with the FEMAP Standard geometry engine. It uses the data stored in the database, not any changes made in the current object (until it is Put to the database).
        **Return Code:** False\n
        """
        ...

    def IsFacet(self) -> Any:
        """
        **Description:**
            Indicates whether or not the surface is faceted surface
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def IsMappable(self, bForceBlends, dMaxBlendRadius, dMergeAngle, pnNumEdges, pnCornerPoints, pdEdgeLength,
                   pnNumEdgeCurves, pnEdgeCurves) -> Any:
        """
        **Description:**
            This function attempts to determine if a surface is appropriate for mapped meshing. If so, it provides corners and edges which will be used to apply a mapped mesh.
        **Remarks/Usage:**
            If a surface has a mapped meshing approach defined, this command will always return FE_OK for the surface.
        **Input:**
            **dMaxBlendRadius:** Maximum Radius of Blend to consider for forced mapped meshing\n
            **dMergeAngle:** Maximum Angle allowed between two curves for the curves to be considered one edge for mapped meshing purposes. \n
        **Output:**
            **pnNumEdges:** Number of mapped edges, usually 4\n
            **pnNumEdgeCurves:** Total number of curves on surface +1 to allow for 0 indicating last curve of last edge\n
        **Return Code:** True\n
        :type dMaxBlendRadius: float

        :type dMergeAngle: float

        :type pnNumEdges: int

        :type pnNumEdgeCurves: int

        """
        ...

    def IsMappedApproach(self) -> Any:
        """
        **Description:**
            Indicates whether or not the surface has a mapped meshing approach assigned
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def IsMultiLoop(self) -> Any:
        """
        **Description:**
            Indicates if a surface has any interior loops (For example, interior holes, slots, etc.)
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def IsPlane(self) -> Any:
        """
        **Description:**
            This method indicates whether a surface is planar
        **Remarks/Usage:**
            This method will only work with solid surfaces, not surfaces created with the FEMAP Standard geometry engine. It uses the data stored in the database, not any changes made in the current object (until it is Put to the database).
        **Return Code:** False\n
        """
        ...

    def IsSphere(self) -> Any:
        """
        **Description:**
            This method indicates whether a surface is spherical
        **Remarks/Usage:**
            This method will only work with solid surfaces, not surfaces created with the FEMAP Standard geometry engine. It uses the data stored in the database, not any changes made in the current object (until it is Put to the database).
        **Return Code:** False\n
        """
        ...

    def IsSuppressed(self) -> Any:
        """
        **Description:**
            Indicates whether or not the surface is suppressed
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def IsTorus(self) -> Any:
        """
        **Description:**
            This method indicates whether a surface is toroidal
        **Remarks/Usage:**
            This method will only work with solid surfaces, not surfaces created with the FEMAP Standard geometry engine. It uses the data stored in the database, not any changes made in the current object (until it is Put to the database).
        **Return Code:** False\n
        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def MaxNormalDeviation(self, dLimit, dAngle) -> Any:
        """
        **Description:**
            This method the maximum angle between the normal vectors on this surface
        **Remarks/Usage:**
            This is an approximate method. It uses the normals at the corners of facets, therefore you are not guaranteed that the maximum deviation will not be slightly larger than the value computed.
        **Input:**
            **dLimit:** A maximum angle that is acceptable. Normally set this to 0.0 - which means to return any angle variation. If you set this to some other positive number, then the method will fail if the angle is greater than the specified value.\n
        **Output:**
            **dAngle:** The maximum angle between normal vectors\n
        **Return Code:** True\n
        :type dLimit: float

        :type dAngle: float

        """
        ...

    def Mesh(self, propID, elemShape, bAllowMapped) -> Any:
        """
        **Description:**
            This method meshes the surface using the current meshing attributes and the values specified.
        **Remarks/Usage:**
            This method simply calls the application method feMeshSurface2( ) with the ID of the current surface and without resetting meshing attributes. If you have made changes to the meshing attributes in the current surface object, you must call Put() prior to calling this method or those changes will not be used.
        **Input:**
            **propID:** Specifies the ID of the property to use for elements as they are created. If you want to use predefined meshing attributes, set propID=0. In this case, all selected surfaces must have meshing attributes defined or they will not be meshed. The propID property must be compatible with surface meshing. \n
            **elemShape:** The shape of the elements to mesh. Must be 2=Tria3, 3=Tria6, 4=Quad4, 5=Quad8 or set to 0 to use the shape that is predefined on the meshing attributes.\n
            **bAllowMapped:** If True, mapped meshing of the surfaces is allowed, otherwise it is not. This argument is ignored if elemShape=0\n
        **Return Code:** True\n
        :type propID: int

        :type elemShape: int

        :type bAllowMapped: bool

        """
        ...

    def MeshPoint(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def MinRadiiOfCurvature(self, pdConcaveRadius, pdConvexRadius, pbIsPlanar) -> Any:
        """
        **Description:**
            This method returns the minimum concave and convex radii of curvature of a surface
        **Remarks/Usage:**
            Use this method to reset all parameters, then adjust individual properties to suit your needs.
        **Output:**
            **pdConcaveRadius:** The minimum radius of curvature on the concave side of the surface\n
            **pdConvexRadius:** The minimum radius of curvature on the convex side of the surface\n
            **pbIsPlanar:** True if the surface is planar\n
        **Return Code:** False\n
        :type pdConcaveRadius: float

        :type pdConvexRadius: float

        :type pbIsPlanar: bool

        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def Nodes(self, getBoundary, getInterior, numNodes, NodeID) -> Any:
        """
        **Description:**
            This method returns the nodes that are attached to this surface
        **Remarks/Usage:**
            None
        **Input:**
            **getBoundary:** If True, the nodes attached to the surface boundary (the curves and points) are selected\n
            **getInterior:** If True, the nodes attached to the interior of the surface (not on the curves or points) are selected\n
        **Output:**
            **numNodes:** The number of nodes returned.\n
            **NodeID:** The IDs of the selected nodes which are attached to the surface.\n
        **Return Code:** True\n
        :type getBoundary: bool

        :type getInterior: bool

        :type numNodes: int

        :type NodeID: tuple[int]

        """
        ...

    def NodesAsSet(self, getBoundary, getInterior, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns the nodes that are attached to this surface in a Set object
        **Remarks/Usage:**
            None
        **Input:**
            **getBoundary:** If True, the nodes attached to the surface boundary (the curves and points) are selected\n
            **getInterior:** If True, the nodes attached to the interior of the surface (not on the curves or points) are selected\n
            **nSetID:** The ID of the Set Object that will contain the IDs of the Nodes\n
            **bClear:** If True, the Set is cleared prior to loading the Node IDs\n
        **Return Code:** True\n
        :type getBoundary: bool

        :type getInterior: bool

        :type nSetID: int

        :type bClear: bool

        """
        ...

    def NormalAtXYZ(self, nLocations, xyz, normal) -> Any:
        """
        **Description:**
            This method finds a unit vector in the direction of the surface normal at one or more locations.
        **Remarks/Usage:**
            This method will work for any surface.
        **Input:**
            **nLocations:** Number of locations specified in the xyz array\n
            **xyz:** The Global Rectangular coordinates of the locations where you want normals computed. This array is stored [x0,y0,z0,x1,y1,z1...], and must contain 3*nLocations entries.\n
        **Output:**
            **normal:** The vectors in the direction of the surface normals. Each set of 3 entries in this array correspond to the matching entries in the xyz array, and are the x,y and z vector components of the normal.\n
        **Return Code:** True\n
        :type nLocations: int

        :type xyz: tuple[float]

        :type normal: tuple[float]

        """
        ...

    def NormalBox(self, box) -> Any:
        """
        **Description:**
            This method finds a bounding box around the unit normals
        **Remarks/Usage:**
            This method will work for any surface.
        **Output:**
            **box:** The values of the normal bounding box, in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type box: tuple[float]

        """
        ...

    def ParamToXYZ(self, u, v, xyz) -> Any:
        """
        **Description:**
            This method converts a parametric location (u,v) to a coordinate location (xyz).
        **Remarks/Usage:**
            This method will work for any type of surface.
        **Input:**
            **u, v:** The parametric coordinates of the location being specified.\n
        **Output:**
            **xyz:** The coordinates of the location in global rectangular.\n
        **Return Code:** True\n
        :type u: float

        :type v: float

        :type xyz: tuple[float]

        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Planar(self, base, normal) -> Any:
        """
        **Description:**
            This method returns information about planar surfaces.
        **Remarks/Usage:**
            This method will only work with solid surfaces, not surfaces created with the FEMAP Standard geometry engine. It uses the data stored in the database, not any changes made in the current object (until they are Put to the database).
        **Output:**
            **base:** The coordinates of a point on the surface \n
            **normal:** The vector that is normal to the plane\n
        **Return Code:** True\n
        :type base: tuple[float]

        :type normal: tuple[float]

        """
        ...

    def PointLoops(self, nCombinedMode, numLoops, numPoints, pointID) -> Any:
        """
        **Description:**
            This method returns the number of loops on a surface along with the IDs of the points used for each loop.
        **Remarks/Usage:**
            None
        **Input:**
            **nCombinedMode:** When finding loops, this method limits which curves on the surfaces will be considered.\n
        **Output:**
            **numLoops:** Total number of surface loops \n
            **numPoints:** Total number of points used by the loops + numLoops\n
            **pointID:** IDs of the points making up each loop. 0 is returned after the last point of each loop as a separator\n
        **Return Code:** False\n
        :type nCombinedMode: int

        :type numLoops: int

        :type numPoints: int

        :type pointID: Any

        """
        ...

    def Points(self, nCombinedMode, numPoints, pointID) -> Any:
        """
        **Description:**
            This method returns a list of all of the points referenced by the surface.
        **Remarks/Usage:**
            This method will work with any surface, but it uses the data stored in the database, not any changes made in the current object (until it is Put to the database). The ID field must be properly specified.
        **Input:**
            **nCombinedMode:** When finding the list of points, this method first finds all curves on the surface, then points on those curves. \n
        **Output:**
            **numPoints:** The number of points in the pointID list.\n
            **pointID:** The IDs of the points on the surface.\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type numPoints: int

        :type pointID: tuple[int]

        """
        ...

    def PointsAsSet(self, nCombinedMode, nSetID, bClear) -> Any:
        """
        **Description:**
            This method returns a list of all of the points referenced by the surface in a Set object.
        **Remarks/Usage:**
            This method will work with any surface, but it uses the data stored in the database, not any changes made in the current object (until it is Put to the database). The ID field must be properly specified.
        **Input:**
            **nCombinedMode:** When finding the list of points, this method first finds all curves on the surface, then points on those curves. \n
            **nSetID:** The ID of the Set Object that will contain the IDs of the Points\n
            **bClear:** If True, the Set is cleared prior to loading the Point IDs\n
        **Return Code:** True\n
        :type nCombinedMode: int

        :type nSetID: int

        :type bClear: bool

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def ProjectAlongVector(self, bBothDirections, vAlong, vOrig, vProj) -> Any:
        """
        **Description:**
            This method projects a location along a specified vector to a location that lies on a surface (i.e., user supplies vector used for projection)
        **Remarks/Usage:**
            None
        **Input:**
            **bBothDirections:** When True, the location will be projected in both directions along the supplied vector to determine the location to use (i.e., if a location was inside a cylindrical surface, it could actually find 2 locations on the surface, and the one closest to the original location will be used). When False, the location will only be projected in the direction of the supplied vector.\n
        **Return Code:** True\n
        :type bBothDirections: bool

        """
        ...

    def ProjectOnto(self, initial, tolerance, projection) -> Any:
        """
        **Description:**
            This method projects a location to the closest location that lies on a surface.
        **Remarks/Usage:**
            This method will work for any surface, but all boundary surfaces must be Put to the database before using this method.
        **Input:**
            **initial:** The initial coordinates to be projected onto the surface.\n
            **tolerance:** The tolerance within which you will consider the projected location to be on the surface. The method stops when it finds a point that is at least this close. This tolerance is only used for certain standard surface types.\n
        **Output:**
            **projection:** The projected location, on the surface.\n
        **Return Code:** True\n
        :type initial: tuple[float]

        :type tolerance: float

        :type projection: tuple[float]

        """
        ...

    def ProjectToClosest(self, vOrig, vProj) -> Any:
        """
        **Description:**
            This method projects a location to the closest location that lies on a surface (i.e., FEMAP determines vector used for projection)
        **Remarks/Usage:**
            Does the same thing as the ProjectOnto method, but always uses a Tolerance value of 1.0E-8
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def RationalParamToXYZ(self, u, v, xyz) -> Any:
        """
        **Description:**
            This method converts a parametric location (u,v) to a coordinate location (xyz) using rational uv space.
        **Remarks/Usage:**

        **Input:**
            **u, v:** The rational parametric coordinates of the location being specified. Parametric coordinates are between 0 and 1\n
        **Output:**
            **xyz:** The coordinates of the location in global rectangular. \n
        **Return Code:** True\n
        :type u: float

        :type v: float

        :type xyz: tuple[float]

        """
        ...

    def RemoveAllMeshPoints(self) -> Any:
        """
        **Description:**
            Removes all mesh points from a surface using the ID of the point
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def RemoveMeshPoint(self, nPointID) -> Any:
        """
        **Description:**
            Removes a mesh point from a surface using the ID of the point
        **Remarks/Usage:**
            None
        **Input:**
            **nPointID:** ID of point to remove as a mesh point on surface.\n
        **Return Code:** True\n
        :type nPointID: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def ResetMeshAttr(self) -> Any:
        """
        **Description:**
            This method resets the mesh attribute parameters to default values.
        **Remarks/Usage:**
            Use this method to reset all parameters, then adjust individual properties to suit your needs.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetBoundaryCurve(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetBoundaryFlag(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetDivisions(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetMeshPoint(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetStdCurve(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetStdCurveReverse(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetapproachData(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Solid(self, pnSolidID) -> Any:
        """
        **Description:**
            This method returns the ID of the Solid that contains the current Surface
        **Remarks/Usage:**
            This method will only work with Solid surfaces and Combined Surfaces that are defined on a Solid.
        **Output:**
            **pnSolidID:** The ID of the Solid that references the current Surface\n
        **Return Code:** True\n
        :type pnSolidID: int

        """
        ...

    def Spherical(self, radius, center) -> Any:
        """
        **Description:**
            This method returns information about spherical surfaces
        **Remarks/Usage:**
            This method will only work with solid surfaces, not surfaces created with the FEMAP Standard geometry engine. It uses the data stored in the database, not any changes made in the current object (until it is Put to the database).
        **Output:**
            **radius:** The radius of the sphere.\n
            **center:** The coordinates of the center of the sphere.\n
        **Return Code:** False\n
        :type radius: float

        :type center: tuple[float]

        """
        ...

    def StdCurve(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def StdCurveReverse(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Tangents(self, u, v, stan, ttan) -> Any:
        """
        **Description:**
            This method finds unit vectors in the directions of the tangents to the surface at a selected location.
        **Remarks/Usage:**
            This method will work for any surface.
        **Input:**
            **u, v:** The parametric coordinates of the location being specified.\n
            **v:** Output:\n
        **Output:**
            **stan, ttan:** The tangent vector in the direction of the uparametric space of the surface.\n
        **Return Code:** True\n
        :type u: float
        :type v: float
        :type u: tuple[float]
        :type v: tuple[float]

        """
        ...

    def Toroidal(self, radius1, radius2, base, Axis) -> Any:
        """
        **Description:**
            This method returns information about toroidal surfaces
        **Remarks/Usage:**
            This method will only work with solid surfaces, not surfaces created with the FEMAP Standard geometry engine. It uses the data stored in the database, not any changes made in the current object (until it is Put to the database).
        **Output:**
            **radius1:** The major radius of the toroid.\n
            **radius2:** The minor radius of the toroid\n
            **base:** A location along the axis of the toroid.\n
            **Axis:** The vector along the axis of the toroid\n
        **Return Code:** False\n
        :type radius1: float

        :type radius2: float

        :type base: tuple[float]

        :type Axis: tuple[float]

        """
        ...

    def XYZToParam(self, xyz, u, v) -> Any:
        """
        **Description:**
            This method converts a coordinate location (xyz) to a parametric location (u,v).
        **Remarks/Usage:**
            This method will work for any type of surface.
        **Input:**
            **xyz:** The coordinates of the location in global rectangular.\n
        **Output:**
            **u:** The parametric coordinates of the location.\n
            **v:** Return Code:\n
        **Return Code:** True\n
        :type xyz: tuple[float]

        :type u: float

        :type v: float

        """
        ...

    def approachData(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def cg(self, xyz) -> Any:
        """
        **Description:**
            This method finds the center of gravity of a surface.
        **Remarks/Usage:**
            This method will only work for solid surfaces. Furthermore, the surface must be Put to the model. The data in the current object is not used.
        **Output:**
            **xyz:** The coordinates of the center of gravity, in global rectangular.\n
        **Return Code:** True\n
        :type xyz: tuple[float]

        """
        ...

    def normal(self, u, v, normal) -> Any:
        """
        **Description:**
            This method finds a unit vector in the direction of the surface normal at a selected location.
        **Remarks/Usage:**
            This method will work for any surface.
        **Input:**
            **u, v:** The parametric coordinates of the location being specified.\n
        **Output:**
            **normal:** The vector in the direction of the surface normal.\n
        **Return Code:** True\n
        :type u: float

        :type v: float

        :type normal: tuple[float]

        """
        ...


class TmgBC:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    vb: Any
    vc: Any
    vi: Any
    vr: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetAll(self, entID, i, r, c) -> Any:
        """
        **Description:**
            This method is obsolete, therefore, GetAll2 should be used instead. This method retrieves an entity with the specified ID.
        **Remarks/Usage:**
            Should no longer be used
        **Input:**
            **entID:** ID of the entity to retrieve.\n
        **Output:**
            **r:** INT4 c[0..242]\n
            **c:** Return Code:\n
        **Return Code:** True\n
        :type entID: int

        :type r: tuple[float]

        :type c: tuple[int]

        """
        ...

    def GetAll2(self, entID, i, r, b, c) -> Any:
        """
        **Description:**
            This method retrieves an entity with the specified ID.
        **Remarks/Usage:**

        **Input:**
            **entID:** ID of the entity to retrieve.\n
        **Output:**
            **r:** BOOL b\n
            **b:** INT4 c\n
            **c:** Return Code:\n
        **Return Code:** True\n
        :type entID: int

        :type r: float

        :type b: bool

        :type c: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutAll(self, entID, i, r, c) -> Any:
        """
        **Description:**
            This method is obsolete, therefore, PutAll2 should be used instead. This method stores an entity with the specified ID.
        **Remarks/Usage:**
            Should no longer be used
        **Input:**
            **entID:** The ID of the entity to store.\n
            **i, r, c:** Notice, the size of the most of the arrays are smaller than in the property definition. c is loaded in an integer array, even though it contains only char values.\n

        **Return Code:** True\n
        :type entID: int
        :type i: tuple[int]
        :type r: tuple[float]
        :type c: tuple[int]

        """
        ...

    def PutAll2(self, entID, i, r, b, c) -> Any:
        """
        **Description:**
            This method stores an entity with the specified ID.
        **Remarks/Usage:**

        **Input:**
            **entID:** The ID of the entity to store.\n
            **i, r, b, c:** Refer to the property descriptions for each of these items. c is loaded in an integer array, even though it contains only char values.\n
        **Return Code:** True\n
        :type entID: int
        :type r: int
        :type r: float
        :type b: bool
        :type c: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def Setb(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setc(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Seti(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setr(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def b(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def c(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def i(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def r(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class TmgCtl:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    vb: Any
    vc: Any
    vi: Any
    vr: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetAll(self, entID, i, r, b, c) -> Any:
        """
        **Description:**
            This method is obsolete, therefore, GetAll2 should be used instead. This method retrieves an entity with the specified ID.
        **Remarks/Usage:**
            Should no longer be used
        **Input:**
            **entID:** ID of the entity to retrieve.\n
        **Output:**
            **r:** BOOL b[0..121]\n
            **b:** INT4 c[0..485]\n
            **c:** Return Code:\n
        **Return Code:** True\n
        :type entID: int

        :type r: tuple[float]

        :type b: tuple[bool]

        :type c: tuple[int]

        """
        ...

    def GetAll2(self, entID, i, r, b, c) -> Any:
        """
        **Description:**
            This method retrieves an entity with the specified ID.
        **Remarks/Usage:**

        **Input:**
            **entID:** ID of the entity to retrieve.\n
        **Output:**
            **r:** BOOL b\n
            **b:** INT4 c\n
            **c:** Return Code:\n
        **Return Code:** True\n
        :type entID: int

        :type r: float

        :type b: bool

        :type c: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutAll(self, entID, i, r, b, c) -> Any:
        """
        **Description:**
            This method is obsolete, therefore, PutAll2 should be used instead. This method stores an entity with the specified ID.
        **Remarks/Usage:**
            Should no longer be used
        **Input:**
            **entID:** The ID of the entity to store.\n
            **i, r, b, c:** Notice, the size of the most of the arrays are smaller than in the property definition.. c is loaded in an integer array, even though it contains only char values.\n

        **Return Code:** True\n
        :type entID: int

        :type i: tuple[int]
        :type r: tuple[float]
        :type b: tuple[bool]
        :type c: tuple[int]

        """
        ...

    def PutAll2(self, entID, i, r, b, c) -> Any:
        """
        **Description:**
            This method stores an entity with the specified ID.
        **Remarks/Usage:**

        **Input:**
            **entID:** The ID of the entity to store.\n
            **i, r, b, c:** BOOL b\n
        **Return Code:** True\n
        :type entID: int
        :type i: int
        :type r: float
        :type b: bool
        :type c: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def Setb(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setc(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Seti(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setr(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def b(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def c(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def i(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def r(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class TmgInt:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    vi: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetAll(self, entID, i) -> Any:
        """
        **Description:**
            This method retrieves an entity with the specified ID.
        **Remarks/Usage:**

        **Input:**
            **entID:** ID of the entity to retrieve.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutAll(self, entID, i) -> Any:
        """
        **Description:**
            This method stores an entity with the specified ID.
        **Remarks/Usage:**

        **Input:**
            **entID:** The ID of the entity to store.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def Seti(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def i(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class TmgOpt:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    vc: Any
    vi: Any
    vr: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetAll(self, entID, i, r, c) -> Any:
        """
        **Description:**
            This method retrieves an entity with the specified ID.
        **Remarks/Usage:**

        **Input:**
            **entID:** ID of the entity to retrieve.\n
        **Output:**
            **r:** INT4 c\n
            **c:** Return Code:\n
        **Return Code:** True\n
        :type entID: int

        :type r: float

        :type c: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutAll(self, entID, i, r, c) -> Any:
        """
        **Description:**
            This method stores an entity with the specified ID.
        **Remarks/Usage:**

        **Input:**
            **entID:** The ID of the entity to store.\n
            **i, r, c:** Refer to the property descriptions for each of these items. c is loaded in an integer array, even though it contains only char values.\n
        **Return Code:** True\n
        :type entID: int
        :type i: int
        :type r: float
        :type c: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def Setc(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Seti(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setr(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def c(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def i(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def r(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class TmgReal:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    vi: Any
    vr: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetAll(self, entID, i, r) -> Any:
        """
        **Description:**
            This method retrieves an entity with the specified ID.
        **Remarks/Usage:**

        **Input:**
            **entID:** ID of the entity to retrieve.\n
        **Output:**
            **r:** Return Code:\n
        **Return Code:** True\n
        :type entID: int

        :type r: float

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutAll(self, entID, i, r) -> Any:
        """
        **Description:**
            This method stores an entity with the specified ID.
        **Remarks/Usage:**

        **Input:**
            **entID:** The ID of the entity to store.\n
            **i, r:** Refer to the property descriptions for each of these items.:\n
        **Return Code:** True\n
        :type entID: int
        :type i: int
        :type r: float

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def Seti(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setr(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def i(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def r(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class Var:
    CLSID: Any
    Active: Any
    Equation: Any
    ID: Any
    SetID: Any
    value: Any
    varname: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Define(self, varname, Equation) -> Any:
        """
        **Description:**
            This method evaluates the equation stored in the current Equation property. The result is returned, and used to update the Value property.
        **Remarks/Usage:**
            This method automatically computes the value and sets all properties for the variable. In addition, the variable is Put to the database so it is permanently retained.
        **Input:**
            **varname:** The variable name to create or update. Maximum 20 characters.\n
            **Equation:** The equation used to define the variable. Maximum 160 characters.\n
        **Return Code:** False\n
        :type varname: str

        :type Equation: str

        """
        ...

    def DefineReal(self, varname, value) -> Any:
        """
        **Description:**
            This method defines a variable and its associated real number.
        **Remarks/Usage:**
            None
        **Input:**
            **varname:** The variable name to create or update. Maximum 20 characters.\n
            **value:** The value to assigned to the variable.\n
        **Return Code:** False\n
        :type varname: str

        :type value: float

        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Evaluate(self) -> Any:
        """
        **Description:**
            This method evaluates the equation stored in the current Equation property. The result is returned, and used to update the Value property.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetVarID(self, varname) -> Any:
        """
        **Description:**
            This method retrieves the encoded ID that is associated with a specified variable name.
        **Remarks/Usage:**
            You do not need to have a variable with the specified name to use this function.
        **Input:**
            **varname:** The name of the variable to compute the associated ID.\n
        **Return Code:** True\n
        :type varname: str

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class View:
    CLSID: Any
    Active: Any
    AmbientLight: Any
    AnimationDelay: Any
    AnimationFrames: Any
    ArrowsToLabel: Any
    Aspect: Any
    BC: Any
    BeamDiagramScale: Any
    BlankNodesOff: Any
    ComplexSyncIncrement: Any
    ComplexSyncMethod: Any
    ComplexSyncPhase: Any
    Contour: Any
    ContourCornerData: Any
    ContourDataConversion: Any
    ContourDataSelection: Any
    ContourDataV2: Any
    ContourElemBreakAngle: Any
    ContourElemBreakColor: Any
    ContourElemBreakGeom: Any
    ContourElemBreakLayer: Any
    ContourElemBreakLinearParabolic: Any
    ContourElemBreakMatl: Any
    ContourElemBreakProp: Any
    ContourElemUnaveraged: Any
    ContourGroup: Any
    ContourLabelDigits: Any
    ContourLabelFreq: Any
    ContourLegendDigits: Any
    ContourLegendFreq: Any
    ContourLegendHorizontal: Any
    ContourLegendLockOrientation: Any
    ContourLegendReversed: Any
    ContourLegendShrinkPct: Any
    ContourLegendTopLeftLabel: Any
    ContourLegendWidthPct: Any
    ContourVecAddlV2: Any
    ContourVecAutoOrient: Any
    ContourVecAutoVec: Any
    ContourVecCSys: Any
    ContourVecColor1: Any
    ContourVecColor2: Any
    ContourVecColor3: Any
    ContourVecDigits: Any
    ContourVecHide: Any
    ContourVecLength: Any
    ContourVecMinLen: Any
    ContourVecMinVec: Any
    ContourVecMinVecOn: Any
    ContourVecMode: Any
    ContourVector1V2: Any
    ContourVector2V2: Any
    ContourVector3V2: Any
    CriteriaMax: Any
    CriteriaMin: Any
    CurveConnectFree: Any
    CurveConnectFreeColor: Any
    CurveConnectManifold: Any
    CurveConnectManifoldColor: Any
    CurveConnectNonManifold: Any
    CurveConnectNonManifoldColor: Any
    CurveConnectWirebody: Any
    CurveConnectWirebodyColor: Any
    DO_BCs_BaseExponent: Any
    DO_BCs_BeforeDecimalSeparator: Any
    DO_BCs_DecimalPlaces: Any
    DO_BCs_Exponent: Any
    DO_BCs_ExponentDigits: Any
    DO_BCs_LeadingZeros: Any
    DO_BCs_MaxDigits: Any
    DO_BCs_MinimumExponentSize: Any
    DO_BCs_Option: Any
    DO_BCs_OriginalDigits: Any
    DO_BCs_RoundToZero: Any
    DO_BCs_RoundToZeroValue: Any
    DO_BCs_SigFigs: Any
    DO_BCs_TrailingZeros: Any
    DO_BeamDiagram_BaseExponent: Any
    DO_BeamDiagram_BeforeDecimalSeparator: Any
    DO_BeamDiagram_DecimalPlaces: Any
    DO_BeamDiagram_Exponent: Any
    DO_BeamDiagram_ExponentDigits: Any
    DO_BeamDiagram_LeadingZeros: Any
    DO_BeamDiagram_MaxDigits: Any
    DO_BeamDiagram_MinimumExponentSize: Any
    DO_BeamDiagram_Option: Any
    DO_BeamDiagram_OriginalDigits: Any
    DO_BeamDiagram_RoundToZero: Any
    DO_BeamDiagram_RoundToZeroValue: Any
    DO_BeamDiagram_SigFigs: Any
    DO_BeamDiagram_TrailingZeros: Any
    DO_ContourArrow_BaseExponent: Any
    DO_ContourArrow_BeforeDecimalSeparator: Any
    DO_ContourArrow_DecimalPlaces: Any
    DO_ContourArrow_Exponent: Any
    DO_ContourArrow_ExponentDigits: Any
    DO_ContourArrow_LeadingZeros: Any
    DO_ContourArrow_MaxDigits: Any
    DO_ContourArrow_MinimumExponentSize: Any
    DO_ContourArrow_Option: Any
    DO_ContourArrow_OriginalDigits: Any
    DO_ContourArrow_RoundToZero: Any
    DO_ContourArrow_RoundToZeroValue: Any
    DO_ContourArrow_SigFigs: Any
    DO_ContourArrow_TrailingZeros: Any
    DO_ContourLegend_BaseExponent: Any
    DO_ContourLegend_BeforeDecimalSeparator: Any
    DO_ContourLegend_DecimalPlaces: Any
    DO_ContourLegend_Exponent: Any
    DO_ContourLegend_ExponentDigits: Any
    DO_ContourLegend_LeadingZeros: Any
    DO_ContourLegend_MaxDigits: Any
    DO_ContourLegend_MinimumExponentSize: Any
    DO_ContourLegend_Option: Any
    DO_ContourLegend_OriginalDigits: Any
    DO_ContourLegend_RoundToZero: Any
    DO_ContourLegend_RoundToZeroValue: Any
    DO_ContourLegend_SigFigs: Any
    DO_ContourLegend_TrailingZeros: Any
    DO_Criteria_BaseExponent: Any
    DO_Criteria_BeforeDecimalSeparator: Any
    DO_Criteria_DecimalPlaces: Any
    DO_Criteria_Exponent: Any
    DO_Criteria_ExponentDigits: Any
    DO_Criteria_LeadingZeros: Any
    DO_Criteria_MaxDigits: Any
    DO_Criteria_MinimumExponentSize: Any
    DO_Criteria_Option: Any
    DO_Criteria_OriginalDigits: Any
    DO_Criteria_RoundToZero: Any
    DO_Criteria_RoundToZeroValue: Any
    DO_Criteria_SigFigs: Any
    DO_Criteria_TrailingZeros: Any
    DO_Deformed_BaseExponent: Any
    DO_Deformed_BeforeDecimalSeparator: Any
    DO_Deformed_DecimalPlaces: Any
    DO_Deformed_Exponent: Any
    DO_Deformed_ExponentDigits: Any
    DO_Deformed_LeadingZeros: Any
    DO_Deformed_MaxDigits: Any
    DO_Deformed_MinimumExponentSize: Any
    DO_Deformed_Option: Any
    DO_Deformed_OriginalDigits: Any
    DO_Deformed_RoundToZero: Any
    DO_Deformed_RoundToZeroValue: Any
    DO_Deformed_SigFigs: Any
    DO_Deformed_TrailingZeros: Any
    DO_FreeBody_BaseExponent: Any
    DO_FreeBody_BeforeDecimalSeparator: Any
    DO_FreeBody_DecimalPlaces: Any
    DO_FreeBody_Exponent: Any
    DO_FreeBody_ExponentDigits: Any
    DO_FreeBody_LeadingZeros: Any
    DO_FreeBody_MaxDigits: Any
    DO_FreeBody_MinimumExponentSize: Any
    DO_FreeBody_Option: Any
    DO_FreeBody_OriginalDigits: Any
    DO_FreeBody_RoundToZero: Any
    DO_FreeBody_RoundToZeroValue: Any
    DO_FreeBody_SigFigs: Any
    DO_FreeBody_TrailingZeros: Any
    DO_Loads_BaseExponent: Any
    DO_Loads_BeforeDecimalSeparator: Any
    DO_Loads_DecimalPlaces: Any
    DO_Loads_Exponent: Any
    DO_Loads_ExponentDigits: Any
    DO_Loads_LeadingZeros: Any
    DO_Loads_MaxDigits: Any
    DO_Loads_MinimumExponentSize: Any
    DO_Loads_Option: Any
    DO_Loads_OriginalDigits: Any
    DO_Loads_RoundToZero: Any
    DO_Loads_RoundToZeroValue: Any
    DO_Loads_SigFigs: Any
    DO_Loads_TrailingZeros: Any
    DeformDataV2: Any
    DeformRelativeToNode: Any
    Deformed: Any
    DeformedAbsScale: Any
    DeformedRelScale: Any
    DiscreteValueOn: Any
    DiscreteValueSetID: Any
    ElementNoResultMode: Any
    FeatureLineAngle: Any
    FinalOutputSet: Any
    FreebodyDigits: Any
    FreebodyLength: Any
    FreebodyMinVecFlag: Any
    FreebodyNodalForceFactor: Any
    FreebodyNodalMomentFactor: Any
    FreebodyShowMag: Any
    FreebodyShowSum: Any
    FreebodyTotalForceFactor: Any
    FreebodyTotalMomentFactor: Any
    FreebodyUnitsPerLength: Any
    GlobalPlyLocation: Any
    ID: Any
    InterOccularDist: Any
    IsosurfaceValue: Any
    LabelGroup: Any
    LoadVecLength: Any
    LoadVectorMinScale: Any
    Magnification: Any
    MaxUserContourPalette: Any
    Mode: Any
    ModelDataContourGroup: Any
    ModelDataContourLabels: Any
    ModelDataContourOn: Any
    OtherVecLength: Any
    OutputSet: Any
    OutputSetInc: Any
    PerspectiveAngle: Any
    PerspectiveDist: Any
    PostTitlesJustification: Any
    PostTitlesLockJustification: Any
    PrevMagnification: Any
    PrevWindowBottom: Any
    PrevWindowLeft: Any
    PrevWindowRight: Any
    PrevWindowTop: Any
    PrevWindowXmax: Any
    PrevWindowXmin: Any
    PrevWindowYmax: Any
    PrevWindowYmin: Any
    RenderLogDepthOffset: Any
    RenderPushForward: Any
    RenderPushLabel: Any
    RenderPushUndeformed: Any
    RenderPushUnit: Any
    RotateAroundModelAxes: Any
    RotateCSys: Any
    RotateSingleAxis: Any
    RotateUseAxis: Any
    RotationCenterOn: Any
    Section1On: Any
    Section2On: Any
    Section3On: Any
    SectionCapMode: Any
    SectionCount: Any
    SectionMode: Any
    SectionPlaneMode: Any
    SectionSpacing: Any
    SetID: Any
    ShowAllLayers: Any
    ShrinkFactor: Any
    SpotlightDist: Any
    StreamLineID: Any
    StreamLineMaxLenFactor: Any
    StreamLineMaxTime: Any
    StreamLineMinSpeedPct: Any
    StreamLineOpt: Any
    StreamLineRungeKuttaOrder: Any
    StreamLineTolerance: Any
    TraceIDV2: Any
    TraceOpt: Any
    TransformDeformCSys: Any
    TransformDeformMode: Any
    TransformDeformX: Any
    TransformDeformXInput: Any
    TransformDeformY: Any
    TransformDeformYInput: Any
    TransformDeformZ: Any
    TransformDeformZInput: Any
    TransformNodalCSys: Any
    TransformNodalMode: Any
    TransformPlateCSys: Any
    TransformPlateDOF: Any
    TransformPlateMode: Any
    TransformPlateTolerance: Any
    TransformSolidCSys: Any
    TransformSolidMode: Any
    TransparencyPercent: Any
    UndefAnimation: Any
    UserContourCount: Any
    ViewLegendJustification: Any
    ViewLegendLockJustification: Any
    WindowBackColor: Any
    WindowBackColor2: Any
    WindowBackColor3: Any
    WindowBorder: Any
    WindowEraseBack: Any
    WindowLogo: Any
    WindowShadeBack: Any
    WindowShadeBackOpt: Any
    WindowShadeHorizon: Any
    WindowTitleBar: Any
    XYCSys: Any
    XYDirection: Any
    XYSubtitle: Any
    XYTitle: Any
    XYXTics: Any
    XYXmax: Any
    XYXmin: Any
    XYYTics: Any
    XYymax: Any
    XYymin: Any
    group: Any
    load: Any
    title: Any
    vAxisLocation: Any
    vCenter: Any
    vClipPlaneNormal: Any
    vClipPlaneOrigin: Any
    vColor: Any
    vColorMode: Any
    vContourColor: Any
    vContourLegendLocation: Any
    vContourVecDir: Any
    vContourVecID1V2: Any
    vContourVecID2V2: Any
    vContourVecID3V2: Any
    vContourVecOn: Any
    vDraw: Any
    vLabel: Any
    vLight: Any
    vLogoLocation: Any
    vPostTitlesLocation: Any
    vPrevCenter: Any
    vPrevRotation: Any
    vRotation: Any
    vRotationCenter: Any
    vRotationVector: Any
    vSection2Base: Any
    vSection2Normal: Any
    vSection3Base: Any
    vSection3Normal: Any
    vSectionBase: Any
    vSectionNormal: Any
    vSpotlightDir: Any
    vStreamLineLocation: Any
    vTransformPlateVector: Any
    vUserContourLevel: Any
    vUserContourPalette: Any
    vUserContourValue: Any
    vViewLegendLocation: Any
    vXYOutputDataV2: Any
    vXYOutputEntity: Any
    vXYOutputSet: Any
    vXYScale: Any
    vXYSetRange: Any
    vfunction: Any

    def Align2Vector(self, vZx, vZy, vZz, vXYx, vXYy, vXYZ, bAutoXY) -> Any:
        """
        **Description:**
            Rotates the current view to be aligned looking along the specified vector.
        **Remarks/Usage:**
            The current object must be loaded with a view from your model.
        **Input:**
            **vZx:** The components of the axis of alignment (normal to the screen)\n
            **vZy:** REAL8 vZz\n
            **vZz:** REAL8 vXYx\n
            **vXYx:** The components of a vector used to determine the X and Y (in screen) axes. The normal vector (vZx,vZy,vZz) is crossed with this vector to determine the Y vector, which is then crossed again to determine X.\n
            **vXYy:** REAL8 vXYz\n
            **vXYZ:** BOOL bAutoXY\n
            **bAutoXY:** If True, the X and Y vectors are swapped so that the model better fits into the window shape.\n
        **Return Code:** False\n
        :type vZx: float

        :type vZy: float

        :type vZz: float

        :type vXYx: float

        :type vXYy: float

        :type vXYZ: float

        :type bAutoXY: bool

        """
        ...

    def AlignCSys(self, csysID) -> Any:
        """
        **Description:**
            Rotates the current view to be aligned with the XY plane of the selected coordinate system.
        **Remarks/Usage:**
            The current object must be loaded with a view from your model.
        **Input:**
            **csysID:** The ID of the coordinate system used for alignment.\n
        **Return Code:** False\n
        :type csysID: int

        """
        ...

    def AlignVector(self, oX, oY, oZ, dX, dY, dZ) -> Any:
        """
        **Description:**
            Rotates the current view to be aligned looking along the specified vector.
        **Remarks/Usage:**
            The current object must be loaded with a view from your model.
        **Input:**
            **oX, oY, oZ:** The origin of the alignment axis - in global rectangular coordinates.\n
            **dX, dY, dZ:** The components of the axis of alignment.\n
        **Return Code:** False\n
        :type oX: float
        :type oY: float
        :type oZ: float
        :type dX: float
        :type dY: float
        :type dZ: float

        """
        ...

    def AlignWorkplane(self) -> Any:
        """
        **Description:**
            Rotates the current view to be aligned with the normal to the workplane.
        **Remarks/Usage:**
            The current object must be loaded with a view from your model.
        **Return Code:** False\n
        """
        ...

    def AutoscaleAll(self, redoBox) -> Any:
        """
        **Description:**
            Changes the magnification so that the current model is scaled to fit in the view.
        **Remarks/Usage:**
            The current object must be loaded with a view from your model.
        **Input:**
            **redoBox:** If set to True, then the imaginary box around the model that is used for autoscaling is recomputed. If set to False, the existing box is used.\n
        **Return Code:** False\n
        :type redoBox: bool

        """
        ...

    def AutoscaleVisible(self, redoBox) -> Any:
        """
        **Description:**
            Changes the magnification so that the visible portions of the model are scaled to fit in the view.
        **Remarks/Usage:**
            The current object must be loaded with a view from your model that is currently visible in a window. This method differs from AutoscaleAll in that the current group, layers and display options are considered when scaling the view.
        **Input:**
            **redoBox:** If set to True, then the imaginary box around the model that is used for autoscaling is recomputed. If set to False, the existing box is used.\n
        **Return Code:** False\n
        :type redoBox: bool

        """
        ...

    def AxisLocation(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ClearMultiGroupList(self) -> Any:
        """
        **Description:**
            This method clear the groups in the Multi Group Display.
        **Remarks/Usage:**

        **Return Code:** False\n
        """
        ...

    def ClipPlaneNormal(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ClipPlaneOrigin(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ColorMode(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ContourColor(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ContourLegendLocation(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ContourVecDir(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ContourVecID1V2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ContourVecID2V2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ContourVecID3V2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ContourVecOn(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Draw(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def FitVisible(self, redoBox) -> Any:
        """
        **Description:**
            Changes the magnification so that the visible portions of the model are scaled to fit in the view, based on the models current orientation.
        **Remarks/Usage:**
            The current object must be loaded with a view from your model that is currently visible in a window. This method differs from AutoscaleVisible in that the models orientation is also taken into account.
        **Input:**
            **redoBox:** If set to True, then the imaginary box around the model that is used to fit the visible entities based on orientation is recomputed. If set to False, the existing box is used.\n
        **Return Code:** False\n
        :type redoBox: bool

        """
        ...

    def Function(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetFontData(self, pdPointHeight, pbBold, pbItalic, ppcName) -> Any:
        """
        **Description:**
            This function returns parameters from View objects. Requires a Get before use.
        **Remarks/Usage:**
            None
        **Output:**
            **pdPointHeight:** The size of the text\n
            **pbBold:** If True if text is Bold, otherwise returns False\n
            **pbItalic:** If True if text is Italicized, otherwise returns False\n
            **ppcName:** Name of Font\n
        **Return Code:** True\n
        :type pdPointHeight: int

        :type pbBold: bool

        :type pbItalic: bool

        :type ppcName: str

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetModelDataContourForm(self, peForm) -> Any:
        """
        **Description:**
            Determines the current option specified for Show As in the Contour Model Data dialog box, which can be Contour, Criteria, or Beam Diagram.
        **Remarks/Usage:**
            Used in conjunction with GetModelDataContourType to determine many of the options currently being used for a plot of model data or discrete values.
        **Output:**
            **peForm:** Option currently set for Show As, which will be one of these options:\n
        **Return Code:** True\n
        :type peForm: Any

        """
        ...

    def GetModelDataContourType(self, eVMDC, ePropType, eMatlType, iLocation) -> Any:
        """
        **Description:**
            Determines the type of model data from the tree structure in the Contour Data From section of the Contour Model Data dialog box currently being displayed. This option can also be used for a Discrete Value plot.
        **Remarks/Usage:**
            Used in conjunction with GetModelDataContourFrom to determine many of the options currently being used for a plot of model data or discrete values.
        **Output:**
            **eVMDC:** Used to determine which model data item is currently displayed as a contour, criteria, beam diagram. See Section 5.78.1.3, "Model Contour Data Types" for more information about selecting the appropriate model data item. If any method other than FVMDC_MATL_TABLE or FVMDC_PROP_TABLE is returned, that is the only value needed to know what model data is plotted.\n
            **ePropType:** Only used when zMDCType returns FVMDC_PROP_TABLE. Indicates the element/property type being used by the index value returned for in iLocation (See Element Typesin Section 3.3.7, "FEMAP Constants")\n
            **eMatlType:** Only used when zMDCType returns FVMDC_MATL_TABLE. Indicates the material type being used by the index value returned for in iLocation (See Element Typesin Section 3.3.7, "FEMAP Constants")\n
        **Return Code:** True\n
        :type eVMDC: Any

        :type ePropType: Any

        :type eMatlType: Any

        """
        ...

    def GetMultiGroupList(self, nGroup, nGroupID) -> Any:
        """
        **Description:**
            This method retrieves the group ids used in the current view for the Multi Group Display.
        **Remarks/Usage:**
            None
        **Output:**
            **nGroup:** Number of groups in nGroupID\n
            **nGroupID:** The group IDs that have been referenced in Multi Group display (Positive ID value = Shown, Negative ID value = Hidden)\n
        **Return Code:** True\n
        :type nGroup: int

        :type nGroupID: tuple[int]

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Initialize(self) -> Any:
        """
        **Description:**
            This initializes a view object to the default settings.
        **Remarks/Usage:**
            View Objects have many properties, and it is difficult and time consuming to initialize them all individually. This method initializes the object just like creating a new view in FEMAP with the default view settings. You can then selectively modify just the properties that you need.
        **Return Code:** False\n
        """
        ...

    def IsLayerVisible(self, layerID) -> Any:
        """
        **Description:**
            Indicates whether the selected layer is in the visible layer list.
        **Remarks/Usage:**
            The current object must be loaded with a view that is visible on the screen.
        **Input:**
            **layerID:** ID of layer to check.\n
        **Return Code:** True\n
        :type layerID: int

        """
        ...

    def Label(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Light(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def LogoLocation(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def PostTitlesLocation(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevCenter(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevRotation(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Redraw(self) -> Any:
        """
        **Description:**
            Redraws the current view.
        **Remarks/Usage:**
            The current object must be loaded with a view that is visible on the screen. Same as the View, Redrawcommand.
        **Return Code:** False\n
        """
        ...

    def Regenerate(self) -> Any:
        """
        **Description:**
            Regenerates the current view.
        **Remarks/Usage:**
            The current object must be loaded with a view that is visible on the screen. Same as the View, Regenerate command.
        **Return Code:** False\n
        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def Rotate(self, oX, oY, oZ, dX, dY, dZ, angle) -> Any:
        """
        **Description:**
            Rotates the current view around the specified axis.
        **Remarks/Usage:**
            The current object must be loaded with a view from your model.
        **Input:**
            **oX:** The origin of the axis of rotation - in global rectangular coordinates.\n
            **oY:** REAL8 oZ\n
            **oZ:** REAL8 dX\n
            **dX:** The components of the axis of rotation.\n
            **dY:** REAL8 dZ\n
            **dZ:** REAL8 angle\n
            **angle:** The angle of rotation, in degrees.\n
        **Return Code:** False\n
        :type oX: float

        :type oY: float

        :type oZ: float

        :type dX: float

        :type dY: float

        :type dZ: float

        :type angle: float

        """
        ...

    def RotationCenter(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def RotationVector(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Section2Base(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Section2Normal(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Section3Base(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Section3Normal(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def SectionBase(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def SectionNormal(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetAxisLocation(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetClipPlaneNormal(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetClipPlaneOrigin(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetColorMode(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetContourColor(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetContourLegendLocation(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetContourVecDir(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetContourVecID1V2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetContourVecID2V2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetContourVecID3V2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetContourVecOn(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetDraw(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetFontData(self, dPointHeight, bBold, bItalic, pcName) -> Any:
        """
        **Description:**
            This function sets parameters on View objects. Requires a Put after use to update View object.
        **Remarks/Usage:**
            None
        **Input:**
            **dPointHeight:** The size of the text\n
            **bBold:** If True if text is Bold, otherwise returns False\n
            **bItalic:** If True if text is Italicized, otherwise returns False\n
            **pcName:** Name of Font\n
        **Return Code:** True\n
        :type dPointHeight: int

        :type bBold: bool

        :type bItalic: bool

        :type pcName: str

        """
        ...

    def SetFunction(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetLabel(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetLayerVisible(self, layerID, Visible) -> Any:
        """
        **Description:**
            Adds or removes layers from the visible layer list.
        **Remarks/Usage:**
            The current object must be loaded with a view that is visible on the screen.
        **Input:**
            **layerID:** ID of layer to modify.\n
            **Visible:** Set to True to make the layer visible, False to remove it from the visible list.\n
        **Return Code:** False\n
        :type layerID: int

        :type Visible: bool

        """
        ...

    def SetLight(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetLogoLocation(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetModelDataContourForm(self, eForm) -> Any:
        """
        **Description:**
            Specifies the Show As option in the Contour Model Data dialog box, which can be Contour, Criteria, or Beam Diagram.
        **Remarks/Usage:**
            Used in conjunction with SetModelDataContourType to display the desired model data as a contour, criteria, or beam diagram plot.
        **Input:**
            **eForm:** Specify an option for Show As, from these options:\n
        **Return Code:** True\n
        :type eForm: Any

        """
        ...

    def SetModelDataContourType(self, eType, ePropType, eMatlType, iLocation) -> Any:
        """
        **Description:**
            Selects the type of model data to display from the tree structure in the Contour Data From section of the Contour Model Data dialog box. This option can also be used for a Discrete Value plot.
        **Remarks/Usage:**
            Used in conjunction with SetModelDataContourForm to display the desired model data as a contour, criteria, or beam diagram plot. To plot discrete values, set the ModelDataContourOn property on the View object to True and use ModelDataContourSetID to select an appropriate discrete value set.
        **Input:**
            **eType:** Used to specify which model data item to display as a contour, criteria, beam diagram. See Section 5.78.1.3, "Model Contour Data Types"for more information about selecting the appropriate model data item. If using any option other than FVMDC_MATL_TABLE or FVMDC_PROP_TABLE, all other arguments in this method are ignored.\n
            **ePropType:** Only used when zMDCType is set to FVMDC_PROP_TABLE. Indicates the element/property type to use for the index value specified in iLocation (See Element Typesin Section 3.3.7, "FEMAP Constants")\n
            **eMatlType:** Only used when zMDCType is set to FVMDC_MATL_TABLE. Indicates the material type to use for the index value specified in iLocation (See Material Typesin Section 3.3.7, "FEMAP Constants")\n
        **Return Code:** True\n
        :type eType: Any

        :type ePropType: Any

        :type eMatlType: Any

        """
        ...

    def SetMultiGroupList(self, bClear, nGroups, nGroupID) -> Any:
        """
        **Description:**
            This method sets the group ids to be used in the current view for the Multi Group Display.
        **Remarks/Usage:**

        **Return Code:** False\n
        """
        ...

    def SetMultiGroupListFromSets(self, bClear, nShowSetID, nHideSetID) -> Any:
        """
        :type bClear: Any
        :type nShowSetID: Any
        :type nHideSetID: Any
        """
        ...

    def SetPostTitlesLocation(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPrevCenter(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPrevRotation(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetRotationCenter(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetRotationVector(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetSection2Base(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetSection2Normal(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetSection3Base(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetSection3Normal(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetSectionBase(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetSectionNormal(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetSpotlightDir(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetStreamLineLocation(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetTransformPlateVector(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetUserContourLevel(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetUserContourPalette(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetUserContourValue(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetViewLegendLocation(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetXYOutputDataV2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetXYOutputEntity(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetXYOutputSet(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetXYScale(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetXYSetRange(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setcenter(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setcolor(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setrotation(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SpotlightDir(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def StreamLineLocation(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def TransformPlateVector(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def UserContourLevel(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def UserContourPalette(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def UserContourValue(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ViewLegendLocation(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Visible(self, Visible) -> Any:
        """
        **Description:**
            This makes a view visible on the screen, or removes it from the screen.
        **Remarks/Usage:**
            This method accomplishes the same task as the View, Activate command.
        **Input:**
            **Visible:** Set to True to make a view visible, False to remove it.\n
        **Return Code:** True\n
        :type Visible: bool

        """
        ...

    def XYOutputDataV2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def XYOutputEntity(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def XYOutputSet(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def XYScale(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def XYSetRange(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def center(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def color(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def rotation(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class ViewOrient:
    CLSID: Any
    Active: Any
    AspectRatio: Any
    AutoAspectRatio: Any
    ID: Any
    Magnification: Any
    ModelAlwaysInFront: Any
    Perspective: Any
    PerspectiveAngle: Any
    RotationAxesOption: Any
    RotationCenterOption: Any
    RotationCoordSys: Any
    SecondaryRotationAxesOption: Any
    SetID: Any
    SingleAxis: Any
    vCenter: Any
    vRotationCenter: Any
    vRotationVector: Any

    def CoordSysRotation(self, iCoordSys, qUseCenter, dX, dY, dZ) -> Any:
        """
        **Description:**
            Enables Model Always in Front of Viewer option (ModelAlwaysInFront=True), sets Rotation Axesto Coordinate System (RotationAxisOption=2), sets the specified Coordinate System in the drop-down (RotationCoordSys=iCoordSys), and sets Rotation Center to Coordinate System (RotationCenterOption=2). When qUseCenter Boolean is set to True, sets Rotation Center to Location (RotationCenterOption=3) and the additional arguments are used to provide X (RotationCenter[0]), Y (RotationCenter[1]), and Z (RotationCenter[2]) coordinates for the rotation center.
        **Remarks/Usage:**
            This function provides similar functionality to the View, Rotate, Rotate Around Coordinate System command.
        **Input:**
            **iCoordSys:** ID of Coordinate System to rotate around\n
            **qUseCenter:** When True, sets Rotation Centerto Locationin the Advanced Rotation Optionsdialog box and use the coordinates specified in dX, dY, and dZ as the location of the rotations center.\n
            **dX:** X coordinate of Rotation Center (only used when qUseCenter=True)\n
            **dY:** Y coordinate of Rotation Center (only used when qUseCenter=True)\n
            **dZ:** Z coordinate of Rotation Center (only used when qUseCenter=True)\n
        **Return Code:** False\n
        :type iCoordSys: int

        :type qUseCenter: bool

        :type dX: float

        :type dY: float

        :type dZ: float

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetEyeDirection(self, pdEyeX, pdEyeY, pdEyeZ, pdRightX, pdRightY, pdRightZ) -> Any:
        """
        **Description:**
            Returns the coordinates of eye direction vector and right direction vector from the view
        **Remarks/Usage:**
            These values can be reviewed in the User Interface using the View, Align, Eye and Directions command
        **Output:**
            **pdEyeX:** X coordinate of Eye direction vector\n
            **pdEyeY:** Y coordinate of Eye direction vector \n
            **pdEyeZ:** Z coordinate of Eye direction vector\n
            **pdRightX:** X coordinate of Right direction vector\n
            **pdRightY:** Y coordinate of Right direction vector \n
            **pdRightZ:** Z coordinate of Right direction vector\n
        **Return Code:** False\n
        :type pdEyeX: float

        :type pdEyeY: float

        :type pdEyeZ: float

        :type pdRightX: float

        :type pdRightY: float

        :type pdRightZ: float

        """
        ...

    def GetFirstPathID(self, piPathID) -> Any:
        """
        **Description:**
            Gets the first ID of the stored play backs.
        **Remarks/Usage:**
            None
        **Output:**
            **piPathID:** The ID of the first path. \n
        **Return Code:** False\n
        :type piPathID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetNextPathID(self, piPathID) -> Any:
        """
        **Description:**
            Gets the next ID of the stored play backs.
        **Remarks/Usage:**
            None
        **Output:**
            **piPathID:** The ID of the next path. \n
        **Return Code:** False\n
        :type piPathID: int

        """
        ...

    def GetRotationAngles(self, pdX, pdY, pdZ) -> Any:
        """
        **Description:**
            Returns the orientation of the view currently loaded in the ViewOrient object in Euler angles relative to the Basic Rectangular Coordinate System
        **Remarks/Usage:**
            This function returns the X, Y, and/or Zvalues that are displayed when using the View, Rotate, Modelcommand and Rotate Around is set to 0..Basic Rectangular.
        **Output:**
            **pdX:** X angle in degrees (-179.9999 to 180.0)\n
            **pdY:** Y angle in degrees (-179.9999 to 180.0)\n
            **pdZ:** Z angle in degrees (-179.9999 to 180.0)\n
        **Return Code:** False\n
        :type pdX: float

        :type pdY: float

        :type pdZ: float

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def ModelRotation(self, qUseCenter, dX, dY, dZ) -> Any:
        """
        **Description:**
            Enables Model Always in Front of Viewer option (ModelAlwaysInFront=True), sets Rotation Axesto Model Axes (RotationAxisOption=1), and sets Rotation Center to View Center (RotationCenterOption=0). When qUseCenter Boolean is set to True, sets Rotation Center to Location (RotationCenterOption=3) and the additional arguments are used to provide X (RotationCenter[0]), Y (RotationCenter[1]), and Z (RotationCenter[2]) coordinates for the rotation center.
        **Remarks/Usage:**
            This function provides similar functionality to the View, Rotate, Rotate About View Center; View, Rotate, Rotate About Rotation Center; and View, Rotate, Rotate Around Model Axis commands.
        **Input:**
            **qUseCenter:** When True, sets Rotation Centerto Locationin the Advanced Rotation Optionsdialog box and use the coordinates specified in dX, dY, and dZ as the location of the rotations center.\n
            **dX:** X coordinate of Rotation Center (only used when qUseCenter=True)\n
            **dY:** Y coordinate of Rotation Center (only used when qUseCenter=True)\n
            **dZ:** Z coordinate of Rotation Center (only used when qUseCenter=True)\n
        **Return Code:** False\n
        :type qUseCenter: bool

        :type dX: float

        :type dY: float

        :type dZ: float

        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def PlaybackDelete(self, iPathID) -> Any:
        """
        :type iPathID: Any
        """
        ...

    def PlaybackNext(self) -> Any:
        """
        """
        ...

    def PlaybackStart(self, iViewID, iPathID) -> Any:
        """
        :type iViewID: Any
        :type iPathID: Any
        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def RecordEnd(self) -> Any:
        """
        """
        ...

    def RecordStart(self, nMaxFrames, iViewID, iPathID) -> Any:
        """
        :type nMaxFrames: Any
        :type iViewID: Any
        :type iPathID: Any
        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def RollThru(self) -> Any:
        """
        **Description:**
            Disables Model Always in Front of Viewer option (ModelAlwaysInFront=False), sets Rotation Axesto View Axis(RotationAxisOption=0), and sets Rotation Center to Screen Center (RotationCenterOption=1).
        **Remarks/Usage:**
            This function provides similar functionality to the View, Rotate, Roll-Thru command.
        **Return Code:** False\n
        """
        ...

    def RotationCenter(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def RotationVector(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetEyeDirection(self, dEyeX, dEyeY, dEyeZ, dRightX, dRightY, dRightZ) -> Any:
        """
        **Description:**
            Sets the coordinates of the eye direction vector and right direction vector to align the view
        **Remarks/Usage:**
            These values are set in the User Interface using the View, Align, Eye and Directions command
        **Input:**
            **dEyeX:** X coordinate of Eye direction vector\n
            **dEyeY:** Y coordinate of Eye direction vector \n
            **dEyeZ:** Z coordinate of Eye direction vector\n
            **dRightX:** X coordinate of Right direction vector\n
            **dRightY:** Y coordinate of Right direction vector \n
            **dRightZ:** Z coordinate of Right direction vector\n
        **Return Code:** False\n
        :type dEyeX: float

        :type dEyeY: float

        :type dEyeZ: float

        :type dRightX: float

        :type dRightY: float

        :type dRightZ: float

        """
        ...

    def SetRotationAngles(self, dX, dY, dZ) -> Any:
        """
        **Description:**
            Set the orientation of the view currently loaded in the ViewOrient object by specifying Euler angles relative to the Basic Rectangular Coordinate System
        **Remarks/Usage:**
            This function provides similar functionality to the View, Rotate, Modelcommand when Rotate Aroundis set to 0..Basic Rectangular and values are entered for X, Y, and/or Z. Also, if values are entered outside the expected range, they will automatically be converted to values within the range.
        **Input:**
            **dX:** X angle in degrees (-179.9999 to 180.0)\n
            **dY:** Y angle in degrees (-179.9999 to 180.0)\n
            **dZ:** Z angle in degrees (-179.9999 to 180.0)\n
        **Return Code:** False\n
        :type dX: float

        :type dY: float

        :type dZ: float

        """
        ...

    def SetRotationCenter(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetRotationVector(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setcenter(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SnapToAxes(self) -> Any:
        """
        **Description:**
            Automatically aligns the view to the closest orthogonal axes relative to current model orientation.
        **Remarks/Usage:**
            This call is used in the Custom Tools, Views, Snap to Closest Orthogonal View command.
        **Return Code:** False\n
        """
        ...

    def Spin(self, nFrames, dX, dY, dZ, dVX, dVY, dVZ, pdFPS) -> Any:
        """
        **Description:**
            This function measures the speed of dynamic rotation as well as spins the active model.
        **Remarks/Usage:**
            A portion of these values are set in the User Interface using the View, Rotate, Spin Around Vector command
        **Input:**
            **nFrames:** Sets the number of Frames to spin. When nFrames=0 the model will remain spinning until you click anywhere in the interface or graphics window.\n
            **dX:** X coordinate of Rotation Center\n
            **dY:** Y coordinate of Rotation Center\n
            **dZ:** Z coordinate of Rotation Center\n
            **dVX:** X coordinate of Rotation vector \n
            **dVY:** Y coordinate of Rotation vector\n
            **dVZ:** Z coordinate of Rotation vector\n
        **Output:**
            **pdFPS:** Frames per second.\n
        **Return Code:** False\n
        :type nFrames: int

        :type dX: float

        :type dY: float

        :type dZ: float

        :type dVX: float

        :type dVY: float

        :type dVZ: float

        :type pdFPS: float

        """
        ...

    def VectorRotation(self, dX, dY, dZ, dVX, dVY, dVZ) -> Any:
        """
        **Description:**
            Enables Model Always in Front of Viewer option (ModelAlwaysInFront=True), sets Rotation Axesto Vector(RotationAxisOption=3), and sets Rotation Center to Location (RotationCenterOption=3). The arguments are used to provide X (RotationCenter[0]), Y (RotationCenter[1]), and Z (RotationCenter[2]) coordinates for the rotation center (base of vector) and X (RotationVector[0]), Y (RotationVector[1]), and Z (RotationVector[2]) coordinates of the tip of the vector.
        **Remarks/Usage:**
            This function provides similar functionality to the View, Rotate, Rotate Around Vector command.
        **Input:**
            **dX:** X coordinate of Rotation Center\n
            **dY:** Y coordinate of Rotation Center\n
            **dZ:** Z coordinate of Rotation Center\n
            **dVX:** X coordinate of Rotation Vector\n
            **dVY:** Y coordinate of Rotation Vector\n
            **dVZ:** Z coordinate of Rotation Vector\n
        **Return Code:** False\n
        :type dX: float

        :type dY: float

        :type dZ: float

        :type dVX: float

        :type dVY: float

        :type dVZ: float

        """
        ...

    def ViewRotation(self, qUseCenter, dX, dY, dZ) -> Any:
        """
        **Description:**
            Enables Model Always in Front of Viewer option (ModelAlwaysInFront=True), sets Rotation Axesto View Axes (RotationAxisOption=0), and sets Rotation Center to View Center (RotationCenterOption=0). When qUseCenter Boolean is set to True, sets Rotation Center to Location (RotationCenterOption=3) and the additional arguments are used to provide X (RotationCenter[0]), Y (RotationCenter[1]), and Z (RotationCenter[2]) coordinates for the rotation center.
        **Remarks/Usage:**
            This function provides similar functionality to the View, Rotate, Rotate About View Center; View, Rotate, Rotate About Rotation Center; and View, Rotate, Rotate Around View Axis commands.
        **Input:**
            **qUseCenter:** When True, sets Rotation Centerto Locationin the Advanced Rotation Optionsdialog box and use the coordinates specified in dX, dY, and dZ as the location of the rotations center.\n
            **dX:** X coordinate of Rotation Center (only used when qUseCenter=True)\n
            **dY:** Y coordinate of Rotation Center (only used when qUseCenter=True)\n
            **dZ:** Z coordinate of Rotation Center (only used when qUseCenter=True)\n
        **Return Code:** False\n
        :type qUseCenter: bool

        :type dX: float

        :type dY: float

        :type dZ: float

        """
        ...

    def center(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class text:
    CLSID: Any
    Active: Any
    AllViews: Any
    BackColor: Any
    BorderColor: Any
    DrawBorder: Any
    DrawPointer: Any
    FontNumber: Any
    HorzJustify: Any
    ID: Any
    ModelPosition: Any
    SetID: Any
    VertJustify: Any
    VisibleView: Any
    color: Any
    layer: Any
    text: Any
    vPointerPosition: Any
    vTextPosition: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetFontData(self, pdPointHeight, pbBold, pbItalic, ppcName) -> Any:
        """
        **Description:**
            This function returns parameters from Text objects. Requires a Get before use.
        **Remarks/Usage:**
            None
        **Output:**
            **pdPointHeight:** The height of the text\n
            **pbBold:** If True if text is Bold, otherwise returns False\n
            **pbItalic:** If True if text is Italicized, otherwise returns False\n
            **ppcName:** Name of Font\n
        **Return Code:** True\n
        :type pdPointHeight: float

        :type pbBold: bool

        :type pbItalic: bool

        :type ppcName: str

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def PointerPosition(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetFontData(self, dPointHeight, bBold, bItalic, pcName) -> Any:
        """
        **Description:**
            This function sets parameters for Text objects. Requires a Put after use to update Text object.
        **Remarks/Usage:**
            None
        **Input:**
            **dPointHeight:** The height of the text\n
            **bBold:** If True if text is Bold. If False text is not Bold\n
            **bItalic:** If True if text is Italicized. If False, text is not Italicized\n
            **pcName:** Name of Font\n
        **Return Code:** True\n
        :type dPointHeight: float

        :type bBold: bool

        :type bItalic: bool

        :type pcName: str

        """
        ...

    def SetPointerPosition(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetTextPosition(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def TextPosition(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class ConnectionProp:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    color: Any
    layer: Any
    plymat: Any
    pmat: Any
    title: Any
    type: Any
    vflag: Any
    vflagI: Any
    vplyval: Any
    vpval: Any

    def ConnectionPropByType(self, bGlue, bAll, nConnectorSetID, bClear) -> Any:
        """
        :type bGlue: Any
        :type bAll: Any
        :type nConnectorSetID: Any
        :type bClear: Any
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetDefaults(self, dContactTolerance) -> Any:
        """
        **Description:**
            This method initializes default values for the connection property.
        **Remarks/Usage:**
            This is a simple method that allows default values to be placed into the object.
        **Input:**
            **dContactTolerance:** Specifies the Max Contact Search Distance for NX Nastran Linear Contact, the Search Distance for NX Nastran Glued Contact, and the Tied Tolerance for NX Nastran Advnaced Nonlinear Contact.\n
        **Return Code:** False\n
        :type dContactTolerance: float

        """
        ...

    def Setflag(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetflagI(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setplyval(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setpval(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def flag(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def flagI(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def plyval(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def pval(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class Connection:
    CLSID: Any
    Active: Any
    ID: Any
    IsCombination: Any
    SetID: Any
    color: Any
    layer: Any
    propID: Any
    title: Any
    vcontact: Any

    def BoundingBox(self, box) -> Any:
        """
        **Description:**
            This method returns the coordinates of a rectangular box that encloses a connector.
        **Remarks/Usage:**
            This method always retrieves a box that is aligned with Global Rectangular coordinates, not an aligned box of minimum volume.
        **Output:**
            **box:** The dimensions of the bounding box, in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type box: tuple[float]

        """
        ...

    def BoundingBoxInCSys(self, nCSysID, box) -> Any:
        """
        **Description:**
            This method returns the coordinates of a rectangular box that encloses a connector, in coordinates of the selected coordinate system
        **Remarks/Usage:**
            This method always retrieves a box that is aligned with the selected coordinate system, not an aligned box of minimum volume.
        **Input:**
            **nCSysID:** ID of coordinate system to return minimum and maximum \n
        **Output:**
            **box:** The dimensions of the bounding box, in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nCSysID: int

        :type box: tuple[float]

        """
        ...

    def CombinationsByType(self, bGlue, bAll, nCombinationSetID, bClear) -> Any:
        """
        **Description:**
            Add the IDs of connector combination(s) (referenced) to a user-created set object based on contact or glued types.
        **Remarks/Usage:**
             In the example below, rc would equal cSet.Count() because cSet starts empty.
        **Input:**
            **bGlue:** If set to False, only connector combination(s) that have referenced connectors with a contact type property will be added to the nConnectorSet. If set to True, only connector combination(s) that have referenced connectors with a glued type property will be added to the set specified by nConnectorSetID.\n
            **bAll:** If set to True, bGlue is ignored and all connector combinations of either type are added to the set specified by nConnectorSetID.\n
            **nCombinationSetID:** The set ID of a FEMAP Set Object to be populated.\n
            **bClear:** If set to True, the set specified by nConnectorSetID will be cleared before new connector combination ID(s) are added.\n
        **Return Code:** True\n
        :type bGlue: bool

        :type bAll: bool

        :type nCombinationSetID: int

        :type bClear: bool

        """
        ...

    def ConnectionsByType(self, bGlue, bAll, nConnectorSetID, bClear) -> Any:
        """
        **Description:**
            Add the IDs of connector(s) to a user-created set object based on contact or glued types.
        **Remarks/Usage:**
            See CombinationsByType for similar example.
        **Input:**
            **bGlue:** If set to False, only connector(s) with a contact type property will be added to the nConnectorSet. If set to True, only connector(s) with a glued type property will be added to the set specified by nConnectorSetID.\n
            **bAll:** If set to True, bGlue is ignored and all connector(s) of either type are added to the set specified by nConnectorSetID.\n
            **nConnectorSetID:** The set ID of a FEMAP Set Object to be populated.\n
            **bClear:** If set to True, the set specified by nConnectorSetID will be cleared before new connector ID(s) are added.\n
        **Return Code:** True\n
        :type bGlue: bool

        :type bAll: bool

        :type nConnectorSetID: int

        :type bClear: bool

        """
        ...

    def Contact(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Enable(self, bEnable) -> Any:
        """
        **Description:**
            This method enables and disables connections
        **Remarks/Usage:**
            Enabled connections are translated for analysis, disabled ones are not.
        **Input:**
            **bEnable:** Enable connection if True, disables it if False\n
        **Return Code:** False\n
        :type bEnable: bool

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetCombinations(self, nCombinationSetID) -> Any:
        """
        **Description:**
            Populates a set object with the IDs of all connector combinations (referenced set) that use one particular connector.
        **Remarks/Usage:**
            This call must be proceeded by a .Get on any valid connector object. The set specified by nCombinationSetID is always cleared before populating.
        **Input:**
            **nCombinationSetID:** The ID of a set to populate with the ID(s) of all connector combinations (connector referenced sets) the connector exists in.\n
        **Return Code:** True\n
        :type nCombinationSetID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def IsEnabled(self) -> Any:
        """
        **Description:**
            This method indicates whether a connection is enabled
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def IsGlueConnector(self, nConnectorID) -> Any:
        """
        **Description:**
            Determines if connector has a glued property type or not.
        **Remarks/Usage:**
            None
        **Input:**
            **nConnectorID:** The ID of the connector to check.\n
        **Return Code:** True\n
        :type nConnectorID: int

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Prop(self) -> Any:
        """
        **Description:**
            This method creates and returns a Connection Property object that is loaded with the property data referenced by a connection
        **Remarks/Usage:**

        **Return Code:** False\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetContact(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...


class Scratch:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any

    def Debug(self) -> Any:
        """
        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def Exist(self, entID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **entID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SetbData(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetnData(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetpData(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetrData(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def bData(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def clear(self) -> Any:
        """
        """
        ...

    def nData(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def pData(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def rData(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class Selector:
    CLSID: Any
    Active: Any
    AddMode: Any
    DrillMode: Any
    MultipleMode: Any
    RelatedMode: Any
    SelectEntity: Any
    ShowInModelInfo: Any

    def Add(self, entityTYPE, nID) -> Any:
        """
        **Description:**
            This method adds an entity to the selector.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entity to add.\n
            **nID:** The ID of the entity of entityType to add\n
        **Return Code:** False\n
        :type entityTYPE: int

        :type nID: int

        """
        ...

    def AddSet(self, entityTYPE, nSetD, bUpdateDataTable) -> Any:
        """
        **Description:**
            This method adds multiple entities to the selector.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entity to add.\n
            **nSetD:** The ID of a Set object that contains the list of IDs of the entities to add.\n
            **bUpdateDataTable:** If True, the selected entities are automatically added to the Data Table.\n
        **Return Code:** False\n
        :type entityTYPE: int

        :type nSetD: int

        :type bUpdateDataTable: bool

        """
        ...

    def ClearAll(self) -> Any:
        """
        **Description:**
            This method clears all entities of any type from the Selector
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def Copy(self) -> Any:
        """
        **Description:**
            This method copies all selected entities to the Clipboard.
        **Remarks/Usage:**
            The entities are copied in FEMAP Neutral format and can then be pasted into another model.
        **Return Code:** False\n
        """
        ...

    def Count(self, entityTYPE, nSelected) -> Any:
        """
        **Description:**
            This method returns the number of entities of a given type that are currently selected
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The entity type to query\n
        **Output:**
            **nSelected:** The number of entityType entities that are currently selected.\n
        **Return Code:** False\n
        :type entityTYPE: int

        :type nSelected: int

        """
        ...

    def GetSelected(self, entityTYPE) -> Any:
        """
        **Description:**
            This method creates and returns a Set object that contains the IDs of all entities of a specified type that are currently selected.
        **Remarks/Usage:**
            The Set object is returned in place of the return code.
        **Input:**
            **entityTYPE:** The type of entity that will be queried.\n
        **Return Code:** False\n
        :type entityTYPE: int

        """
        ...

    def GetSelectedID(self, entityTYPE, nNumSelected, pnSelectedID) -> Any:
        """
        **Description:**
            This method returns the number of entities of a specified type and fills an array which contains the IDs of all entities of a specified type that are currently selected.
        **Remarks/Usage:**
            None
        **Output:**
            **nNumSelected:** The number of entries in the nSelectedID array.\n
            **pnSelectedID:** The IDs of the entities of the specified type currently in the Selector object.\n
        **Return Code:** False\n
        :type nNumSelected: int

        :type pnSelectedID: tuple[int]

        """
        ...

    def Grow(self) -> Any:
        """
        **Description:**
            This method grows the current selection by adding adjacent entities
        **Remarks/Usage:**
            This method automatically enables Multiple Mode. It is the same as calling the Grow command on the selector toolbar.
        **Return Code:** False\n
        """
        ...

    def LoadGroup(self, groupID) -> Any:
        """
        **Description:**
            This method adds the specified group to the selection
        **Remarks/Usage:**
            This Method automatically enables Multiple Mode. It does not clear the current selection before adding the group.
        **Input:**
            **groupID:** The ID of the group to load\n
        **Return Code:** True\n
        :type groupID: int

        """
        ...

    def Paste(self, bShowDlg) -> Any:
        """
        **Description:**
            This method pastes entities from the Clipboard into the current model.
        **Remarks/Usage:**
            Data on the clipboard must be in FEMAP Neutral format, as placed there by the Selector Copy command/method.
        **Return Code:** False\n
        """
        ...

    def SaveGroup(self, groupID) -> Any:
        """
        **Description:**
            This method saves the current selection as a group
        **Remarks/Usage:**
            None
        **Input:**
            **groupID:** The ID of the group to create\n
        **Return Code:** True\n
        :type groupID: int

        """
        ...

    def SelectBox(self) -> Any:
        """
        **Description:**
            This method displays the box selection dialog.
        **Remarks/Usage:**
            This method automatically enables Multiple Mode
        **Return Code:** False\n
        """
        ...

    def SelectCircle(self) -> Any:
        """
        **Description:**
            This method displays the circle selection dialog.
        **Remarks/Usage:**
            This method automatically enables Multiple Mode
        **Return Code:** False\n
        """
        ...

    def SelectFreehand(self) -> Any:
        """
        **Description:**
            This method displays the freehand selection dialog.
        **Remarks/Usage:**
            This method automatically enables Multiple Mode
        **Return Code:** False\n
        """
        ...

    def SelectPolygon(self) -> Any:
        """
        **Description:**
            This method displays the polygon selection dialog.
        **Remarks/Usage:**
            This method automatically enables Multiple Mode
        **Return Code:** False\n
        """
        ...

    def Show(self, bShowAll) -> Any:
        """
        **Description:**
            This method shows the current selection
        **Remarks/Usage:**
            None
        **Input:**
            **bShowAll:** If True, all selected entities are shown. If False, only those of the active type (specified by the SelectEntity property) are shown.\n
        **Return Code:** False\n
        :type bShowAll: bool

        """
        ...

    def Shrink(self) -> Any:
        """
        **Description:**
            This method shrinks the current selection by removing outer entities
        **Remarks/Usage:**
            This method automatically enables Multiple Mode. It is the same as calling the Shrink command on the selector toolbar.
        **Return Code:** False\n
        """
        ...

    def Tooltips(self, bOn, bIncludeLayersAndGroups) -> Any:
        """
        **Description:**
            This method will turn on or turn off the Show Tooltips and Layers/Groups in Tooltips options in the Select Toolbar
        **Remarks/Usage:**
            The bOn option must be set to True for a Tooltip to be shown (i.e., having only bIncludeLayersAndGroups set to True will not show a Tooltip containing only the Layer and Group information for an entity).
        **Input:**
            **bOn:** If True, the Show Tooltips option will be turned on. If False, the Show Tooltips options will be turned off.\n
        **Return Code:** False\n
        :type bOn: bool

        """
        ...

    def UpdateDataTable(self) -> Any:
        """
        **Description:**
            This method adds the current selection to the Data Table
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def clear(self, entityTYPE) -> Any:
        """
        **Description:**
            This method clears all entities of the specified type from the Selector
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The entity type to remove from the selector.\n
        **Return Code:** False\n
        :type entityTYPE: int

        """
        ...


class LoadDefinition:
    CLSID: Any
    Active: Any
    DataType: Any
    ID: Any
    SetID: Any
    loadType: Any
    title: Any

    def CountLoads(self) -> Any:
        """
        **Description:**
            This method returns the number of loads referenced by a load definition, as a return code.
        **Remarks/Usage:**
            This method relies on the current Load Definition ID to count the referenced loads
        **Return Code:** True\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def IsTotalLoad(self) -> Any:
        """
        **Description:**
            This method indicates whether the current load definition represents a total load applied to geometry.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextLoad(self, pDispatch) -> Any:
        """
        **Description:**
            This method returns the next available load that is contained in the Load Definition
        **Remarks/Usage:**
            This method, coupled with ResetNextLoad provides an easy way to retrieve all loads from a Load Definition.
        **Output:**
            **pDispatch:** The next load object. Depending on the type of the load definition this could be a LoadGeom, LoadMesh, LoadNTemp or LoadGeom object\n
        **Return Code:** True\n
        :type pDispatch: Any

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutAll(self, entID, enDataType, enLoadType, sTitle) -> Any:
        """
        **Description:**
            This method stores a Load Definition with the specified ID along with all the available options.
        **Remarks/Usage:**
            Unlike the standard Put method, this function loads all of the properties as arguments. If you are updating all of the properties before storing an entity, this function will be faster than multiple calls to load each property individually.
        **Input:**
            **entID:** The ID of the Load Definition to store.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def ResetNextLoad(self) -> Any:
        """
        **Description:**
            This method initializes all options prior to calling the NextLoad method below
        **Remarks/Usage:**
            This method is used prior to calling NextLoad to specify which loads will be retrieved. It simply resets this object so that the next call to NextLoad will return the first load available in the object.
        **Return Code:** True\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetTotalLoad(self, bTotalLoad) -> Any:
        """
        **Description:**
            This method sets whether the current load definition is a total load applied on the geometry.
        **Remarks/Usage:**
            None
        **Input:**
            **bTotalLoad:** If TRUE, load is set to total load. \n
        **Return Code:** True\n
        :type bTotalLoad: bool

        """
        ...


class BCDefinition:
    CLSID: Any
    Active: Any
    DataType: Any
    ID: Any
    OnType: Any
    SetID: Any
    title: Any

    def CountBCs(self) -> Any:
        """
        **Description:**
            This method returns the number of constraints referenced by a constraint definition, as a return code.
        **Remarks/Usage:**
            This method relies on the current Constraint Definition ID to count the referenced constraints
        **Return Code:** True\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextBC(self, pDispatch) -> Any:
        """
        **Description:**
            This method returns the next available constraint that is contained in the Constraint Definition
        **Remarks/Usage:**
            This method, coupled with ResetNextBC provides an easy way to retrieve all constraints from a Constraint Definition.
        **Output:**
            **pDispatch:** The next constraint object. Depending on the type of the constraint definition this could be a BCNode, BCGeom or BEqn object\n
        **Return Code:** True\n
        :type pDispatch: Any

        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutAll(self, entID, enDataType, enOnType, sTitle) -> Any:
        """
        **Description:**
            This method stores a Constraint Definition with the specified ID along with all the available options.
        **Remarks/Usage:**
            Unlike the standard Put method, this function loads all of the properties as arguments. If you are updating all of the properties before storing an entity, this function will be faster than multiple calls to load each property individually.
        **Input:**
            **entID:** The ID of the Constraint Definition to store.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def ResetNextBC(self) -> Any:
        """
        **Description:**
            This method initializes all options prior to calling the NextBC method below
        **Remarks/Usage:**
            This method is used prior to calling NextBC to specify which constraints will be retrieved. It simply resets this object so that the next call to NextBC will return the first constraint available in the object.
        **Return Code:** True\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class GFXPoint:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    color: Any
    layer: Any
    symbol: Any
    vXYZ: Any
    x: Any
    y: Any
    z: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteAll(self, bAllSets, nSetID) -> Any:
        """
        **Description:**
            Deletes all GFXPoints in one or more sets
        **Remarks/Usage:**
            None
        **Input:**
            **bAllSets:** If True, all entities, in all sets are deleted. If False, then all entities in Set nSetID are deleted\n
            **nSetID:** The setID to delete if bAllSets=False\n
        **Return Code:** True\n
        :type bAllSets: bool

        :type nSetID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutAll(self, entID, x, y, z, layer, color, symbol) -> Any:
        """
        **Description:**
            This method stores an entity with the specified ID.
        **Remarks/Usage:**
            Unlike the standard Put method, this function loads all of the properties as arguments. If you are updating all of the properties before storing an entity, this function will be faster than multiple calls to load each property individually.
        **Input:**
            **entID:** The ID of the entity to store.\n
            **x, y, z, layer, color, symbol:** Refer to the property descriptions for each of these items.\n

        **Return Code:** True\n
        :type entID: int
        :type x: float
        :type y: float
        :type z: float
        :type layer: int
        :type color: int
        :type symbol: int

        """
        ...

    def PutAllArray(self, numPoint, entID, xyz, layer, color, symbol) -> Any:
        """
        **Description:**
            This method stores multiple GFXPoint entities with the specified data.
        **Remarks/Usage:**
            This is the fastest Put method if you have a large number of items to create, but still need full control over all options. All data can be accumulated in arrays and then transferred in one call.
        **Input:**
            **numPoint:** The number of GFXPoints to create (i.e. the number of entries in the arrays)\n
            **entID:** The IDs of the GFXPoints to store.\n
            **xyz, layer, color, symbol:** Refer to the property descriptions for each of these items. xyz is an array of the entity coordinates. In the array, there must be 3 entries for a entity, followed by the 3 for the next entity, ... . All must be in global rectangular coordinates.\n
        **Return Code:** True\n
        :type numPoint: int
        :type entID: tuple[int]
        :type xyz: tuple[float]
        :type layer: tuple[int]
        :type color: tuple[int]
        :type symbol: tuple[int]

        """
        ...

    def PutCoordArray(self, numPoint, xyz, layer, color, symbol) -> Any:
        """
        **Description:**
            This is a simpler version of PutAllArray that allows multiple entities to be stored.
        **Remarks/Usage:**
            This method is even faster than PutAllArray, and requires less memory, it does not however give you full control. Entities are simply stored in the next available ID, and the same layer, color... are used for every entity - only the coordinates are input as an array.
        **Input:**
            **xyz, layer, color, symbol:** Refer to the property descriptions for each of these items. xyz is an array of the entity coordinates. In the array, there must be 3 entries for a entity, followed by the 3 for the next entity, ... . All must be in global rectangular coordinates.\n

        **Return Code:** True\n
        :type numPoint: int
        :type xyz: tuple[float]
        :type layer: int
        :type color: int
        :type symbol: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def Setxyz(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def xyz(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class GFXLine:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    color: Any
    layer: Any
    vXYZ: Any
    x1: Any
    x2: Any
    y1: Any
    y2: Any
    z1: Any
    z2: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteAll(self, bAllSets, nSetID) -> Any:
        """
        **Description:**
            Deletes all GFXLines in one or more sets
        **Remarks/Usage:**
            None
        **Input:**
            **bAllSets:** If True, all entities, in all sets are deleted. If False, then all entities in Set nSetID are deleted\n
            **nSetID:** The setID to delete if bAllSets=False\n
        **Return Code:** True\n
        :type bAllSets: bool

        :type nSetID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutAll(self, entID, x1, y1, z1, x2, y2, z2, layer, color) -> Any:
        """
        **Description:**
            This method stores an entity with the specified ID.
        **Remarks/Usage:**
            Unlike the standard Put method, this function loads all of the properties as arguments. If you are updating all of the properties before storing an entity, this function will be faster than multiple calls to load each property individually.
        **Input:**
            **entID:** The ID of the entity to store.\n
            **x1, y1, z1, x2, y2, z2, layer, color:** Refer to the property descriptions for each of these items.\n
        **Return Code:** True\n
        :type entID: int

        :type y1: float

        :type z1: float

        :type x2: float

        :type y2: float

        :type z2: float

        :type layer: int

        :type color: int

        """
        ...

    def PutAllArray(self, numLine, entID, xyz, layer, color) -> Any:
        """
        **Description:**
            This method stores multiple GFXLine entities with the specified data.
        **Remarks/Usage:**
            This is the fastest Put method if you have a large number of items to create, but still need full control over all options. All data can be accumulated in arrays and then transferred in one call.
        **Input:**
            **numLine:** The number of GFXLines to create (i.e. the number of entries in the arrays)\n
            **entID:** The IDs of the GFXLines to store.\n
            **xyz, layer, color:** Refer to the property descriptions for each of these items. xyz is an array of the entity coordinates. In the array, there must be 6 entries for a entity (3 for the first end then 3 for the second end), followed by the 6 for the next entity, ... . All must be in global rectangular coordinates.\n

        **Return Code:** True\n
        :type numLine: int

        :type entID: tuple[int]

        :type xyz: tuple[float]

        :type layer: tuple[int]

        :type color: tuple[int]

        """
        ...

    def PutCoordArray(self, numLine, xyz, layer, color) -> Any:
        """
        **Description:**
            This is a simpler version of PutAllArray that allows multiple entities to be stored.
        **Remarks/Usage:**
            This method is even faster than PutAllArray, and requires less memory, it does not however give you full control. Entities are simply stored in the next available ID, and the same layer, color... are used for every entity - only the coordinates are input as an array.
        **Input:**
            **numLine:** The number of GFXLines to create (i.e. the number of entries in the arrays)\n
            **xyz, layer, color:** Refer to the property descriptions for each of these items. xyz is an array of the entity coordinates. In the array, there must be 6 entries for a entity (3 for the first end then 3 for the second end), followed by the 6 for the next entity, ... . All must be in global rectangular coordinates.\n

        **Return Code:** True\n
        :type numLine: int

        :type xyz: tuple[float]

        :type layer: int

        :type color: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def Setxyz(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def xyz(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...


class GFXArrow:
    CLSID: Any
    Active: Any
    ID: Any
    Length: Any
    SetID: Any
    color: Any
    dX: Any
    dY: Any
    dZ: Any
    layer: Any
    lengthmode: Any
    location: Any
    style: Any
    vXYZ: Any
    vdxyz: Any
    x: Any
    y: Any
    z: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteAll(self, bAllSets, nSetID) -> Any:
        """
        **Description:**
            Deletes all GFXArrows in one or more sets
        **Remarks/Usage:**
            None
        **Input:**
            **bAllSets:** If True, all entities, in all sets are deleted. If False, then all entities in Set nSetID are deleted\n
            **nSetID:** The setID to delete if bAllSets=False\n
        **Return Code:** True\n
        :type bAllSets: bool

        :type nSetID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutAll(self, entID, x, y, z, dX, dY, dZ, Length, lengthmode, layer, color, style) -> Any:
        """
        **Description:**
            This method stores an entity with the specified ID.
        **Remarks/Usage:**
            Unlike the standard Put method, this function loads all of the properties as arguments. If you are updating all of the properties before storing an entity, this function will be faster than multiple calls to load each property individually.
        **Input:**
            **entID:** The ID of the entity to store.\n
            **x, y, z, dX, dY, dZ, Length, lengthmode, layer, color, style:** Refer to the property descriptions for each of these items. \n

        **Return Code:** True\n
        :type entID: int
        :type x: float
        :type y: float
        :type z: float
        :type dX: float
        :type dY: float
        :type dZ: float
        :type Length: float
        :type lengthmode: int
        :type layer: int
        :type color: int
        :type style: int

        """
        ...

    def PutAllArray(self, numArrow, entID, xyz, dxyz, Length, lengthmode, layer, color, style) -> Any:
        """
        **Description:**
            This method stores multiple GFXArrow entities with the specified data.
        **Remarks/Usage:**
            This is the fastest Put method if you have a large number of items to create, but still need full control over all options. All data can be accumulated in arrays and then transferred in one call.
        **Input:**
            **numArrow:** The number of GFXArrows to create (i.e. the number of entries in the arrays)\n
            **entID:** The IDs of the GFXArrows to store.\n
            **xyz, dxyz, Length, lengthmode, layer, color, style:** Refer to the property descriptions for each of these items. xyz is an array of the entity coordinates. In the array, there must be 3 entries for a entity, followed by the 3 for the next entity, ... .The dxyz array is stored similarly. The other arrays have just one entry per arrow. All must be in global rectangular coordinates.\n
        **Return Code:** True\n
        :type numArrow: int
        :type entID: tuple[int]
        :type xyz: tuple[float]
        :type dxyz: tuple[float]
        :type Length: tuple[float]
        :type lengthmode: tuple[int]
        :type layer: tuple[int]
        :type color: tuple[int]
        :type style: tuple[int]

        """
        ...

    def PutCoordArray(self, numArrow, xyz, dxyz, Length, lengthmode, layer, color, style) -> Any:
        """
        **Description:**
            This is a simpler version of PutAllArray that allows multiple entities to be stored.
        **Remarks/Usage:**
            This method is even faster than PutAllArray, and requires less memory, it does not however give you full control. Entities are simply stored in the next available ID, and the same layer, color... are used for every entity - only the coordinates are input as an array.
        **Input:**
            **numArrow:** The number of GFXArrows to create (i.e. the number of entries in the arrays)\n
            **xyz:** Refer to the property descriptions for each of these items. xyz is an array of the entity coordinates. In the array, there must be 3 entries for a entity, followed by the 3 for the next entity, ... .The dxyz array is stored similarly. The other arrays have just one entry per arrow. All must be in global rectangular coordinates.\n
            **xyz:** REAL8 length[0..numAr-1]\n
            **Length:** INT4 lengthmode\n
            **Length:** INT4 layer\n
            **layer:** INT4 color\n
            **color:** INT4 style\n
            **style:** \n
        **Return Code:** True\n
        :type numArrow: int

        :type xyz: tuple[float]

        :type xyz: tuple[float]

        :type Length: tuple[float]

        :type Length: int

        :type layer: int

        :type color: int

        :type style: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def Setdxyz(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setxyz(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def dxyz(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def xyz(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class GFXTria3:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    autonormal: Any
    edgecolor: Any
    edgeflags: Any
    fillcolor: Any
    layer: Any
    vNormal: Any
    vXYZ: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteAll(self, bAllSets, nSetID) -> Any:
        """
        **Description:**
            Deletes all GFXTria3s in one or more sets
        **Remarks/Usage:**
            None
        **Input:**
            **bAllSets:** If True, all entities, in all sets are deleted. If False, then all entities in Set nSetID are deleted\n
            **nSetID:** The setID to delete if bAllSets=False\n
        **Return Code:** True\n
        :type bAllSets: bool

        :type nSetID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutAll(self, entID, xyz, edgeflags, normal, autonormal, layer, fillcolor, edgecolor) -> Any:
        """
        **Description:**
            This method stores an entity with the specified ID.
        **Remarks/Usage:**
            Unlike the standard Put method, this function loads all of the properties as arguments. If you are updating all of the properties before storing an entity, this function will be faster than multiple calls to load each property individually.
        **Input:**
            **entID:** The ID of the entity to store.\n
            **xyz:** Refer to the property descriptions for each of these items. \n
            **edgeflags:** REAL8 normal[0..8]\n
            **normal:** BOOL autonormal\n
            **normal:** INT4 layer\n
            **layer:** INT4 fillcolor\n
            **fillcolor:** INT4 edgecolor\n
            **edgecolor:** \n
        **Return Code:** True\n
        :type entID: int

        :type xyz: tuple[float]

        :type edgeflags: int

        :type normal: tuple[float]

        :type normal: bool

        :type layer: int

        :type fillcolor: int

        :type edgecolor: int

        """
        ...

    def PutAllArray(self, numTria, entID, xyz, edgeflags, normal, autonormal, layer, fillcolor, edgecolor) -> Any:
        """
        **Description:**
            This method stores multiple GFXTria3 entities with the specified data.
        **Remarks/Usage:**
            This is the fastest Put method if you have a large number of items to create, but still need full control over all options. All data can be accumulated in arrays and then transferred in one call.
        **Input:**
            **numTria:** The number of GFXTria3s to create (i.e. the number of entries in the arrays)\n
            **entID:** The IDs of the GFXTria3s to store.\n
            **xyz:** Refer to the property descriptions for each of these items. xyz is an array of the entity coordinates. In the array, there must be 9 entries for a entity (3 for the first corner, 3 for the 2nd, ...), followed by the 9 for the next entity, ... . The normal array is stored similarly, but contains the components of the normal vectors. All other arrays contain one entry per triangle. All must be in global rectangular coordinates.\n
            **edgeflags:** REAL8 normal [0..(3*3*numTria)-1]\n
            **normal:** INT4 layer[0..numTria-1]\n
            **layer:** INT4 fillcolor[0..numTria-1]\n
            **fillcolor:** INT4 edgecolor[0..numTria-1]\n
            **edgecolor:** \n
        **Return Code:** True\n
        :type numTria: int

        :type entID: tuple[int]

        :type xyz: tuple[float]

        :type edgeflags: tuple[int]

        :type normal: tuple[bool]

        :type layer: tuple[int]

        :type fillcolor: tuple[int]

        :type edgecolor: tuple[int]

        """
        ...

    def PutCoordArray(self, numTria, xyz, layer, fillcolor, edgecolor) -> Any:
        """
        **Description:**
            This is a simpler version of PutAllArray that allows multiple entities to be stored.
        **Remarks/Usage:**
            This method is even faster than PutAllArray, and requires less memory, it does not however give you full control. Entities are simply stored in the next available ID, and the same layer, color... are used for every entity - only the coordinates are input as an array.
        **Input:**
            **numTria:** The number of GFXTria3s to create (i.e. the number of entries in the arrays)\n
            **xyz, layer, fillcolor, edgecolor:** Refer to the property descriptions for each of these items. xyz is an array of the entity coordinates. In the array, there must be 9 entries for a entity (3 for the first corner, 3 for the 2nd, ...), followed by the 9 for the next entity, ... . All must be in global rectangular coordinates.\n
        **Return Code:** True\n
        :type numTria: int
        :type xyz: tuple[float]
        :type layer: int
        :type fillcolor: int
        :type edgecolor: int

        """
        ...

    def PutCoordNormalArray(self, numTria, xyz, edgeflags, normal, autonormal, layer, fillcolor, edgecolor) -> Any:
        """
        **Description:**
            This is a simpler version of PutAllArray that allows multiple entities to be stored, and still allows you to specify the triangle normal vectors.
        **Remarks/Usage:**
            This method is even faster than PutAllArray, and requires less memory, it does not however give you full control. Entities are simply stored in the next available ID, and the same layer, color... are used for every entity - only the coordinates, edgeflags and normals are input as arrays.
        **Input:**
            **numTria:** The number of GFXTria3s to create (i.e. the number of entries in the arrays)\n
            **xyz, edgeflags, normal, autonormal, layer, fillcolor, edgecolor:** Refer to the property descriptions for each of these items. xyz is an array of the entity coordinates. In the array, there must be 9 entries for a entity (3 for the first corner, 3 for the 2nd, ...), followed by the 9 for the next entity, ... . The normal array is stored similarly, but contains the components of the normal vectors. All other arrays contain one entry per triangle. All must be in global rectangular coordinates.\n
        **Return Code:** True\n
        :type numTria: int
        :type xyz: tuple[float]
        :type edgeflags: tuple[int]
        :type normal: tuple[float]
        :type autonormal: bool
        :type layer: int
        :type fillcolor: int
        :type edgecolor: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def Setnormal(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def Setxyz(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def normal(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def xyz(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...


class GFXQuad4:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    autonormal: Any
    edgecolor: Any
    edgeflags: Any
    fillcolor: Any
    layer: Any
    vNormal: Any
    vXYZ: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteAll(self, bAllSets, nSetID) -> Any:
        """
        **Description:**
            Deletes all GFXQuad4s in one or more sets
        **Remarks/Usage:**
            None
        **Input:**
            **bAllSets:** If True, all entities, in all sets are deleted. If False, then all entities in Set nSetID are deleted\n
            **nSetID:** The setID to delete if bAllSets=False\n
        **Return Code:** True\n
        :type bAllSets: bool

        :type nSetID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutAll(self, entID, xyz, edgeflags, normal, autonormal, layer, fillcolor, edgecolor) -> Any:
        """
        **Description:**
            This method stores an entity with the specified ID.
        **Remarks/Usage:**
            Unlike the standard Put method, this function loads all of the properties as arguments. If you are updating all of the properties before storing an entity, this function will be faster than multiple calls to load each property individually.
        **Input:**
            **entID:** The ID of the entity to store.\n
            **xyz:** Refer to the property descriptions for each of these items. \n
            **edgeflags:** REAL8 normal[0..11]\n
            **normal:** BOOL autonormal\n
            **normal:** INT4 layer\n
            **layer:** INT4 fillcolor\n
            **fillcolor:** INT4 edgecolor\n
            **edgecolor:** \n
        **Return Code:** True\n
        :type entID: int

        :type xyz: tuple[float]

        :type edgeflags: int

        :type normal: tuple[float]

        :type normal: bool

        :type layer: int

        :type fillcolor: int

        :type edgecolor: int

        """
        ...

    def PutAllArray(self, numQuad, entID, xyz, edgeflags, normal, autonormal, layer, fillcolor, edgecolor) -> Any:
        """
        **Description:**
            This method stores multiple GFXQuad4 entities with the specified data.
        **Remarks/Usage:**
            This is the fastest Put method if you have a large number of items to create, but still need full control over all options. All data can be accumulated in arrays and then transferred in one call.
        **Input:**
            **numQuad:** The number of GFXQuad4s to create (i.e. the number of entries in the arrays)\n
            **entID:** The IDs of the GFXQuad4s to store.\n
            **xyz:** Refer to the property descriptions for each of these items. xyz is an array of the entity coordinates. In the array, there must be 12 entries for a entity (3 for the first corner, 3 for the 2nd, ...), followed by the 12 for the next entity, ... . The normal array is stored similarly, but contains the components of the normal vectors. All other arrays contain one entry per quad. All must be in global rectangular coordinates.\n
            **edgeflags:** REAL8 normal [0..(4*3*numQuad)-1]\n
            **normal:** INT4 layer[0..numQuad-1]\n
            **layer:** INT4 fillcolor[0..numQuad-1]\n
            **fillcolor:** INT4 edgecolor[0..numQuad-1]\n
            **edgecolor:** \n
        **Return Code:** True\n
        :type numQuad: int

        :type entID: tuple[int]

        :type xyz: tuple[float]

        :type edgeflags: tuple[int]

        :type normal: tuple[bool]

        :type layer: tuple[int]

        :type fillcolor: tuple[int]

        :type edgecolor: tuple[int]

        """
        ...

    def PutCoordArray(self, numQuad, xyz, layer, fillcolor, edgecolor) -> Any:
        """
        **Description:**
            This is a simpler version of PutAllArray that allows multiple entities to be stored.
        **Remarks/Usage:**
            This method is even faster than PutAllArray, and requires less memory, it does not however give you full control. Entities are simply stored in the next available ID, and the same layer, color... are used for every entity - only the coordinates are input as an array.
        **Input:**
            **numQuad:** The number of GFXQuad4s to create (i.e. the number of entries in the arrays)\n
            **xyz, layer, fillcolor, edgecolor:** Refer to the property descriptions for each of these items. xyz is an array of the entity coordinates. In the array, there must be 12 entries for a entity (3 for the first corner, 3 for the 2nd, ...), followed by the 12 for the next entity, ... . All must be in global rectangular coordinates.\n

        **Return Code:** True\n
        :type numQuad: int

        :type xyz: tuple[float]

        :type layer: int

        :type fillcolor: int

        :type edgecolor: int

        """
        ...

    def PutCoordNormalArray(self, numQuad, xyz, edgeflags, normal, autonormal, layer, fillcolor, edgecolor) -> Any:
        """
        **Description:**
            This is a simpler version of PutAllArray that allows multiple entities to be stored, and still allows you to specify the quad normal vectors.
        **Remarks/Usage:**
            This method is even faster than PutAllArray, and requires less memory, it does not however give you full control. Entities are simply stored in the next available ID, and the same layer, color... are used for every entity - only the coordinates, edgeflags and normals are input as arrays.
        **Input:**
            **numQuad:** The number of GFXQuad4s to create (i.e. the number of entries in the arrays)\n
            **xyz, edgeflags, normal, autonormal, layer, fillcolor, edgecolor:** Refer to the property descriptions for each of these items. xyz is an array of the entity coordinates. In the array, there must be 12 entries for a entity (3 for the first corner, 3 for the 2nd, ...), followed by the 12 for the next entity, ... . The normal array is stored similarly, but contains the components of the normal vectors. All other arrays contain one entry per quad. All must be in global rectangular coordinates.\n
        **Return Code:** True\n
        :type numQuad: int
        :type xyz: tuple[float]
        :type edgeflags: tuple[int]
        :type normal: tuple[float]
        :type autonormal: bool
        :type layer: int
        :type fillcolor: int
        :type edgecolor: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def Setnormal(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def Setxyz(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def normal(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def xyz(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...


class globalply:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    failuretheory: Any
    matlID: Any
    thickness: Any
    title: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class LoadBolt:
    CLSID: Any
    Active: Any
    ID: Any
    LoadDefinitionID: Any
    PreloadType: Any
    SetID: Any
    color: Any
    layer: Any
    preload: Any

    def AddArray(self, Count, RegionID, Values) -> Any:
        """
        **Description:**
            This method creates multiple Bolt Preloads. This method is obsolete and should be replaced by PutArray.
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the other parameters in the object - such as, color and setID, and any other types required for your loads. This method simply uses the data you specify here to overwrite specific values in the LoadBolt object, and create a new preload for each entry in the arrays.
        **Input:**
            **Count:** The number of bolt preloads to create, and the number of IDs in RegionID\n
            **Values:** Bolt Preload Values. Refer to preload property.\n
        **Return Code:** True\n
        :type Count: int

        :type Values: tuple[float]

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetAllArray(self, Count, BoltRegionID, layer, color, LoadDefinitionID, BoltType, BoltPreload,
                    BoltLength) -> Any:
        """
        **Description:**
            This method returns information on multiple Bolt Preloads
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the setID parameter in the object.
        **Output:**
            **Count:** The number of bolt preloads to create, and the number of IDs in RegionID\n
            **layer:** The IDs of the layers the loads are on.\n
            **color:** The IDs of the load color.\n
            **BoltType:** The type of bolt.\n
            **BoltPreload:** The Preload Values.\n
            **BoltLength:** The Length Values.\n
        **Return Code:** True\n
        :type Count: int

        :type layer: tuple[int]

        :type color: tuple[int]

        :type BoltType: tuple[int]

        :type BoltPreload: tuple[float]

        :type BoltLength: tuple[float]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutAllArray(self, Count, BoltRegionID, layer, color, LoadDefinitionID, BoltType, BoltPreload,
                    BoltLength) -> Any:
        """
        **Description:**
            This method creates multiple Bolt Preloads
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the setID parameter in the object. For more information on how to create loads, see Section 2.8, "Working with Loads and Constraints".
        **Input:**
            **Count:** The number of bolt preloads to create, and the number of IDs in RegionID\n
            **layer:** The IDs of the layers the loads are on.\n
            **color:** The IDs of the load color.\n
            **BoltType:** The type of bolt.\n
            **BoltPreload:** The Preload Values.\n
            **BoltLength:** The Length Values.\n
        **Return Code:** True\n
        :type Count: int

        :type layer: tuple[int]

        :type color: tuple[int]

        :type BoltType: tuple[int]

        :type BoltPreload: tuple[float]

        :type BoltLength: tuple[float]

        """
        ...

    def PutArray(self, Count, RegionID, Values) -> Any:
        """
        **Description:**
            This method creates multiple Bolt Preloads
        **Remarks/Usage:**
            Prior to using this method, you must properly specify the other parameters in the object - such as, color and setID, and any other types required for your loads. This method simply uses the data you specify here to overwrite specific values in the LoadBolt object, and create a new preload for each entry in the arrays. For more information on how to create loads, see Section 2.8, "Working with Loads and Constraints".
        **Input:**
            **Count:** The number of bolt preloads to create, and the number of IDs in RegionID\n
            **Values:** Bolt Preload Values. Refer to preload property.\n
        **Return Code:** True\n
        :type Count: int

        :type Values: tuple[float]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class MapOutput:
    CLSID: Any
    Active: Any
    DataConversion: Any
    DefaultMapValue1: Any
    DefaultMapValue2: Any
    DefaultMapValue3: Any
    ID: Any
    MapOffsetTolerance: Any
    MapOption: Any
    MapToType: Any
    SetID: Any
    TargetSet: Any
    UseCriteria: Any
    loadType: Any

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetOutputDataSurface(self, dataSurfID) -> Any:
        """
        **Description:**
            This method retrieves the Data Surface ID from current model for use in the MapOutput Object.
        **Remarks/Usage:**
            Used in conjunction with MapOutputDataToLocation
        **Return Code:** True\n
        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def MapFromModelToLocationV2(self, outModelID, nGroup, nOutSet, nOutVect, vLocationX, vLocationY, vLocationZ,
                                 vLocationP, vLoadX, vLoadY, vLoadZ) -> Any:
        """
        **Description:**
            This method replaces MapFromModelToLocation. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above". This method maps output data from a source model to any locations in space.
        **Remarks/Usage:**
            This method will work with any output, but will only map to types specified in LoadType. All listed properties must be set on the MapOutput object before calling this method.
        **Input:**
            **outModelID:** ID of the source model containing output to be mapped.\n
            **nGroup:** ID of group of entities in source model from which to map output.\n
            **nOutSet:** ID of output set in source model containing data from which to map output.\n
            **nOutVect:** ID of output vector in source model containing data from which to map output.\n
            **vLocationX, vLocationY, vLocationZ:** Array of global rectangular x-coordinates for locations where data is to be mapped.N = number of locations for which mapped values are returned.\n
        **Output:**
            **vLocationP:** Output value mapped to location. Values ordered 0..N-1 in VARIANT\n
            **vLoadX, vLoadY, vLoadZ:** Unit x vector (global, rectangular) of corresponding mapped output value.\n

        **Return Code:** True\n
        :type outModelID: int
        :type nGroup: int
        :type nOutSet: int
        :type nOutVect: int
        :type vLocationX: tuple[float] or Any
        :type vLocationY: tuple[float] or Any
        :type vLocationZ: tuple[float] or Any
        :type vLocationP: Any
        :type vLoadX: Any
        :type vLoadY: Any
        :type vLoadZ: Any

        """
        ...

    def MapFromModelToSet2V2(self, outModelID, nGroup, nOutSet, nOutVect, ID, elFace) -> Any:
        """
        **Description:**
            This method replaces MapFromModelToSet2. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above". This method maps output data from a source model to loads on a target model. It performs the same function as Femap menu command Model->Load->Map Output From Model... Similar to MapFromModelToSet, but allows specification of Element or Node IDs, along with Element Face IDs, if needed, instead of specifying the TargetSet in the MapOutput object.
        **Remarks/Usage:**
            This method will work with any output, but will only map to types specified in LoadType. All listed properties in the MapOutput object, except TargetSet, must be set before calling this method.
        **Input:**
            **outModelID:** ID of the source model containing output to be mapped.\n
            **nGroup:** ID of group of entities in source model from which to map output.\n
            **nOutSet:** ID of output set in source model containing data from which to map output.\n
            **nOutVect:** ID of output vector in source model containing data from which to map output.\n
        **Return Code:** True\n
        :type outModelID: int

        :type nGroup: int

        :type nOutSet: int

        :type nOutVect: int

        """
        ...

    def MapFromModelToSetV2(self, outModelID, nGroup, nOutSet, nOutVect) -> Any:
        """
        **Description:**
            This method replaces MapFromModelToSet. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above". This method maps output data from a source model to loads on a target model. It performs the same function as Femap menu command Model->Load->Map Output From Model...
        **Remarks/Usage:**
            This method will work with any output, but will only map to types specified in LoadType. All listed properties must be set on the MapOutput object before calling this method.
        **Input:**
            **outModelID:** ID of the source model containing output to be mapped.\n
            **nGroup:** ID of group of entities in source model from which to map output.\n
            **nOutSet:** ID of output set in source model containing data from which to map output.\n
            **nOutVect:** ID of output vector in source model containing data from which to map output.\n
        **Return Code:** True\n
        :type outModelID: int

        :type nGroup: int

        :type nOutSet: int

        :type nOutVect: int

        """
        ...

    def MapOutputDataToLocation(self, Count, vXYx, vValXYZ, qValid) -> Any:
        """
        **Description:**
            This method maps values to locations specified in vXYZ using local Data Surface retrieved with GetOutputDataSurface
        **Remarks/Usage:**
            Used for mapping locations to Data Surface in current model.
        **Input:**
            **Count:** The number of locations to map in vXYZ.\n
            **vXYx:** Array of point coordinates in XYZ order where data is to be mapped.\n
        **Output:**
            **vValXYZ:** Array of output values mapped in valX, valY, valZ order.\n
            **qValid:** Array of validation indicators. If qValid = FALSE (0), value was not mapped.\n
        **Return Code:** True\n
        :type Count: int

        :type vXYx: tuple[float]

        :type vValXYZ: tuple[float]

        :type qValid: tuple[bool]

        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class DataSurf:
    CLSID: Any
    Active: Any
    AlongCoordProjectID: Any
    CSys: Any
    DataConversion: Any
    DefOutMapValue1: Any
    DefOutMapValue2: Any
    DefOutMapValue3: Any
    ExtendEdgeValues: Any
    ID: Any
    InterpMin: Any
    InterpPercent: Any
    MapOffsetTolerance: Any
    OutMapOption: Any
    ParamCurveSurfID: Any
    SetID: Any
    TabularUdefOption: Any
    TabularUdefVal: Any
    UseCriteria: Any
    title: Any
    vector: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Evaluate(self, geomID, enOnType, mapSetID, isElemental) -> Any:
        """
        **Description:**
            This method Evaluates the Data Surface prior to calling GetData().
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetCellValue(self, nPage, nRow, nCol, nComponent, dValue) -> Any:
        """
        **Description:**
            This method retrieves the value of a cell.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page containing cell to retrieve value from\n
            **nRow:** Row containing cell to retrieve value from. \n
            **nCol:** Column containing cell to retrieve value from\n
            **nComponent:** Component of the value vector in which to retrieve value from. Component: Scalar = 0, Vector = 0..3 \n
        **Output:**
            **dValue:** Value of the cell.\n
        **Return Code:** True\n
        :type nPage: int

        :type nRow: int

        :type nCol: int

        :type nComponent: int

        :type dValue: float

        """
        ...

    def GetColumnTitle(self, nPage, nCol, sTitle) -> Any:
        """
        **Description:**
            This method retrieves the title of a column.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page containing column to retrieve title from\n
            **nCol:** Column retrieve title from. \n
        **Return Code:** True\n
        :type nPage: int

        :type nCol: int

        """
        ...

    def GetColumnValue(self, nPage, nCol, dValue) -> Any:
        """
        **Description:**
            This method retrieves the value of a column.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page containing column to retrieve value from\n
            **nCol:** Column retrieve value from. \n
        **Output:**
            **dValue:** Value of column.\n
        **Return Code:** True\n
        :type nPage: int

        :type nCol: int

        :type dValue: float

        """
        ...

    def GetData(self, geomID, feaID, Coord, sVal, cgXYZ) -> Any:
        """
        **Description:**
            This method gets the computed Data Surface value at the independent variable.
        **Remarks/Usage:**
            Before calling GetData the Data Surface must first have been evaluated with Evaluate().
        **Input:**
            **geomID:** Between 2,4 Point Parametric Data Surface: ID of curve/surface supplying parametric space.\n
            **feaID:** Mesh, Output Map Data Surface: ID of mesh entity.\n
            **Coord:** or\n
            **Coord:** Along Coordinates, Between Coordinates, Tabular, Arbitrary 3D, Equation Data Surfaces: Location where the Data Surface will be evaluated at.\n
        **Output:**
            **sVal:** Computed value for Scalar Data Surface. Magnitude for Vector Data Surface.\n
            **cgXYZ:** or\n
            **cgXYZ:** Computed vector components for Vector Data Surfaces.\n
        **Return Code:** False\n
        :type geomID: int

        :type feaID: int

        :type Coord: tuple[float]

        :type Coord: Any

        :type sVal: float

        :type cgXYZ: tuple[float]

        :type cgXYZ: Any

        """
        ...

    def GetDataArray(self, nCount, vgeomID, vfeaID, Coord, sVal, cgXYZ) -> Any:
        """
        **Description:**
            This method is similar to GetData(), but allows for retrieval of data at multiple geometry/fea entities/coordinates.
        **Remarks/Usage:**
            Before calling GetDataArray() the Data Surface must first have been evaluated with Evaluate().
        **Input:**
            **nCount:** Number of entities being supplied in vGeomID, vfeaID or 1/3 the number in vCoord. Note that the size of arrays has to be consistent with this value\n
            **Coord:** Along Coordinates, Between Coordinates, Tabular, Arbitrary 3D, or Equation Data Surfaces: Location where the Data Surface will be evaluated at in global rectangular coordinates.\n
        **Output:**
            **sVal:** Computed values for Scalar Data Surface. Magnitudes for Vector Data Surface.\n
            **cgXYZ:** Computed vector components for Vector Data Surfaces.\n
        **Return Code:** False\n
        :type nCount: int

        :type Coord: tuple[float]

        :type sVal: Any

        :type cgXYZ: Any

        """
        ...

    def GetDataSurf(self, entID) -> Any:
        """
        **Description:**
            This method retrieves the Data Surface ID
        **Remarks/Usage:**

        **Input:**
            **entID:** ID of the Data Surface to retrieve.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetDataSurfInfo(self, nPages, nComponent, sTitle) -> Any:
        """
        **Description:**
            This method retrieves Data Surface information.
        **Remarks/Usage:**

        **Output:**
            **nPages:** Number of Pages in Data Surface\n
            **nComponent:** Number of components for Data Surface\n
            **sTitle:** Title of Data Surface\n
        **Return Code:** True\n
        :type nPages: int

        :type nComponent: int

        :type sTitle: str

        """
        ...

    def GetDataSurfType(self) -> Any:
        """
        **Description:**
            This method returns the Data Surface Type
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetPageInfo(self, nPage, nRow, nCol) -> Any:
        """
        **Description:**
            This method retrieves page information.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page to retrieve info for.\n
        **Output:**
            **nRow:** Number of Row in page\n
            **nCol:** Number of Columns in page.\n
        **Return Code:** True\n
        :type nPage: int

        :type nRow: int

        :type nCol: int

        """
        ...

    def GetPageTitle(self, nPage, sTitle) -> Any:
        """
        **Description:**
            This method retrieves the title of a page.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page to retrieve title from.\n
        **Output:**
            **sTitle:** Title of page.\n
        **Return Code:** True\n
        :type nPage: int

        :type sTitle: str

        """
        ...

    def GetPageValue(self, nPage, dValue) -> Any:
        """
        **Description:**
            This method retrieves the value of a page.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page to retrieve value from.\n
        **Output:**
            **dValue:** Value of page.\n
        **Return Code:** True\n
        :type nPage: int

        :type dValue: float

        """
        ...

    def GetRowTitle(self, nPage, nCol, sTitle) -> Any:
        """
        **Description:**
            This method retrieves the title of a row.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page containing row to retrieve title from\n
            **nCol:** Row to retrieve title from. \n
        **Output:**
            **sTitle:** Title of row\n
        **Return Code:** True\n
        :type nPage: int

        :type nCol: int

        :type sTitle: str

        """
        ...

    def GetRowValue(self, nPage, nCol, dValue) -> Any:
        """
        **Description:**
            This method retrieves the title of a row.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page containing row to retrieve value from\n
            **nCol:** Row to retrieve value from. \n
        **Output:**
            **dValue:** Value of row\n
        **Return Code:** True\n
        :type nPage: int

        :type nCol: int

        :type dValue: float

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutDataSurf(self, entID) -> Any:
        """
        **Description:**
            This method stores the Data Surface in the model database with the specified ID.
        **Remarks/Usage:**

        **Input:**
            **entID:** ID of the Data Surface to store.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def Resize(self, nPage, nRow, nCol, bVector) -> Any:
        """
        **Description:**
            This method resizes the Data Surface grid.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Number of Pages.\n
            **nRow:** Number of Rows.\n
            **nCol:** Number of Columns.\n
            **bVector:** Flag for vector Data Surface.\n
        **Return Code:** True\n
        :type nPage: int

        :type nRow: int

        :type nCol: int

        :type bVector: bool

        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetCellBlank(self, nPage, nRow, nCol, nComponent) -> Any:
        """
        **Description:**
            This method set a cell to blank.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page that contains the cell to set.\n
            **nRow:** Row containing cell to set.\n
            **nCol:** Column containing cell to set.\n
            **nComponent:** Component of value vector to set.\n
        **Return Code:** True\n
        :type nPage: int

        :type nRow: int

        :type nCol: int

        :type nComponent: int

        """
        ...

    def SetCellEquation(self, nPage, nRow, nCol, nComponent, sEquation) -> Any:
        """
        **Description:**
            This method sets the equation of a cell.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page containing cell to set.\n
            **nRow:** Row containing cell to set. \n
            **nCol:** Column containing cell to set.\n
            **nComponent:** Component of the value vector in which to set. Components: Scalar = 0, Vector = 0..3 \n
            **sEquation:** Equation to set the cell to.\n
        **Return Code:** True\n
        :type nPage: int

        :type nRow: int

        :type nCol: int

        :type nComponent: int

        :type sEquation: str

        """
        ...

    def SetCellValue(self, nPage, nRow, nCol, nComponent, dValue) -> Any:
        """
        **Description:**
            This method sets the value of a cell.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page containing cell to set value.\n
            **nRow:** Row containing cell to set value. \n
            **nCol:** Column containing cell to set value.\n
            **nComponent:** Component of the value vector in which to set value for. Components: Scalar = 0, Vector = 0..3 \n
            **dValue:** Value to set.\n
        **Return Code:** True\n
        :type nPage: int

        :type nRow: int

        :type nCol: int

        :type nComponent: int

        :type dValue: float

        """
        ...

    def SetColumnTitle(self, nPage, nCol, sTitle) -> Any:
        """
        **Description:**
            This method set the title of a column.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page that contains the column to set.\n
            **nCol:** Column to set.\n
            **sTitle:** Title to set. \n
        **Return Code:** True\n
        :type nPage: int

        :type nCol: int

        :type sTitle: str

        """
        ...

    def SetColumnValue(self, nPage, nCol, rVal) -> Any:
        """
        **Description:**
            This method sets the value of a column.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page that contains the column to set.\n
            **nCol:** Column to set.\n
        **Return Code:** True\n
        :type nPage: int

        :type nCol: int

        """
        ...

    def SetPageTitle(self, nPage, sTitle) -> Any:
        """
        **Description:**
            This method sets the title of a page.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page to set title.\n
            **sTitle:** Title of page.\n
        **Return Code:** True\n
        :type nPage: int

        :type sTitle: str

        """
        ...

    def SetPageValue(self, nPage, rVal) -> Any:
        """
        **Description:**
            This method sets the value of a page.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page to set value.\n
        **Return Code:** True\n
        :type nPage: int

        """
        ...

    def SetRowTitle(self, nPage, nRow, sTitle) -> Any:
        """
        **Description:**
            This method sets the title of a row.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page containing row to set title for\n
            **nRow:** Row to set title for. \n
            **sTitle:** Title of row. \n
        **Return Code:** True\n
        :type nPage: int

        :type nRow: int

        :type sTitle: str

        """
        ...

    def SetRowValue(self, nPage, nRow, rVal) -> Any:
        """
        **Description:**
            This method sets the value of a row.
        **Remarks/Usage:**

        **Input:**
            **nPage:** Page containing row to set value for.\n
            **nRow:** Row to set value for. \n
        **Return Code:** True\n
        :type nPage: int

        :type nRow: int

        """
        ...

    def VarAlongCoord(self, projID, xyz, val_xyz) -> Any:
        """
        **Description:**
            This method creates a Along Coordinates Data Surface.
        **Remarks/Usage:**
            The following Data Surface Object properties that are valid:
        **Input:**
            **projID:** Number of variation locations used to create Data Surface\n
            **xyz:** or\n
            **xyz:** xyz is an array of the variation coordinates. In the array, there must be 3 entries for each location, followed by the 3 for the next location.\n
            **xyz:** val_xyz is an array of the variation values. In the array, there must be 3 entries for the variation location, followed by the 3 variation values for the next location. If Data Surface is a Scalar then just define the y,z values as zero.\n
        **Return Code:** True\n
        :type projID: int

        :type xyz: tuple[float]

        :type xyz: Any

        :type xyz: Any

        """
        ...

    def VarArbitrary3DCoord(self, projID, xyz, val_xyz) -> Any:
        """
        **Description:**
            This method creates a Arbitrary 3D Data Surface.
        **Remarks/Usage:**
            The following Data Surface Object properties that are valid:
        **Input:**
            **projID:** Number of variation locations in xyz, val_xyz arrays.\n
            **xyz:** or\n
            **xyz:** xyz is an array of the variation coordinates. In the array, there must be 3 entries for each location, followed by the 3 for the next location.\n
            **xyz:** or\n
            **xyz:** val_xyz is an array of the variation values. In the array, there must be 3 entries for the variation location, followed by the 3 variation values for the next location. If Data Surface is a Scalar then just define the y,z values as zero.\n
        **Return Code:** True\n
        :type projID: int

        :type xyz: tuple[float]

        :type xyz: Any

        :type xyz: tuple[float]

        :type xyz: Any

        """
        ...

    def VarBetween2Pts(self, xyz, val_xyz) -> Any:
        """
        **Description:**
            This method creates a Between Coordinates Data Surface with the 2 Point Linear Variation Type.
        **Remarks/Usage:**
            The following Data Surface Object properties that are valid:
        **Input:**
            **xyz:** or\n
            **xyz:** xyz is an array of the variation coordinates. In the array, there must be 3 entries for each location, followed by the 3 for the next location.\n
            **xyz:** or\n
            **xyz:** val_xyz is an array of the variation values. In the array, there must be 3 entries for the variation location, followed by the 3 variation values for the next location. If Data Surface is a Scalar then just define the y,z values as zero.\n
        **Return Code:** True\n
        :type xyz: tuple[float]

        :type xyz: Any

        :type xyz: tuple[float]

        :type xyz: Any

        """
        ...

    def VarBetween4Pts(self, xyz, val_xyz) -> Any:
        """
        **Description:**
            This method creates a Between Coordinates Data Surface with the 4 Point Bilinear Variation Type.
        **Remarks/Usage:**
            Data Surface Object properties that are valid:
        **Input:**
            **xyz:** or\n
            **xyz:** xyz is an array of the variation coordinates. In the array, there must be 3 entries for each location, followed by the 3 for the next location.\n
            **xyz:** or\n
            **xyz:** val_xyz is an array of the variation values. In the array, there must be 3 entries for the variation location, followed by the 3 variation values for the next location. If Data Surface is a Scalar then just define the y,z values as zero.\n
        **Return Code:** True\n
        :type xyz: tuple[float]

        :type xyz: Any

        :type xyz: tuple[float]

        :type xyz: Any

        """
        ...

    def VarBetween8Pts(self, xyz, val_xyz) -> Any:
        """
        **Description:**
            This method creates a Between Coordinates Data Surface with the 8 Point Trilinear Variation Type.
        **Remarks/Usage:**
            Data Surface Object properties that are valid:
        **Input:**
            **xyz:** or\n
            **xyz:** xyz is an array of the variation coordinates. In the array, there must be 3 entries for each location, followed by the 3 for the next location.\n
            **xyz:** or\n
            **xyz:** val_xyz is an array of the variation values. In the array, there must be 3 entries for the variation location, followed by the 3 variation values for the next location. If Data Surface is a Scalar then just define the y,z values as zero.\n
        **Return Code:** True\n
        :type xyz: tuple[float]

        :type xyz: Any

        :type xyz: tuple[float]

        :type xyz: Any

        """
        ...

    def VarEquation(self, Equation) -> Any:
        """
        **Description:**
            This method creates a Arbitrary 3D Data Surface.
        **Remarks/Usage:**
            The following Data Surface Object properties that are valid:
        **Return Code:** True\n
        """
        ...

    def VarMeshSurface(self, SetID, enOnType, sX, sY, sZ) -> Any:
        """
        **Description:**
            This method creates a Output Map Data Surface.
        **Remarks/Usage:**
            The following Data Surface Object properties that are valid:
        **Input:**
            **SetID:** ID of the femap set containing the Data Surface entities.\n
            **enOnType:** Type of entity in Data Surface. For more information, see Section 3.3.5, "Entity Types". Only Node and Element types are valid. \n
            **sX:** String containing value or expression for x cell in Data Surface.\n
            **sY:** String containing value or expression for y cell in Data Surface.\n
            **sZ:** String containing value or expression for z cell in Data Surface.\n
        **Return Code:** True\n
        :type SetID: int

        :type enOnType: int

        :type sX: str

        :type sY: str

        :type sZ: str

        """
        ...

    def VarOutputMapV2(self, ModelID, groupID, outSetID, outVecID) -> Any:
        """
        **Description:**
            This method creates a Output Map Data Surface. This method replaces (insert method name without V2 here). For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            The following Data Surface Object properties that are valid:
        **Input:**
            **ModelID:** ID of the source model containing output to be mapped.\n
            **groupID:** ID of group of entities in source model from which to map output.\n
            **outSetID:** ID of output set containing data from which to map output.\n
            **outVecID:** ID of output vector containing data from which to map output.\n
        **Return Code:** True\n
        :type ModelID: int

        :type groupID: int

        :type outSetID: int

        :type outVecID: int

        """
        ...

    def VarParametric2Pt(self, xyz, val_xyz) -> Any:
        """
        **Description:**
            This method creates a Between Coordinates Data Surface with the 2 Point Parametric Variation Type.
        **Remarks/Usage:**
            The following Data Surface Object properties that are valid:
        **Input:**
            **xyz:** or\n
            **xyz:** xyz is an array of the variation coordinates. In the array, there must be 3 entries for each location, followed by the 3 for the next location.\n
            **xyz:** or\n
            **xyz:** val_xyz is an array of the variation values. In the array, there must be 3 entries for the variation location, followed by the 3 variation values for the next location. If Data Surface is a Scalar then just define the y,z values as zero.\n
        **Return Code:** True\n
        :type xyz: tuple[float]

        :type xyz: Any

        :type xyz: tuple[float]

        :type xyz: Any

        """
        ...

    def VarParametric4Pt(self, xyz, val_xyz) -> Any:
        """
        **Description:**
            This method creates a Between Coordinates Data Surface with the 4 Point Parametric Variation Type.
        **Remarks/Usage:**
            The following Data Surface Object properties that are valid:
        **Input:**
            **xyz:** or\n
            **xyz:** xyz is an array of the variation coordinates. In the array, there must be 3 entries for each location, followed by the 3 for the next location.\n
            **xyz:** or\n
            **xyz:** val_xyz is an array of the variation values. In the array, there must be 3 entries for the variation location, followed by the 3 variation values for the next location. If Data Surface is a Scalar then just define the y,z values as zero.\n
        **Return Code:** True\n
        :type xyz: tuple[float]

        :type xyz: Any

        :type xyz: tuple[float]

        :type xyz: Any

        """
        ...

    def VarSpatialUVtable(self, uDiv, vDiv) -> Any:
        """
        **Description:**
            This method creates a Tabular Parametric uv Data Surface.
        **Remarks/Usage:**
            The following Data Surface Object properties that are valid:
        **Input:**
            **uDiv:** Number of divisions in the u direction.\n
            **vDiv:** Number of divisions in the v direction.\n
        **Return Code:** True\n
        :type uDiv: int

        :type vDiv: int

        """
        ...

    def VarSpatialXYZTable(self, xDiv, yDiv, zDiv) -> Any:
        """
        **Description:**
            This method creates a Output Map Data Surface.
        **Remarks/Usage:**
            The following Data Surface Object properties that are valid:
        **Input:**
            **xDiv:** Number of divisions in the 1st dimension.\n
            **yDiv:** Number of divisions in the 2st dimension.\n
            **zDiv:** Number of divisions in the 3st dimension.\n
        **Return Code:** True\n
        :type xDiv: int

        :type yDiv: int

        :type zDiv: int

        """
        ...


class DataTable:
    CLSID: Any
    Locked: Any
    NumberOfColumns: Any
    NumberOfRows: Any
    Visible: Any
    VisibleColsOnly: Any
    VisibleRowsOnly: Any
    type: Any

    def AddColumn(self, bClear, bHidden, entityTYPE, entitySetID, colTitle, ColType, nRows, ID, value,
                  nNewColumnID) -> Any:
        """
        **Description:**
            This method creates a new column in the Data Table and adds data to it.
        **Remarks/Usage:**
            This method will automatically create Model ID, Set ID and ID columns in the Data Table if they do not exist - you should never attempt to create these columns yourself.
        **Input:**
            **bClear:** If True, all previously existing data in the Data Table is deleted.\n
            **bHidden:** If True, the column is created hidden, if False, the column is visible.\n
            **entityTYPE:** The type of entities being shown in the Data Table. This needs to be the same for all columns. For more information on Entity Types refer to the table in Section 3.3.6, "Entity Types". \n
            **entitySetID:** The Set ID associated with these values being added. Can be 0 to match any Set ID or use the default for new rows.\n
            **colTitle:** The title for the column - must be unique among all existing columns\n
            **ColType:** The type of column to create (0=Bool/Check Box, 1=Integer, 2=Real, 3=String). Boolean arrays will create a column that is displayed as Check Boxes (checked on if True).\n
            **nRows:** The number of entries in the ID and Value arrays.\n
            **ID:** The entity IDs associated with the data in the corresponding location in Value. If a row with the same ID already exists in the Data Table, the associated Value is assigned to that row. If no row with that ID exists, a new row is created with the current Model ID, the specified entitySetID, and this ID, and the new row is assigned the value.\n
            **value:** This Variant contains an array with the values to be assigned to the rows selected by the corresponding entity IDs from ID. Depending on the option you specify in colType, the variant must contain either a Boolean, Integer, Double or String array. \n
        **Output:**
            **ID:** The index of the column that was created. This index is always based on the order the column was created, not the visible location, no matter how VisibleColsOnly is set. If VisibleColsOnly=False, this number can be used to access the column.\n
        **Return Code:** True\n
        :type bClear: bool

        :type bHidden: bool

        :type entityTYPE: int

        :type entitySetID: int

        :type colTitle: str

        :type ColType: int

        :type nRows: int

        :type ID: tuple[int]

        :type value: Any

        :type ID: int

        """
        ...

    def AddDataColumn(self, bHidden, colTitle, ColType, nRows, Rows, value, nNewColumnID) -> Any:
        """
        **Description:**
            This method creates a new column and updates values in it by row index
        **Remarks/Usage:**
            None
        **Input:**
            **bHidden:** If True, the column is created hidden. If False, the column is visible.\n
            **colTitle:** The title for the column - must be unique for every column.\n
            **ColType:** The type of column to create (0=BOOL/Check Box, 1=Integer, 2=Real, 3=String). Boolean arrays will create a column that is displayed as Check Boxes (checked on if True).\n
            **nRows:** The number of entries in the ID and Value arrays.\n
            **Rows:** The row indices of the rows to update.\n
        **Output:**
            **nNewColumnID:** The index of the column that was created. This index is always based on the order the column was created, not the visible location, no matter how the property VisibleColsOnly is set. If VisibleColsOnly=False, this number can be used to access the column.\n
        **Return Code:** True\n
        :type bHidden: bool

        :type colTitle: str

        :type ColType: int

        :type nRows: int

        :type Rows: tuple[int]

        :type nNewColumnID: int

        """
        ...

    def AddElementChecks(self) -> Any:
        """
        **Description:**
            Adds Femap element checks to the existing entities in the table
        **Remarks/Usage:**
            This method simply calls the Add Femap Element Checks command from the Data Table toolbar. The Data Table must contain one or more Elements.
        **Return Code:** True\n
        """
        ...

    def AddEntityData(self, bClear, entityTYPE, entitySetID, entityIDSet) -> Any:
        """
        **Description:**
            This method adds entity data to the Data Table
        **Remarks/Usage:**
            None
        **Input:**
            **bClear:** If True, all previously existing data in the Data Table is deleted.\n
            **entityTYPE:** The type of entities being added to the Data Table. For more information on Entity Types refer to the table in Section 3.3.6, "Entity Types". \n
            **entitySetID:** The Set ID associated with these values being added. Can be 0 to use the default Set ID.\n
            **entityIDSet:** The ID of a Set object that contains the IDs of the entities to add. If entityIDSet is negative, then just a single entity is added whose id is the absolute value of entityIDSet\n
        **Return Code:** True\n
        :type bClear: bool

        :type entityTYPE: int

        :type entitySetID: int

        :type entityIDSet: int

        """
        ...

    def AddGroup(self, nColumn, bShowInGroupOnly, bSortAscending) -> Any:
        """
        **Description:**
            This method updates the Data Table to group by a selected column
        **Remarks/Usage:**
            This method can be used multiple times to add additional columns to the grouping order. If a column was already in the grouping order it is moved to the lowest level. Calling this method will automatically show the GroupBy header. You can call ShowGroup to hide it, if necessary.
        **Input:**
            **nColumn:** The index of a column to add to Grouping\n
            **bShowInGroupOnly:** If True, the column is removed from being visible in the table, and is only visible in grouping and the group headers. If False, the column is still used for grouping, but is also visible in the table.\n
            **bSortAscending:** True=Sort in Ascending order, False=Descending order\n
        **Return Code:** True\n
        :type nColumn: int

        :type bShowInGroupOnly: bool

        :type bSortAscending: bool

        """
        ...

    def AddMassProperties(self) -> Any:
        """
        **Description:**
            Adds mass properties to the existing entities in the table
        **Remarks/Usage:**
            This method simply calls the Add Mass Properties command from the Data Table toolbar. The Data Table must contain one or more Curves, Surfaces, Solids, Elements, Properties or Materials.
        **Return Code:** True\n
        """
        ...

    def AddMeshAssociativity(self) -> Any:
        """
        **Description:**
            Adds mesh associativity data to the existing entities in the table
        **Remarks/Usage:**
            This method simply calls the Add Mesh Associativity command from the Data Table toolbar. The Data Table must contain one or more Points, Curves, Surfaces or Solids.
        **Return Code:** True\n
        """
        ...

    def AddNastranElementChecks(self) -> Any:
        """
        **Description:**
            Adds NX Nastran element checks to the existing entities in the table
        **Remarks/Usage:**
            This method simply calls the Add Nastran Element Checks command from the Data Table toolbar. The Data Table must contain one or more Elements.
        **Return Code:** True\n
        """
        ...

    def AddOutputV2(self, nOutputSet, nOutputVector, nNewColumnID) -> Any:
        """
        **Description:**
            This method adds data from an Output Vector to a column in the Data Table. This method replaces AddOutput. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            This method provides a simple way to add analysis results to the data table, however the table must be preloaded with the nodes/elements where you want to retrieve the results.
        **Input:**
            **nOutputSet:** The Output Set that contains the data to add.\n
            **nOutputVector:** The ID of the Output Vector that contains the data to add.\n
        **Output:**
            **nNewColumnID:** The column ID of the column that is created.\n
        **Return Code:** True\n
        :type nOutputSet: int

        :type nOutputVector: int

        :type nNewColumnID: int

        """
        ...

    def AddSelection(self, numRows, Rows, bSelect) -> Any:
        """
        **Description:**
            This method updates the Data Table to select/deselect one or more rows
        **Remarks/Usage:**
            This method can be used multiple times to add additional rows to the selection.
        **Input:**
            **numRows:** The number of entries in the Rows array\n
            **Rows:** The indices of the rows to select/deselect\n
            **bSelect:** True = Select, False = Deselect Rows\n
        **Return Code:** True\n
        :type numRows: int

        :type Rows: tuple[int]

        :type bSelect: bool

        """
        ...

    def AddSort(self, nColumn, bSortAscending) -> Any:
        """
        **Description:**
            This method updates the Data Table to sort by a selected column
        **Remarks/Usage:**
            This method can be used multiple times to add additional columns to the sorting order. If a column was already in the sorting order it is moved to the lowest level.
        **Input:**
            **nColumn:** The index of a column to sort by\n
        **Return Code:** True\n
        :type nColumn: int

        """
        ...

    def ClearGroup(self) -> Any:
        """
        **Description:**
            This method removes any grouping order
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def ClearSelection(self) -> Any:
        """
        **Description:**
            This method removes selection from all rows
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def ClearSort(self) -> Any:
        """
        **Description:**
            This method removes any sorting order
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Copy(self, bCopyAll) -> Any:
        """
        **Description:**
            This method copies the contents of the Data Table to the clipboard
        **Remarks/Usage:**
            None
        **Input:**
            **bCopyAll:** True = Copy entire Data Table, False = Copy only selected rows (and header)\n
        **Return Code:** True\n
        :type bCopyAll: bool

        """
        ...

    def DeleteRows(self, numRows, Rows) -> Any:
        """
        **Description:**
            This method deletes specified rows from the Data Table
        **Remarks/Usage:**
            None
        **Input:**
            **numRows:** The number of entries in the Rows array\n
            **Rows:** The indices of the rows to delete\n
        **Return Code:** True\n
        :type numRows: int

        :type Rows: tuple[int]

        """
        ...

    def FindColumn(self, colTitle) -> Any:
        """
        **Description:**
            This method returns the index of the column that matches your search criteria.
        **Remarks/Usage:**
            This function can be used if you do not want to keep track of column indices. Because it returns the column index as the Return Code, this method can be used directly in other calls as shown in the example. It will always return the appropriate matching index, regardless of the setting of VisibleColsOnly.
        **Input:**
            **colTitle:** The title of the column to locate\n
        **Return Code:** True\n
        :type colTitle: str

        """
        ...

    def FindRow(self, ModelID, SetID, ID) -> Any:
        """
        **Description:**
            This method returns the index of the row that matches your search criteria.
        **Remarks/Usage:**
            This function can be used if you do not want to keep track of row indices. Because it returns the row index as the Return Code, this method can be used directly in other calls as shown in the example. It will always return the appropriate matching index, regardless of the setting of VisibleRowsOnly.
        **Input:**
            **ModelID:** The ID of the Model to match. ( 0 = Any Model ). This is only necessary if you want to load data from multiple models in the same table.\n
            **SetID:** The SetID of the entity to match ( 0 = Any SetID ). This is not necessary for most model entities (like nodes, elements, properties...) which all have SetID = 1\n
            **ID:** The ID of the entity to match ( 0 = Any ID )\n
        **Return Code:** True\n
        :type ModelID: int

        :type SetID: int

        :type ID: int

        """
        ...

    def GetColumnInfo(self, numColumns, ColType, colTitle) -> Any:
        """
        **Description:**
            This method is obsolete and should no longer be used. Use GetColumnInfo2 instead.
        **Remarks/Usage:**
            This method can be used to retrieve arrays that indicate all of the entities in the Data Table. If VisibleColsOnly is True, only information about visible columns is returned.
        **Output:**
            **numColumns:** The number of entries in the colType and colTitle arrays\n
            **ColType:** A value indicating the type of data in the column.\n
            **colTitle:** The titles of the columns\n
        **Return Code:** True\n
        :type numColumns: int

        :type ColType: tuple[int]

        :type colTitle: tuple[str]

        """
        ...

    def GetColumnInfo2(self, numColumns, ColType, colTitle) -> Any:
        """
        **Description:**
            Returns information about all the columns in the table. Returns column types that match those needed for AddColumn() and UpdateColumn().
        **Remarks/Usage:**
            This method can be used to retrieve arrays that indicate all of the entities in the Data Table. If VisibleColsOnly is True, only information about visible columns is returned.
        **Output:**
            **numColumns:** The number of entries in the colType and colTitle arrays\n
            **ColType:** A value indicating the type of data in the column.\n
            **colTitle:** The titles of the columns\n
        **Return Code:** True\n
        :type numColumns: int

        :type ColType: tuple[int]

        :type colTitle: tuple[str]

        """
        ...

    def GetColumnText(self, nColumn, numRowsOrAll, Rows, numData, ColumnText) -> Any:
        """
        **Description:**
            This method returns data from selected rows in a column
        **Remarks/Usage:**
            This method is identical to GetColumnValue, except that it always returns the data as a text string.
        **Input:**
            **nColumn:** The index of a column to query\n
            **numRowsOrAll:** The number of entries in the Rows array, or -1 to retrieve data from all rows\n
            **Rows:** The indices of the rows to query\n
        **Output:**
            **numData:** The number of items returned in ColumnData\n
            **ColumnText:** The data recovered from Column nColumn and the selected rows. This method always retrieves the text that is displayed, rather than numeric values. For columns displaying check boxes, the string returned is 1 if the box is on, and 0 if it is off.\n
        **Return Code:** True\n
        :type nColumn: int

        :type numRowsOrAll: int

        :type Rows: tuple[int]

        :type numData: int

        :type ColumnText: tuple[str]

        """
        ...

    def GetColumnTitle(self, nColumn, colTitle) -> Any:
        """
        **Description:**
            Returns the title of a column in the table.
        **Remarks/Usage:**
            None
        **Input:**
            **nColumn:** The index of the column to query.\n
        **Output:**
            **colTitle:** The title of the column\n
        **Return Code:** True\n
        :type nColumn: int

        :type colTitle: str

        """
        ...

    def GetColumnValue(self, nColumn, numRowsOrAll, Rows, numData, ColumnData) -> Any:
        """
        **Description:**
            This method returns data from selected rows in a column
        **Remarks/Usage:**
            Typically numData will be the same as numRowsOrAll (if numRowsOrAll is not -1), unless some of the rows you request are invalid. The GetColumnText method is similar, but always returns the data as text strings.
        **Input:**
            **nColumn:** The index of a column to query\n
            **numRowsOrAll:** The number of entries in the Rows array, or -1 to retrieve data from all rows\n
            **Rows:** The indices of the rows to query\n
        **Output:**
            **numData:** The number of items returned in ColumnData\n
            **ColumnData:** The data recovered from Column nColumn and the selected rows. Depending on the type of data contained in the column, this could be an array of booleans, integers, doubles or strings.\n
        **Return Code:** True\n
        :type nColumn: int

        :type numRowsOrAll: int

        :type Rows: tuple[int]

        :type numData: int

        :type ColumnData: Any

        """
        ...

    def GetColumnVisible(self, nColumn, bVisible) -> Any:
        """
        **Description:**
            Returns the visibility of a column in the table.
        **Remarks/Usage:**
            None
        **Input:**
            **nColumn:** The index of the column to query.\n
        **Output:**
            **bVisible:** True if the column is visible, False if hidden\n
        **Return Code:** True\n
        :type nColumn: int

        :type bVisible: bool

        """
        ...

    def GetColumnWidth(self, nColumn, nWidth) -> Any:
        """
        **Description:**
            Returns the width of a column in the table.
        **Remarks/Usage:**
            None
        **Input:**
            **nColumn:** The index of the column to query.\n
        **Output:**
            **nWidth:** The width of the column in pixels\n
        **Return Code:** True\n
        :type nColumn: int

        :type nWidth: int

        """
        ...

    def GetGroup(self, numColumns, Columns) -> Any:
        """
        **Description:**
            This method retrieves the indices of all columns used for grouping
        **Remarks/Usage:**
            None
        **Output:**
            **numColumns:** The number of columns in the grouping order\n
            **Columns:** The indices of the grouping columns\n
        **Return Code:** True\n
        :type numColumns: int

        :type Columns: tuple[int]

        """
        ...

    def GetRowInfo(self, numRows, ModelID, SetID, ID) -> Any:
        """
        **Description:**
            Returns information about all the rows in the table.
        **Remarks/Usage:**
            This method can be used to retrieve arrays that indicate all of the entities in the Data Table. If VisibleRowsOnly is True, only information about visible rows is returned.
        **Output:**
            **numRows:** The number of entries in the ModelID, SetID and ID arrays\n
            **ModelID:** The ID of the Model associated with the entity in each row.\n
            **SetID:** The SetID of the entity in the row\n
            **ID:** The ID of the entity in the row.\n
        **Return Code:** True\n
        :type numRows: int

        :type ModelID: tuple[int]

        :type SetID: tuple[int]

        :type ID: tuple[int]

        """
        ...

    def GetRowValues(self, numRowsOrAll, Rows, numData, RowData) -> Any:
        """
        **Description:**
            This method returns data from all columns for selected rows
        **Remarks/Usage:**
            The RowData variant that is returned can be accessed as a two-dimensional array, where the first index represents the column, and the second the row ... RowData(column)(row)
        **Input:**
            **Rows:** The number of entries in the Rows array, or -1 to retrieve data from all rows\n
            **Rows:** The indices of the rows to query\n
        **Output:**
            **numData:** The number of Columns returned in RowData\n
            **RowData:** The data recovered from the selected rows for all columns. The data is returned as an array of Variants, where each variant contains an array of data for the corresponding column. Depending on the type of data contained in the column, this could be an array of booleans, integers, doubles or strings.\n
        **Return Code:** True\n
        :type Rows: int

        :type Rows: tuple[int]

        :type numData: int

        :type RowData: Any

        """
        ...

    def GetRowVisible(self, nRow, bVisible) -> Any:
        """
        **Description:**
            Returns the visibility of a row in the table.
        **Remarks/Usage:**
            None
        **Input:**
            **nRow:** The index of the row to query\n
        **Output:**
            **bVisible:** True if the row is visible, False if hidden\n
        **Return Code:** True\n
        :type nRow: int

        :type bVisible: bool

        """
        ...

    def GetSelection(self, numRows, Rows) -> Any:
        """
        **Description:**
            This method retrieves the indices of all rows that are selected
        **Remarks/Usage:**
            None
        **Output:**
            **numRows:** The number of rows in the selection\n
            **Rows:** The indices of the selected rows\n
        **Return Code:** True\n
        :type numRows: int

        :type Rows: tuple[int]

        """
        ...

    def GetSort(self, numColumns, Columns) -> Any:
        """
        **Description:**
            This method retrieves the indices of all columns used for sorting
        **Remarks/Usage:**
            None
        **Output:**
            **numColumns:** The number of columns in the sorting order\n
            **Columns:** The indices of the sorting columns\n
        **Return Code:** True\n
        :type numColumns: int

        :type Columns: tuple[int]

        """
        ...

    def Lock(self, bLock) -> Any:
        """
        **Description:**
            This method Locks or Unlocks the Data Table to allow it to be updated
        **Remarks/Usage:**
            None
        **Input:**
            **bLock:** True = Lock, False = Unlock the Data Table\n
        **Return Code:** True\n
        :type bLock: bool

        """
        ...

    def Print(self) -> Any:
        """
        **Description:**
            This method prints the visible contents of the Data Table
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Save(self, bCopyAll, fName, nFormat) -> Any:
        """
        **Description:**
            This method copies the contents of the Data Table to a file.
        **Remarks/Usage:**
            None
        **Input:**
            **bCopyAll:** True = Copy entire Data Table, False = Copy only selected rows (and header)\n
            **fName:** The name of the file that you want to create\n
            **nFormat:** The format that you want to use when creating the file (0=Tab Delimitted Text, 1=Comma-Separated Text, 2=Rich Text Format - RTF)\n
        **Return Code:** True\n
        :type bCopyAll: bool

        :type fName: str

        :type nFormat: int

        """
        ...

    def SetBackgroundColor(self, nColumn, numRows, Rows, nRed, nGreen, nBlue) -> Any:
        """
        **Description:**
            Changes the color of the background displayed in one or more rows in a selected column
        **Remarks/Usage:**
            None
        **Input:**
            **nColumn:** The index of the column to update\n
            **numRows:** The number of entries in th Rows array\n
            **Rows:** The indices of the rows to update\n
            **nRed:** The Red level (0-255)\n
            **nGreen:** The Green level (0-255)\n
            **nBlue:** The Blue level (0-255)\n
        **Return Code:** True\n
        :type nColumn: int

        :type numRows: int

        :type Rows: tuple[int]

        :type nRed: int

        :type nGreen: int

        :type nBlue: int

        """
        ...

    def SetColumnAlignment(self, nColumnOrAll, nAlign) -> Any:
        """
        **Description:**
            Updates the alignment of data in the selected column(s)
        **Remarks/Usage:**
            None
        **Input:**
            **nColumnOrAll:** The index of the column to update ( -1 = All Columns )\n
            **nAlign:** The data alignment (0=Left, 1=Center, 2=Right)\n
        **Return Code:** True\n
        :type nColumnOrAll: int

        :type nAlign: int

        """
        ...

    def SetColumnPosition(self, nColumn, nNewIndex, bAfter) -> Any:
        """
        **Description:**
            Moves the display location of a column in the Data Table
        **Remarks/Usage:**
            This method will automatically make the specified column that you are moving visible - even if it is not currently.
        **Input:**
            **nColumn:** The index of the column to update \n
            **nNewIndex:** The index of the new location in the table. The column is moved to the left of this location.\n
            **bAfter:** If True, the nColumn is placed after the nNewIndex column, otherwise it is placed before that column\n
        **Return Code:** True\n
        :type nColumn: int

        :type nNewIndex: int

        :type bAfter: bool

        """
        ...

    def SetColumnTitle(self, nColumn, colTitle) -> Any:
        """
        **Description:**
            Sets the title for a column
        **Remarks/Usage:**
            None
        **Input:**
            **nColumn:** The index of the column to update \n
            **colTitle:** The title of the column\n
        **Return Code:** True\n
        :type nColumn: int

        :type colTitle: str

        """
        ...

    def SetColumnVisible(self, nColumnOrAll, bVisible) -> Any:
        """
        **Description:**
            Sets one or all columns visible or hidden
        **Remarks/Usage:**
            None
        **Input:**
            **nColumnOrAll:** The index of the column to update (-1=All Columns)\n
            **bVisible:** True to make the column(s) visible, or False to hide them.\n
        **Return Code:** True\n
        :type nColumnOrAll: int

        :type bVisible: bool

        """
        ...

    def SetColumnWidth(self, nColumnOrAll, nWidth) -> Any:
        """
        **Description:**
            Sets the width of one or all columns
        **Remarks/Usage:**
            None
        **Input:**
            **nColumnOrAll:** The index of the column to update (-1=All Columns)\n
            **nWidth:** The width of the columns in pixels\n
        **Return Code:** True\n
        :type nColumnOrAll: int

        :type nWidth: int

        """
        ...

    def SetRowVisible(self, nRowOrAll, bVisible) -> Any:
        """
        **Description:**
            Sets one or all rows visible or hidden
        **Remarks/Usage:**
            None
        **Input:**
            **nRowOrAll:** The index of the row to update (-1=All Rows)\n
            **bVisible:** True to make the row(s) visible, or False to hide them.\n
        **Return Code:** True\n
        :type nRowOrAll: int

        :type bVisible: bool

        """
        ...

    def SetTextColor(self, nColumn, numRows, Rows, nRed, nGreen, nBlue) -> Any:
        """
        **Description:**
            Changes the color of the text displayed in one or more rows in a selected column
        **Remarks/Usage:**
            None
        **Input:**
            **nColumn:** The index of the column to update\n
            **numRows:** The number of entries in th Rows array\n
            **Rows:** The indices of the rows to update\n
            **nRed:** The Red level (0-255)\n
            **nGreen:** The Green level (0-255)\n
            **nBlue:** The Blue level (0-255)\n
        **Return Code:** True\n
        :type nColumn: int

        :type numRows: int

        :type Rows: tuple[int]

        :type nRed: int

        :type nGreen: int

        :type nBlue: int

        """
        ...

    def Show(self, bShowAll) -> Any:
        """
        **Description:**
            This method shows (draws) the specified contents of the Data Table
        **Remarks/Usage:**
            None
        **Input:**
            **bShowAll:** True = Show all visible Rows, False = Show only selected rows\n
        **Return Code:** True\n
        :type bShowAll: bool

        """
        ...

    def ShowGroup(self, bVisible) -> Any:
        """
        **Description:**
            This method shows and hides the Group By header
        **Remarks/Usage:**
            None
        **Input:**
            **bVisible:** True = Show Header, False = Hide Header\n
        **Return Code:** True\n
        :type bVisible: bool

        """
        ...

    def UpdateColumn(self, nColumn, ColType, nRows, Rows, value) -> Any:
        """
        **Description:**
            This method updates a column in the Data Table. Rows are specified by row indices.
        **Remarks/Usage:**
            This method is similar to UpdateColumnByID except that it cannot add additional rows to the table.
        **Input:**
            **nColumn:** Index of the column to update\n
            **ColType:** The type of data being updated (0=Bool/Check Box, 1=Integer, 2=Real, 3=String). \n
            **nRows:** The number of entries in the ID and Value arrays.\n
            **Rows:** The row indices of the rows to update.\n
            **value:** This Variant contains an array with the values to be assigned to the rows selected by the corresponding indices from Rows. Depending on the option you specify in colType, the variant must contain either a Boolean, Integer, Double or String array. \n
        **Return Code:** True\n
        :type nColumn: int

        :type ColType: int

        :type nRows: int

        :type Rows: tuple[int]

        :type value: Any

        """
        ...

    def UpdateColumnByID(self, nColumn, entitySetID, ColType, nRows, ID, value) -> Any:
        """
        **Description:**
            This method updates a column in the Data Table and adds data to it if selected IDs do not exist. Rows to update are selected by IDs
        **Remarks/Usage:**
            None
        **Input:**
            **nColumn:** Index of the column to update\n
            **entitySetID:** The Set ID associated with these values being updated. Can be 0 to match any Set ID or use the default for new rows.\n
            **ColType:** The type of data being updated (0=Bool/Check Box, 1=Integer, 2=Real, 3=String). \n
            **nRows:** The number of entries in the ID and Value arrays.\n
            **ID:** The entity IDs associated with the data in the corresponding location in Value. If a row with the same ID already exists in the Data Table, the associated Value is assigned to that row. If no row with that ID exists, a new row is created with the current Model ID, the specified entitySetID, and this ID, and the new row is assigned the value.\n
            **value:** This Variant contains an array with the values to be assigned to the rows selected by the corresponding entity IDs from ID. Depending on the option you specify in colType, the variant must contain either a Boolean, Integer, Double or String array. \n
        **Return Code:** True\n
        :type nColumn: int

        :type entitySetID: int

        :type ColType: int

        :type nRows: int

        :type ID: tuple[int]

        :type value: Any

        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            This method clears the contents of the Data Table
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...


class Reference:
    CLSID: Any
    Active: Any
    ID: Any
    ParentFileName: Any
    ReadFileTime: Any
    ReadFrom: Any
    ReadTime: Any
    ReadType: Any
    SetID: Any
    filename: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteAll(self) -> Any:
        """
        **Description:**
            This method deletes all References currently in the model.
        **Remarks/Usage:**
            This method does the same thing as clicking the Remove All button in the Reference Manager dialog box, which is accessed using the File, References command.
        **Return Code:** False\n
        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class AeroPanel:
    CLSID: Any
    color: Any
    dChord12: Any
    dChord34: Any
    icp: Any
    layer: Any
    nChord: Any
    nIgid: Any
    nLchordID: Any
    nLspanID: Any
    nSpan: Any
    pid: Any
    title: Any
    type: Any
    vPt1: Any
    vPt4: Any

    def AeroChordXYZ(self, nNumChord, dChordLoc) -> Any:
        """
        **Description:**
            This methods retrieve the locations of the Chord edge locations in the global coordinate system
        **Remarks/Usage:**

        **Output:**
            **nNumChord:** Number of Chord edge locations\n
        **Return Code:** True\n
        :type nNumChord: int

        """
        ...

    def AeroSpanXYZ(self, nNumSpan, dSpanLoc) -> Any:
        """
        **Description:**
            This methods retrieve the locations of the Span edge locations in the global coordinate system
        **Remarks/Usage:**

        **Output:**
            **nNumSpan:** Number of Span edge locations\n
            **dSpanLoc:** [0.. nNumChord -1] \n
        **Return Code:** True\n
        :type nNumSpan: int

        :type dSpanLoc: float

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetBoxSet(self, iBox1, iBox2) -> Any:
        """
        **Description:**
            This method creates and returns a Set object that contains the IDs of the aero elements included within the box set bounded by Box 1 - Box2.
        **Remarks/Usage:**
            This method is used to determine the panel elements chosen based on a Aero Spline BOX1, BOX2 definition.
        **Return Code:** True\n
        """
        ...

    def GetDivisionList(self, nChord, cval, nSpan, sVal) -> Any:
        """
        **Description:**
            This method retrieves Chord /Span division arrays for the Aero Panel
        **Remarks/Usage:**

        **Output:**
            **nChord:** The number of chord divisions for which data is being returned.\n
            **cval:** The division location along the chord as a percentage along the edge - i.e. 0.8 mean a division 80% of the way between points \n
            **nSpan:** The number of span divisions for which data is being returned.\n
            **sVal:** The division location along the span as a percentage along the edge - i.e. 0.8 mean a division 80% of the way between points \n
        **Return Code:** True\n
        :type nChord: int

        :type cval: tuple[float]

        :type nSpan: int

        :type sVal: tuple[float]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def InterferenceBodyCount(self) -> Any:
        """
        **Description:**
            This method retrieves the number of Interference Body elements defined.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def PanelChordCount(self) -> Any:
        """
        **Description:**
            This method retrieves the number of Chord elements defined.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def PanelSpanCount(self) -> Any:
        """
        **Description:**
            This method retrieves the number of Span elements defined.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Pt1(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Pt4(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutDivisionList(self, nChord, cval, nSpan, sVal) -> Any:
        """
        **Description:**
            This method retrieves Chord/Span division arrays for the Aero Panel
        **Remarks/Usage:**

        **Input:**
            **nChord:** The number of chord divisions for which data is being stored.\n
            **cval:** The division location along the chord as a percentage along the edge - i.e. 0.8 mean a division 80% of the way between points \n
            **nSpan:** The number of span divisions for which data is being stored.\n
            **sVal:** The division location along the span as a percentage along the edge - i.e. 0.8 mean a division 80% of the way between points \n
        **Return Code:** True\n
        :type nChord: int

        :type cval: tuple[float]

        :type nSpan: int

        :type sVal: tuple[float]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetPt1(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPt4(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SlenderBodyCount(self) -> Any:
        """
        **Description:**
            This method retrieves the number of Slender Body elements defined.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...


class AeroProp:
    CLSID: Any
    ap_d_ar: Any
    ap_d_width: Any
    ap_i_lrib: Any
    ap_i_lrsb: Any
    ap_i_lth1: Any
    ap_i_lth2: Any
    ap_i_orient: Any
    ap_i_thi1: Any
    ap_i_thi2: Any
    ap_i_thi3: Any
    ap_i_thn1: Any
    ap_i_thn2: Any
    ap_i_thn3: Any
    color: Any
    layer: Any
    title: Any
    type: Any
    vpdval: Any
    vpnval: Any

    def ClearIbList(self) -> Any:
        """
        **Description:**
            This method clears the Interference Body Radi arrays in the Aero Property
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def ClearSbList(self) -> Any:
        """
        **Description:**
            This method clears the Slender Body Radi arrays in the Aero Property
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def ClearTheta1List(self) -> Any:
        """
        **Description:**
            This method clears the Theta 1 arrays in the Aero Property
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def ClearTheta2List(self) -> Any:
        """
        **Description:**
            This method clears the Theta 2 arrays in the Aero Property
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetIBRadiCount(self) -> Any:
        """
        **Description:**
            This method returns the number of Interference Body Radii specified on an Aero Property
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetRadiList(self, nListID, nCount, nVal) -> Any:
        """
        **Description:**
            This method retrieves Radi arrays for the Aero Property
        **Remarks/Usage:**

        **Input:**
            **nListID:** 0 = Radi at Slender Body, 1 = Radi at Interference Body\n
        **Output:**
            **nCount:** The number of values for which data is being returned.\n
            **nVal:** Radi values \n
        **Return Code:** True\n
        :type nListID: int

        :type nCount: int

        :type nVal: tuple[float]

        """
        ...

    def GetSBRadiCount(self) -> Any:
        """
        **Description:**
            This method returns the number of Slender Body Radii specified on an Aero Property
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def GetThetaList(self, nListID, nCount, nVal) -> Any:
        """
        **Description:**
            This method retrieves theta arrays for the Aero Property
        **Remarks/Usage:**

        **Input:**
            **nListID:** 0 = Theta1, 1 = Theta2\n
        **Output:**
            **nCount:** The number of theta values for which data is being returned.\n
            **nVal:** Theta values \n
        **Return Code:** True\n
        :type nListID: int

        :type nCount: int

        :type nVal: tuple[float]

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def InterferenceBodyDivisionByProp(self) -> Any:
        """
        **Description:**
            This method returns the number of Interference Body Divisions on an Aero Property
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def PutRadiList(self, nListID, nCount, nVal) -> Any:
        """
        **Description:**
            This method saves Radi arrays to the Aero Property
        **Remarks/Usage:**

        **Input:**
            **nListID:** 0 = Theta1, 1 = Theta2\n
            **nCount:** The number of theta values being defined.\n
            **nVal:** Theta values \n
        **Return Code:** True\n
        :type nListID: int

        :type nCount: int

        :type nVal: tuple[float]

        """
        ...

    def PutThetaList(self, nListID, nCount, nVal) -> Any:
        """
        **Description:**
            This method saves theta arrays to the Aero Property
        **Remarks/Usage:**

        **Input:**
            **nListID:** 0 = Theta1, 1 = Theta2\n
            **nCount:** The number of theta values being defined.\n
            **nVal:** Theta values \n
        **Return Code:** True\n
        :type nListID: int

        :type nCount: int

        :type nVal: tuple[float]

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SlenderBodyDivisionByProp(self) -> Any:
        """
        **Description:**
            This method returns the number of Slender Body Divisions on an Aero Property
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...


class AeroSpline:
    CLSID: Any
    cid: Any
    color: Any
    dZ: Any
    dthx: Any
    dthy: Any
    dtor: Any
    iBox1: Any
    iBox2: Any
    icaero: Any
    isetg: Any
    layer: Any
    melem: Any
    meth: Any
    nelem: Any
    title: Any
    type: Any
    usage: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetBoxSet(self) -> Any:
        """
        **Description:**
            This method creates and returns a Set object that contains the IDs of the aero elements included within the box set bounded by Box 1 - Box2 belonging to the Aero Panel defined by icaero in the Spline properties.
        **Remarks/Usage:**
            This method is used to determine the panel elements chosen based on a Aero Spline BOX1, BOX2 definition.
        **Return Code:** True\n
        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetNodeSet(self) -> Any:
        """
        **Description:**
            This method creates and returns a Set object that contains the IDs of the Nodes in the Structural Grid Group.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class AeroSurf:
    CLSID: Any
    CSys: Any
    Label: Any
    aeid: Any
    aeid1: Any
    color: Any
    crefc: Any
    crefs: Any
    csys1: Any
    eff: Any
    hmllim: Any
    hmulim: Any
    layer: Any
    ldw: Any
    pllim: Any
    pulim: Any
    title: Any
    tqllim: Any
    tqulim: Any

    def ClearSurfaceSet1(self) -> Any:
        """
        **Description:**
            This method clears the array that contains the IDs of the Aero Panel elements in Control Surface 1.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def ClearSurfaceSet2(self) -> Any:
        """
        **Description:**
            This method clears the array that contains the IDs of the Aero Panel elements in Control Surface 2.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetSurfaceSet1(self) -> Any:
        """
        **Description:**
            This method creates and returns a Set object that contains the IDs of the Aero Panel elements in Control Surface 1.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def GetSurfaceSet2(self) -> Any:
        """
        **Description:**
            This method creates and returns a Set object that contains the IDs of the Aero Panel elements in Control Surface 2.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def PutSurfaceSet1(self, nSetID) -> Any:
        """
        **Description:**
            This method loads Aero Panel elements into Control Surface 1 arrays.
        **Remarks/Usage:**

        **Input:**
            **nSetID:** The ID of the Set Object that will contain the IDs of the elements. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def PutSurfaceSet2(self, nSetID) -> Any:
        """
        **Description:**
            This method loads Aero Panel elements into Control Surface 2 arrays.
        **Remarks/Usage:**

        **Input:**
            **nSetID:** The ID of the Set Object that will contain the IDs of the elements. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class Freebody:
    CLSID: Any
    Active: Any
    AlternateApplied: Any
    AlternateMPC: Any
    AlternateSPC: Any
    CSys: Any
    DisplayMode: Any
    ID: Any
    NodeMarkerColor: Any
    ReverseTotalValues: Any
    SectionCurve: Any
    SectionGroup: Any
    SectionIncludeClippedElem: Any
    SectionLimitToGroup: Any
    SectionLocation: Any
    SectionMode: Any
    SectionRadius: Any
    SectionReverse: Any
    SectionRotateSums: Any
    SectionSumLocation: Any
    SectionTolerance: Any
    SetID: Any
    UseNodalOuputCS: Any
    group: Any
    layer: Any
    title: Any
    vNodalVecColor: Any
    vNodalVectorMode: Any
    vSectionPlaneBase: Any
    vSectionPlaneNormal: Any
    vSectionVectorBase: Any
    vSectionVectorTip: Any
    vShowNodalVec: Any
    vShowTotalVec: Any
    vSumComponents: Any
    vSumContributions: Any
    vTotalVecColor: Any
    vTotalVectorMode: Any
    x: Any
    y: Any
    z: Any

    def CalculateNodalCenter(self, bUpdate, xyz) -> Any:
        """
        **Description:**
            Calculates the center of the nodes stored in the freebody object and optionally updates the summation location.
        **Remarks/Usage:**
            The method only works when the freebody is set to entity select mode (group is set to 0), otherwise FE_INVALID is returned.
        **Input:**
            **bUpdate:** Update the location of the summation vector\n
        **Output:**
            **xyz:** Center of nodes in freebody in global rectangular coordinate system\n
        **Return Code:** False\n
        :type bUpdate: bool

        :type xyz: Any

        """
        ...

    def CalculateSummation(self, outSetID, calculations) -> Any:
        """
        **Description:**
            This method is obsolete. For new applications, you should use CalculateSummation2
        **Remarks/Usage:**
            The method only works when the freebody is set to entity select mode (group is set to 0), otherwise FE_INVALID is returned.
        **Output:**
            **calculations:** Calculated summed forces and moments\n
        **Return Code:** False\n
        :type calculations: Any

        """
        ...

    def CalculateSummation2(self, nSetID, bUseFBCSys, nNumSets, outsetIDs, calculations) -> Any:
        """
        **Description:**
            Calculates the total summation vector based on the settings in the freebody for one or more output sets in either the freebody coordinate system, or the global coordinate system
        **Remarks/Usage:**
            This method only works when the freebody is set to interface load mode, otherwise FE_INVALID is returned.
        **Input:**
            **nSetID:** The ID of a Set object containing a list of output sets. Alternatively, specify a negative number to specify the ID of a single output set\n
            **bUseFBCSys:** Use the freebody coordinate system to return the calculations. If FALSE, calculations are returned in the global coordinate system\n
        **Output:**
            **nNumSets:** Number of output sets returned\n
        **Return Code:** False\n
        :type nSetID: int

        :type bUseFBCSys: bool

        :type nNumSets: int

        """
        ...

    def ClearElements(self) -> Any:
        """
        **Description:**
            Resets elements stored in the freebody object.
        **Remarks/Usage:**
            The method only works when the freebody is set to entity select mode (group is set to 0), otherwise FE_INVALID is returned.
        **Return Code:** False\n
        """
        ...

    def ClearNodes(self) -> Any:
        """
        **Description:**
            Resets nodes stored in the freebody object.
        **Remarks/Usage:**
            The method only works when the freebody is set to entity select mode (group is set to 0), otherwise FE_INVALID is returned.
        **Return Code:** False\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetElements(self, numElem, elemID) -> Any:
        """
        **Description:**
            This method retrieves the number of elements and an array of element IDs selected by the Freebody.
        **Remarks/Usage:**
            The method only works when the freebody is set to entity select mode (group is set to 0), otherwise FE_INVALID is returned.
        **Output:**
            **numElem:** The number of elements for which IDs are being returned.\n
            **elemID:** The IDs of the elements\n
        **Return Code:** False\n
        :type numElem: int

        :type elemID: tuple[int]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetNodalSums(self, nSetID, nNumNodes, nNodeIDs, dVals) -> Any:
        """
        **Description:**
            This method Returns values for summations calculated at nodes for all freebody nodes for one or more output sets.
        **Remarks/Usage:**
            This method returns the values that Femap calculates as a sum at a node, dependent on the selected components and contributions. It does not return the solver-calculated nodal imbalance at a node.
        **Input:**
            **nSetID:** The ID of a Set object containing a list of output sets. Alternatively, specify a negative number to specify the ID of a single output set\n
        **Output:**
            **nNumNodes:** Number of nodes in freebody\n
            **nNodeIDs:** The IDs of the nodes\n
        **Return Code:** False\n
        :type nSetID: int

        :type nNumNodes: int

        :type nNodeIDs: tuple[int]

        """
        ...

    def GetNodes(self, numNode, NodeID) -> Any:
        """
        **Description:**
            This method retrieves the number of nodes and an array of node IDs selected by the Freebody.
        **Remarks/Usage:**
            The method only works when the freebody is set to entity select mode (group is set to 0), otherwise FE_INVALID is returned.
        **Return Code:** False\n
        """
        ...

    def GetSectionCutSums(self, nOutSetSetID, nCuts, pnNumCuts, pCutLocs, pSumLocs, pSums) -> Any:
        """
        **Description:**
            Calculates the total summation for a freebody in section cut mode across one or more output sets
        **Remarks/Usage:**
            Only valid for use with freebodies in section cut mode
        **Input:**
            **nOutSetSetID:** The ID of a Set that contains output set IDs to use for calculating total summation. Alternatively, if you specify a negative value, this is simply the ID of a single output set.\n
            **nCuts:** Positive value: number of equally spaced cuts to make\n
        **Output:**
            **pnNumCuts:** Number of section cuts returned\n
        **Return Code:** False\n
        :type nOutSetSetID: int

        :type nCuts: int

        :type pnNumCuts: int

        """
        ...

    def GetSumAtNode(self, nNodeID, nSetID, dVals) -> Any:
        """
        **Description:**
            Returns the calculated summation at a single node for one or more output sets.
        **Remarks/Usage:**
            This method returns the values that Femap calculates as a sum at a node, dependent on the selected components and contributions. It does not return the solver-calculated nodal imbalance at a node.
        **Input:**
            **nNodeID:** Node ID\n
            **nSetID:** The ID of a Set object containing a list of output sets. Alternatively, specify a negative number to specify the ID of a single output set\n
        **Return Code:** False\n
        :type nNodeID: int

        :type nSetID: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NodalVecColor(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def NodalVectorMode(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SectionPlaneBase(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def SectionPlaneNormal(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def SectionVectorBase(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def SectionVectorTip(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetElements(self, bClear, SetID) -> Any:
        """
        **Description:**
            Sets the elements stored in the freebody object.
        **Remarks/Usage:**
            The method only works when the freebody is set to entity select mode (group is set to 0), otherwise FE_INVALID is returned.
        **Input:**
            **bClear:** Clear any existing elements from the freebody\n
            **SetID:** Set ID containing elements to add to the freebody\n
        **Return Code:** False\n
        :type bClear: bool

        :type SetID: int

        """
        ...

    def SetLocationFromCoord(self, x, y, z, pLoc) -> Any:
        """
        **Description:**
            Set the section cut location by specifying x, y, z coordinates
        **Remarks/Usage:**
            Only valid for use with freebody entities in section cut mode with section cut (SectionMode) defined by plane/normal (0), plane/vector (1), or vector (2).
        **Input:**
            **x, y, z:** Coordinates in global rectangular coordinate system\n
        **Output:**
            **pLoc:** Calculated location\n
        **Return Code:** True\n
        :type x: float

        :type y: float

        :type z: float

        :type pLoc: float

        """
        ...

    def SetNodalVecColor(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNodalVectorMode(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetNodes(self, bClear, SetID) -> Any:
        """
        **Description:**
            Sets the elements stored in the freebody object..
        **Remarks/Usage:**
            The method only works when the freebody is set to entity select mode (group is set to 0), otherwise FE_INVALID is returned.
        **Input:**
            **bClear:** Clear any existing nodes from the freebody\n
            **SetID:** Set ID containing nodes to add to the freebody\n
        **Return Code:** False\n
        :type bClear: bool

        :type SetID: int

        """
        ...

    def SetSectionPlaneBase(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetSectionPlaneNormal(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetSectionVectorBase(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetSectionVectorTip(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetShowNodalVec(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetShowTotalVec(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetSumComponents(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetSumContributions(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetTotalVecColor(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetTotalVectorMode(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Show(self) -> Any:
        """
        **Description:**
            Highlights both the nodes and elements of the freebody entity currently loaded in the Freebody Object
        **Remarks/Usage:**
            To insure a particular Show Mode and options are used for highlighting, set any combination of the available Info_ViewShow... options before calling this method.
        **Return Code:** True\n
        """
        ...

    def ShowNodalVec(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ShowTotalVec(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def SumComponents(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def SumContributions(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def TotalVecColor(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def TotalVectorMode(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class SEReference:
    CLSID: Any
    ASMFile: Any
    Active: Any
    AssignForm: Any
    ID: Any
    LoadsMatrix: Any
    Mass: Any
    ReferenceFile: Any
    ReferenceID: Any
    ReferenceType: Any
    SetID: Any
    Stiffness: Any
    StructuralDaming: Any
    ViscousDamping: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class Chart:
    CLSID: Any
    Active: Any
    AxisMajorColor: Any
    AxisMajorColorAutoDim: Any
    AxisTitleX: Any
    AxisTitleY: Any
    AxisValueFontSize: Any
    ComplexPlotLocation: Any
    DarkBackground: Any
    Font: Any
    ID: Any
    LabelFontSize: Any
    LabelFromChart: Any
    LabelVisible: Any
    LegendDirection: Any
    LegendFontSize: Any
    LegendVisible: Any
    MarkerFromChart: Any
    MarkerSize: Any
    MarkerStyle: Any
    MarkerVisible: Any
    MasterScale: Any
    OutputSet: Any
    OutputSetAll: Any
    OutputSetEnd: Any
    OutputSetInherit: Any
    Palette: Any
    PaletteFromChart: Any
    ScaleInherit: Any
    SetID: Any
    ShowLabelMaxMin: Any
    ShowLabelX: Any
    ShowLabelY: Any
    TitleFontBold: Any
    TitleFontColor: Any
    TitleFontItalic: Any
    TitleFontSize: Any
    TitleFontUnderline: Any
    TitleJustification: Any
    TitleLocation: Any
    TitleVisible: Any
    style: Any
    title: Any
    vAxisAutoscale: Any
    vAxisAutoscale2: Any
    vAxisLabelDecimal: Any
    vAxisLabelDecimal2: Any
    vAxisLabelFormat: Any
    vAxisLabelFormat2: Any
    vAxisMajorGridlineVisible: Any
    vAxisMajorInterval: Any
    vAxisMajorTickmarkVisible: Any
    vAxisMinorCount: Any
    vAxisMinorCountLog: Any
    vAxisMinorGridlineVisible: Any
    vAxisMinorTickmarkVisible: Any
    vAxisRange: Any
    vAxisRange2: Any
    vAxisRangePad: Any
    vAxisRangePad2: Any
    vAxisStyle: Any
    vAxisStyle2: Any
    vAxisTitleBold: Any
    vAxisTitleFontColor: Any
    vAxisTitleFontSize: Any
    vAxisTitleItalic: Any
    vAxisTitleJustification: Any
    vAxisTitleUnderline: Any
    vAxisTitleVisible: Any
    vAxisVisible: Any
    vAxisZoom: Any
    vLegendLocation: Any

    def AddDataSeries(self, SetID) -> Any:
        """
        **Description:**
            Adds one or more Data Series to the Chart
        **Remarks/Usage:**
            None.
        **Input:**
            **SetID:** ID of set containing Data Series IDs to add. When value is negative, ID of Data Series to add\n
        **Return Code:** True\n
        :type SetID: int

        """
        ...

    def AxisAutoscale(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisAutoscale2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisLabelDecimal(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisLabelDecimal2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisLabelFormat(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisLabelFormat2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisMajorGridlineVisible(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisMajorInterval(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisMajorTickmarkVisible(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisMinorCount(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisMinorCountLog(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisMinorGridlineVisible(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisMinorTickmarkVisible(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisRange(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def AxisRange2(self, nRowIndex, nColIndex) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        """
        ...

    def AxisRangePad(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisRangePad2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisStyle(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisStyle2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisTitleBold(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisTitleColor(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisTitleFontSize(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisTitleItalic(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisTitleJustification(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisTitleUnderline(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisTitleVisible(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisVisible(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AxisZoom(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetDataSeries(self, numDS, dsID) -> Any:
        """
        **Description:**
            Returns an array of Data Series displayed on the Chart
        **Remarks/Usage:**
            None
        **Output:**
            **numDS:** Number of Data Series on Chart\n
            **dsID:** Data Series IDs\n
        **Return Code:** False\n
        :type numDS: int

        :type dsID: tuple[int]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def LegendLocation(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def RemoveAllDataSeries(self) -> Any:
        """
        **Description:**
            Removes all data series from the chart
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def RemoveDataSeries(self, SetID) -> Any:
        """
        **Description:**
            Removes one or more Data Series from the Chart
        **Remarks/Usage:**
            None
        **Input:**
            **SetID:** ID of set containing data series IDs to Remove. When value is negative, ID of data series to remove\n
        **Return Code:** False\n
        :type SetID: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetAxisAutoscale(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisAutoscale2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisLabelDecimal(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisLabelDecimal2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisLabelFormat(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisLabelFormat2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisMajorGridlineVisible(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisMajorInterval(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisMajorTickmarkVisible(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisMinorCount(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisMinorCountLog(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisMinorGridlineVisible(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisMinorTickmarkVisible(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisRange(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def SetAxisRange2(self, nRowIndex, nColIndex, arg2) -> Any:
        """
        :type nRowIndex: Any
        :type nColIndex: Any
        :type arg2: Any
        """
        ...

    def SetAxisRangePad(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisRangePad2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisStyle(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisStyle2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisTitleBold(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisTitleColor(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisTitleFontSize(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisTitleItalic(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisTitleJustification(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisTitleUnderline(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisTitleVisible(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisVisible(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAxisZoom(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetLegendLocation(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def ShowPane(self) -> Any:
        """
        **Description:**
            Displays the Chart in the Charting pane
        **Remarks/Usage:**
            The charting pane will display the chart as it exists in memory at the time this method is called. Any subsequent changes to the chart object will not be displayed.
        **Return Code:** True\n
        """
        ...


class ChartSeries:
    CLSID: Any
    AbsoluteCombination: Any
    Active: Any
    ColorInherit: Any
    CombinationType: Any
    ComplexEnd: Any
    ComplexMethod: Any
    ComplexPhase: Any
    ComplexStart: Any
    ConvertMethod: Any
    ConvertMethod2: Any
    FunctionID: Any
    ID: Any
    Interval: Any
    LabelInherit: Any
    LabelVisible: Any
    Location2: Any
    MarkerInherit: Any
    MarkerSize: Any
    MarkerStyle: Any
    MarkerVisible: Any
    OutputSet: Any
    OutputSetAll: Any
    OutputSetEnd: Any
    OutputVector2V2: Any
    OutputVectorV2: Any
    Position: Any
    PositionCoordSys: Any
    PositionIsRelative: Any
    Scale: Any
    SeriesType: Any
    SetID: Any
    ShowLabelMaxMin: Any
    ShowLabelX: Any
    ShowLabelY: Any
    SortData: Any
    StudyID: Any
    TransformNodalCSys: Any
    TransformNodalCSys2: Any
    TransformNodalMode: Any
    TransformNodalMode2: Any
    TransformPlateCSys: Any
    TransformPlateCSys2: Any
    TransformPlateDOF: Any
    TransformPlateDOF2: Any
    TransformPlateMode: Any
    TransformPlateMode2: Any
    TransformPlateTolerance: Any
    TransformPlateTolerance2: Any
    TransformSolidCSys: Any
    TransformSolidCSys2: Any
    TransformSolidMode: Any
    TransformSolidMode2: Any
    color: Any
    group: Any
    location: Any
    title: Any
    vTransformPlateVector: Any
    vTransformPlateVector2: Any

    def CopyToClipboard(self) -> Any:
        """
        **Description:**
            Copies all of the XY values to the clipboard
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetEntityType(self, chartID) -> Any:
        """
        **Description:**
            Returns either Node or Element for the specified Chart
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetXY(self, numPoints, xyValues, xRange, yRange) -> Any:
        """
        **Description:**
            Retrieves all XY values from Data Series
        **Remarks/Usage:**
            None.
        **Output:**
            **numPoints:** Number of points returned\n
            **xRange:** VARIANT xRange[0..1]\n
            **xRange:** Min/Max X Values\n
            **xRange:** Min/Max Y Values\n
        **Return Code:** False\n
        :type numPoints: int

        :type xRange: tuple[Any]

        :type xRange: tuple[Any]

        :type xRange: tuple[Any]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetTransformPlateVector(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetTransformPlateVector2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def TransformPlateVector(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def TransformPlateVector2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class TableData:
    CLSID: Any
    Active: Any
    Columns: Any
    FunctionType: Any
    ID: Any
    Rows: Any
    SetID: Any
    VectorFunctionType: Any
    subtype: Any
    title: Any
    type: Any

    def CellRange(self, nMinRow, nMaxRow, nMinCol, nMaxCol) -> Any:
        """
        **Description:**
            Finds the range of valid cells in the Table currently loaded in the object
        **Remarks/Usage:**
            None
        **Output:**
            **nMinRow:** The max/min Row and Column indices of the valid cells in the table.\n
            **nMaxRow:** INT4 nMinCol\n
            **nMinCol:** INT4 nMaxCol\n
            **nMaxCol:** Return Code:\n
        **Return Code:** True\n
        :type nMinRow: int

        :type nMaxRow: int

        :type nMinCol: int

        :type nMaxCol: int

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetCellDouble(self, nRow, nCol, dValue) -> Any:
        """
        **Description:**
            Retrieve a Real, Double-precision value from a specified cell
        **Remarks/Usage:**
            None
        **Input:**
            **nRow, nCol:** The row and column of the cell to retrieve.\n
        **Output:**
            **dValue:** The current value stored in the selected cell\n
        **Return Code:** True\n
        :type nRow: int
        :type nCol: int
        :type dValue: float

        """
        ...

    def GetCellEntity(self, nRow, nCol, ntype, nID) -> Any:
        """
        **Description:**
            Retrieve an Entity from a specified cell
        **Remarks/Usage:**
            None
        **Input:**
            **nRow, nCol:** The row and column of the cell to retrieve.\n

        **Output:**
            **ntype:** The Entity Type to stored in the specified cell. For entity information, see Section 3.3.6, "Entity Types".\n
            **nID:** The ID of the Entity stored in the specified cell\n
        **Return Code:** True\n
        :type nRow: int

        :type nCol: int

        :type ntype: int

        :type nID: int

        """
        ...

    def GetCellInteger(self, nRow, nCol, nValue) -> Any:
        """
        **Description:**
            Retrieve an integer value from a specified cell
        **Remarks/Usage:**
            None
        **Input:**
            **nRow, nCol:** The row and column of the cell to retrieve.\n
        **Output:**
            **nValue:** The current value stored in the selected cell\n
        **Return Code:** True\n
        :type nRow: int

        :type nCol: int

        :type nValue: int

        """
        ...

    def GetCellText(self, nRow, nCol, sText) -> Any:
        """
        **Description:**
            Retrieve a Text String value from a specified cell
        **Remarks/Usage:**
            This method will return a text representation of cells specified with integer or real, double-precision values
        **Input:**
            **nRow, nCol:** The row and column of the cell to retrieve.\n
        **Output:**
            **sText:** The text string retrieved from that cell\n
        **Return Code:** True\n
        :type nRow: int

        :type nCol: int

        :type sText: str

        """
        ...

    def GetFunction(self, entID) -> Any:
        """
        **Description:**
            Loads a function into the current Table object
        **Remarks/Usage:**
            None
        **Input:**
            **entID:** The ID of the function to load\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetMultiCellDouble(self, nFirstRow, nLastRow, nFirstCol, nLastCol, dValues) -> Any:
        """
        **Description:**
            Retrieve Real, Double-precision values from a range of specified cells
        **Remarks/Usage:**
            Cells that are in the valid range, but do not have a specified value will return a value of 0.0. Querying these cells will not cause an error in the Return Code.
        **Return Code:** True\n
        """
        ...

    def GetMultiCellInteger(self, nFirstRow, nLastRow, nFirstCol, nLastCol, nValues) -> Any:
        """
        **Description:**
            Retrieve Integer values from a range of specified cells
        **Remarks/Usage:**
            Cells that are in the valid range, but do not have a specified value will return a value of 0.0. Querying these cells will not cause an error in the Return Code.
        **Return Code:** True\n
        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Initialize(self, nNumRow, nNumCol) -> Any:
        """
        **Description:**
            Initializes the current Table object to contain the specified range of cells
        **Remarks/Usage:**
            This method will clear any data/cell that was previously in the Table object.
        **Input:**
            **nNumRow:** The number of Rows in the Table\n
            **nNumCol:** The number of Columns in the Table\n
        **Return Code:** True\n
        :type nNumRow: int

        :type nNumCol: int

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutFunction(self, entID) -> Any:
        """
        **Description:**
            Saves the current Table object as a Function
        **Remarks/Usage:**
            None
        **Input:**
            **entID:** The ID of the function to create/update\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def Resize(self, nNumRow, nNumCol) -> Any:
        """
        **Description:**
            Resizes an already populated Table object to the newly specified sizes
        **Remarks/Usage:**
            Use this method to grow your table beyond the sizes specified in the Initialize method. Using the Resize method does not change the contents of already existing cells.
        **Input:**
            **nNumRow:** The number of Rows in the Table\n
            **nNumCol:** The number of Columns in the Table\n
        **Return Code:** True\n
        :type nNumRow: int

        :type nNumCol: int

        """
        ...

    def SaveToFile(self, sFilename, bAppend) -> Any:
        """
        **Description:**
            Saves the current table to a comma-separated text file
        **Remarks/Usage:**
            None
        **Input:**
            **sFilename:** The name of the file to create\n
            **bAppend:** Option to allow appending to an existing file. If False, the file will be overwritten.\n
        **Return Code:** True\n
        :type sFilename: str

        :type bAppend: bool

        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetCellDouble(self, nRow, nCol, dValue) -> Any:
        """
        **Description:**
            Assign a Real, Double-precision value to a specified cell
        **Remarks/Usage:**
            None
        **Input:**
            **nRow:** The row and column of the cell to update.\n
            **nCol:** REAL8 dValue\n
            **dValue:** The value assigned to that cell\n
        **Return Code:** True\n
        :type nRow: int

        :type nCol: int

        :type dValue: float

        """
        ...

    def SetCellEntity(self, nRow, nCol, ntype, nID) -> Any:
        """
        **Description:**
            Specify an Entity to assign to a specified cell
        **Remarks/Usage:**
            None
        **Input:**
            **nRow:** The row and column of the cell to update.\n
            **nCol:** INT4 nType\n
            **ntype:** The Entity Type to assign to the cell. For entity information, see Section 3.3.6, "Entity Types".\n
            **nID:** The ID of the Entity to assign to the cell\n
        **Return Code:** True\n
        :type nRow: int

        :type nCol: int

        :type ntype: int

        :type nID: int

        """
        ...

    def SetCellEquation(self, nRow, nCol, sEqn) -> Any:
        """
        **Description:**
            Specify a text string that contains an equation to assign to a specified cell
        **Remarks/Usage:**
            None
        **Input:**
            **nRow:** The row and column of the cell to update.\n
            **nCol:** STRING sEqn\n
            **sEqn:** The equation to assign to the cell\n
        **Return Code:** True\n
        :type nRow: int

        :type nCol: int

        :type sEqn: str

        """
        ...

    def SetCellInteger(self, nRow, nCol, nValue) -> Any:
        """
        **Description:**
            Assign an integer value to a specified cell
        **Remarks/Usage:**
            None
        **Input:**
            **nRow:** The row and column of the cell to update.\n
            **nCol:** INT4 nValue\n
            **nValue:** The value assigned to that cell\n
        **Return Code:** True\n
        :type nRow: int

        :type nCol: int

        :type nValue: int

        """
        ...

    def SetCellText(self, nRow, nCol, sText) -> Any:
        """
        **Description:**
            Assign a Text String value to a specified cell
        **Remarks/Usage:**
            None
        **Input:**
            **nRow:** The row and column of the cell to update.\n
            **nCol:** STRING sText\n
            **sText:** The text assigned to that cell\n
        **Return Code:** True\n
        :type nRow: int

        :type nCol: int

        :type sText: str

        """
        ...

    def SetMultiCellDouble(self, nFirstRow, nLastRow, nFirstCol, nLastCol, dValues) -> Any:
        """
        **Description:**
            Assign Real, Double-precision values to a range of specified cells
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def SetMultiCellInteger(self, nFirstRow, nLastRow, nFirstCol, nLastCol, nValues) -> Any:
        """
        **Description:**
            Assign Integer values to a range of specified cells
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def SetMultiCellText(self, nFirstRow, nLastRow, nFirstCol, nLastCol, sValues) -> Any:
        """
        **Description:**
            Assign text string values to a range of specified cells
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            Clears the current object
        **Remarks/Usage:**
            Calling this method removes all valid cells from the object
        **Return Code:** True\n
        """
        ...


class Interpolate:
    CLSID: Any
    AmbientScalar: Any
    CentroidAveraging: Any
    DistanceTolerance: Any
    EngineeringShearStrain: Any
    UseSolidFreeFacesOnly: Any
    vAmbientTensor: Any
    vAmbientVector: Any

    def AddElements(self, nElemSetID) -> Any:
        """
        :type nElemSetID: Any
        """
        ...

    def AddNodalV2(self, nSetID, nX, nY, nZ, nRX, nRY, nRZ) -> Any:
        """
        :type nSetID: Any
        :type nX: Any
        :type nY: Any
        :type nZ: Any
        :type nRX: Any
        :type nRY: Any
        :type nRZ: Any
        """
        ...

    def AddScalarV2(self, nSetID, nVecID) -> Any:
        """
        :type nSetID: Any
        :type nVecID: Any
        """
        ...

    def AddTensor2DV2(self, nSetID, nVecX, nVecY, nVecXY) -> Any:
        """
        :type nSetID: Any
        :type nVecX: Any
        :type nVecY: Any
        :type nVecXY: Any
        """
        ...

    def AddTensorV2(self, nSetID, nVecX, nVecY, nVecZ, nVecXY, nVecYZ, nVecZX) -> Any:
        """
        :type nSetID: Any
        :type nVecX: Any
        :type nVecY: Any
        :type nVecZ: Any
        :type nVecXY: Any
        :type nVecYZ: Any
        :type nVecZX: Any
        """
        ...

    def AddVectorV2(self, nSetID, nVecX, nVecY, nVecZ) -> Any:
        """
        :type nSetID: Any
        :type nVecX: Any
        :type nVecY: Any
        :type nVecZ: Any
        """
        ...

    def AmbientTensor(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def AmbientVector(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ClearResults(self) -> Any:
        """
        """
        ...

    def FindElement(self, vCoord, nElemID) -> Any:
        """
        :type vCoord: Any
        :type nElemID: Any
        """
        ...

    def FindInvariant(self, vCoord, nInvariantType, nElemID, dValue) -> Any:
        """
        :type vCoord: Any
        :type nInvariantType: Any
        :type nElemID: Any
        :type dValue: Any
        """
        ...

    def FindNodal(self, vCoord, nElemID, dX, dY, dZ, dRX, dRY, dRZ) -> Any:
        """
        :type vCoord: Any
        :type nElemID: Any
        :type dX: Any
        :type dY: Any
        :type dZ: Any
        :type dRX: Any
        :type dRY: Any
        :type dRZ: Any
        """
        ...

    def FindScalar(self, vCoord, nElemID, dValue) -> Any:
        """
        :type vCoord: Any
        :type nElemID: Any
        :type dValue: Any
        """
        ...

    def FindTensor(self, vCoord, nElemID, dX, dY, dZ, dXY, dYZ, dZX) -> Any:
        """
        :type vCoord: Any
        :type nElemID: Any
        :type dX: Any
        :type dY: Any
        :type dZ: Any
        :type dXY: Any
        :type dYZ: Any
        :type dZX: Any
        """
        ...

    def FindTensor2D(self, vCoord, nElemID, dX, dY, dXY) -> Any:
        """
        :type vCoord: Any
        :type nElemID: Any
        :type dX: Any
        :type dY: Any
        :type dXY: Any
        """
        ...

    def FindVector(self, vCoord, nElemID, dX, dY, dZ) -> Any:
        """
        :type vCoord: Any
        :type nElemID: Any
        :type dX: Any
        :type dY: Any
        :type dZ: Any
        """
        ...

    def FindVector2(self, vCoord, nElemID, dX, dY, dZ) -> Any:
        """
        :type vCoord: Any
        :type nElemID: Any
        :type dX: Any
        :type dY: Any
        :type dZ: Any
        """
        ...

    def FindVectorTotal(self, vCoord, nElemID, dTotal) -> Any:
        """
        :type vCoord: Any
        :type nElemID: Any
        :type dTotal: Any
        """
        ...

    def MultiElement(self, nNumCoord, vCoord, nElemID) -> Any:
        """
        :type nNumCoord: Any
        :type vCoord: Any
        :type nElemID: Any
        """
        ...

    def MultiInvariant(self, nNumCoord, vCoord, nInvariantType, nElemID, dValue) -> Any:
        """
        :type nNumCoord: Any
        :type vCoord: Any
        :type nInvariantType: Any
        :type nElemID: Any
        :type dValue: Any
        """
        ...

    def MultiNodal(self, nNumCoord, vCoord, nElemID, dX, dY, dZ, dRX, dRY, dRZ) -> Any:
        """
        :type nNumCoord: Any
        :type vCoord: Any
        :type nElemID: Any
        :type dX: Any
        :type dY: Any
        :type dZ: Any
        :type dRX: Any
        :type dRY: Any
        :type dRZ: Any
        """
        ...

    def MultiScalar(self, nNumCoord, vCoord, nElemID, dValue) -> Any:
        """
        :type nNumCoord: Any
        :type vCoord: Any
        :type nElemID: Any
        :type dValue: Any
        """
        ...

    def MultiTensor(self, nNumCoord, vCoord, nElemID, dX, dY, dZ, dXY, dYZ, dZX) -> Any:
        """
        :type nNumCoord: Any
        :type vCoord: Any
        :type nElemID: Any
        :type dX: Any
        :type dY: Any
        :type dZ: Any
        :type dXY: Any
        :type dYZ: Any
        :type dZX: Any
        """
        ...

    def MultiTensor2D(self, nNumCoord, vCoord, nElemID, dX, dY, dXY) -> Any:
        """
        :type nNumCoord: Any
        :type vCoord: Any
        :type nElemID: Any
        :type dX: Any
        :type dY: Any
        :type dXY: Any
        """
        ...

    def MultiVector(self, nNumCoord, vCoord, nElemID, dX, dY, dZ) -> Any:
        """
        :type nNumCoord: Any
        :type vCoord: Any
        :type nElemID: Any
        :type dX: Any
        :type dY: Any
        :type dZ: Any
        """
        ...

    def MultiVectorTotal(self, nNumCoord, vCoord, nElemID, dTotal) -> Any:
        """
        :type nNumCoord: Any
        :type vCoord: Any
        :type nElemID: Any
        :type dTotal: Any
        """
        ...

    def SetAmbientTensor(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetAmbientVector(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetComplexOptions(self, bExpandComplex, dComplexPhase) -> Any:
        """
        :type bExpandComplex: Any
        :type dComplexPhase: Any
        """
        ...

    def SetGlobalPly(self, nGlobalPly) -> Any:
        """
        :type nGlobalPly: Any
        """
        ...

    def SetNodalTransform(self, nTransformMode, nCSysID) -> Any:
        """
        :type nTransformMode: Any
        :type nCSysID: Any
        """
        ...

    def SetOutputMode(self, nConvertMode, bAverageCorners, bBreakProp, bBreakMatl, bBreakLayer, bBreakColor, bBreakGeom,
                      dBreakAngle) -> Any:
        """
        :type nConvertMode: Any
        :type bAverageCorners: Any
        :type bBreakProp: Any
        :type bBreakMatl: Any
        :type bBreakLayer: Any
        :type bBreakColor: Any
        :type bBreakGeom: Any
        :type dBreakAngle: Any
        """
        ...

    def SetOutputMode2(self, nConvertMode, bAverageCorners, bBreakLinearParabolic, bBreakProp, bBreakMatl, bBreakLayer,
                       bBreakColor, bBreakGeom, dBreakAngle) -> Any:
        """
        :type nConvertMode: Any
        :type bAverageCorners: Any
        :type bBreakLinearParabolic: Any
        :type bBreakProp: Any
        :type bBreakMatl: Any
        :type bBreakLayer: Any
        :type bBreakColor: Any
        :type bBreakGeom: Any
        :type dBreakAngle: Any
        """
        ...

    def SetOutputOrientQuad4(self, nStress, nStrain, nForce) -> Any:
        """
        :type nStress: Any
        :type nStrain: Any
        :type nForce: Any
        """
        ...

    def SetOutputOrientQuad8(self, nStress, nStrain, nForce) -> Any:
        """
        :type nStress: Any
        :type nStrain: Any
        :type nForce: Any
        """
        ...

    def SetOutputOrientSolid(self, nIsotropic, nAnisotropic, nHyperelastic) -> Any:
        """
        :type nIsotropic: Any
        :type nAnisotropic: Any
        :type nHyperelastic: Any
        """
        ...

    def SetOutputOrientTri3(self, nStress, nStrain, nForce) -> Any:
        """
        :type nStress: Any
        :type nStrain: Any
        :type nForce: Any
        """
        ...

    def SetOutputOrientTri6(self, nStress, nStrain, nForce) -> Any:
        """
        :type nStress: Any
        :type nStrain: Any
        :type nForce: Any
        """
        ...

    def SetPlateTransform(self, nTransformMode, nCSysID, nDOF, vAlongVector, dToleranceAngle) -> Any:
        """
        :type nTransformMode: Any
        :type nCSysID: Any
        :type nDOF: Any
        :type vAlongVector: Any
        :type dToleranceAngle: Any
        """
        ...

    def SetSolidTransform(self, nTransformMode, nCSysID) -> Any:
        """
        :type nTransformMode: Any
        :type nCSysID: Any
        """
        ...

    def clear(self) -> Any:
        """
        """
        ...


class BeamCalculator:
    CLSID: Any
    Element: Any
    IncludeAxialForce: Any
    IncludeMomentY: Any
    IncludeMomentZ: Any
    IncludeShearForceY: Any
    IncludeShearForceZ: Any
    IncludeTorque: Any
    MeshFactor: Any
    Position: Any

    def CalculateStress(self, nOutputSetID, enStressComponent, pnNumNodes, pdCoordinates, pdStresses, pdMaxStress,
                        pnMaxStressIndex, pdMinStress, pnMinIndexStress) -> Any:
        """
        **Description:**
            Calculates stresses based on forces in one or more specified output sets. Use Include* properties to specify which force components are considered in the calculations.\n
            Note that unless the “Position” property is set, the default position along the beam (End A) is used for all calculations. To recover stresses at different positions along the beam, the “Position” property must be set for each position of interest prior to each corresponding CalculateStress.
            The FindMaxMinStress method automatically will perform calculations for stresses at End A, the beam midpoint, and End B, and return the maximum and minimum stresses.\n
        **Remarks/Usage:**

        **Input:**
            **nOutputSetID:** Output set(s) to use when calculating internal stresses. Use a negative number to specify a single output set ID, otherwise a positive number specifies the Femap Set object ID containing multiple Output Set IDs\n
            **enStressComponent:** Stress component to return. Use zBeamCalculatorStressComponent.\n
        **Output:**
            **pnNumNodes:** Number of Nodes\n
            **pdCoordinates:** Y and Z coordinate for each node\n
            **pdStresses:** Stresses at each node. Array is organized by:\n
            -   Output sets\n
            -   Stress components\n
            -   Stress\n
            nOS = number of output sets requested
            nComp = number of stress components requested. Normally 1, unless FBMC_SC_ALL is specified, in which case 8.\n
            **pdMaxStress:** Maximum stress. If only a single stress component is specified, an array of length 1 is returned containing the maximum stress for the requested stress component. If all stress components are specified, the array is 8 items long and each index corresponds to the values from the zBeamCalculatorStressComponent enumeration\n
            **pnMaxStressIndex:** The values in this array vary based upon the requested data \n
            If a single stress component is specified, the array will be of length 1, otherwise the array will be of length 8.\n
            If a single output set is specified the value(s) in the array will be the node index where the maximum stress was found. If multiple output sets are specified the value(s) in the array will be the output set corresponding to the max stress\n
            **pdMinStress:** Minimum stress. If only a single stress component is specified, an array of length 1 is returned containing the minimum stress for the requested stress component. If all stress components are specified, the array is 8 items long and each index corresponds to the values from the zBeamCalculatorStressComponent enumeration\n
            **pnMinIndexStress:** The values in this array vary based upon the requested data\n
            If a single stress component is specified, the array will be of length 1, otherwise the array will be of length 8.\n
            If a single output set is specified the value(s) in the array will be the node index where the minimum stress was found. If multiple output sets are specified the value(s) in the array will be the output set corresponding to the minimum stress
        **Return Code:** True\n

        :type nOutputSetID: int
        :type enStressComponent: Any
        :type pnNumNodes: int
        :type pdCoordinates: tuple[float]
        :type pdStresses: tuple[float]
        :type pdMaxStress: tuple[float]
        :type pnMaxStressIndex: tuple[int]
        :type pdMinStress: tuple[float]
        :type pnMinIndexStress: tuple[int]

        """
        ...

    def CalculateStressFromForces(self, dEndAForces, dEndBForces, enStressComponent, pnNumNodes, pdCoordinates,
                                  pdStresses, pdMaxStress, pnMaxStressInfo, pdMinStress, pnMinStressInfo) -> Any:
        """
        **Description:**
            Calculates beam stresses using user-defined forces, rather than forces from an output set. Include* Beam Calculator properties are ignored when using this method.
        **Remarks/Usage:**

        **Input:**
            **dEndAForces:** Forces at end A\n
            **dEndBForces:** Forces at end B\n
            **enStressComponent:** Stress component to return. Use zBeamCalculatorStressComponent\n
        **Output:**
            **pnNumNodes:** Number of Nodes\n
            **pdCoordinates:** [(0..pnNumNodes)*2 - 1]\n
            **pdStresses:** [nOS*nComp*(pnNumNodes) - 1]\n
        **Return Code:** True\n
        :type dEndAForces: tuple[float]

        :type dEndBForces: tuple[float]

        :type enStressComponent: Any

        :type pnNumNodes: int

        :type pdCoordinates: float

        :type pdStresses: float

        """
        ...

    def FindMaxMinStress(self, nOutputSetID, enStressComponent, nMaxSetID, enMaxComponent, dMaxLocation, dMaxStress,
                         nMinSetID, enMinComponent, dMinLocation, dMinStress) -> Any:
        """
        **Description:**
            Returns maximum and minimum stress along with the associated stress component for an element across one or more output sets. Max/min stresses are taken from calculations performed at End A, End B and 50% along the length of the element.
        **Remarks/Usage:**

        **Input:**
            **nOutputSetID:** Output Set ID. Positive value is the ID of a Set object containing one or more output sets. A negative value is the ID of a single Output Set\n
        **Output:**
            **nMaxSetID:** Output set ID associated with maximum stress\n
            **enMaxComponent:** Stress component associated with maximum stress. Unless FBMC_SC_ALL is specified, this will be the same as the component specified with enComponent\n
            **dMaxLocation:** Location along the beam where maximum stress is found. Currently, will return:\n
            **dMaxStress:** Maximum stress\n
            **nMinSetID:** Output set ID associated with minimum stress\n
            **enMinComponent:** Stress component associated with minimum stress. Unless FBMC_SC_ALL is specified, this will be the same as the component specified with enComponent\n
            **dMinLocation:** Location along the beam where minimum stress is found. Currently, will return:\n
            **dMinStress:** Minimum stress\n
        **Return Code:** True\n
        :type nOutputSetID: int

        :type nMaxSetID: int

        :type enMaxComponent: Any

        :type dMaxLocation: float

        :type dMaxStress: float

        :type nMinSetID: int

        :type enMinComponent: Any

        :type dMinLocation: float

        :type dMinStress: float

        """
        ...

    def GetElementProperties(self, dArea, dIzz, dIyy, dIyz, dfJ, dShearAreaY, dShearAreaZ, dWarp, dNeutralAxisOffsetY,
                             dNeutralAxisOffsetZ) -> Any:
        """
        **Description:**
            Returns beam properties calculated from mesh at the location along the beam specified for the element specified
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def GetMeshInfo(self, nNumNode, dNodeYZ, nNumElem, nElemNodes) -> Any:
        """
        **Description:**
            Returns node location element connectivity information about the associated mesh
        **Remarks/Usage:**

        **Output:**
            **nNumNode:** Number of nodes\n
            **dNodeYZ:** [0..((pnNumNode)*2 - 1)]\n
            **nNumElem:** Number of elements\n
            **nElemNodes:** [0..((pnNumElem)*9 - 1)]\n
        **Return Code:** True\n
        :type nNumNode: int

        :type dNodeYZ: float

        :type nNumElem: int

        :type nElemNodes: int

        """
        ...


class AnalysisStudy:
    CLSID: Any
    Active: Any
    AnalysisProg: Any
    AnalysisSet: Any
    AnalysisType: Any
    FileTime: Any
    ID: Any
    SetID: Any
    notes: Any
    title: Any

    def AddOutputSets(self, nSetID) -> Any:
        """
        **Description:**
            The method adds all output sets in a set object to an analysis study
        **Remarks/Usage:**

        **Input:**
            **nSetID:** The ID of a Set that contains output set IDs to add to analysis study. Alternatively, if you specify a negative value, this is simply the ID of a single output set to add to the analysis study.\n
        **Return Code:** False\n
        :type nSetID: int

        """
        ...

    def CountOutputSets(self) -> Any:
        """
        **Description:**
            This method returns the number of output sets which reside in an analysis study.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nSetID, bDeleteOutput) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nSetID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def HasOutputSet(self, nSetID) -> Any:
        """
        **Description:**
            This method returns a Boolean indicating if the specified output set reside in the analysis study currently loaded in the AnalysisStudy object.
        **Remarks/Usage:**

        **Input:**
            **nSetID:** The ID of an output set\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def OutputSets(self, nOutputSetSetID) -> Any:
        """
        **Description:**
            This method loads an existing Set object with the output set IDs for the analysis study currently loaded in the AnalysisStudy object
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def RemoveAllOutputSets(self) -> Any:
        """
        **Description:**
            The method removes all output sets from an analysis study
        **Remarks/Usage:**

        **Return Code:** False\n
        """
        ...

    def RemoveOutputSets(self, nSetID) -> Any:
        """
        **Description:**
            The method removes all output sets in a set object from an analysis study
        **Remarks/Usage:**

        **Input:**
            **nSetID:** The ID of a Set that contains output set IDs to remove from analysis study. Alternatively, if you specify a negative value, this is simply the ID of a single output set to remove from the analysis study.\n
        **Return Code:** False\n
        :type nSetID: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class DrawErase:
    CLSID: Any
    AutoSelectMesh: Any
    DrawModeSelectFromAll: Any
    Enable: Any
    EraseGeometry: Any
    EraseMesh: Any
    EraseMode: Any
    ExclusiveDrawMode: Any

    def ClearAll(self) -> Any:
        """
        **Description:**
            Removes all entities of all types from the Draw/Erase lists
        **Remarks/Usage:**

        **Return Code:** False\n
        """
        ...

    def EraseSet(self, entityTYPE, nSetD, bAddToSelection, bClear, bRedraw) -> Any:
        """
        **Description:**
            Loads a set object with entity IDs of a particular entity type into the Draw/Erase Toolbar. Has options to add the IDs to the Erase list or the Draw list and also allows you to clear the list before loading the IDs from the set object.
        **Remarks/Usage:**

        **Input:**
            **entityTYPE:** The type of entities to be removed from the Draw/Erase lists. For entity information, see page179.\n
            **nSetD:** ID of the set filled with entity IDs to load into the Draw/Erase Toolbar\n
            **bAddToSelection:** When True, adds entity IDs from set to the Erase list. When False, adds entity IDs from the set to the Draw list.\n
            **bClear:** When True, clears the Erase list or Draw list before adding the entity IDs from the set. When False, adds the entity IDs to the Erase list or Draw list.\n
            **bRedraw:** When True, a Window, Redraw command will be done. When False, it will not be done.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type nSetD: int

        :type bAddToSelection: bool

        :type bClear: bool

        :type bRedraw: bool

        """
        ...

    def GetErased(self, entityTYPE) -> Any:
        """
        **Description:**
            This method creates and returns a Set object that contains the IDs of all entities of a specified type that are currently selected by the Draw/Erase Toolbar
        **Remarks/Usage:**
            The Set object is returned in place of the return code.
        **Input:**
            **entityTYPE:** The type of entities to be removed from the Draw/Erase lists. For entity information, see page179.\n
        **Return Code:** False\n
        :type entityTYPE: int

        """
        ...

    def Grow(self) -> Any:
        """
        **Description:**
            Expands selection to include the entities connected to the currently selected entities
        **Remarks/Usage:**
            The function does the same thing as using the Grow command on the Draw/Erase Toolbar
        **Return Code:** False\n
        """
        ...

    def HasErased(self) -> Any:
        """
        **Description:**
            Allows you to determine if entities of any type are currently selected by the Draw/Erase Toolbar.
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def HasErasedType(self, entityTYPE) -> Any:
        """
        **Description:**
            Allows you to determine if entities of the specified type are currently selected by the Draw/Erase Toolbar.
        **Remarks/Usage:**

        **Input:**
            **entityTYPE:** The type of entities to be removed from the Draw/Erase lists. For entity information, see page179.\n
        **Return Code:** True\n
        :type entityTYPE: int

        """
        ...

    def LoadGroup(self, groupID) -> Any:
        """
        **Description:**
            Loads a entities found in a specified group into the current mode of Draw/Erase Toolbar. When set to Draw mode, entities in the group will be drawn. When set to Erase mode entities in the group will be erased.
        **Remarks/Usage:**

        **Input:**
            **groupID:** ID of the group to load into the Draw/Erase Toolbar\n
        **Return Code:** False\n
        :type groupID: int

        """
        ...

    def SaveGroup(self, groupID, title) -> Any:
        """
        **Description:**
            Creates a new group of the visible entities and related entities.
        **Remarks/Usage:**

        **Input:**
            **groupID:** ID of the group to create. Specifying a value of -1 will use the next available Group ID or a value of 0 to display the dialog box of the Create Group command on the Draw/Erase Toolbar.\n
            **title:** Title of Group\n
        **Return Code:** False\n
        :type groupID: int

        :type title: str

        """
        ...

    def Shrink(self) -> Any:
        """
        **Description:**
            Reduces selection to no longer include the entities which are not fully surrounded by other entities of the same type
        **Remarks/Usage:**
            The function does the same thing as using the Shrink command on the Draw/Erase Toolbar
        **Return Code:** False\n
        """
        ...

    def clear(self, entityTYPE) -> Any:
        """
        **Description:**
            Removes all entities of the selected type from the Draw/Erase lists
        **Remarks/Usage:**

        **Input:**
            **entityTYPE:** The type of entities to be removed from the Draw/Erase lists. For entity information, see Section 3.3.6, "Entity Types"\n
        **Return Code:** False\n
        :type entityTYPE: int

        """
        ...


class Frequency:
    CLSID: Any
    Active: Any
    CLUSTER: Any
    DF: Any
    F1: Any
    F2: Any
    FSPD: Any
    ID: Any
    LOG: Any
    NDF: Any
    NEF: Any
    NF: Any
    NFM: Any
    SetID: Any
    type: Any

    def AddCaseFreq(self, NF, Fi, asetID, on, acaseID) -> Any:
        """
        :type NF: Any
        :type Fi: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def AddCaseFreq1(self, F1, DF, NDF, asetID, on, acaseID) -> Any:
        """
        :type F1: Any
        :type DF: Any
        :type NDF: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def AddCaseFreq2(self, F1, F2, NF, asetID, on, acaseID) -> Any:
        """
        :type F1: Any
        :type F2: Any
        :type NF: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def AddCaseFreq3(self, F1, F2, NEF, LOG, CLUSTER, asetID, on, acaseID) -> Any:
        """
        :type F1: Any
        :type F2: Any
        :type NEF: Any
        :type LOG: Any
        :type CLUSTER: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def AddCaseFreq4(self, F1, F2, NFM, FPSD, asetID, on, acaseID) -> Any:
        """
        :type F1: Any
        :type F2: Any
        :type NFM: Any
        :type FPSD: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def AddCaseFreq5(self, F1, F2, NFR, FRi, asetID, on, acaseID) -> Any:
        """
        :type F1: Any
        :type F2: Any
        :type NFR: Any
        :type FRi: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def AddCaseFreq5ByFuncID(self, F1, F2, funcID, asetID, on, acaseID) -> Any:
        """
        :type F1: Any
        :type F2: Any
        :type funcID: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def AddCaseFreqByFuncID(self, funcID, asetID, on, acaseID) -> Any:
        """
        :type funcID: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def AddFreq(self, NF, Fi, asetID, on) -> Any:
        """
        **Description:**
            This method adds a FREQ list of solution frequencies, with NF frequency values stored in Fi. If on=TRUE, it means the FREQ list of solution frequencies is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The ID of the newly added list of solution frequencies is the unused maximum ID counting from 0.
        **Input:**
            **NF:** The number of frequency values in Fi\n
            **Fi:** Frequency values (F1,F2,) of FREQ\n
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type NF: int

        :type Fi: tuple[float]

        :type asetID: int

        :type on: bool

        """
        ...

    def AddFreq1(self, F1, DF, NDF, asetID, on) -> Any:
        """
        **Description:**
            This method adds a FREQ1 list of solution frequencies. If on=TRUE, it means the FREQ1 input is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The ID of the newly added list of solution frequencies is the unused maximum ID counting from 0.
        **Input:**
            **F1:** F1 in FREQ1 of NX NASTRAN\n
            **DF:** DF in FREQ1 of NX NASTRAN\n
            **DF:** NDF in FREQ1 of NX NASTRAN\n
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ1 is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type F1: float

        :type DF: float

        :type DF: int

        :type asetID: int

        :type on: bool

        """
        ...

    def AddFreq2(self, F1, F2, NF, asetID, on) -> Any:
        """
        **Description:**
            This method adds a FREQ2 list of solution frequencies. If on=TRUE, it means the FREQ2 input is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The ID of the newly added list of solution frequencies is the unused maximum ID counting from 0.
        **Input:**
            **F1:** F1 in FREQ2 of NX NASTRAN\n
            **F2:** F2 in FREQ2 of NX NASTRAN\n
            **NF:** NF in FREQ2 of NX NASTRAN\n
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ2 is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type NF: int

        :type asetID: int

        :type on: bool

        """
        ...

    def AddFreq3(self, F1, F2, NEF, LOG, CLUSTER, asetID, on) -> Any:
        """
        **Description:**
            This method adds a FREQ3 list of solution frequencies. If on=TRUE, it means the FREQ3 input is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The ID of the newly added list of solution frequencies is the unused maximum ID counting from 0.
        **Input:**
            **F1:** F1 in FREQ3 of NX NASTRAN\n
            **F2:** F2 in FREQ3 of NX NASTRAN\n
            **NEF:** NEF in FREQ3 of NX NASTRAN\n
            **LOG:** If LOG=TRUE, it sets TYPE=LOG in FREQ3. Otherwise it sets TYPE=LINEAR.\n
            **CLUSTER:** CLUSTER in FREQ3 of NX NASTRAN\n
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ3 is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type NEF: int

        :type LOG: bool

        :type CLUSTER: float

        :type asetID: int

        :type on: bool

        """
        ...

    def AddFreq4(self, F1, F2, NFM, FPSD, asetID, on) -> Any:
        """
        **Description:**
            This method adds a FREQ4 list of solution frequencies. If on=TRUE, it means the FREQ4 input is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The ID of the newly added list of solution frequencies is the unused maximum ID counting from 0.
        **Input:**
            **F1:** F1 in FREQ4 of NX NASTRAN\n
            **F2:** F2 in FREQ4 of NX NASTRAN\n
            **NFM:** NFM in FREQ4 of NX NASTRAN\n
            **FPSD:** FPSD in FREQ4 of NX NASTRAN\n
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ4 is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type NFM: int

        :type FPSD: float

        :type asetID: int

        :type on: bool

        """
        ...

    def AddFreq5(self, F1, F2, NFR, FRi, asetID, on) -> Any:
        """
        **Description:**
            This method adds a FREQ5 list of solution frequencies, with NFR frequency values stored in FRi. If on=TRUE, it means the FREQ5 input is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The ID of the newly added list of solution frequencies is the unused maximum ID counting from 0.
        **Input:**
            **F1:** F1 in FREQ5 of NX NASTRAN\n
            **F2:** F2 in FREQ5 of NX NASTRAN\n
            **NFR:** The number of frequency values in FRi\n
            **FRi:** Frequency values (F1,F2,) of FREQ5 in the range of F1 and F2\n
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ5 is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type NFR: int

        :type FRi: tuple[float]

        :type asetID: int

        :type on: bool

        """
        ...

    def AddFreq5ByFuncID(self, F1, F2, funcID, asetID, on) -> Any:
        """
        **Description:**
            This method adds a FREQ5 list of solution frequencies, with the frequency values defined by a function specified by funcID. If on=TRUE, it means the FREQ5 input is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The ID of the newly added list of solution frequencies is the unused maximum ID counting from 0. Refer to Section 5.30, "Function Objects".
        **Input:**
            **F1:** F1 in FREQ5 of NX NASTRAN\n
            **F2:** F2 in FREQ5 of NX NASTRAN\n
            **funcID:** The ID of the function\n
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ5 is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type funcID: int

        :type asetID: int

        :type on: bool

        """
        ...

    def AddFreqByFuncID(self, funcID, asetID, on) -> Any:
        """
        **Description:**
            This method adds a FREQ list of solution frequencies, with the frequency values defined by a function specified by funcID. If on=TRUE, it means the FREQ input is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The ID of the newly added list of solution frequencies is the unused maximum ID counting from 0. Refer to Section 5.30, "Function Objects".
        **Input:**
            **funcID:** The ID of the function\n
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type funcID: int

        :type asetID: int

        :type on: bool

        """
        ...

    def AllOff(self, asetID) -> Any:
        """
        **Description:**
            This method sets the flag to False for all solution frequencies list(s) defined in the model, in the analysis set(s) specified by asetID.
        **Remarks/Usage:**
            Opposite operation to AllOn
        **Input:**
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
        **Return Code:** True\n
        :type asetID: int

        """
        ...

    def AllOffCase(self, asetID, acaseID) -> Any:
        """
        :type asetID: Any
        :type acaseID: Any
        """
        ...

    def AllOn(self, asetID) -> Any:
        """
        **Description:**
            This method sets the flag to True for all solution frequencies list(s) defined in the model, in the analysis set(s) specified by asetID.
        **Remarks/Usage:**
            Opposite operation to AllOff
        **Input:**
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
        **Return Code:** True\n
        :type asetID: int

        """
        ...

    def AllOnCase(self, asetID, acaseID) -> Any:
        """
        :type asetID: Any
        :type acaseID: Any
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetFREQ1Data(self, F1, DF, NDF) -> Any:
        """
        **Description:**
            This method returns the FREQ1 data.
        **Remarks/Usage:**
            This method simply retrieves the information about the Freq from the current object. You must first load that data by using the Get( ) method.
        **Output:**
            **F1:** Value of First Frequency (F1)\n
            **DF:** Value of Frequency Increment (DF)\n
            **DF:** Value of Number of Increments (NDF)\n
        **Return Code:** True\n
        :type F1: float

        :type DF: int

        :type DF: int

        """
        ...

    def GetFREQ2Data(self, F1, F2, NF) -> Any:
        """
        **Description:**
            This method returns the FREQ2 data.
        **Remarks/Usage:**
            This method simply retrieves the information about the Freq from the current object. You must first load that data by using the Get( ) method.
        **Output:**
            **F1:** Value of First Frequency (F1)\n
            **F2:** Value of Last Frequency (F2)\n
            **NF:** Value for the Number of Log Interval (NF)\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type NF: int

        """
        ...

    def GetFREQ3Data(self, F1, F2, NEF, LOG, CLUSTER) -> Any:
        """
        **Description:**
            This method returns the FREQ3 data.
        **Remarks/Usage:**
            This method simply retrieves the information about the Freq from the current object. You must first load that data by using the Get( ) method.
        **Output:**
            **F1:** Value of First Frequency (F1)\n
            **F2:** Value of Last Frequency (F2)\n
            **NEF:** Value of Number of Frequencies (NEF)\n
            **LOG:** If True, Logarithmic option is checked\n
            **CLUSTER:** Value of Cluster\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type NEF: int

        :type LOG: bool

        :type CLUSTER: float

        """
        ...

    def GetFREQ4Data(self, F1, F2, NFM, FPSD) -> Any:
        """
        **Description:**
            This method returns the FREQ4 data.
        **Remarks/Usage:**
            This method simply retrieves the information about the Freq from the current object. You must first load that data by using the Get( ) method.
        **Output:**
            **F1:** Value of First Frequency (F1)\n
            **F2:** Value of Last Frequency (F2)\n
            **NFM:** Value of Number of Frequencies (NFM)\n
            **FPSD:** Value of Spread (FSPD, +/- %)\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type NFM: int

        :type FPSD: float

        """
        ...

    def GetFREQ5Data(self, F1, F2, NFR, FRi, funcID) -> Any:
        """
        **Description:**
            This method returns the FREQ5 data.
        **Remarks/Usage:**
            This method simply retrieves the information about the Freq from the current object. You must first load that data by using the Get( ) method.
        **Output:**
            **F1:** Value of First Frequency (F1)\n
            **F2:** Value of Last Frequency (F2)\n
            **NFR:** Value of Number of Frequencies (NFR)\n
            **FRi:** Frequency values (F1,F2,) of FREQ5 in the range of F1 and F2.\n
            **funcID:** ID of FEMAP function specified in Function ID drop-down\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type NFR: int

        :type FRi: tuple[float]

        :type funcID: int

        """
        ...

    def GetFREQData(self, NF, Fi, funcID) -> Any:
        """
        **Description:**
            This method returns the FREQ data.
        **Remarks/Usage:**
            This method simply retrieves the information about the Freq from the current object. You must first load that data by using the Get( ) method.
        **Return Code:** True\n
        """
        ...

    def GetFREQType(self, FREQ_Type) -> Any:
        """
        **Description:**
            This method returns the FREQ type.
        **Remarks/Usage:**
            This method simply retrieves the information about the Freq from the current object. You must first load that data by using the Get( ) method.
        **Output:**
            **FREQ_Type:** The Freq type - FREQ, FREQ1, FREQ2, FREQ3, FREQ4 or FREQ5.\n
        **Return Code:** True\n
        :type FREQ_Type: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetFREQ1Data(self, F1, DF, NDF) -> Any:
        """
        **Description:**
            This method sets the FREQ1 data.
        **Remarks/Usage:**
            This method does not store that information to the model database. After using this function, you must call Put() if you want to store the lists in the database.
        **Input:**
            **F1:** Value of First Frequency (F1)\n
            **DF:** Value of Frequency Increment (DF)\n
            **DF:** Value of Number of Increments (NDF)\n
        **Return Code:** True\n
        :type F1: float

        :type DF: int

        :type DF: int

        """
        ...

    def SetFREQ2Data(self, F1, F2, NF) -> Any:
        """
        **Description:**
            This method sets the FREQ2 data.
        **Remarks/Usage:**
            This method does not store that information to the model database. After using this function, you must call Put() if you want to store the lists in the database.
        **Input:**
            **F1:** Value of First Frequency (F1)\n
            **F2:** Value of Last Frequency (F2)\n
            **NF:** Value for the Number of Log Interval (NF)\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type NF: int

        """
        ...

    def SetFREQ3Data(self, F1, F2, NEF, LOG, CLUSTER) -> Any:
        """
        **Description:**
            This method sets the FREQ3 data.
        **Remarks/Usage:**
            This method does not store that information to the model database. After using this function, you must call Put() if you want to store the lists in the database.
        **Input:**
            **F1:** Value of First Frequency (F1)\n
            **F2:** Value of Last Frequency (F2)\n
            **NEF:** Value of Number of Frequencies (NEF)\n
            **LOG:** If True, checks Logarithmic option\n
            **CLUSTER:** Value of Cluster\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type NEF: int

        :type LOG: bool

        :type CLUSTER: float

        """
        ...

    def SetFREQ4Data(self, F1, F2, NFM, FPSD) -> Any:
        """
        **Description:**
            This method sets the FREQ4 data.
        **Remarks/Usage:**
            This method does not store that information to the model database. After using this function, you must call Put() if you want to store the lists in the database.
        **Input:**
            **F1:** Value of First Frequency (F1)\n
            **F2:** Value of Last Frequency (F2)\n
            **NFM:** Value of Number of Frequencies (NFM)\n
            **FPSD:** Value of Spread (FSPD, +/- %)\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type NFM: int

        :type FPSD: float

        """
        ...

    def SetFREQ5Data(self, F1, F2, NFR, FRi, funcID) -> Any:
        """
        **Description:**
            This method sets the FREQ5 data.
        **Remarks/Usage:**
            This method does not store that information to the model database. After using this function, you must call Put() if you want to store the lists in the database.
        **Input:**
            **F2:** Value of Last Frequency (F2)\n
            **NFR:** Value of Number of Frequencies (NFR)\n
            **FRi:** Frequency values (F1,F2,) of FREQ5 in the range of F1 and F2.\n
            **funcID:** ID of FEMAP function specified in Function ID drop-down\n
        **Return Code:** True\n
        :type F2: float

        :type NFR: int

        :type FRi: tuple[float]

        :type funcID: int

        """
        ...

    def SetFREQData(self, NF, Fi, funcID) -> Any:
        """
        **Description:**
            This method sets the FREQ data.
        **Remarks/Usage:**
            This method does not store that information to the model database. After using this function, you must call Put() if you want to store the lists in the database.
        **Return Code:** True\n
        """
        ...

    def TurnOff(self, asetID, freqID) -> Any:
        """
        **Description:**
            This method sets the flag to False for the solution frequencies list(s) specified by freqID, in the analysis set(s) specified by asetID.
        **Remarks/Usage:**
            Opposite operation to TurnOn
        **Input:**
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **freqID:** The ID of a set that contains IDs of lists of solution frequencies. Alternatively, if you specify a negative value, this is simply the ID of the single list of solution frequencies, while a value of 0 selects all available lists of solution frequencies. Refer to Section 4.6, "Set Objects"\n
        **Return Code:** True\n
        :type asetID: int

        :type freqID: int

        """
        ...

    def TurnOffCase(self, asetID, freqID, acaseID) -> Any:
        """
        :type asetID: Any
        :type freqID: Any
        :type acaseID: Any
        """
        ...

    def TurnOn(self, asetID, freqID) -> Any:
        """
        **Description:**
            This method sets the flag to True for the solution frequencies list(s) specified by freqID, in the analysis set(s) specified by asetID.
        **Remarks/Usage:**
            Opposite operation to TurnOff
        **Input:**
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **freqID:** The ID of a set that contains IDs of lists of solution frequencies. Alternatively, if you specify a negative value, this is simply the ID of the single list of solution frequencies, while a value of 0 selects all available lists of solution frequencies. Refer to Section 4.6, "Set Objects"\n
        **Return Code:** True\n
        :type asetID: int

        :type freqID: int

        """
        ...

    def TurnOnCase(self, asetID, freqID, acaseID) -> Any:
        """
        :type asetID: Any
        :type freqID: Any
        :type acaseID: Any
        """
        ...

    def UpdCaseFreq(self, NF, Fi, asetID, on, acaseID) -> Any:
        """
        :type NF: Any
        :type Fi: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def UpdCaseFreq1(self, F1, DF, NDF, asetID, on, acaseID) -> Any:
        """
        :type F1: Any
        :type DF: Any
        :type NDF: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def UpdCaseFreq2(self, F1, F2, NF, asetID, on, acaseID) -> Any:
        """
        :type F1: Any
        :type F2: Any
        :type NF: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def UpdCaseFreq3(self, F1, F2, NEF, LOG, CLUSTER, asetID, on, acaseID) -> Any:
        """
        :type F1: Any
        :type F2: Any
        :type NEF: Any
        :type LOG: Any
        :type CLUSTER: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def UpdCaseFreq4(self, F1, F2, NFM, FPSD, asetID, on, acaseID) -> Any:
        """
        :type F1: Any
        :type F2: Any
        :type NFM: Any
        :type FPSD: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def UpdCaseFreq5(self, F1, F2, NFR, FRi, asetID, on, acaseID) -> Any:
        """
        :type F1: Any
        :type F2: Any
        :type NFR: Any
        :type FRi: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def UpdCaseFreq5ByFuncID(self, F1, F2, funcID, asetID, on, acaseID) -> Any:
        """
        :type F1: Any
        :type F2: Any
        :type funcID: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def UpdCaseFreqByFuncID(self, funcID, asetID, on, acaseID) -> Any:
        """
        :type funcID: Any
        :type asetID: Any
        :type on: Any
        :type acaseID: Any
        """
        ...

    def UpdFreq(self, NF, Fi, asetID, on) -> Any:
        """
        **Description:**
            This method updates the current list of solution frequencies to FREQ type, with NF frequency values stored in Fi. If on=TRUE, it means the FREQ input is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The current list of solution frequencies is selected by the Get method of the Entity object. It needs to call the Put method of the Entity object to update.
        **Input:**
            **NF:** The number of frequency values in Fi\n
            **Fi:** Frequency values (F1,F2,) of FREQ\n
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type NF: int

        :type Fi: tuple[float]

        :type asetID: int

        :type on: bool

        """
        ...

    def UpdFreq1(self, F1, DF, NDF, asetID, on) -> Any:
        """
        **Description:**
            This method updates the current list of solution frequencies to a FREQ1 list of solution frequencies. If on=TRUE, it means the FREQ1 input is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The current list of solution frequencies is selected by the Get method of the Entity object. It needs to call the Put method of the Entity object to update.
        **Input:**
            **F1:** F1 in FREQ1 of NX NASTRAN\n
            **DF:** DF in FREQ1 of NX NASTRAN\n
            **DF:** NDF in FREQ1 of NX NASTRAN\n
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ1 is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type F1: float

        :type DF: float

        :type DF: int

        :type asetID: int

        :type on: bool

        """
        ...

    def UpdFreq2(self, F1, F2, NF, asetID, on) -> Any:
        """
        **Description:**
            This method updates the current list of solution frequencies to a FREQ2 list of solution frequencies. If on=TRUE, it means the FREQ2 input is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The current list of solution frequencies is selected by the Get method of the Entity object. It needs to call the Put method of the Entity object to update.
        **Input:**
            **F1:** F1 in FREQ2 of NX NASTRAN\n
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ2 is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type F1: float

        :type asetID: int

        :type on: bool

        """
        ...

    def UpdFreq3(self, F1, F2, NEF, LOG, CLUSTER, asetID, on) -> Any:
        """
        **Description:**
            This method updates the current list of solution frequencies to a FREQ3 list of solution frequencies. If on=TRUE, it means the FREQ3 input is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The current list of solution frequencies is selected by the Get method of the Entity object. It needs to call the Put method of the Entity object to update.
        **Input:**
            **F1:** F1 in FREQ3 of NX NASTRAN\n
            **F2:** F2 in FREQ3 of NX NASTRAN\n
            **NEF:** NEF in FREQ3 of NX NASTRAN\n
            **LOG:** If LOG=TRUE, it sets TYPE=LOG in FREQ3. Otherwise it sets TYPE=LINEAR.\n
            **CLUSTER:** CLUSTER in FREQ3 of NX NASTRAN\n
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ3 is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type NEF: int

        :type LOG: bool

        :type CLUSTER: float

        :type asetID: int

        :type on: bool

        """
        ...

    def UpdFreq4(self, F1, F2, NFM, FPSD, asetID, on) -> Any:
        """
        **Description:**
            This method updates the current list of solution frequencies to a FREQ4 list of solution frequencies. If on=TRUE, it means the FREQ4 input is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The current list of solution frequencies is selected by the Get method of the Entity object. It needs to call the Put method of the Entity object to update.
        **Input:**
            **F1:** F1 in FREQ4 of NX NASTRAN\n
            **F2:** F2 in FREQ4 of NX NASTRAN\n
            **NFM:** NFM in FREQ4 of NX NASTRAN\n
            **FPSD:** FPSD in FREQ3 of NX NASTRAN\n
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ4 is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type NFM: int

        :type FPSD: float

        :type asetID: int

        :type on: bool

        """
        ...

    def UpdFreq5(self, F1, F2, NFR, FRi, asetID, on) -> Any:
        """
        **Description:**
            This method updates the current list of solution frequencies to FREQ5 type, with NFR frequency values stored in FRi. If on=TRUE, it means the FREQ5 input is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The current list of solution frequencies is selected by the Get method of the Entity object. It needs to call the Put method of the Entity object to update.
        **Input:**
            **F1:** F1 in FREQ5 of NX NASTRAN\n
            **F2:** F2 in FREQ5 of NX NASTRAN\n
            **NFR:** The number of frequency values in FRi\n
            **FRi:** Frequency values (F1,F2,) of FREQ5 in the range of F1 and F2\n
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ5 is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type NFR: int

        :type FRi: tuple[float]

        :type asetID: int

        :type on: bool

        """
        ...

    def UpdFreq5ByFuncID(self, F1, F2, funcID, asetID, on) -> Any:
        """
        **Description:**
            This method updates the current list of solution frequencies to a FREQ5 list of solution frequencies, with the frequency values defined by a function specified by funcID. If on=TRUE, it means the FREQ5 input is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The current list of solution frequencies is selected by the Get method of the Entity object. It needs to call the Put method of the Entity object to update. Refer to Section 5.30, "Function Objects".
        **Input:**
            **F1:** F1 in FREQ5 of NX NASTRAN\n
            **F2:** F2 in FREQ5 of NX NASTRAN\n
            **funcID:** The ID of the function\n
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ5 is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type F1: float

        :type F2: float

        :type funcID: int

        :type asetID: int

        :type on: bool

        """
        ...

    def UpdFreqByFuncID(self, funcID, asetID, on) -> Any:
        """
        **Description:**
            This method updates the current list of solution frequencies to a FREQ list of solution frequencies, with the frequency values defined by a function specified by funcID. If on=TRUE, it means the FREQ input is used in the analysis set specified by asetID.
        **Remarks/Usage:**
            The current list of solution frequencies is selected by the Get() method of the Entity object. It needs to call the Put() method of the Entity object to update. Refer to Section 5.30, "Function Objects".
        **Input:**
            **asetID:** The ID of a set that contains analysis set IDs. Alternatively, if you specify a negative value, this is simply the ID of the single analysis set, while a value of 0 indicates all analysis sets. Refer to Section 4.6, "Set Objects"\n
            **on:** If on=TRUE, it sets the flag that the input FREQ is used in the analysis set specified by asetID.\n
        **Return Code:** True\n
        :type asetID: int

        :type on: bool

        """
        ...


class MidFaceCentroidModel:
    CLSID: Any

    def GenerateMidFaceCentroidNodes(self) -> Any:
        """
        """
        ...

    def KeepNodes(self, qKeepNodes) -> Any:
        """
        :type qKeepNodes: Any
        """
        ...

    def Rotate(self) -> Any:
        """
        """
        ...

    def SetCentroidNodeColor(self, iColor) -> Any:
        """
        :type iColor: Any
        """
        ...

    def SetFaceNodeColor(self, iColor) -> Any:
        """
        :type iColor: Any
        """
        ...

    def SetLoadAndConstraintSet(self, ILoadSet, IBCSet) -> Any:
        """
        :type ILoadSet: Any
        :type IBCSet: Any
        """
        ...

    def SetMappingBrick20(self, iDefaultMapping, iGroupHex20, iGroupHex26, iGroupHex27) -> Any:
        """
        :type iDefaultMapping: Any
        :type iGroupHex20: Any
        :type iGroupHex26: Any
        :type iGroupHex27: Any
        """
        ...

    def SetMappingPyramid13(self, iDefaultMapping, iGroupPyramid14, iGroupPyramid18, iGroupPyramid19) -> Any:
        """
        :type iDefaultMapping: Any
        :type iGroupPyramid14: Any
        :type iGroupPyramid18: Any
        :type iGroupPyramid19: Any
        """
        ...

    def SetMappingQuad8(self, iDefaultMapping, iGroupQuad8, iGroupQuad9) -> Any:
        """
        :type iDefaultMapping: Any
        :type iGroupQuad8: Any
        :type iGroupQuad9: Any
        """
        ...

    def SetMappingTetra10(self, iDefaultMapping, iGroupTet10, iGroupTet14, iGroupTet15) -> Any:
        """
        :type iDefaultMapping: Any
        :type iGroupTet10: Any
        :type iGroupTet14: Any
        :type iGroupTet15: Any
        """
        ...

    def SetMappingTria6(self, iDefaultMapping, iGroupTri6, iGroupTri7) -> Any:
        """
        :type iDefaultMapping: Any
        :type iGroupTri6: Any
        :type iGroupTri7: Any
        """
        ...

    def SetMappingWedge15(self, iDefaultMapping, iGroupWedge15, iGroupWedge20, iGroupWedge21) -> Any:
        """
        :type iDefaultMapping: Any
        :type iGroupWedge15: Any
        :type iGroupWedge20: Any
        :type iGroupWedge21: Any
        """
        ...

    def SetNodeStartIDs(self, iFirstFaceNodeID, iFirstCentroidNodeID) -> Any:
        """
        :type iFirstFaceNodeID: Any
        :type iFirstCentroidNodeID: Any
        """
        ...

    def SetPointGroup(self, IGroup) -> Any:
        """
        :type IGroup: Any
        """
        ...

    def SetTitle(self, fName) -> Any:
        """
        :type fName: Any
        """
        ...

    def ShowHex_20(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowHex_26(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowHex_27(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowHex_8(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowPyramid_14(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowPyramid_18(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowPyramid_19(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowPyramid_5(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowQuad_4(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowQuad_8(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowQuad_9(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowTet_14(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowTet_15(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowTet_4(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowTri_3(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowTri_6(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowTri_7(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowWedge_15(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowWedge_20(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowWedge_21(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def ShowWedge_6(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def Show_Tet_10(self, qNodes) -> Any:
        """
        :type qNodes: Any
        """
        ...

    def WriteNeutralFile(self, fName) -> Any:
        """
        :type fName: Any
        """
        ...


class UserDefinedGraphics:
    CLSID: Any

    def Attach(self, pDetachedName) -> Any:
        """
        **Description:**
            This function attaches previously detached graphics to a User Defined Graphics object. When the graphics are attached, they will replace all graphics in the User Defined Graphics object at the point Attach is called. While graphics are attached, they will be lost when the User Defined Graphics object is destroyed unless Detach is called again. The graphics data to attach is specified by pDetachedName: if a previously detached graphics data has a matching pDetachedName, it will be attached to the User Defined Graphics object. The main use of the Detach/Attach capability is to be able to have graphics survive after an API has finished running and to then access them again in another API. It is advised to not use the same pDetachedName for more than one Detach at a time as a call to Attach will not know which order to access them in.
        **Remarks/Usage:**
            None
        **Input:**
            **pDetachedName:** See description\n
        **Return Code:** True\n
        :type pDetachedName: str

        """
        ...

    def BitmapCreate(self, iWidth, iHeight, pqBits, piBitmapID) -> Any:
        """
        **Description:**
            This function creates a Bitmap that can be used by a Bitmap collector
        **Remarks/Usage:**
            None
        **Input:**
            **iWidth:** Width of Bitmap\n
            **iHeight:** Height of Bitmap\n
        **Output:**
            **piBitmapID:** ID of Bitmap created\n
        **Return Code:** True\n
        :type iWidth: int

        :type iHeight: int

        :type piBitmapID: int

        """
        ...

    def BitmapMarkForDeletion(self, iBitmapID) -> Any:
        """
        **Description:**
            This function marks a Bitmap for deletion. After it has been marked for deletion, it cannot be used by a Bitmap collector
        **Remarks/Usage:**
            None
        **Input:**
            **iBitmapID:** ID of Bitmap to mark for deletion\n
        **Return Code:** True\n
        :type iBitmapID: int

        """
        ...

    def Blank(self, qBlanked) -> Any:
        """
        **Description:**
            This function blanks the User Defined Graphics object so it will not be drawn until it is un-blanked
        **Remarks/Usage:**
            There is also a CollectorBlank method for individual collectors of graphics entities inside the User Defined Graphics object
        **Input:**
            **qBlanked:** If True, the User Defined Graphics object is blanked. If False, the User Defined Graphics object is un-blanked.\n
        **Return Code:** True\n
        :type qBlanked: bool

        """
        ...

    def CollectorAddLineLocations(self, iCollectorID, iAppearanceID, nLines, pdPoints) -> Any:
        """
        **Description:**
            This functions adds lines at locations in global space to a Line collector.
        **Remarks/Usage:**
            None
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nLines:** Number of lines to add\n
            **pdPoints:** [0..nLines*2*3)-1]\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nLines: int

        :type pdPoints: float

        """
        ...

    def CollectorAddMeshLineLocations(self, iCollectorID, iAppearanceID, nPoints, pdPoints, nLines, piLines) -> Any:
        """
        **Description:**
            This functions adds a polyline at locations in global space to a Line collector.
        **Remarks/Usage:**
            None
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nPoints:** Number of points\n
            **pdPoints:** [0..(3*nPoints)-1]\n
            **nLines:** Number of lines\n
            **piLines:** [0..(2*nLines)-1]\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nPoints: int

        :type pdPoints: float

        :type nLines: int

        :type piLines: int

        """
        ...

    def CollectorAddMeshTriangleLocations(self, iCollectorID, iAppearanceID, nPoints, pdPoints, nTriangles,
                                          piTriangles) -> Any:
        """
        **Description:**
            This functions adds a mesh of triangles at locations in global space to a Triangle collector.
        **Remarks/Usage:**
            If the selected appearance has lighting/shading switched on, the normal used is calculated as the normal of each flat triangle.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nPoints:** Number of points\n
            **pdPoints:** [0..nPoints*3)-1]\n
            **nTriangles:** Number of triangles\n
            **piTriangles:** [0..nTriangles*3)-1]\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nPoints: int

        :type pdPoints: float

        :type nTriangles: int

        :type piTriangles: float

        """
        ...

    def CollectorAddMeshTriangleNormalLocations(self, iCollectorID, iAppearanceID, nPoints, pdPoints, pdNormals,
                                                nTriangles, piTriangles) -> Any:
        """
        **Description:**
            This functions adds a mesh of triangles at locations in global space to a Triangle collector. The normal enable the lighting/shading to be smooth over the mesh of triangles.
        **Remarks/Usage:**
            None
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nPoints:** Number of points\n
            **pdPoints:** [0..(3*nPoints)-1]\n
            **pdNormals:** [0..(3*nPoints)-1]\n
            **nTriangles:** Number of triangles\n
            **piTriangles:** [0..(3*nTriangles)-1]\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nPoints: int

        :type pdPoints: float

        :type pdNormals: float

        :type nTriangles: int

        :type piTriangles: int

        """
        ...

    def CollectorAddPointEntityFaceLocations(self, iCollectorID, iAppearanceID, eType, nIDs, piIDs, piFaceIDs) -> Any:
        """
        **Description:**
            This function adds points specified by a particular face of existing Femap entities to a Point collector or Bitmap collector
        **Remarks/Usage:**
            A point is created at the centroid of the specified face of the specified element (currently only shells and solids)
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
            **piFaceIDs:** Face ID of entity\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        :type piFaceIDs: tuple[int]

        """
        ...

    def CollectorAddPointEntityLocations(self, iCollectorID, iAppearanceID, eType, nIDs, piIDs) -> Any:
        """
        **Description:**
            This function adds points specified by existing Femap entities to a Point collector or Bitmap collector
        **Remarks/Usage:**
            IF FT_CURVE or FT_SURFACE is used, multiple points are created at the locations used for geometry based loading. If FT_ELEM is used, a point is created at the centroid of the element (currently only shells and solids)
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        """
        ...

    def CollectorAddPointLocations(self, iCollectorID, iAppearanceID, nPoints, pdPoints) -> Any:
        """
        **Description:**
            This functions adds point locations in global space to a Point collector or to a Bitmap collector.
        **Remarks/Usage:**
            A point (or bitmap) will be drawn at each location specified using the specified appearance. If the appearance ID is too large, it is wrapped: if there are 5 appearances and the iAppearanceID is set to 8 then appearance 3 will be used.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nPoints:** Number of points\n
            **pdPoints:** [0..(3*npoints)-1]\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nPoints: int

        :type pdPoints: float

        """
        ...

    def CollectorAddPolyLineLocations(self, iCollectorID, iAppearanceID, nPoints, pdPoints) -> Any:
        """
        **Description:**
            This functions adds a polyline at locations in global space to a Line collector.
        **Remarks/Usage:**
            None
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nPoints:** Number of points in the polyline\n
            **pdPoints:** [0..(3*nPoints)+2]\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nPoints: int

        :type pdPoints: float

        """
        ...

    def CollectorAddSymbolEntityEdgeAutoLocations(self, iCollectorID, iAppearanceID, eType, nIDs, piIDs, piEdgeIDs,
                                                  piOrientOptions) -> Any:
        """
        **Description:**
            This functions adds symbol locations specified by particular edges of existing Femap entities to a Symbol collector. The direction and the orthogonal direction is provided for each location. This currently only applies to FT_ELEM. The direction and the orthogonal directions are specified using an orientation option, piOrientOption
        **Remarks/Usage:**
            This function is only valid for FT_ELEM. The Edge ID is based on the numbering of the midside nodes of the parabolic versions of the elements.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
            **piEdgeIDs:** Edge ID of entity\n
            **piOrientOptions:** Orientation option to determine orthogonal direction of symbol at each location. See Remarks section to see the various options available for each entity type\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        :type piEdgeIDs: tuple[int]

        :type piOrientOptions: tuple[int]

        """
        ...

    def CollectorAddSymbolEntityEdgeLocations(self, iCollectorID, iAppearanceID, eType, nIDs, piIDs, piEdgeIDs,
                                              pdDirections, pdOrthogonals) -> Any:
        """
        **Description:**
            This functions adds symbol locations specified by particular edges of existing Femap entities to a Symbol collector. The direction and the orthogonal direction is provided for each location. This currently only applies to FT_ELEM.
        **Remarks/Usage:**
            This function is only valid for FT_ELEM. The Edge ID is based on the numbering of the midside nodes of the parabolic versions of the elements.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
            **piEdgeIDs:** Edge ID of entity\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        :type piEdgeIDs: tuple[int]

        """
        ...

    def CollectorAddSymbolEntityFaceLocations(self, iCollectorID, iAppearanceID, eType, nIDs, piIDs, piFaceIDs,
                                              pdDirections, pdOrthogonals) -> Any:
        """
        **Description:**
            This functions adds symbol locations specified by particular faces of existing Femap entities to a Symbol collector. Direction and orthogonal direction are provided for each location
        **Remarks/Usage:**
            If qScreenOrient = True in the previous call to SymbolCreate, the values of pfOrthogonals are ignored and the symbol XZ plane is rotated in global space to be as close as possible to the plane of the screen.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
            **piFaceIDs:** Face ID of entity\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        :type piFaceIDs: tuple[int]

        """
        ...

    def CollectorAddSymbolEntityFaceNormalAutoLocations(self, iCollectorID, iAppearanceID, eType, nIDs, piIDs,
                                                        piFaceIDs, piOrientOptions, pdOrientAngles) -> Any:
        """
        **Description:**
            This functions adds symbol locations specified by particular faces of existing Femap entities to a Symbol collector. The direction is the normal to the particular face of the existing Femap entities. The orthogonal direction is controlled by an orientation option, piOrientOption (and orientation angle for FT_SURFACE)
        **Remarks/Usage:**
            The face ID is ignored by the FT_CURVE entities but the tangential direction on the curve is used to align the symbols.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
            **piFaceIDs:** Face ID of entity\n
            **piOrientOptions:** Orientation option to determine orthogonal direction of symbol at each location. See Remarks section to see the various options available for each entity type\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        :type piFaceIDs: tuple[int]

        :type piOrientOptions: tuple[int]

        """
        ...

    def CollectorAddSymbolEntityFaceNormalLocations(self, iCollectorID, iAppearanceID, eType, nIDs, piIDs, piFaceIDs,
                                                    pdOrthogonals) -> Any:
        """
        **Description:**
            This functions adds symbol locations specified by particular faces of existing Femap entities to a Symbol collector. The direction is the normal to the particular face of the existing Femap entities. The orthogonal direction is provided for each location
        **Remarks/Usage:**
            The face ID is ignored by the FT_CURVE entities but the tangential direction on the curve is used to align the symbols
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
            **piFaceIDs:** Face ID of entity\n
            **pdOrthogonals:** [0..(3*nIDs)-1]\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        :type piFaceIDs: tuple[int]

        :type pdOrthogonals: float

        """
        ...

    def CollectorAddSymbolEntityLocations(self, iCollectorID, iAppearanceID, eType, nIDs, piIDs, pdDirections,
                                          pdOrthogonals) -> Any:
        """
        **Description:**
            This functions adds symbol locations specified by existing Femap entities to a Symbol collector. Direction and orthogonal direction are provided for each location
        **Remarks/Usage:**
            If qScreenOrient = True in the previous call to SymbolCreate, the values of pfOrthogonals are ignored and the symbol XZ plane is rotated in global space to be as close as possible to the plane of the screen.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** [0..nIDs-1]\n
            **pdOrthogonals:** [0..(3*nIDs)-1]\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nIDs: int

        :type piIDs: int

        :type pdOrthogonals: float

        """
        ...

    def CollectorAddSymbolLocations(self, iCollectorID, iAppearanceID, nSymbols, pdPoints, pfDirections,
                                    pdOrthogonals) -> Any:
        """
        **Description:**
            This functions adds symbol locations and orientations in global space to a Symbol collector.
        **Remarks/Usage:**
            If qScreenOrient = True in the previous call to SymbolCreate, the values of pfOrthogonals are ignored and the symbol XZ plane is rotated in global space to be as close as possible to the plane of the screen.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nSymbols:** Number of symbols to draw\n
            **pdPoints:** [0..(3*nsymbols)-1]\n
            **pdOrthogonals:** [0..(3*nsymbols)-1]\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nSymbols: int

        :type pdPoints: float

        :type pdOrthogonals: float

        """
        ...

    def CollectorAddSymbolREAL8EntityEdgeAutoLocations(self, iCollectorID, iSymbolAppearanceID, iLabelAppearanceID,
                                                       eType, nIDs, piIDs, piEdgeIDs, piOrientOptions, pdValues) -> Any:
        """
        **Description:**
            This functions adds symbol locations specified by particular edges of existing Femap entities to a Symbol collector. The direction and the orthogonal direction is provided for each location. This currently only applies to FT_ELEM. The direction and the orthogonal directions are specified using an orientation option, piOrientOption. A REAL8 value is provided for each symbol location.
        **Remarks/Usage:**
            This function is only valid for FT_ELEM. The Edge ID is based on the numbering of the midside nodes of the parabolic versions of the elements.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iSymbolAppearanceID:** ID of appearance to use for these entities\n
            **eType:** Number of entity IDs\n
            **nIDs:** List of entity IDs\n
            **piIDs:** Edge ID of entity\n
            **piEdgeIDs:** Orientation option to determine orthogonal direction of symbol at each location. See Remarks section to see the various options available for each entity type\n
            **piOrientOptions:** Value for each symbol location\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iSymbolAppearanceID: int

        :type eType: int

        :type nIDs: tuple[int]

        :type piIDs: tuple[int]

        :type piEdgeIDs: tuple[int]

        :type piOrientOptions: tuple[float]

        """
        ...

    def CollectorAddSymbolREAL8EntityEdgeLocations(self, iCollectorID, iSymbolAppearanceID, iLabelAppearanceID, eType,
                                                   nIDs, piIDs, piEdgeIDs, pdDirections, pdOrthogonals,
                                                   pdValues) -> Any:
        """
        **Description:**
            This functions adds symbol locations specified by particular edges of existing Femap entities to a Symbol collector. The direction and the orthogonal direction is provided for each location. This currently only applies to FT_ELEM. A REAL8 value is provided for each symbol location.
        **Remarks/Usage:**
            This function is only valid for FT_ELEM. The Edge ID is based on the numbering of the midside nodes of the parabolic versions of the elements.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iSymbolAppearanceID:** ID of appearance to use for these entities\n
            **eType:** Number of entity IDs\n
            **nIDs:** List of entity IDs\n
            **piIDs:** Edge ID of entity\n
            **piEdgeIDs:** Direction of symbol at each location\n
            **pdOrthogonals:** Value for each symbol location\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iSymbolAppearanceID: int

        :type eType: int

        :type nIDs: tuple[int]

        :type piIDs: tuple[int]

        :type piEdgeIDs: tuple[float]

        :type pdOrthogonals: tuple[float]

        """
        ...

    def CollectorAddSymbolREAL8EntityFaceLocations(self, iCollectorID, iSymbolAppearanceID, iLabelAppearanceID, eType,
                                                   nIDs, piIDs, piFaceIDs, pdDirections, pdOrthogonals,
                                                   pdValues) -> Any:
        """
        **Description:**
            This functions adds symbol locations specified by particular faces of existing Femap entities to a Symbol collector. Direction and orthogonal direction are provided for each location. A REAL8 value is provided for each symbol location.
        **Remarks/Usage:**
            If qScreenOrient = True in the previous call to SymbolCreate, the values of pfOrthogonals are ignored and the symbol XZ plane is rotated in global space to be as close as possible to the plane of the screen.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iSymbolAppearanceID:** Appearance ID for symbol\n
            **iLabelAppearanceID:** Appearance ID for REAL8 value text\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
            **pdOrthogonals:** [0..(3*nsymbols)-1]\n
            **pdValues:** [0..nsymbols-1]\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iSymbolAppearanceID: int

        :type iLabelAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        :type pdOrthogonals: float

        :type pdValues: float

        """
        ...

    def CollectorAddSymbolREAL8EntityFaceNormalAutoLocations(self, iCollectorID, iSymbolAppearanceID,
                                                             iLabelAppearanceID, eType, nIDs, piIDs, piFaceIDs,
                                                             piOrientOptions, pdOrientAngles, pdValues) -> Any:
        """
        **Description:**
            This functions adds symbol locations specified by particular faces of existing Femap entities to a Symbol collector. The direction is the normal to the particular face of the existing Femap entities. The orthogonal direction is controlled by an orientation option, piOrientOption (and orientation angle for FT_SURFACE). A REAL8 value is provided for each symbol location.
        **Remarks/Usage:**
            The face ID is ignored by the FT_CURVE entities but the tangential direction on the curve is used to align the symbols.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iSymbolAppearanceID:** ID of appearance to use for these entities\n
            **eType:** Number of entity IDs\n
            **nIDs:** List of entity IDs\n
            **piIDs:** Face ID of entity\n
            **piFaceIDs:** Orientation option to determine orthogonal direction of symbol at each location. See Remarks section to see the various options available for each entity type\n
            **pdOrientAngles:** Value for each symbol location\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iSymbolAppearanceID: int

        :type eType: int

        :type nIDs: tuple[int]

        :type piIDs: tuple[int]

        :type piFaceIDs: tuple[int]

        :type pdOrientAngles: tuple[float]

        """
        ...

    def CollectorAddSymbolREAL8EntityFaceNormalLocations(self, iCollectorID, iSymbolAppearanceID, iLabelAppearanceID,
                                                         eType, nIDs, piIDs, piFaceIDs, pdOrthogonals, pdValues) -> Any:
        """
        **Description:**
            This functions adds symbol locations specified by particular faces of existing Femap entities to a Symbol collector. The direction is the normal to the particular face of the existing Femap entities. The orthogonal direction is provided for each location. A REAL8 value is provided for each symbol location.
        **Remarks/Usage:**
            If qScreenOrient = True in the previous call to SymbolCreate, the values of pfOrthogonals are ignored and the symbol XZ plane is rotated in global space to be as close as possible to the plane of the screen.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iSymbolAppearanceID:** Appearance ID for symbol\n
            **iLabelAppearanceID:** Appearance ID for REAL8 value text\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
            **pdOrthogonals:** [0..(3*nsymbols)-1]\n
            **pdValues:** [0..nsymbols-1]\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iSymbolAppearanceID: int

        :type iLabelAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        :type pdOrthogonals: float

        :type pdValues: float

        """
        ...

    def CollectorAddSymbolREAL8EntityLocations(self, iCollectorID, iSymbolAppearanceID, iLabelAppearanceID, eType, nIDs,
                                               piIDs, pdDirections, pdOrthogonals, pdValues) -> Any:
        """
        **Description:**
            This functions adds symbol locations specified by existing Femap entities to a Symbol collector. Direction and orthogonal direction are provided for each location. A REAL8 value is provided for each symbol location.
        **Remarks/Usage:**
            If qScreenOrient = True in the previous call to SymbolCreate, the values of pfOrthogonals are ignored and the symbol XZ plane is rotated in global space to be as close as possible to the plane of the screen.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iSymbolAppearanceID:** Appearance ID for symbol\n
            **iLabelAppearanceID:** Appearance ID for REAL8 value text\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
            **pdOrthogonals:** [0..(3*nsymbols)-1]\n
            **pdValues:** [0..nsymbols-1]\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iSymbolAppearanceID: int

        :type iLabelAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        :type pdOrthogonals: float

        :type pdValues: float

        """
        ...

    def CollectorAddSymbolREAL8Locations(self, iCollectorID, iSymbolAppearanceID, iLabelAppearanceID, nSymbols,
                                         pdPoints, pfDirections, pdOrthogonals, pdValues) -> Any:
        """
        **Description:**
            This functions adds symbol locations and orientations in global space to a Symbol collector.
        **Remarks/Usage:**
            If qScreenOrient = True in the previous call to SymbolCreate, the values of pfOrthogonals are ignored and the symbol XZ plane is rotated in global space to be as close as possible to the plane of the screen.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iSymbolAppearanceID:** Appearance ID for symbol\n
            **iLabelAppearanceID:** Appearance ID for REAL8 value text\n
            **nSymbols:** Number of symbols to draw\n
            **pdPoints:** [0..(3*nsymbols)-1]\n
            **pdOrthogonals:** [0..(3*nsymbols)-1]\n
            **pdValues:** [0..nsymbols-1]\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iSymbolAppearanceID: int

        :type iLabelAppearanceID: int

        :type nSymbols: int

        :type pdPoints: float

        :type pdOrthogonals: float

        :type pdValues: float

        """
        ...

    def CollectorAddTextEntityFaceLocations(self, iCollectorID, iAppearanceID, eType, nIDs, piIDs, piFaceIDs,
                                            ppText) -> Any:
        """
        **Description:**
            This function adds text at locations specified by a particular face of existing Femap entities to a Text collector
        **Remarks/Usage:**
            None
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
            **ppText:** STRING for each location\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        :type ppText: tuple[str]

        """
        ...

    def CollectorAddTextEntityLocations(self, iCollectorID, iAppearanceID, eType, nIDs, piIDs, ppText) -> Any:
        """
        **Description:**
            This function adds text at locations specified by existing Femap entities to a Text collector.
        **Remarks/Usage:**
            None
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
            **ppText:** STRING for each location\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        :type ppText: tuple[str]

        """
        ...

    def CollectorAddTextINT4EntityFaceLocations(self, iCollectorID, iAppearanceID, eType, nIDs, piIDs, piFaceIDs,
                                                piValues) -> Any:
        """
        **Description:**
            This function adds text based on an INT4 value at a location specified by a particular face of existing Femap entities to a TextINT4 collector. An INT4 value is supplied for each location.
        **Remarks/Usage:**
            None
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
            **piFaceIDs:** Face ID of entity\n
            **piValues:** INT4 value for each location\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        :type piFaceIDs: tuple[int]

        :type piValues: tuple[int]

        """
        ...

    def CollectorAddTextINT4EntityLocations(self, iCollectorID, iAppearanceID, eType, nIDs, piIDs, piValues) -> Any:
        """
        **Description:**
            This function adds text based on an INT4 value at a location specified by existing Femap entities to a TextINT4 collector. An INT4 value is supplied for each location.
        **Remarks/Usage:**
            None
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
            **piValues:** INT4 value for each location\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        :type piValues: tuple[str]

        """
        ...

    def CollectorAddTextINT4Locations(self, iCollectorID, iAppearanceID, nPoints, pdPoints, piValues) -> Any:
        """
        **Description:**
            This functions adds text based on an INT4 value at locations in global space to a Text collector. An INT4 value is supplied for each location.
        **Remarks/Usage:**
            None
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nPoints:** Number of points\n
            **pdPoints:** [0..(3*nPoints)-1]\n
            **piValues:** INT4 value for each location\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nPoints: int

        :type pdPoints: float

        :type piValues: tuple[int]

        """
        ...

    def CollectorAddTextLocations(self, iCollectorID, iAppearanceID, nPoints, pdPoints, ppText) -> Any:
        """
        **Description:**
            This functions adds text at locations in global space to a Text collector.
        **Remarks/Usage:**
            None
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nPoints:** Number of points\n
            **pdPoints:** [0..(3*nPoints)-1]\n
            **ppText:** STRING for each location\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nPoints: int

        :type pdPoints: float

        :type ppText: tuple[str]

        """
        ...

    def CollectorAddTextREAL8EntityFaceLocations(self, iCollectorID, iAppearanceID, eType, nIDs, piIDs, piFaceIDs,
                                                 pdValues) -> Any:
        """
        **Description:**
            This function adds text based on a REAL8 value at a location specified by a particular face of existing Femap entities to a TextREAL8 collector. An REAL8 value is supplied for each location.
        **Remarks/Usage:**
            None
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
            **piFaceIDs:** Face ID of entity\n
            **pdValues:** REAL8 value for each location\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        :type piFaceIDs: tuple[int]

        :type pdValues: tuple[float]

        """
        ...

    def CollectorAddTextREAL8EntityLocations(self, iCollectorID, iAppearanceID, eType, nIDs, piIDs, pdValues) -> Any:
        """
        **Description:**
            This function adds text based on a REAL8 value at a location specified by existing Femap entities to a TextREAL8 collector. A REAL8 value is supplied for each location.
        **Remarks/Usage:**
            None
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nIDs:** Number of entity IDs\n
            **piIDs:** List of entity IDs\n
            **pdValues:** REAL8 value for each location\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nIDs: int

        :type piIDs: tuple[int]

        :type pdValues: tuple[float]

        """
        ...

    def CollectorAddTextREAL8Locations(self, iCollectorID, iAppearanceID, nPoints, pdPoints, pdValues) -> Any:
        """
        **Description:**
            This functions adds text based on a REAL8 value at locations in global space to a TextREAL8 collector. A REAL8 value is supplied for each location.
        **Remarks/Usage:**
            None
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nPoints:** Number of points\n
            **pdPoints:** [0..(3*nPoints)-1]\n
            **pdValues:** REAL8 value for each location\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nPoints: int

        :type pdPoints: float

        :type pdValues: tuple[float]

        """
        ...

    def CollectorAddTriangleLocations(self, iCollectorID, iAppearanceID, nTriangles, pdPoints) -> Any:
        """
        **Description:**
            This functions adds triangles at locations in global space to a Triangle collector.
        **Remarks/Usage:**
            If the selected appearance has lighting/shading switched on, the normal used is calculated as the normal of each flat triangle.
        **Input:**
            **iCollectorID:** ID of collector to add data\n
            **iAppearanceID:** ID of appearance to use for these entities\n
            **nTriangles:** Number of triangles\n
            **pdPoints:** [0..nTriangles*3*3)-1]\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iAppearanceID: int

        :type nTriangles: int

        :type pdPoints: float

        """
        ...

    def CollectorAppearance(self, iCollectorID, iAppearanceID, dColor1, dColor2, dLineWidth, iLineStyle, iFillPattern,
                            qLighting, iCullMode, iFont, dPointSize) -> Any:
        """
        **Description:**
            This function adds an appearance to a collector
        **Remarks/Usage:**
            The second color is used when the line style or fill pattern are not 0 and fColor2 is different from fColor1. The second color is also used as the background color for text if that option is selected in View Options and fColor2 is different from fColor1.
        **Input:**
            **iCollectorID:** ID of collector to add appearance\n
            **dColor1:** Red, Green, Blue and Alpha values of Color 1\n
            **dColor2:** Red, Green, Blue and Alpha values of Color 2\n
            **dLineWidth:** Width of lines to be drawn in pixels\n
            **iLineStyle:** Style of Line to be drawn. 0 = Solid Line; 1 = Long Dash; 2 = Short dash; 3 = Medium dash, Short dash; 4 = Medium dash, Short dash, Short dash\n
            **iFillPattern:** Style of Fill Pattern. 0 = Solid, 1 = Horizontal Line, 2 = Vertical Line, 3 = Diagonal Lines Top Left to Bottom Right, 4 = Diagonal Lines Bottom Left to Top Right, 5 = Check, 6= Diagonal Check\n
            **qLighting:** If True, filled faces can be processed with lighting/shading\n
            **iCullMode:** Cull Mode. 0 = No Face Culling, 1 = Cull Back Face, 2 = Cull Front Face\n
            **iFont:** Text font (see Label Font in View Options dialog). Greater than 1000, will use the font specified in View Options, Label Parameters. \n
            **dPointSize:** Size that points are drawn in pixels\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type dColor1: tuple[float]

        :type dColor2: tuple[float]

        :type dLineWidth: float

        :type iLineStyle: int

        :type iFillPattern: int

        :type qLighting: bool

        :type iCullMode: int

        :type iFont: int

        :type dPointSize: float

        """
        ...

    def CollectorAppearanceSetFontData(self, iCollectorID, iAppearanceID, iPointHeight, bBold, bItalic, pcName) -> Any:
        """
        **Description:**
            This function defines the font for an existing CollectorAppearance
        **Remarks/Usage:**
            If requested font with desired options is not available from Windows on a certain operating system or machine, will use a font as close as possible which is available from Windows on the operating system/machine.
        **Input:**
            **iCollectorID:** ID of collector to add appearance\n
            **iPointHeight:** Size in point height (for example, 8 pt, 9 pt, 10 pt, etc) for font requested from Windows via pcName\n
            **bBold:** If True, attempts to use Bold version of font requested from Windows via pcName\n
            **bItalic:** If True, attempts to use Italic version of font requested from Windows via pcName\n
            **pcName:** Name of font to request from Windows\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type iPointHeight: int

        :type bBold: bool

        :type bItalic: bool

        :type pcName: str

        """
        ...

    def CollectorBitmap(self, pName, nAppearances, iBitmapID, dXOffset, dYOffset, dDepthOffset, piCollectorID) -> Any:
        """
        **Description:**
            This function creates a Bitmap collector. Bitmap locations (points) can be added based on location in global space or relative to Femap entities such as FT_POINT, FT_CURVE, FT_SURFACE, FT_NODE and FT_ELEM.
        **Remarks/Usage:**
            A bitmap must be created using the following method:
        **Input:**
            **pName:** Name of collector - currently not used\n
            **nAppearances:** Number of appearances that will be added to this collector (see CollectorAppearance)\n
            **dYOffset:** Y offset of location compared to bottom left of bitmap\n
            **dDepthOffset:** Depth offset - currently not used (set to 0.0)\n
        **Output:**
            **piCollectorID:** The ID of the collector created\n
        **Return Code:** True\n
        :type pName: str

        :type nAppearances: int

        :type dYOffset: float

        :type dDepthOffset: float

        :type piCollectorID: int

        """
        ...

    def CollectorBlank(self, iCollectorID, qBlanked) -> Any:
        """
        **Description:**
            This function blanks the specified collector so it will not be drawn until it is un-blanked.
        **Remarks/Usage:**
            There is also a Blank method for the complete User Defined Graphics object
        **Input:**
            **iCollectorID:** ID of collector to blank/unblank\n
            **qBlanked:** If True, the specified collector is blanked. If False, the specified collector is un-blanked.\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type qBlanked: bool

        """
        ...

    def CollectorLabels(self, iCollectorID, qLabels) -> Any:
        """
        **Description:**
            This function controls whether labels are drawn for a collector. Currently this only applies to SymbolREAL8 collectors.
        **Remarks/Usage:**

        **Input:**
            **iCollectorID:** ID of collector to label or no label\n
            **qLabels:** If True, labels are drawn. If False, labels are not drawn.\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type qLabels: bool

        """
        ...

    def CollectorLines(self, pName, nAppearances, dDepthOffset, piCollectorID) -> Any:
        """
        **Description:**
            This function create a Line collector.
        **Remarks/Usage:**
            Line entities added using the following methods:
        **Input:**
            **pName:** Name of collector - currently not used\n
            **nAppearances:** Number of appearances that will be added to this collector (see CollectorAppearance)\n
            **dDepthOffset:** Depth offset - currently not used (set to 0.0)\n
        **Output:**
            **piCollectorID:** The ID of the collector created\n
        **Return Code:** True\n
        :type pName: str

        :type nAppearances: int

        :type dDepthOffset: float

        :type piCollectorID: int

        """
        ...

    def CollectorMarkForDeletion(self, iCollectorID) -> Any:
        """
        **Description:**
            This function marks the specified collector for deletion. It will be no longer accessible from the API and will be deleted during the next draw.
        **Remarks/Usage:**
            None
        **Input:**
            **iCollectorID:** ID of collector to mark for deletion\n
        **Return Code:** True\n
        :type iCollectorID: int

        """
        ...

    def CollectorPoints(self, pName, nAppearances, dDepthOffset, piCollectorID) -> Any:
        """
        **Description:**
            This function creates a Point collector. Points can be added based on location in global space or relative to Femap entities such as FT_POINT, FT_CURVE, FT_SURFACE, FT_NODE and FT_ELEM.
        **Remarks/Usage:**
            Point entities added using the functions:
        **Input:**
            **pName:** Name of collector - currently not used\n
            **nAppearances:** Number of appearances that will be added to this collector (see CollectorAppearance)\n
            **dDepthOffset:** Depth offset - currently not used (set to 0.0)\n
        **Output:**
            **piCollectorID:** The ID of the collector created\n
        **Return Code:** True\n
        :type pName: str

        :type nAppearances: int

        :type dDepthOffset: float

        :type piCollectorID: int

        """
        ...

    def CollectorSingleSymbol(self, iCollectorID, qSingle) -> Any:
        """
        **Description:**
            This function controls whether a single symbol or multiple symbols are drawn on a curve or surface entity
        **Remarks/Usage:**
            By default, entities of type FT_CURVE and FT_SURFACE will draw multiple symbols on the curve or surface. This function enables a single symbol to be drawn at the centroid of the entity.
        **Input:**
            **iCollectorID:** ID of collector to control\n
            **qSingle:** If True, draw a single symbol. If False, draw multiple symbols\n
        **Return Code:** True\n
        :type iCollectorID: int

        :type qSingle: bool

        """
        ...

    def CollectorSymbol(self, pName, nAppearances, iSymbolID, qScreenScale, dScreenScale, dDepthOffset,
                        piCollectorID) -> Any:
        """
        **Description:**
            This function creates a Symbol collector. Symbol locations (points) can be added based on location in global space or relative to Femap entities such as FT_POINT, FT_CURVE, FT_SURFACE, FT_NODE and FT_ELEM.
        **Remarks/Usage:**
            A symbol must be created using the following method:
        **Input:**
            **pName:** Name of collector - currently not used\n
            **nAppearances:** Number of appearances that will be added to this collector (see CollectorAppearance)\n
            **iSymbolID:** ID of symbol to use (see SymbolCreate)\n
            **qScreenScale:** If True, fScale is a percentage of screen size, If False, fScale is a multiplying factor\n
            **dScreenScale:** Scale factor for symbols\n
            **dDepthOffset:** Depth offset - currently not used (set to 0.0)\n
        **Output:**
            **piCollectorID:** The ID of the collector created\n
        **Return Code:** True\n
        :type pName: str

        :type nAppearances: int

        :type iSymbolID: int

        :type qScreenScale: bool

        :type dScreenScale: float

        :type dDepthOffset: float

        :type piCollectorID: int

        """
        ...

    def CollectorSymbolREAL8(self, pName, nAppearances, iSymbolID, qScreenScale, dMaxScale, dMinScale, dXOffset,
                             dYOffset, dZOffset, dDepthOffset, pFormat, piCollectorID) -> Any:
        """
        **Description:**
            This function creates a Symbol collector that has a REAL8 value associated with each symbol entity. Symbol locations (points) can be added based on location in global space or relative to Femap entities such as FT_POINT, FT_CURVE, FT_SURFACE, FT_NODE and FT_ELEM. The associated REAL8 value can be displayed on each instance of the symbol and can also be used to scale the size of the symbol entities.
        **Remarks/Usage:**
            A symbol must be created using the following method:
        **Input:**
            **pName:** Name of collector - currently not used\n
            **nAppearances:** Number of appearances that will be added to this collector (see CollectorAppearance)\n
            **iSymbolID:** ID of symbol to use (see SymbolCreate)\n
            **qScreenScale:** If True, fMaxScale and fMinScale are percentages of screen size. If False, MaxScale and fMinScale are multiplying factors\n
            **dMaxScale:** Scale factor of largest associated REAL8 value\n
            **dMinScale:** Scale factor of smallest associated REAL8 value\n
            **dXOffset:** X offset of REAL8 value\n
            **dYOffset:** Y offset of REAL8 value\n
            **dZOffset:** Z offset of REAL8 value (set to 0.0)\n
            **dDepthOffset:** Depth offset - currently not used (set to 0.0)\n
            **pFormat:** C/C++ format string (should contain a "%g" or equivalent)\n
        **Output:**
            **piCollectorID:** The ID of the collector created\n
        **Return Code:** True\n
        :type pName: str

        :type nAppearances: int

        :type iSymbolID: int

        :type qScreenScale: bool

        :type dMaxScale: float

        :type dMinScale: float

        :type dXOffset: float

        :type dYOffset: float

        :type dZOffset: float

        :type dDepthOffset: float

        :type pFormat: str

        :type piCollectorID: int

        """
        ...

    def CollectorText(self, pName, nAppearances, dXOffset, dYOffset, dZOffset, piCollectorID) -> Any:
        """
        **Description:**
            This function create a Text collector. Text locations (points) can be added based on location in global space or relative to Femap entities such as FT_POINT, FT_CURVE, FT_SURFACE, FT_NODE and FT_ELEM.
        **Remarks/Usage:**
            Bitmap location entities added using the following methods:
        **Input:**
            **pName:** Name of collector - currently not used\n
            **nAppearances:** Number of appearances that will be added to this collector (see CollectorAppearance)\n
            **dXOffset:** X offset of Text location\n
            **dYOffset:** Y offset of Text location\n
            **dZOffset:** Z offset of Text location (set to 0.0)\n
        **Output:**
            **piCollectorID:** The ID of the collector created\n
        **Return Code:** True\n
        :type pName: str

        :type nAppearances: int

        :type dXOffset: float

        :type dYOffset: float

        :type dZOffset: float

        :type piCollectorID: int

        """
        ...

    def CollectorTextINT4(self, pName, nAppearances, dXOffset, dYOffset, dZOffset, pFormat, piCollectorID) -> Any:
        """
        **Description:**
            This function create a TextINT4 collector. Text locations (points) can be added based on location in global space or relative to Femap entities such as FT_POINT, FT_CURVE, FT_SURFACE, FT_NODE and FT_ELEM. This collector is more efficient memory wise that a Text Collector if all you want to write is an INT4 value or an INT4 value with some text that is the same for all INT4s.
        **Remarks/Usage:**
            INT4 text entities added using the following methods:
        **Input:**
            **pName:** Name of collector - currently not used\n
            **nAppearances:** Number of appearances that will be added to this collector (see CollectorAppearance)\n
            **dXOffset:** X offset of Text location\n
            **dYOffset:** Y offset of Text location\n
            **dZOffset:** Z offset of Text location (set to 0.0)\n
            **pFormat:** C/C++ format string (should contain a "%d" or equivalent)\n
        **Output:**
            **piCollectorID:** The ID of the collector created\n
        **Return Code:** True\n
        :type pName: str

        :type nAppearances: int

        :type dXOffset: float

        :type dYOffset: float

        :type dZOffset: float

        :type pFormat: str

        :type piCollectorID: int

        """
        ...

    def CollectorTextREAL8(self, pName, nAppearances, dXOffset, dYOffset, dZOffset, pFormat, piCollectorID) -> Any:
        """
        **Description:**
            This function create a TextREAL8 collector. Text locations (points) can be added based on location in global space or relative to Femap entities such as FT_POINT, FT_CURVE, FT_SURFACE, FT_NODE and FT_ELEM. This collector is more efficient memory wise that a Text Collector if all you want to write is a REAL8 value or a REAL8 value with some text that is the same for all REAL8s.
        **Remarks/Usage:**
            REAL8 text entities added using the following methods:
        **Input:**
            **pName:** Name of collector - currently not used\n
            **nAppearances:** Number of appearances that will be added to this collector (see CollectorAppearance)\n
            **dXOffset:** X offset of Text location\n
            **dYOffset:** Y offset of Text location\n
            **dZOffset:** Z offset of Text location (set to 0.0)\n
            **pFormat:** C/C++ format string (should contain a "%g" or equivalent)\n
        **Output:**
            **piCollectorID:** The ID of the collector created\n
        **Return Code:** True\n
        :type pName: str

        :type nAppearances: int

        :type dXOffset: float

        :type dYOffset: float

        :type dZOffset: float

        :type pFormat: str

        :type piCollectorID: int

        """
        ...

    def CollectorTriangles(self, pName, nAppearances, dDepthOffset, piCollectorID) -> Any:
        """
        **Description:**
            This function create a Triangle collector
        **Remarks/Usage:**
            Triangle entities added using the following methods:
        **Input:**
            **pName:** Name of collector - currently not used\n
            **nAppearances:** Number of appearances that will be added to this collector (see CollectorAppearance)\n
            **dDepthOffset:** Depth offset - currently not used (set to 0.0)\n
        **Output:**
            **piCollectorID:** The ID of the collector created\n
        **Return Code:** True\n
        :type pName: str

        :type nAppearances: int

        :type dDepthOffset: float

        :type piCollectorID: int

        """
        ...

    def Detach(self, pDetachedName) -> Any:
        """
        **Description:**
            This function detaches the graphics in a User Defined Graphics object. When the graphics are detached, they cannot be controlled and will persist as is, until the model is closed. The graphics data will no longer exist in the User Defined Graphics object. The User Defined Graphics object can continue to be used by adding new graphics data. The pDetachedName is copied to the detached graphics data to enable the graphics data to be reattached to a User Defined Graphics object using the Attach function. The main use of the Detach/Attach capability is to be able to have graphics survive after an API has finished running and to then access them again in another API. It is advised to not use the same pDetachedName for more than one Detach at a time as a call to Attach will not know which order to access them in.
        **Remarks/Usage:**
            None
        **Input:**
            **pDetachedName:** See description\n
        **Return Code:** True\n
        :type pDetachedName: str

        """
        ...

    def GetView(self, piViewID) -> Any:
        """
        **Description:**
            This function is used to query the view ID of the User Defined Graphics object.
        **Remarks/Usage:**
            If you set the active view ID by calling SetView(-1), this function will not provide -1 but will provide the ID of the active view ID when the SetView(-1) was called.
        **Output:**
            **piViewID:** ID of view\n
        **Return Code:** True\n
        :type piViewID: int

        """
        ...

    def Publish(self) -> Any:
        """
        **Description:**
            This function publishes the User Defined Graphics object graphics data and makes it available to the graphics system
        **Remarks/Usage:**
            Graphics entities in a User Defined Graphics object will not be visible until the Publish method is called. If any graphical entities are added after calling the Publish method, all entities in the User Defined Graphics object will not be visible until the Publish method is called again.
        **Return Code:** True\n
        """
        ...

    def SetName(self, pName) -> Any:
        """
        **Description:**
            This function provides the User Defined Graphics object with a name. This is not currently implemented.
        **Remarks/Usage:**
            None
        **Input:**
            **pName:** Name of User Defined Graphics Object\n
        **Return Code:** True\n
        :type pName: str

        """
        ...

    def SetView(self, iViewID) -> Any:
        """
        **Description:**
            This function controls which windows the graphics in the User Defined Graphics object are drawn.
        **Remarks/Usage:**
            If iViewID is set to 0, then the graphics are drawn in all windows of the active Model. If iViewID is set to -1, the active view ID is used. If iViewID is set to n, then the graphics are drawn in the window that is using view n. If an invalid iViewID is specified, the graphics will not be drawn in any window. If you change the active view, the graphics will NOT move to the new active view.
        **Input:**
            **iViewID:** Specifies the ID of the view(s). 0=all views, -1=determines active view and sets that view, n>0 is the ID of an existing view\n
        **Return Code:** True\n
        :type iViewID: int

        """
        ...

    def SymbolAddFillBrick(self, iSymbolID, iAppearanceOffset, dPoints, qEndCap) -> Any:
        """
        **Description:**
            This function adds a filled brick to a Symbol
        **Remarks/Usage:**
            None
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **dPoints:** Coordinates of 8 corners of a brick (i.e., 0=X coordinate of corner 1, 1=Ycoordinate of corner 1, 2=Z coordinate of corner 1, 3=X coordinate of corner 2, 4=Ycoordinate of corner 2, 5=Z coordinate of corner 2...21=X coordinate of corner 8, 22=Y coordinate of corner 8, 23=Z coordinate of corner 8)\n
            **qEndCap:** Draw the two end caps. Without end caps, it is a square tube.\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type dPoints: tuple[float]

        :type qEndCap: bool

        """
        ...

    def SymbolAddFillCircle(self, iSymbolID, iAppearanceOffset, dCenter, dPointOnCircle, dNormal, nDividers) -> Any:
        """
        **Description:**
            This function adds a filled circle to a Symbol
        **Remarks/Usage:**
            The normal does not have to exactly represent the normal. The normal is used to generate an orthogonal direction that will be in the plane of the circle.
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **dCenter:** Coordinate of center of circle in Symbol space\n
            **dPointOnCircle:** Coordinate of point on circle in Symbol space\n
            **dNormal:** Vector normal to the circle\n
            **nDividers:** Number of divisions in a quarter of a circle\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type dCenter: tuple[float]

        :type dPointOnCircle: tuple[float]

        :type dNormal: tuple[float]

        :type nDividers: int

        """
        ...

    def SymbolAddFillCone(self, iSymbolID, iAppearanceOffset, dCenter, dPointOnCircle, dDirection, dHeight, nDividers,
                          nSubDividers, qEndCap) -> Any:
        """
        **Description:**
            This function adds a filled cone to a Symbol
        **Remarks/Usage:**
            The angle between the direction of the cone and the vector from the center to the point on circle does not have to be 90 degrees (it must not be 0 degrees). If the angle is not 90, the cone will be skewed.
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **dCenter:** Coordinate of center of circle in Symbol space\n
            **dPointOnCircle:** Coordinate of point on circle in Symbol space\n
            **dDirection:** Vector normal to the circle\n
            **dHeight:** Height of cone\n
            **nDividers:** Number of lines drawn along conical surface\n
            **nSubDividers:** Number of sub-divisions along circle between nDividers\n
            **qEndCap:** Draw the end cap\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type dCenter: tuple[float]

        :type dPointOnCircle: tuple[float]

        :type dDirection: tuple[float]

        :type dHeight: float

        :type nDividers: int

        :type nSubDividers: int

        :type qEndCap: bool

        """
        ...

    def SymbolAddFillCylinder(self, iSymbolID, iAppearanceOffset, dCenter, dPointOnCircle, dDirection, dHeight,
                              nDividers, nSubDividers, qEndCap) -> Any:
        """
        **Description:**
            This function adds a filled cylinder to a Symbol
        **Remarks/Usage:**
            None
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **dCenter:** Coordinate of center of circle in Symbol space\n
            **dPointOnCircle:** Coordinate of point on circle in Symbol space\n
            **dDirection:** Vector along cylinder\n
            **dHeight:** Height of cylinder\n
            **nDividers:** Number of lines drawn along cylindrical surface\n
            **nSubDividers:** Number of sub-divisions along circle between nDividers\n
            **qEndCap:** Draw the two end caps. Without end caps, it is a cylindrical tube.\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type dCenter: tuple[float]

        :type dPointOnCircle: tuple[float]

        :type dDirection: tuple[float]

        :type dHeight: float

        :type nDividers: int

        :type nSubDividers: int

        :type qEndCap: bool

        """
        ...

    def SymbolAddFillSphere(self, iSymbolID, iAppearanceOffset, dCenter, dPointOnEquator, dDirection, dAngle,
                            nLongDividers, nLongSubDividers, nLatDividers, nLatSubDividers) -> Any:
        """
        **Description:**
            This function adds a filled sphere to a Symbol
        **Remarks/Usage:**
            Internally, nLongSubDividers and nLatSubDividers are increased until the angle for each subdivision is less than 22.5 degrees. The values of nLongDividers, nLatDividers, nLongSubDividers and nLatSubDividers control how smooth the surface is. The same variables are used as for SymbolAddLineSphere so the faceted lines and faceted filled surface line up.
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **dCenter:** Coordinate of center of sphere in Symbol space\n
            **dPointOnEquator:** Coordinate of point on equator in Symbol space\n
            **dDirection:** Vector normal to the equator of the sphere\n
            **dAngle:** Angle of revolution (360.0 is a sphere)\n
            **nLongSubDividers:** Number of divisions between longitudinal lines\n
            **nLatDividers:** Number of latitudinal lines drawn on sphere\n
            **nLatSubDividers:** Number of divisions between latitudinal lines\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type dCenter: tuple[float]

        :type dPointOnEquator: tuple[float]

        :type dDirection: tuple[float]

        :type dAngle: float

        :type nLongSubDividers: int

        :type nLatDividers: int

        :type nLatSubDividers: int

        """
        ...

    def SymbolAddFillTriangle(self, iSymbolID, iAppearanceOffset, dPoints, dNormals) -> Any:
        """
        **Description:**
            This function adds a filled triangle to a Symbol
        **Remarks/Usage:**
            The normal do not have to be normal to the triangle. This enables smoother lit/shaded surfaces to be displayed.
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **dPoints:** Coordinates of triangle corners in Symbol space (i.e., 0=X coordinate of corner 1, 1=Ycoordinate of corner 1, 2=Z coordinate of corner 1, 3=X coordinate of corner 2, 4=Ycoordinate of corner 2, 5=Z coordinate of corner 2, 6=X coordinate of corner 3, 7=Y coordinate of corner 3, 8=Z coordinate of corner 3)\n
            **dNormals:** Normal vectors at triangle corners in Symbol space (i.e., 0=X coordinate of vector at corner 1, 1=Ycoordinate of vector at corner 1, 2=Z coordinate of vector at corner 1, 3=X coordinate of vector at corner 2, 4=Ycoordinate of vector at corner 2, 5=Z coordinate of vector at corner 2, 6=X coordinate of vector at corner 3, 7=Y coordinate of vector at corner 3, 8=Z coordinate of vector at corner 3)\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type dPoints: tuple[float]

        :type dNormals: tuple[float]

        """
        ...

    def SymbolAddFillTubeBrick(self, iSymbolID, iAppearanceOffset, dOuterPoints, dInnerPoints) -> Any:
        """
        **Description:**
            This function adds a filled quad tube with thickness to a Symbol
        **Remarks/Usage:**
            None
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **dOuterPoints:** Coordinates of outer 8 corners of a brick (i.e., 0=X coordinate of corner 1, 1=Ycoordinate of corner 1, 2=Z coordinate of corner 1, 3=X coordinate of corner 2, 4=Ycoordinate of corner 2, 5=Z coordinate of corner 2...21=X coordinate of corner 8, 22=Y coordinate of corner 8, 23=Z coordinate of corner 8)\n
            **dInnerPoints:** Coordinates of inner 8 corners of a brick (i.e., 0=X coordinate of corner 1, 1=Ycoordinate of corner 1, 2=Z coordinate of corner 1, 3=X coordinate of corner 2, 4=Ycoordinate of corner 2, 5=Z coordinate of corner 2...21=X coordinate of corner 8, 22=Y coordinate of corner 8, 23=Z coordinate of corner 8)\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type dOuterPoints: tuple[float]

        :type dInnerPoints: tuple[float]

        """
        ...

    def SymbolAddFillTubeCylinder(self, iSymbolID, iAppearanceOffset, dCenter, dPointOnCircle, dDirection, dHeight,
                                  dInnerProportion, nDividers, nSubDividers) -> Any:
        """
        **Description:**
            This function adds a filled cylindrical tube with thickness to a Symbol
        **Remarks/Usage:**
            None
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **dCenter:** Coordinate of center of circle in Symbol space\n
            **dPointOnCircle:** Coordinate of point on circle in Symbol space\n
            **dDirection:** Vector along cylinder\n
            **dHeight:** Height of cylinder\n
            **nDividers:** Number of lines drawn along cylindrical surface\n
            **nSubDividers:** Number of sub-divisions along circle between nDividers\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type dCenter: tuple[float]

        :type dPointOnCircle: tuple[float]

        :type dDirection: tuple[float]

        :type dHeight: float

        :type nDividers: int

        :type nSubDividers: int

        """
        ...

    def SymbolAddLineBrick(self, iSymbolID, iAppearanceOffset, dPoints) -> Any:
        """
        **Description:**
            This function adds a wireframe brick to a Symbol
        **Remarks/Usage:**
            None
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **dPoints:** Coordinates of 8 corners of a brick (i.e., 0=X coordinate of corner 1, 1=Ycoordinate of corner 1, 2=Z coordinate of corner 1, 3=X coordinate of corner 2, 4=Ycoordinate of corner 2, 5=Z coordinate of corner 2...21=X coordinate of corner 8, 22=Y coordinate of corner 8, 23=Z coordinate of corner 8)\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type dPoints: tuple[float]

        """
        ...

    def SymbolAddLineCircle(self, iSymbolID, iAppearanceOffset, dCenter, dPointOnCircle, dNormal, nDividers) -> Any:
        """
        **Description:**
            This function adds a circle to a Symbol.
        **Remarks/Usage:**
            The normal does not have to exactly represent the normal. The normal is used to generate an orthogonal direction that will be in the plane of the circle.
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **dCenter:** Coordinate of center of circle in Symbol space\n
            **dPointOnCircle:** Coordinate of point on circle in Symbol space\n
            **dNormal:** Vector normal to the circle\n
            **nDividers:** Number of divisions in a quarter of a circle\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type dCenter: tuple[float]

        :type dPointOnCircle: tuple[float]

        :type dNormal: tuple[float]

        :type nDividers: int

        """
        ...

    def SymbolAddLineCone(self, iSymbolID, iAppearanceOffset, dCenter, dPointOnCircle, dDirection, dHeight, nDividers,
                          nSubDividers) -> Any:
        """
        **Description:**
            This function adds a wireframe cone to a Symbol
        **Remarks/Usage:**
            The angle between the direction of the cone and the vector from the center to the point on circle does not have to be 90 degrees (it must not be 0 degrees). If the angle is not 90, the cone will be skewed.
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **dCenter:** Coordinate of center of circle in Symbol space\n
            **dPointOnCircle:** Coordinate of point on circle in Symbol space\n
            **dDirection:** Vector normal to the circle\n
            **dHeight:** Height of cone\n
            **nDividers:** Number of lines drawn along conical surface\n
            **nSubDividers:** Number of divisions along circle between nDividers\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type dCenter: tuple[float]

        :type dPointOnCircle: tuple[float]

        :type dDirection: tuple[float]

        :type dHeight: float

        :type nDividers: int

        :type nSubDividers: int

        """
        ...

    def SymbolAddLineCylinder(self, iSymbolID, iAppearanceOffset, dCenter, dPointOnCircle, dDirection, dHeight,
                              nDividers, nSubDividers) -> Any:
        """
        **Description:**
            This function adds a wireframe cylinder to a Symbol
        **Remarks/Usage:**
            The angle between the direction of the cylinder and the vector from the center to the point on circle does not have to be 90 degrees (it must not be 0 degrees). If the angle is not 90, the cylinder will be skewed.
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **dCenter:** Coordinate of center of circle in Symbol space\n
            **dPointOnCircle:** Coordinate of point on circle in Symbol space\n
            **dDirection:** Vector along cylinder\n
            **dHeight:** Height of cylinder\n
            **nDividers:** Number of lines drawn along cylindrical surface\n
            **nSubDividers:** Number of divisions along circle between nDividers\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type dCenter: tuple[float]

        :type dPointOnCircle: tuple[float]

        :type dDirection: tuple[float]

        :type dHeight: float

        :type nDividers: int

        :type nSubDividers: int

        """
        ...

    def SymbolAddLinePoly(self, iSymbolID, iAppearanceOffset, nPoints, pdPoints) -> Any:
        """
        **Description:**
            This function adds a polyline to a Symbol.
        **Remarks/Usage:**
            None
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **nPoints:** Number of points\n
            **pdPoints:** [0..nPoints*3)-1]\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type nPoints: int

        :type pdPoints: float

        """
        ...

    def SymbolAddLineSphere(self, iSymbolID, iAppearanceOffset, dCenter, dPointOnEquator, dDirection, dAngle,
                            nLongDividers, nLongSubDividers, nLatDividers, nLatSubDividers) -> Any:
        """
        **Description:**
            This function adds a wireframe sphere to a Symbol
        **Remarks/Usage:**
            Internally, nLongSubDividers and nLatSubDividers is increased until the angle for each subdivision is less than 22.5 degrees. The values of nLongDividers and nLatDividers control how many lines are drawn and nLongSubDividers and nLatSubDividers control how smooth they are.
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **dCenter:** Coordinate of center of sphere in Symbol space\n
            **dPointOnEquator:** Coordinate of point on equator in Symbol space\n
            **dDirection:** Vector normal to the equator of the sphere\n
            **dAngle:** Angle of revolution (360.0 is a sphere)\n
            **nLongSubDividers:** Number of divisions between longitudinal lines\n
            **nLatDividers:** Number of latitudinal lines drawn on sphere\n
            **nLatSubDividers:** Number of divisions between latitudinal lines\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type dCenter: tuple[float]

        :type dPointOnEquator: tuple[float]

        :type dDirection: tuple[float]

        :type dAngle: float

        :type nLongSubDividers: int

        :type nLatDividers: int

        :type nLatSubDividers: int

        """
        ...

    def SymbolAddLineStraight(self, iSymbolID, iAppearanceOffset, dPoints) -> Any:
        """
        **Description:**
            This function adds individual lines to a Symbol.
        **Remarks/Usage:**
            None
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **dPoints:** [0..nPoints*2*3)-1]\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type dPoints: float

        """
        ...

    def SymbolAddPoints(self, iSymbolID, iAppearanceOffset, nPoints, pdPoints) -> Any:
        """
        **Description:**
            This function adds points to a Symbol.
        **Remarks/Usage:**
            None
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iAppearanceOffset:** Appearance offset (see remarks for function SymbolCreate)\n
            **nPoints:** Number of points\n
            **pdPoints:** [0..nPoints*3)-1]\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iAppearanceOffset: int

        :type nPoints: int

        :type pdPoints: float

        """
        ...

    def SymbolCreate(self, nAppearances, dLabelLocation, qScreenOrient, piSymbolID) -> Any:
        """
        **Description:**
            This function creates a Symbol that can be used by a Symbol or SymbolREAL8 collector
        **Remarks/Usage:**
            fLabelLocation currently only used by SymbolREAL8 collector.
        **Input:**
            **nAppearances:** Number of appearances used by the Symbol\n
            **dLabelLocation:** Location in Symbol space that a label can be located\n
        **Return Code:** True\n
        :type nAppearances: int

        :type dLabelLocation: tuple[float]

        """
        ...

    def SymbolMarkForDeletion(self, iSymbolID) -> Any:
        """
        **Description:**
            This function marks a Symbol for deletion. After it has been marked for deletion, it cannot be used by a Symbol or SymbolREAL8 collector
        **Remarks/Usage:**
            None
        **Input:**
            **iSymbolID:** ID of Symbol to mark for deletion\n
        **Return Code:** True\n
        :type iSymbolID: int

        """
        ...

    def SymbolSetAddInScreen(self, iSymbolID, iInScreenMode) -> Any:
        """
        **Description:**
            This function controls whether Symbol components for screen oriented Symbols are placed.
        **Remarks/Usage:**
            None
        **Input:**
            **iSymbolID:** ID of Symbol to add\n
            **iInScreenMode:** In Screen mode. 0 = Load Symbol Component to draw when not aligned into or out of screen; > 0 = Load Symbol component to draw when aligned out of screen; < 0 = Load Symbol component to draw when aligned into screen\n
        **Return Code:** True\n
        :type iSymbolID: int

        :type iInScreenMode: int

        """
        ...


class vector:
    CLSID: Any
    Active: Any
    ID: Any
    Length: Any
    SetID: Any
    title: Any
    vBase: Any
    vDir: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutAll(self, ID, sTitle, vBase, vDir, dLen) -> Any:
        """
        **Description:**
            This method saves a vector to the database with all the available options using a single call
        **Remarks/Usage:**
            None.
        **Input:**
            **ID:** ID of vector\n
            **vBase:** Vector base location in global rectangular coordinates\n
            **vDir:** Components of a vector defining the vector direction\n
        **Return Code:** True\n
        :type ID: int

        :type vBase: tuple[float]

        :type vDir: tuple[float]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def Setbase(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setdir(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def base(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def dir(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class Plane:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    title: Any
    vAxis: Any
    vBase: Any
    vNorm: Any

    def Axis(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutAll(self, ID, sTitle, vBase, vNorm, vAxis) -> Any:
        """
        **Description:**
            This method saves a plane to the database with all the available options using a single call
        **Remarks/Usage:**
            None.
        **Input:**
            **ID:** ID of plane\n
            **vBase:** Plane base location in global rectangular coordinates\n
            **vNorm:** Components of the vector normal to the plane\n
        **Return Code:** True\n
        :type ID: int

        :type vBase: tuple[float]

        :type vNorm: tuple[float]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetAxis(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setbase(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setnorm(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def base(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def norm(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class MeshHardPointDefinition:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    title: Any

    def CountMeshPoints(self) -> Any:
        """
        **Description:**
            This method returns the number of mesh points referenced by a mesh point definition, as a return code.
        **Remarks/Usage:**
            This method relies on the current Mesh Point Definition ID to count the referenced mesh points
        **Return Code:** True\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, entID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **entID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextMeshPoint(self, pDispatch) -> Any:
        """
        **Description:**
            This method returns the next available mesh point that is contained in the Mesh Point Definition
        **Remarks/Usage:**
            This method, coupled with ResetNextMeshPoint provides an easy way to retrieve all mesh points from a Mesh Point Definition.
        **Output:**
            **pDispatch:** The next mesh point object.\n
        **Return Code:** True\n
        :type pDispatch: Any

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def ResetNextMeshPoint(self) -> Any:
        """
        **Description:**
            This method initializes all options prior to calling the NextMeshPoint method below
        **Remarks/Usage:**
            This method is used prior to calling NextMeshPoint to specify which MeshPoint will be retrieved. It simply resets this object so that the next call to NextMeshPoint will return the first MeshPoint available in the object.
        **Return Code:** True\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class MeshHardPoint:
    CLSID: Any
    Active: Any
    DefinitionID: Any
    DistanceToGeometry: Any
    ID: Any
    Locked: Any
    NodeOnGeometry: Any
    OnGeometryID: Any
    OnGeometryType: Any
    SetID: Any
    color: Any
    layer: Any
    pointID: Any
    vLocationOnGeometry: Any

    def AutoDistanceToGeometry(self) -> Any:
        """
        **Description:**
            This method automatically calculates a distance, then sets the Distance to Geometry value for the mesh point object which is associated with a geometric entity
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Enable(self, bEnable) -> Any:
        """
        **Description:**
            This method is used to enable or disable a Mesh Point
        **Remarks/Usage:**
            None
        **Input:**
            **bEnable:** Flag to set the state of the mesh point. \n
        **Return Code:** True\n
        :type bEnable: bool

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def IsEnabled(self) -> Any:
        """
        **Description:**
            This method checks the state of the mesh point.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def LocationOnGeometry(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def OnPoint(self, pointID) -> Any:
        """
        **Description:**
            This method sets the ID of the underlying point of a mesh point
        **Remarks/Usage:**
            None
        **Input:**
            **pointID:** ID of geometric point to use for underlying point of mesh point\n
        **Return Code:** True\n
        :type pointID: int

        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetLocationOnGeometry(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Solid(self, pnSolidID) -> Any:
        """
        **Description:**
            This method retrieves the ID of the Solid associated with a mesh point
        **Remarks/Usage:**
            None
        **Output:**
            **pnSolidID:** ID of Solid associated with mesh point\n
        **Return Code:** False\n
        :type pnSolidID: int

        """
        ...

    def UpdateMeshPoints(self, bDoAll, nMeshPointSetID, nDuplicatesOnSolidID) -> Any:
        """
        **Description:**
            This method automatically determines which geometric entity all or the selected mesh point(s) should be associated
        **Remarks/Usage:**
            None
        **Input:**
            **bDoAll:** Flag to have all mesh points be updated (True) or only the mesh points included in the set object specified for nMeshPointSetID (False)\n
            **nMeshPointSetID:** The ID of a set that contains a list of mesh point IDs that will be automatically associated with geometric entities, if they are not already associated with a geometric entity. Alternatively, if you specify a negative value, this is simply the ID of the single mesh point to associate to a geometric entity\n
            **nDuplicatesOnSolidID:** ID of solid to automatically attach Mesh Point(s) currently in set object specified for nMeshPointSetID. Mesh points in set will automatically attach to points, curves, and/or surfaces of the specified solid, or the solid itself. Setting this to a value of 0 will consider all solids.\n
        **Return Code:** False\n
        :type bDoAll: bool

        :type nMeshPointSetID: int

        :type nDuplicatesOnSolidID: int

        """
        ...

    def UpdateMeshPointsOnGeometry(self, nSolidSetID, nSurfaceSetID, nCurveSetID, nPointSetID, nDuplicatesOnSolidID,
                                   bUpdateUnassignedPoints, bUpdatePointsOnDeletedGeometry, bResizeCurves,
                                   bEnabledPointsOnly) -> Any:
        """
        **Description:**
            This method updates mesh points associated with specific solids, surfaces, curves, and/or points while considering a number of additional options.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...


class OptRel:
    CLSID: Any
    Active: Any
    BoundType: Any
    ID: Any
    NameField: Any
    RelationshipID: Any
    RelationshipType: Any
    SetID: Any
    TopologyActive: Any
    TypeField: Any
    title: Any
    vBounds: Any

    def Bounds(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def CalculateBounds(self, pdLower, pdUpper) -> Any:
        """
        **Description:**
            Returns the lower and upper bounds, as well as the initial value that will be written to the analysis deck. Note, this does not update any object properties
        **Remarks/Usage:**
            None
        **Output:**
            **pdLower:** Lower bound\n
            **pdUpper:** Upper bound\n
        **Return Code:** True\n
        :type pdLower: float

        :type pdUpper: float

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetMatl(self, pnMatlID, sType, sName, pbBoundType, pdMin, pdMax) -> Any:
        """
        **Description:**
            Get material relationship parameters
        **Remarks/Usage:**
            None
        **Output:**
            **pnMatlID:** Material ID\n
            **sType:** Material type\n
            **sName:** Material field name\n
            **pbBoundType:** Bound type. Use enum zBoundType\n
            **pdMin:** Material value lower bound\n
            **pdMax:** Material value upper bound\n
        **Return Code:** True\n
        :type pnMatlID: int

        :type sType: str

        :type sName: str

        :type pbBoundType: int

        :type pdMin: float

        :type pdMax: float

        """
        ...

    def GetProp(self, pnPropID, sType, sName, pbBoundType, pdMin, pdMax) -> Any:
        """
        **Description:**
            Get property relationship parameters
        **Remarks/Usage:**
            None
        **Output:**
            **pnPropID:** Property ID\n
            **sType:** Property type\n
            **sName:** Property field name\n
            **pbBoundType:** Bound type. Use enum zBoundType\n
            **pdMin:** Property value lower bound\n
            **pdMax:** Property value upper bound\n
        **Return Code:** True\n
        :type pnPropID: int

        :type sType: str

        :type sName: str

        :type pbBoundType: int

        :type pdMin: float

        :type pdMax: float

        """
        ...

    def GetShellT(self, nSetID, bClear, pdLower, pdUpper) -> Any:
        """
        **Description:**
            Get shell thickness relationship parameters
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of a Set object to be populated with topology optimization entities\n
            **bClear:** Clear any existing IDs from the Set\n
        **Output:**
            **pdLower:** Shell thickness lower bound\n
            **pdUpper:** Shell thickness upper bound\n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        :type pdLower: float

        :type pdUpper: float

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTopology(self, nSetID, bClear, bActive) -> Any:
        """
        **Description:**
            Sets up the Optimization Relationship as a topology optimization region in a single call
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of a Set object to be populated with topology optimization entities\n
            **bClear:** Clear any existing IDs from the Set\n
        **Output:**
            **bActive:** Entities are active (True) or frozen (False)\n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        :type bActive: bool

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetBounds(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetupMatl(self, nMatlID, sType, sName, bBoundType, dMin, dMax) -> Any:
        """
        **Description:**
            Sets material relationship parameters in a single call
        **Remarks/Usage:**
            When specifying material types or names that are not natively supported by FEMAP, these will show up as Custom optimization variables in the FEMAP User Interface.
        **Input:**
            **nMatlID:** Material ID\n
            **sType:** Material type\n
            **sName:** Material field name\n
            **bBoundType:** Bound type. Use enum zBoundType:\n
            **dMin:** Material value lower bound\n
            **dMax:** Material value upper bound\n
        **Return Code:** True\n
        :type nMatlID: int

        :type sType: str

        :type sName: str

        :type bBoundType: int

        :type dMin: float

        :type dMax: float

        """
        ...

    def SetupProp(self, nPropID, sType, sName, bBoundType, dMin, dMax) -> Any:
        """
        **Description:**
            Sets property relationship parameters in a single call
        **Remarks/Usage:**
            When specifying property types or names that are not natively supported by FEMAP, these will show up as Custom optimization variables in the FEMAP User Interface.
        **Input:**
            **nPropID:** Property ID\n
            **sType:** Property type\n
            **sName:** Property field name\n
            **bBoundType:** Bound type. Use enum zBoundType:\n
            **dMin:** Property value lower bound\n
            **dMax:** Property value upper bound\n
        **Return Code:** True\n
        :type nPropID: int

        :type sType: str

        :type sName: str

        :type bBoundType: int

        :type dMin: float

        :type dMax: float

        """
        ...

    def SetupShellT(self, nSetID, dLower, dUpper) -> Any:
        """
        **Description:**
            Sets up a shell thickness relationship in a single call
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of Set object containing elements to optimize for thickness\n
            **dLower:** Shell thickness lower bound\n
            **dUpper:** Shell thickness upper bound\n
        **Return Code:** True\n
        :type nSetID: int

        :type dLower: float

        :type dUpper: float

        """
        ...

    def SetupTopology(self, nSetID, bActive, bValidate, bSilent) -> Any:
        """
        **Description:**
            Sets up the Optimization Relationship as a topology optimization region in a single call
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of a Set object containing elements for topology optimization\n
            **bActive:** Specifies if elements are active (True) or frozen (False)\n
        **Return Code:** True\n
        :type nSetID: int

        :type bActive: bool

        """
        ...


class OptResp:
    CLSID: Any
    Active: Any
    ID: Any
    ResponseCategory: Any
    SetID: Any
    VectorIDV2: Any
    atta: Any
    attaBlank: Any
    attb: Any
    attbFieldType: Any
    attiDataType: Any
    ptype: Any
    rtype: Any
    title: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetBuckle(self, pnSetID, pnApproxCode) -> Any:
        """
        **Description:**
            Retrieves attributes for buckling response in a single call
        **Remarks/Usage:**
            Optimization response constraints are retrieved separately using the GetConstraints method
        **Output:**
            **pnSetID:** Mode Number\n
            **pnApproxCode:** Approximation code. 0 = Default, 1 = Direct, 2 = Inverse\n
        **Return Code:** True\n
        :type pnSetID: int

        :type pnApproxCode: int

        """
        ...

    def GetConstraints(self, pdLowerBounds, pdUpperbound) -> Any:
        """
        **Description:**
            Retrieves optimization response bounds
        **Remarks/Usage:**
            None
        **Output:**
            **pdLowerBounds:** Lower Bound\n
            **pdUpperbound:** Upper Bound\n
        **Return Code:** False\n
        :type pdLowerBounds: float

        :type pdUpperbound: float

        """
        ...

    def GetDisplacement(self, nSetID, bClear, pnDof) -> Any:
        """
        **Description:**
            Retrieves attributes for displacement response in a single call
        **Remarks/Usage:**
            Optimization response constraints are retrieved separately using the GetConstraints method
        **Input:**
            **nSetID:** ID of Set object to be populated with displacement response nodes \n
            **bClear:** Clear Set Object of entities prior to populating\n
        **Output:**
            **pnDof:** Displacement degree of freedom. \n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        :type pnDof: int

        """
        ...

    def GetESE(self, nSetID, bClear, pbDensity, penDataType) -> Any:
        """
        **Description:**
            Retrieves attributes for elemental strain energy response in a single call
        **Remarks/Usage:**
            Optimization response constraints are retrieved separately using the GetConstraints method
        **Input:**
            **nSetID:** ID of Set object to be populated with response entities \n
            **bClear:** Clear Set Object of entities prior to populating\n
        **Output:**
            **pbDensity:** Strain energy density\n
            **penDataType:** Data type for specified entities. FET_ELEM or FET_PROP\n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        :type pbDensity: int

        :type penDataType: int

        """
        ...

    def GetEign(self, pnSetID, pnApproxCode) -> Any:
        """
        **Description:**
            Retrieves attributes for normal modes response in a single call
        **Remarks/Usage:**
            Optimization response constraints are retrieved separately using the GetConstraints method
        **Output:**
            **pnSetID:** Mode Number\n
            **pnApproxCode:** Approximation code. 0 = Default, 1 = Direct, 2 = Inverse\n
        **Return Code:** True\n
        :type pnSetID: int

        :type pnApproxCode: int

        """
        ...

    def GetElemV2(self, nSetID, bClear, pnVecID, penDataType) -> Any:
        """
        **Description:**
            This method replaces GetElem. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above". Retrieves attributes for elemental force / stress / strain response in a single call.
        **Remarks/Usage:**
            Optimization response constraints are retrieved separately using the GetConstraints method
        **Input:**
            **nSetID:** ID of Set object to be populated with response entities \n
            **bClear:** Clear Set Object of entities prior to populating\n
        **Output:**
            **pnVecID:** Output Vector ID\n
            **penDataType:** Data type for specified entities. FET_ELEM or FET_PROP\n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        :type pnVecID: int

        :type penDataType: int

        """
        ...

    def GetEntities(self, nSetID, bClear, penDataType) -> Any:
        """
        **Description:**
            Gets the specified optimization response entities
        **Remarks/Usage:**
            This method can be used to specify entities for optimization responses, however it is recommended to use the setup methods instead
        **Input:**
            **nSetID:** ID of Set object to receive entity IDs\n
            **bClear:** Clear the Set object before populating\n
        **Output:**
            **penDataType:** Data type of optimization response entities. Use enDataType. See Section 3.3.6, "Entity Types"\n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        :type penDataType: int

        """
        ...

    def GetFreq(self, pnSetID, pnApproxCode) -> Any:
        """
        **Description:**
            Retrieves attributes for frequency response in a single call
        **Remarks/Usage:**
            Optimization response constraints are retrieved separately using the GetConstraints method
        **Output:**
            **pnSetID:** Mode Number\n
            **pnApproxCode:** Approximation code. 0 = Default, 1 = Direct, 2 = Inverse\n
        **Return Code:** True\n
        :type pnSetID: int

        :type pnApproxCode: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetSPCForce(self, nSetID, bClear, pnDof) -> Any:
        """
        **Description:**
            Retrieves attributes for SPC response in a single call
        **Remarks/Usage:**
            Optimization response constraints are retrieved separately using the GetConstraints method
        **Input:**
            **nSetID:** ID of Set object to be populated with response nodes \n
            **bClear:** Clear Set Object of entities prior to populating\n
        **Output:**
            **pnDof:** Force/Moment Component. \n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        :type pnDof: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetConstraints(self, dLowerBound, dUpperBound) -> Any:
        """
        **Description:**
            Sets optimization response bounds
        **Remarks/Usage:**
            SetConstraints is used in conjunction with the Setup* methods
        **Input:**
            **dLowerBound:** Lower Bound\n
            **dUpperBound:** Upper Bound\n
        **Return Code:** True\n
        :type dLowerBound: float

        :type dUpperBound: float

        """
        ...

    def SetEntities(self, nSetID, bClear, enDataType) -> Any:
        """
        **Description:**
            Sets the entities for optimization responses
        **Remarks/Usage:**
            This method can be used to specify entities for optimization responses, however it is recommended to use the setup methods instead
        **Input:**
            **nSetID:** ID of Set object containing entities for optimization responses\n
            **bClear:** Clear existing entities from Set Object\n
            **enDataType:** Data type of entities. Use enDataType. See Section 3.3.6, "Entity Types"\n
        **Return Code:** True\n
        :type nSetID: int

        :type bClear: bool

        :type enDataType: int

        """
        ...

    def SetupBuckle(self, nModeNum, nApproxCode) -> Any:
        """
        **Description:**
            Sets up an buckling optimization response in a single call
        **Remarks/Usage:**
            Optimization response constraints are specified separately using the SetConstraints method
        **Input:**
            **nModeNum:** Mode Number\n
            **nApproxCode:** Approximation code. 0 = Default, 1 = Direct, 2 = Inverse\n
        **Return Code:** True\n
        :type nModeNum: int

        :type nApproxCode: int

        """
        ...

    def SetupDisplacement(self, nSetID, nDOF) -> Any:
        """
        **Description:**
            Sets up a displacement optimization response in a single call
        **Remarks/Usage:**
            Optimization response constraints are specified separately using the SetConstraints method
        **Input:**
            **nSetID:** The ID of a set that contains a list of node IDs. Alternatively, if you specify a negative value, this is simply the ID of the single node. \n
            **nDOF:** Displacement degree of freedom. \n
        **Return Code:** True\n
        :type nSetID: int

        :type nDOF: int

        """
        ...

    def SetupESE(self, nSetID, bValidate, bDensity, enDataType) -> Any:
        """
        **Description:**
            Sets up an elemental strain energy optimization response in a single call
        **Remarks/Usage:**
            Optimization response constraints are specified separately using the SetConstraints method
        **Input:**
            **nSetID:** The ID of a set that contains a list of element IDs or property IDs. Alternatively, if you specify a negative value, this is simply the ID of the single element or property \n
            **bValidate:** Validate entities\n
            **bDensity:** Strain energy density response\n
            **enDataType:** Data type for specified entities. FET_ELEM or FET_PROP\n
        **Return Code:** True\n
        :type nSetID: int

        :type bValidate: bool

        :type bDensity: int

        :type enDataType: int

        """
        ...

    def SetupEign(self, nModeNum, nApproxCode) -> Any:
        """
        **Description:**
            Sets up an normal modes optimization response in a single call
        **Remarks/Usage:**
            Optimization response constraints are specified separately using the SetConstraints method
        **Input:**
            **nModeNum:** Mode Number\n
            **nApproxCode:** Approximation code. 0 = Default, 1 = Direct, 2 = Inverse\n
        **Return Code:** True\n
        :type nModeNum: int

        :type nApproxCode: int

        """
        ...

    def SetupElemV2(self, nSetID, bValidate, nVecID, enDataType) -> Any:
        """
        **Description:**
            This method replaces SetupElem. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above". Sets up an elemental force / stress / strain optimization response in a single call
        **Remarks/Usage:**
            Optimization response constraints are specified separately using the SetConstraints method
        **Input:**
            **nSetID:** The ID of a set that contains a list of element IDs or property IDs. Alternatively, if you specify a negative value, this is simply the ID of the single element or property \n
            **bValidate:** Validate entities \n
            **nVecID:** Output Vector ID\n
            **enDataType:** Data type for specified entities. FET_ELEM or FET_PROP\n
        **Return Code:** True\n
        :type nSetID: int

        :type bValidate: bool

        :type nVecID: int

        :type enDataType: int

        """
        ...

    def SetupFreq(self, nModeNum, nApproxCode) -> Any:
        """
        **Description:**
            Sets up an frequency optimization response in a single call
        **Remarks/Usage:**
            Optimization response constraints are specified separately using the SetConstraints method
        **Input:**
            **nModeNum:** Mode Number\n
            **nApproxCode:** Approximation code. 0 = Default, 1 = Direct, 2 = Inverse\n
        **Return Code:** True\n
        :type nModeNum: int

        :type nApproxCode: int

        """
        ...

    def SetupSPCForce(self, nSetID, bValidate, nDOF) -> Any:
        """
        **Description:**
            Sets up an SPC force / moment optimization response in a single call
        **Remarks/Usage:**
            Optimization response constraints are specified separately using the SetConstraints method
        **Input:**
            **nSetID:** The ID of a set that contains a list of node IDs. Alternatively, if you specify a negative value, this is simply the ID of the single node. \n
            **bValidate:** Validate node set \n
            **nDOF:** Force/Moment Component. \n
        **Return Code:** True\n
        :type nSetID: int

        :type bValidate: bool

        :type nDOF: int

        """
        ...


class DiscreteValueSet:
    CLSID: Any
    Active: Any
    ID: Any
    IntegerType: Any
    SetID: Any
    rangeType: Any

    def AddLevelFloat(self, dValue1, dValue2, iColor) -> Any:
        """
        **Description:**
            Adds a new level to the bottom of the discrete value set containing the specified floating point (real number) value(s) and assigns the specified color to the new level
        **Remarks/Usage:**
            None
        **Input:**
            **iColor:** ID of the Color to assign the new level.\n
        **Return Code:** True\n
        :type iColor: int

        """
        ...

    def AddLevelInteger(self, iValue1, iValue2, iColor) -> Any:
        """
        **Description:**
            Adds a new level to the bottom of the discrete value set containing the specified integer value(s) and assigns the specified color to the new level
        **Remarks/Usage:**
            None
        **Input:**
            **iValue1:** For a discrete value set with individual values, sets the integer value for the new level. For a discrete value set with ranges of values, sets integer value which is the lower bound of the range for the new level.\n
            **iValue2:** Only used when a discrete value set has ranges of values. Sets the integer value which is the upper bound of the range for the new level\n
            **iColor:** ID of the Color to assign the new level.\n
        **Return Code:** True\n
        :type iValue1: int

        :type iValue2: int

        :type iColor: int

        """
        ...

    def AutoCreateLevels(self, iVuID, iGroupID, sTitle, eVMDC, nLevels, iRangeOption, iLowestValue, dLowestValue,
                         ePropType, eMatlType, iLocation) -> Any:
        """
        **Description:**
            Automatically creates a discrete value set using the specified model data item, which can be created using data from the whole model or a group
        **Remarks/Usage:**
            Colors are automatically assigned to the levels
        **Return Code:** False\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def CreateRangeFloat(self, nRanges, dMinimum, dMaximum) -> Any:
        """
        **Description:**
            Automatically create a sequential range of floating point (real number) values in a discrete value set based on the provided number of ranges and Maximum/Minimum values
        **Remarks/Usage:**
            Colors are automatically assigned to the levels
        **Input:**
            **nRanges:** Number of ranges to create\n
            **dMinimum:** Minimum floating point (real number) value\n
            **dMaximum:** Maximum floating point (real number) value\n
        **Return Code:** True\n
        :type nRanges: int

        :type dMinimum: float

        :type dMaximum: float

        """
        ...

    def CreateRangeInteger(self, nRanges, iMinimum, iMaximum) -> Any:
        """
        **Description:**
            Automatically create a sequential range of integer values in a discrete value set based on the provided number of ranges and Maximum/Minimum values
        **Remarks/Usage:**
            Colors are automatically assigned to the levels
        **Input:**
            **nRanges:** Number of ranges to create\n
            **iMinimum:** Minimum integer value\n
            **iMaximum:** Maximum integer value\n
        **Return Code:** True\n
        :type nRanges: int

        :type iMinimum: int

        :type iMaximum: int

        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLevelFloat(self, iLevelID, pdValue1, pdValue2, piColor) -> Any:
        """
        **Description:**
            Returns the floating point (real number) value(s) and color ID for a given level in the discrete value set
        **Remarks/Usage:**
            None
        **Input:**
            **iLevelID:** Level ID\n
        **Output:**
            **piColor:** ID of the Color currently assigned to the specified level.\n
        **Return Code:** True\n
        :type iLevelID: int

        :type piColor: int

        """
        ...

    def GetLevelInteger(self, iLevelID, piValue1, piValue2, piColor) -> Any:
        """
        **Description:**
            Returns the integer value(s) and color ID for a given level in the discrete value set
        **Remarks/Usage:**
            None
        **Input:**
            **iLevelID:** Level ID\n
        **Output:**
            **piValue1:** For a discrete value set with individual values, returns the integer value for the specified level. For a discrete value set with ranges of values, returns the integer value which is the lower bound of the range for the specified level.\n
            **piValue2:** Only used when a discrete value set has ranges of values. Returns the integer value which is the upper bound of the range for the specified level\n
            **piColor:** ID of the Color currently assigned to the specified level.\n
        **Return Code:** True\n
        :type iLevelID: int

        :type piValue1: int

        :type piValue2: int

        :type piColor: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetNumberLevels(self, pnLevels) -> Any:
        """
        **Description:**
            Returns the number of levels, ranges of values or individual values, in the discrete value set (i.e., rows shown in the Discrete Value Set dialog box)
        **Remarks/Usage:**
            None
        **Output:**
            **pnLevels:** Number of levels\n
        **Return Code:** False\n
        :type pnLevels: int

        """
        ...

    def GetTitle(self, sTitle) -> Any:
        """
        **Description:**
            Returns the title of the discrete value set
        **Remarks/Usage:**
            None
        **Output:**
            **sTitle:** Title of discrete value set\n
        **Return Code:** False\n
        :type sTitle: str

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetLevelFloat(self, iLevelID, dValue1, dValue2, iColor) -> Any:
        """
        **Description:**
            Sets floating point (real number) value(s) and color ID for the specified level in the discrete value set
        **Remarks/Usage:**
            None
        **Input:**
            **iLevelID:** Level ID\n
            **iColor:** ID of the Color to assign the specified level.\n
        **Return Code:** True\n
        :type iLevelID: int

        :type iColor: int

        """
        ...

    def SetLevelInteger(self, iLevelID, iValue1, iValue2, iColor) -> Any:
        """
        **Description:**
            Sets integer value(s) and color ID for the specified level in the discrete value set
        **Remarks/Usage:**
            None
        **Input:**
            **iLevelID:** Level ID\n
            **iValue1:** For a discrete value set with individual values, sets the integer value for the specified level. For a discrete value set with ranges of values, sets integer value which is the lower bound of the range for the specified level.\n
            **iValue2:** Only used when a discrete value set has ranges of values. Sets the integer value which is the upper bound of the range for the specified level\n
            **iColor:** ID of the Color to assign the specified level.\n
        **Return Code:** True\n
        :type iLevelID: int

        :type iValue1: int

        :type iValue2: int

        :type iColor: int

        """
        ...

    def SetTitle(self, sTitle) -> Any:
        """
        **Description:**
            Sets the title of the discrete value set
        **Remarks/Usage:**
            None
        **Input:**
            **sTitle:** Title of discrete value set\n
        **Return Code:** False\n
        :type sTitle: str

        """
        ...

    def Sort(self) -> Any:
        """
        **Description:**
            Sorts the entries in the discrete value set into ascending order based on the first and second values
        **Remarks/Usage:**
            A Sort is automatically called in the Put function for Discrete Value Set Objects
        **Return Code:** True\n
        """
        ...


class OptMC:
    CLSID: Any
    Active: Any
    ID: Any
    ManConType: Any
    SetID: Any
    dField1: Any
    dField2: Any
    nField1: Any
    title: Any
    vVec1: Any
    vVec2: Any
    vVec3: Any
    vVec4: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, nID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **nID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def GetAddm(self, pdAngle, pdMin, pvBase, pvDir) -> Any:
        """
        **Description:**
            Retrieves an additive manufacturing constraint
        **Remarks/Usage:**
            None
        **Output:**
            **pdAngle:** Maximum overhang angle. Specify 0.0 for no constraint\n
            **pdMin:** Minimum allowed size. Specify 0.0 for no constraint\n
            **pvBase:** Coordinates of a point on a plane for the base plate in Global Rectangular coordinates.\n
            **pvDir:** Components of a vector normal to the base plate in the direction of material addition.\n
        **Return Code:** True\n
        :type pdAngle: float

        :type pdMin: float

        :type pvBase: Any

        :type pvDir: Any

        """
        ...

    def GetCast(self, pvCastBase, pvCastDir, pvMoldDir1, pvMoldDir2) -> Any:
        """
        **Description:**
            Retrieves a casting die direction manufacturing constraint
        **Remarks/Usage:**
            None
        **Output:**
            **pvCastBase:** Coordinates of a point on the casting plane, in Global Rectangular\n
            **pvCastDir:** Components of a vector normal to the casting plane.\n
            **pvMoldDir1:** Components of a vector that defines the first direction of mold removal\n
            **pvMoldDir1:** Components of an optional secondary mold removal vector. \n
        **Return Code:** True\n
        :type pvCastBase: Any

        :type pvCastDir: Any

        :type pvMoldDir1: Any

        :type pvMoldDir1: Any

        """
        ...

    def GetCheckerboard(self, pbEnabled) -> Any:
        """
        **Description:**
            Retrieves a checkerboarding manufacturing constraint
        **Remarks/Usage:**
            None
        **Output:**
            **pbEnabled:** Checkerboarding control is enabled (True)\n
        **Return Code:** True\n
        :type pbEnabled: bool

        """
        ...

    def GetCycSym(self, pvBase, pvRot, pvNorm, pnSect) -> Any:
        """
        **Description:**
            Retrieves a cyclic symmetry manufacturing constraint
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def GetExtrusion(self, pvDir) -> Any:
        """
        **Description:**
            Retrieves a casting die direction constraint
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetMaxSize(self, pdSize) -> Any:
        """
        **Description:**
            Retrieves a maximum size manufacturing constraint
        **Remarks/Usage:**
            None
        **Output:**
            **pdSize:** Maximum Size value\n
        **Return Code:** True\n
        :type pdSize: float

        """
        ...

    def GetMinSize(self, pdSize) -> Any:
        """
        **Description:**
            Retrieves a minimum size manufacturing constraint
        **Remarks/Usage:**
            None
        **Output:**
            **pdSize:** Minimum Size value\n
        **Return Code:** True\n
        :type pdSize: float

        """
        ...

    def GetPlSym(self, pvBase, pvDir) -> Any:
        """
        **Description:**
            Retrieves a planar symmetry manufacturing constraint
        **Remarks/Usage:**
            None
        **Output:**
            **pvBase:** Coordinate of a point on a symmetry plane, in global rectangular\n
            **pvDir:** Components of a vector normal to the symmetry plane\n
        **Return Code:** True\n
        :type pvBase: tuple[Any]

        :type pvDir: tuple[Any]

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, nID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **nID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetAddm(self, dAngle, dMin, vBase, vDir) -> Any:
        """
        **Description:**
            Sets up an additive manufacturing constraint
        **Remarks/Usage:**
            None
        **Input:**
            **dAngle:** Maximum overhang angle. Specify 0.0 for no constraint\n
            **dMin:** Minimum allowed size. Specify 0.0 for no constraint\n
            **vBase:** Coordinates of a point on a plane for the base plate. Must be specified in Global Rectangular coordinates.\n
            **vDir:** Components of a vector normal to the base plate in the direction of material addition.\n
        **Return Code:** False\n
        :type dAngle: float

        :type dMin: float

        :type vBase: tuple[Any]

        :type vDir: tuple[Any]

        """
        ...

    def SetCast(self, vCastBase, vCastDir, vMoldDir1, vMoldDir2) -> Any:
        """
        **Description:**
            Sets up a casting die direction manufacturing constraint
        **Remarks/Usage:**
            None
        **Input:**
            **vCastBase:** Coordinates of a point on the casting plane, in Global Rectangular\n
            **vCastDir:** Components of a vector normal to the casting plane.\n
            **vMoldDir1:** Components of a vector that defines the first direction of mold removal\n
            **vMoldDir1:** Components of an optional secondary mold removal vector. \n
        **Return Code:** False\n
        :type vCastBase: tuple[Any]

        :type vCastDir: tuple[Any]

        :type vMoldDir1: tuple[Any]

        :type vMoldDir1: tuple[Any]

        """
        ...

    def SetCheckerboard(self, bEnabled) -> Any:
        """
        **Description:**
            Sets up a checkerboarding manufacturing constraint
        **Remarks/Usage:**
            Checkerboarding is on by default and a manufacturing constraint does not need to be created to enable
        **Input:**
            **bEnabled:** Enable checkerboarding control (True)\n
        **Return Code:** False\n
        :type bEnabled: bool

        """
        ...

    def SetCycSym(self, vBase, vRot, vNorm, nSect) -> Any:
        """
        **Description:**
            Sets up a cyclic symmetry manufacturing constraint
        **Remarks/Usage:**
            None
        **Input:**
            **vBase:** Coordinate of a point on a cyclic symmetry plane, in global rectangular\n
            **vRot:** Components of a vector defining the axis of rotation\n
            **vNorm:** Components of vector perpendicular to the axis of rotation\n
            **nSect:** Number of sectors \n
        **Return Code:** False\n
        :type vBase: tuple[Any]

        :type vRot: tuple[Any]

        :type vNorm: tuple[Any]

        :type nSect: int

        """
        ...

    def SetExtrusion(self, vDir) -> Any:
        """
        **Description:**
            Sets up a extrusion manufacturing constraint
        **Remarks/Usage:**
            None
        **Input:**
            **vDir:** Components of a vector defining the extrusion direction\n
        **Return Code:** False\n
        :type vDir: Any

        """
        ...

    def SetMaxSize(self, dSize) -> Any:
        """
        **Description:**
            Sets up a maximum size manufacturing constraint
        **Remarks/Usage:**
            None
        **Input:**
            **dSize:** Maximum Size value\n
        **Return Code:** False\n
        :type dSize: float

        """
        ...

    def SetMinSize(self, dSize) -> Any:
        """
        **Description:**
            Sets up a minimum size manufacturing constraint
        **Remarks/Usage:**
            None
        **Input:**
            **dSize:** Minimum Size value\n
        **Return Code:** False\n
        :type dSize: float

        """
        ...

    def SetPlSym(self, vBase, vDir) -> Any:
        """
        **Description:**
            Sets up a planar symmetry manufacturing constraint
        **Remarks/Usage:**
            None
        **Input:**
            **vBase:** Coordinate of a point on a symmetry plane, in global rectangular\n
            **vDir:** Components of a vector normal to the symmetry plane\n
        **Return Code:** False\n
        :type vBase: tuple[Any]

        :type vDir: tuple[Any]

        """
        ...

    def SetVec1(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetVec2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetVec3(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetVec4(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Vec1(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Vec2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Vec3(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Vec4(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class CopyTool:
    CLSID: Any
    AddToCopiedEntityGroups: Any
    AlwaysCreateParentCSys: Any
    CopyActiveColor: Any
    CopyInSameLocation: Any
    CopyMeshSize: Any
    CopyToActiveCSys: Any
    CopyToActiveLayer: Any
    ReflectionTrapWidth: Any
    Repetitions: Any
    UsePattern: Any

    def AllOtherEntities(self, bOn) -> Any:
        """
        **Description:**
            Specifies that all entity types which are associated with, referenced by, and applied to the entities being duplicated will also be duplicated
        **Remarks/Usage:**
            None
        **Input:**
            **bOn:** Flag to include all entity types which are associated with, referenced by, and applied to the entities being duplicated (True) or not (False)\n
        **Return Code:** False\n
        :type bOn: bool

        """
        ...

    def AlongVector(self, nDataType, nEntitySetID, vdirection) -> Any:
        """
        **Description:**
            Copies entities of the specified type along a user-defined vector, using the options specified on the CopyTool object by the CopyTool Object Properties and CopyTool Object Options Methods
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be copied. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, or FT_ELEM. \n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be copied. Alternatively, if you specify a negative value, this is simply the ID of the single entity to copy. \n
            **vdirection:** The XYZ components of the vector to create copies along. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type vdirection: tuple[float]

        """
        ...

    def BetweenCSys(self, nDataType, nEntitySetID, nFromCSysID, nToCSysID) -> Any:
        """
        **Description:**
            Copies entities of the specified type then orients the duplicate entities by aligning the XYZ axes of the From coordinate system to XYZ axes of the To coordinate system, using the options specified on the CopyTool object by the CopyTool Object Properties and CopyTool Object Options Methods
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be copied and aligned. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, or FT_ELEM. \n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be copied and aligned. Alternatively, if you specify a negative value, this is simply the ID of the single entity to copy and align. \n
            **nFromCSysID:** The ID of the Coordinate System to use as the From Coordinate System\n
            **nToCSysID:** The ID of the Coordinate System to use as the To Coordinate System\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type nFromCSysID: int

        :type nToCSysID: int

        """
        ...

    def BetweenPlanes(self, nDataType, nEntitySetID, vFromBase, vFromNormal, vFromX, vToBase, vToNormal, vToX) -> Any:
        """
        **Description:**
            Copies entities of the specified type then orients the duplicate entities by aligning the From plane to the To plane, including the normal direction of the planes, using the options specified on the CopyTool object by the CopyTool Object Properties and CopyTool Object Options Methods
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be copied and aligned. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, or FT_ELEM. \n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be copied and aligned. Alternatively, if you specify a negative value, this is simply the ID of the single entity to copy and align. \n
            **vFromBase:** The XYZ coordinates of location in the plane to align from during alignment. Must be specified in Global Rectangular coordinates.\n
            **vFromNormal:** The components of a vector normal to the plane to align from during alignment. Must be specified in Global Rectangular coordinates.\n
            **vFromX:** The components of a vector that specifies the "X"/control direction within the plane to align from during alignment. Must be specified in Global Rectangular coordinates.\n
            **vToBase:** The XYZ coordinates of location in the plane to align to during alignment. Must be specified in Global Rectangular coordinates.\n
            **vToNormal:** The components of a vector normal to the plane to align to during alignment. Must be specified in Global Rectangular coordinates.\n
            **vToX:** The components of a vector that specifies the "X"/control direction within the plane to align to during alignment. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type vFromBase: tuple[float]

        :type vFromNormal: tuple[float]

        :type vFromX: tuple[float]

        :type vToBase: tuple[float]

        :type vToNormal: tuple[float]

        :type vToX: tuple[float]

        """
        ...

    def BetweenVectors(self, nDataType, nEntitySetID, vFromBase, vFromDir, vToBase, vToDir) -> Any:
        """
        **Description:**
            Copies entities of the specified type then orients the duplicate entities by moving the From Base location to the To Base location, then aligning the vector specified by the From coordinates to the vector specified by To coordinates, using the options specified on the CopyTool object by the CopyTool Object Properties and CopyTool Object Options Methods
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be copied and aligned. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, or FT_ELEM. \n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be copied and aligned. Alternatively, if you specify a negative value, this is simply the ID of the single entity to copy and align. \n
            **vFromBase:** The XYZ coordinates of the location at the base of a vector to align from. Must be specified in Global Rectangular coordinates.\n
            **vFromDir:** The components of the vector to align from during copy. Must be specified in Global Rectangular coordinates.\n
            **vToBase:** The XYZ coordinates of the location at the base of a vector to align to. Must be specified in Global Rectangular coordinates.\n
            **vToDir:** The components of the vector to align to during copy. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type vFromBase: tuple[float]

        :type vFromDir: tuple[float]

        :type vToBase: tuple[float]

        :type vToDir: tuple[float]

        """
        ...

    def CreatePattern(self, nDataType, nEntitySetID) -> Any:
        """
        **Description:**
            Creates copies using the pattern specified by the SetVectorPattern and/or SetCSysPattern Copy Tool Object Options methods and other options specified by various CopyTool Object Options Methods.
        **Remarks/Usage:**
            Either SetVectorPattern or SetCSysPattern must be set in at least one direction, otherwise coincident entities will be created.
        **Input:**
            **nDataType:** The type of entities to be copied to create a pattern. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, or FT_ELEM. \n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be copied to create a pattern. Alternatively, if you specify a negative value, this is simply the ID of the single entity to copy to create a pattern. \n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        """
        ...

    def InPlace(self, nDataType, nEntitySetID) -> Any:
        """
        **Description:**
            Copies entities of the specified type in place, using the options specified on the CopyTool object by the CopyTool Object Properties and CopyTool Object Options Methods.
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be copied in place. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, or FT_ELEM. \n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be copied in place. Alternatively, if you specify a negative value, this is simply the ID of the single entity to copy in place. \n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        """
        ...

    def IncludeOtherEntities(self, bGeometry, bMesh, bLoads, bConstraints, bConnections) -> Any:
        """
        **Description:**
            This method has been superseded by IncludeOtherEntities2, which has an individual option specifically for coordinate systems. Specifies which other types of entities should be duplicated when finite element entities or geometric entities are duplicated (options are found in the Other Entities to Includesection of Copy Options)
        **Remarks/Usage:**
            None
        **Input:**
            **bGeometry:** Flag to include geometric entities associated to finite element entities being duplicated (True) or not (False)\n
            **bMesh:** Flag to include finite element entities associated to geometric entities being duplicated (True) or not (False)\n
            **bLoads:** Flag to include loads applied to entities being duplicated (True) or not (False)\n
            **bConstraints:** Flag to include constraints applied to entities being duplicated (True) or not (False)\n
            **bConnections:** Flag to include regions which reference entities being duplicated (True) or not (False)\n
        **Return Code:** False\n
        :type bGeometry: bool

        :type bMesh: bool

        :type bLoads: bool

        :type bConstraints: bool

        :type bConnections: bool

        """
        ...

    def IncludeOtherEntities2(self, bCoordSys, bGeometry, bMesh, bLoads, bConstraints, bConnections) -> Any:
        """
        **Description:**
            Specifies which other types of entities should be duplicated when finite element entities or geometric entities are duplicated (options are found in the Other Entities to Includesection of Copy Options). This method supersedes IncludeOtherEntities.
        **Remarks/Usage:**
            None
        **Input:**
            **bCoordSys:** Flag to include coordinate systems associated to finite element entities being duplicated (True) or not (False)\n
            **bGeometry:** Flag to include geometric entities associated to finite element entities being duplicated (True) or not (False)\n
            **bMesh:** Flag to include finite element entities associated to geometric entities being duplicated (True) or not (False)\n
            **bLoads:** Flag to include loads applied to entities being duplicated (True) or not (False)\n
            **bConstraints:** Flag to include constraints applied to entities being duplicated (True) or not (False)\n
            **bConnections:** Flag to include regions which reference entities being duplicated (True) or not (False)\n
        **Return Code:** False\n
        :type bCoordSys: bool

        :type bGeometry: bool

        :type bMesh: bool

        :type bLoads: bool

        :type bConstraints: bool

        :type bConnections: bool

        """
        ...

    def PointToPoint(self, nDataType, nEntitySetID, vFrom, vTo) -> Any:
        """
        **Description:**
            Copies entities of the specified type along a vector defined by from one user-defined location to another user-defined location, using the options specified on the CopyTool object by the CopyTool Object Properties and CopyTool Object Options Methods
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be copied. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, or FT_ELEM. \n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be copied. Alternatively, if you specify a negative value, this is simply the ID of the single entity to copy. \n
            **vFrom:** The XYZ coordinates of the location at the base of a vector to move along. Must be specified in Global Rectangular coordinates.\n
            **vTo:** The XYZ coordinates of the location at the tip of a vector to move along. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type vFrom: tuple[float]

        :type vTo: tuple[float]

        """
        ...

    def Reflect(self, nDataType, nEntitySetID, vAcrossBase, vAcrossDir) -> Any:
        """
        **Description:**
            Copies entities of the specified type by reflecting them across the specified plane, using the options specified on the CopyTool object by the CopyTool Object Properties, including ReflectionTrapWidth, and CopyTool Object Options Methods.
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be copied and reflected. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, or FT_ELEM. \n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be copied and reflected. Alternatively, if you specify a negative value, this is simply the ID of the single entity to copy and reflect. \n
            **vAcrossBase:** The XYZ coordinates of the location at the base of the reflection plane. Must be specified in Global Rectangular coordinates.\n
            **vAcrossDir:** The components of a vector normal to the reflection plane. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type vAcrossBase: tuple[float]

        :type vAcrossDir: tuple[float]

        """
        ...

    def RotateAroundVector(self, nDataType, nEntitySetID, vAroundBase, vAroundDir, dAngle, dDistanceAlong) -> Any:
        """
        **Description:**
            Copies entities of the specified type, then rotates them around a user-defined vector by a specified amount, in degrees, and optionally along the user-defined vector a specified distance, using the options specified on the CopyTool object by the CopyTool Object Properties and CopyTool Object Options Methods
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be copied. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, or FT_ELEM. \n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be copied and rotated/moved. Alternatively, if you specify a negative value, this is simply the ID of the single entity to copy and rotate/move. \n
            **vAroundBase:** The XYZ coordinates of the location at the base of a vector to rotate around. Must be specified in Global Rectangular coordinates.\n
            **vAroundDir:** The components of a vector to rotate around. Must be specified in Global Rectangular coordinates.\n
            **dAngle:** The angle of rotation, in degrees.\n
            **dDistanceAlong:** The total distance along the axis of rotation, typically zero.\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type vAroundBase: tuple[float]

        :type vAroundDir: tuple[float]

        :type dAngle: float

        :type dDistanceAlong: float

        """
        ...

    def RotatePointToPoint(self, nDataType, nEntitySetID, vAroundBase, vAroundDir, vFrom, vTo) -> Any:
        """
        **Description:**
            Copies entities of the specified type, then rotates them around a user-defined from one location to another location (locations define both angle of rotation and distance along the user-defined vector), using the options specified on the CopyTool object by the CopyTool Object Properties and CopyTool Object Options Methods
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be copied. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, or FT_ELEM. \n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be copied and rotated/moved. Alternatively, if you specify a negative value, this is simply the ID of the single entity to copy and rotate/move. \n
            **vAroundBase:** The XYZ coordinates of the location at the base of a vector to rotate around. Must be specified in Global Rectangular coordinates.\n
            **vAroundDir:** The components of a vector to rotate around. Must be specified in Global Rectangular coordinates.\n
            **vFrom:** The XYZ coordinates of the location to rotate/move from. Must be specified in Global Rectangular coordinates.\n
            **vTo:** The XYZ coordinates of the location to rotate/move to. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type vAroundBase: tuple[float]

        :type vAroundDir: tuple[float]

        :type vFrom: tuple[float]

        :type vTo: tuple[float]

        """
        ...

    def SetCSysPattern(self, nPatternDirection, bOn, nNumberInPattern, dSpacing, nCSysID) -> Any:
        """
        **Description:**
            Specifies if pattern direction 1, 2, and/or 3, should be used when creating a pattern, as well as how many repetitions, spacing between duplicates, and coordinate system used to define pattern directions.
        **Remarks/Usage:**
            Once all the desired pattern directions and options have been specified, use CreatePattern to create duplicates in the specified pattern.
        **Input:**
            **nPatternDirection:** Pattern Direction:\n
            **bOn:** When True, the pattern direction specified with nPatternDirection will be used when creating a pattern. When False, the pattern direction specified will not be considered\n
            **nNumberInPattern:** Number of repetitions to make in the direction specified in nPatternDirection\n
            **dSpacing:** The distance between each duplicate created in the direction specified by nPatternDirection. The coordinate system axes are always considered as unit vectors so unlike the SetVectorPattern method, dSpacing is always the total distance between instances.\n
            **nCSysID:** Coordinate System used to define the 3 pattern directions.\n
        **Return Code:** True\n
        :type nPatternDirection: int

        :type bOn: bool

        :type nNumberInPattern: int

        :type dSpacing: float

        :type nCSysID: int

        """
        ...

    def SetNumbering(self, nMethod, nToBy) -> Any:
        """
        **Description:**
            Specifies option to use in the Numbering section, along with Toor By value.
        **Remarks/Usage:**
            None
        **Input:**
            **nToBy:** When zCopyReumMethod is set to FCPRNM_BLOCK, used to specify Tovalue. Sets By value when set to FCPRNM_OFFSET.\n
        **Return Code:** False\n
        :type nToBy: int

        """
        ...

    def SetPropertyOption(self, nApproach, nOverrideID) -> Any:
        """
        **Description:**
            Specifies which option is used to assign properties to duplicate elements (specified in Properties/Material Optionssection) or assign properties to duplicate geometric entities when the original geometric entity already have mesh attributes assigned (specified in Other Entities to Include section)
        **Remarks/Usage:**
            None
        **Input:**
            **nOverrideID:** Property to use for duplicates when zCopyPropApproach is set to FCPPR_OVERRIDE. If type of specified property is not compatible with a duplicate, the duplicate maintains the original property.\n
        **Return Code:** True\n
        :type nOverrideID: int

        """
        ...

    def SetVectorPattern(self, nPatternDirection, bOn, nNumberInPattern, dSpacing, vdirection) -> Any:
        """
        **Description:**
            Specifies if pattern direction 1, 2, and/or 3 should be used when creating a pattern, as well as how many repetitions, spacing between duplicates, and direction vector for each pattern direction.
        **Remarks/Usage:**
            Once all the desired pattern directions and options have been specified, use CreatePattern to create duplicates in the specified pattern.
        **Input:**
            **nPatternDirection:** Pattern Direction. 0 = Direction 1, 1 = Direction 2, 2 = Direction 3\n
            **bOn:** When True, the pattern direction specified with nPatternDirection will be used when creating a pattern. When False, the pattern direction specified will not be considered\n
            **nNumberInPattern:** Number of repetitions to make in the direction specified in nPatternDirection\n
            **dSpacing:** The distance between each duplicate created in the direction specified by nPatternDirection. The total distance between each instance in the pattern is the product of dSpacing and the magnitude of vDirection. dSpacing is only the actual distance if vDirection is specified as a unit vector.\n
            **vdirection:** The XYZ components of the vector to create copies along the direction specified in nPatternDirection. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nPatternDirection: int

        :type bOn: bool

        :type nNumberInPattern: int

        :type dSpacing: float

        :type vdirection: tuple[float]

        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            Clears everything in the CopyTool object.
        **Remarks/Usage:**
            Use to clear all values in the CopyTool object specified by the CopyTool Object Properties and CopyTool Object Options Methods. It may be a good idea to use this method to purge the object so no unwanted options are used, especially if performing a different operation (i.e. a Copy command after using Rotate command with a number of Repetitions.
        **Return Code:** False\n
        """
        ...


class MoveTool:
    CLSID: Any
    AlwaysCreateParentCSys: Any
    ReflectionTrapWidth: Any

    def AlongVector(self, nDataType, nEntitySetID, vdirection) -> Any:
        """
        **Description:**
            Moves entities of the specified type along a user-defined vector, using the options specified on the MoveTool object by the MoveTool Object Properties and MoveTool Object Options Methods
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be moved. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, or FT_ELEM. \n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be moved. Alternatively, if you specify a negative value, this is simply the ID of the single entity to move. \n
            **vdirection:** The XYZ components of the vector to move along. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type vdirection: tuple[float]

        """
        ...

    def BetweenCSys(self, nDataType, nEntitySetID, nFromCSysID, nToCSysID) -> Any:
        """
        **Description:**
            Reorients entities of the specified type by aligning the XYZ axes of the From coordinate system to XYZ axes of the To coordinate system, using the options specified on the MoveTool object by the MoveTool Object Properties and MoveTool Object Options Methods
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be aligned. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, FT_ELEM, or FT_CSYS\n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be aligned. Alternatively, if you specify a negative value, this is simply the ID of the single entity to align. \n
            **nFromCSysID:** The ID of the Coordinate System to use as the From Coordinate System\n
            **nToCSysID:** The ID of the Coordinate System to use as the To Coordinate System\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type nFromCSysID: int

        :type nToCSysID: int

        """
        ...

    def BetweenPlanes(self, nDataType, nEntitySetID, vFromBase, vFromNormal, vFromX, vToBase, vToNormal, vToX) -> Any:
        """
        **Description:**
            Reorients entities of the specified type by aligning the From plane to the To plane, including the normal direction of the planes, using the options specified on the MoveTool object by the MoveTool Object Properties and MoveTool Object Options Methods
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be aligned. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, FT_ELEM, or FT_CSYS\n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be aligned. Alternatively, if you specify a negative value, this is simply the ID of the single entity to align. \n
            **vFromBase:** The XYZ coordinates of location in the plane to align from during alignment. Must be specified in Global Rectangular coordinates.\n
            **vFromNormal:** The components of a vector normal to the plane to align from during alignment. Must be specified in Global Rectangular coordinates.\n
            **vFromX:** The components of a vector that specifies the "X"/control direction within the plane to align from during alignment. Must be specified in Global Rectangular coordinates.\n
            **vToBase:** The XYZ coordinates of location in the plane to align to during alignment. Must be specified in Global Rectangular coordinates.\n
            **vToNormal:** The components of a vector normal to the plane to align to during alignment. Must be specified in Global Rectangular coordinates.\n
            **vToX:** The components of a vector that specifies the "X"/control direction within the plane to align to during alignment. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type vFromBase: tuple[float]

        :type vFromNormal: tuple[float]

        :type vFromX: tuple[float]

        :type vToBase: tuple[float]

        :type vToNormal: tuple[float]

        :type vToX: tuple[float]

        """
        ...

    def BetweenVectors(self, nDataType, nEntitySetID, vFromBase, vFromDir, vToBase, vToDir) -> Any:
        """
        **Description:**
            Reorients entities of the specified type by moving the From Base location to the To Base location, then aligning the vector specified by the From coordinates to the vector specified by To coordinates, using the options specified on the MoveTool object by the MoveTool Object Properties and MoveTool Object Options Methodss
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be aligned. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, FT_ELEM, or FT_CSYS\n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be aligned. Alternatively, if you specify a negative value, this is simply the ID of the single entity to align. \n
            **vFromBase:** The XYZ coordinates of the location at the base of a vector to align from. Must be specified in Global Rectangular coordinates.\n
            **vFromDir:** The components of the vector to align from during move. Must be specified in Global Rectangular coordinates.\n
            **vToBase:** The XYZ coordinates of the location at the base of a vector to align to. Must be specified in Global Rectangular coordinates.\n
            **vToDir:** The components of the vector to align from during move. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type vFromBase: tuple[float]

        :type vFromDir: tuple[float]

        :type vToBase: tuple[float]

        :type vToDir: tuple[float]

        """
        ...

    def IncludeOtherEntities(self, bGeometryOrMesh) -> Any:
        """
        **Description:**
            This method has been superseded by IncludeOtherEntities2, which has an individual option for coordinate systems. Specifies which other types of entities should be moved/rotated/reflected/aligned when finite element entities, geometric entities, or coordinate systems are moved/rotated/reflected/aligned (option is found in the Other Entities to Includesection of Move Options)
        **Remarks/Usage:**
            None
        **Input:**
            **bGeometryOrMesh:** Flag to include geometric entities associated to finite element entities being moved/rotated/reflected/aligned or to include finite element entities associated to geometric entities being moved/rotated/reflected/aligned (True) or not (False). For coordinate systems, both geometry and mesh will be being moved/rotated/reflected/aligned when this argument is set to True.\n
        **Return Code:** False\n
        :type bGeometryOrMesh: bool

        """
        ...

    def IncludeOtherEntities2(self, bCoordSys, bGeometryOrMesh) -> Any:
        """
        **Description:**
            Specifies which other types of entities should be moved/rotated/reflected/aligned when finite element entities, geometric entities, and/or coordinate systems are moved/rotated/reflected/aligned (option is found in the Other Entities to Includesection of Move Options). This method supersedes IncludeOtherEntities.
        **Remarks/Usage:**
            None
        **Input:**
            **bCoordSys:** Flag to include moving coordinate systems associated with entities when moving geometry, mesh, or coordinate systems.\n
            **bGeometryOrMesh:** Flag to include geometric entities associated to finite element entities being moved/rotated/reflected/aligned or to include finite element entities associated to geometric entities being moved/rotated/reflected/aligned (True) or not (False). For coordinate systems, both geometry and mesh will be being moved/rotated/reflected/aligned when this argument is set to True.\n
        **Return Code:** False\n
        :type bCoordSys: bool

        :type bGeometryOrMesh: bool

        """
        ...

    def PointToPoint(self, nDataType, nEntitySetID, vFrom, vTo) -> Any:
        """
        **Description:**
            Moves entities of the specified type along a vector defined by from one user-defined location to another user-defined location, using the options specified on the MoveTool object by the MoveTool Object Properties and MoveTool Object Options Methods
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be moved. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, FT_ELEM, or FT_CSYS. \n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be moved. Alternatively, if you specify a negative value, this is simply the ID of the single entity to move. \n
            **vFrom:** The XYZ coordinates of the location at the base of a vector to move along. Must be specified in Global Rectangular coordinates.\n
            **vTo:** The XYZ coordinates of the location at the tip of a vector to move along. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type vFrom: tuple[float]

        :type vTo: tuple[float]

        """
        ...

    def Reflect(self, nDataType, nEntitySetID, vAcrossBase, vAcrossDir) -> Any:
        """
        **Description:**
            Reflects entities of the specified type by reflecting them across the specified plane, using the options specified on the MoveTool object by the MoveTool Object Properties, including ReflectionTrapWidth, and MoveTool Object Options Methods.
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be reflected. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, FT_ELEM, or FT_CSYS.\n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be reflected. Alternatively, if you specify a negative value, this is simply the ID of the single entity to reflect. \n
            **vAcrossBase:** The XYZ coordinates of the location at the base of the reflection plane. Must be specified in Global Rectangular coordinates.\n
            **vAcrossDir:** The components of a vector normal to the reflection plane. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type vAcrossBase: tuple[float]

        :type vAcrossDir: tuple[float]

        """
        ...

    def RotateAroundVector(self, nDataType, nEntitySetID, vAroundBase, vAroundDir, dAngle, dDistanceAlong) -> Any:
        """
        **Description:**
            Rotates entities of the specified type around a user-defined vector by a specified amount, in degrees, and optionally along the user-defined vector a specified distance, using the options specified on the MoveTool object by the MoveTool Object Properties and MoveTool Object Options Methods
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be rotated/moved. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, FT_ELEM, or FT_CSYS \n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be rotated/moved. Alternatively, if you specify a negative value, this is simply the ID of the single entity to rotate/move. \n
            **vAroundBase:** The XYZ coordinates of the location at the base of a vector to rotate around. Must be specified in Global Rectangular coordinates.\n
            **vAroundDir:** The components of a vector to rotate around. Must be specified in Global Rectangular coordinates.\n
            **dAngle:** The angle of rotation, in degrees.\n
            **dDistanceAlong:** The total distance along the axis of rotation, typically zero.\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type vAroundBase: tuple[float]

        :type vAroundDir: tuple[float]

        :type dAngle: float

        :type dDistanceAlong: float

        """
        ...

    def RotatePointToPoint(self, nDataType, nEntitySetID, vAroundBase, vAroundDir, vFrom, vTo) -> Any:
        """
        **Description:**
            Rotates entities of the specified type around a user-defined from one location to another location (locations define both angle of rotation and distance along the user-defined vector), using the options specified on the MoveTool object by the MoveTool Object Properties and MoveTool Object Options Methods
        **Remarks/Usage:**
            None
        **Input:**
            **nDataType:** The type of entities to be rotate/move. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, FT_ELEM, or FT_CSYS \n
            **nEntitySetID:** The ID of a set that contains a list of entity IDs that will be rotated/moved. Alternatively, if you specify a negative value, this is simply the ID of the single entity to rotate/move. \n
            **vAroundBase:** The XYZ coordinates of the location at the base of a vector to rotate around. Must be specified in Global Rectangular coordinates.\n
            **vAroundDir:** The components of a vector to rotate around. Must be specified in Global Rectangular coordinates.\n
            **vFrom:** The XYZ coordinates of the location to rotate/move from. Must be specified in Global Rectangular coordinates.\n
            **vTo:** The XYZ coordinates of the location to rotate/move to. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nDataType: int

        :type nEntitySetID: int

        :type vAroundBase: tuple[float]

        :type vAroundDir: tuple[float]

        :type vFrom: tuple[float]

        :type vTo: tuple[float]

        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            Clears everything in the MoveTool object.
        **Remarks/Usage:**
            Use to clear all values in the MoveTool object specified by the MoveTool Object Properties and MoveTool Object Options Methods. It may be a good idea to use this method to purge the object so no unwanted options are used, especially if performing a different operation (i.e. a Move By command after using Rotate By command).
        **Return Code:** False\n
        """
        ...


class Fibersim:
    CLSID: Any
    bAngleSnap: Any
    bCentroid: Any
    bUniqueLayerID: Any
    dAngleDiv: Any
    dAngleTol: Any
    dSearchFactor: Any
    nMatCount: Any
    nPlyCount: Any

    def ConnectToDB(self, filname) -> Any:
        """
        :type filname: Any
        """
        ...

    def CreatePlyPoints(self, nPlyID) -> Any:
        """
        :type nPlyID: Any
        """
        ...

    def FindMatchingLayupElems(self, nLayupID, elSetID, matchSetID, dAngleMatchTol, dThickPctMatchTol) -> Any:
        """
        :type nLayupID: Any
        :type elSetID: Any
        :type matchSetID: Any
        :type dAngleMatchTol: Any
        :type dThickPctMatchTol: Any
        """
        ...

    def GetFibersimPlyInfo(self, plyID, sTitle, nLayerID, nGlobalPlyID, nmatID) -> Any:
        """
        :type plyID: Any
        :type sTitle: Any
        :type nLayerID: Any
        :type nGlobalPlyID: Any
        :type nmatID: Any
        """
        ...

    def GetLayupAtElem(self, elID, layupID, vRefVec) -> Any:
        """
        :type elID: Any
        :type layupID: Any
        :type vRefVec: Any
        """
        ...

    def GetLayupAtLoc(self, xyz, layupID) -> Any:
        """
        :type xyz: Any
        :type layupID: Any
        """
        ...

    def GlobalPlyDirectionPreview(self, gPlyID, nDisplayTime) -> Any:
        """
        :type gPlyID: Any
        :type nDisplayTime: Any
        """
        ...

    def PlyDirectionPreview(self, nPlyID, nDisplayTime) -> Any:
        """
        :type nPlyID: Any
        :type nDisplayTime: Any
        """
        ...

    def PlyPreview(self, nPlyID, nDisplayTime) -> Any:
        """
        :type nPlyID: Any
        :type nDisplayTime: Any
        """
        ...

    def PlyRefDirectionPreview(self, nPlyID, nDisplayTime) -> Any:
        """
        :type nPlyID: Any
        :type nDisplayTime: Any
        """
        ...

    def ProcessElements(self, elSetID) -> Any:
        """
        :type elSetID: Any
        """
        ...

    def SetAngleSnap(self, dAngle, dTol) -> Any:
        """
        :type dAngle: Any
        :type dTol: Any
        """
        ...

    def SetLaminateOffsets(self, elSetID, bReset, bTop) -> Any:
        """
        :type elSetID: Any
        :type bReset: Any
        :type bTop: Any
        """
        ...


class MonitorPoint:
    CLSID: Any
    Active: Any
    AeroMeshSetID: Any
    AeroPanelID: Any
    CompTitle: Any
    ElemGroup: Any
    HasAeroMeshList: Any
    HasElemList: Any
    HasNodeList: Any
    HasPanelList: Any
    ID: Any
    Name: Any
    NodeGroup: Any
    NodeSetID: Any
    PanelSetID: Any
    SetID: Any
    color: Any
    defCSys: Any
    elemSetID: Any
    layer: Any
    outCSys: Any
    title: Any
    type: Any
    vSumComponents: Any
    vSumContributions: Any
    vXYZ: Any
    x: Any
    y: Any
    z: Any

    def ClearAeroMeshSet(self) -> Any:
        """
        **Description:**
            This method clears the array that contains the array that contains the IDs of the Aero Mesh entities in the Aero Mesh List
        **Remarks/Usage:**
            Cannot be used when type = MPT_1_AEROMESH. Use ClearComponentSet instead. See Section 5.53.2.5, "ClearComponentSet"
        **Return Code:** True\n
        """
        ...

    def ClearComponentSet(self, entityTYPE) -> Any:
        """
        **Description:**
            This method clears the array that contains the array that contains the IDs of the Nodes in the Node List (type = MPT_1_STRUCT or MPT_3), Elements in the Element List (type = MPT_3), or Aero Panels in the Aero Panel List (type = MPT_1_AEROPANEL)
        **Remarks/Usage:**
            Cannot be used when type = MPT_1_AEROMESH. Use ClearAeroMeshSet instead. See Section 5.53.2.6, "ClearAeroMeshSet"
        **Input:**
            **entityTYPE:** The entity type:\n
        **Return Code:** True\n
        :type entityTYPE: int

        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetAeroMeshSet(self, pAeroMeshSet) -> Any:
        """
        **Description:**
            This method Loads a Set object that contains the IDs of the Aero Mesh entities in the Aero Mesh List.
        **Remarks/Usage:**
            Only valid when type = MPT_1_AEROMESH. For all other types, use GetComponentSet. See Section 5.53.2.3, "GetComponentSet"
        **Output:**
            **pAeroMeshSet:** Set object that contains the IDs of the Aero Mesh entities in the Aero Mesh list\n
        **Return Code:** True\n
        :type pAeroMeshSet: Any

        """
        ...

    def GetComponentSet(self, entityTYPE, pSelectedComponentSet) -> Any:
        """
        **Description:**
            This method loads a Set object that contains the IDs of the Nodes in the Node List (type = MPT_1_STRUCT or MPT_3), Elements in the Element List (type = MPT_3), or Aero Panels in the Aero Panel List (type = MPT_1_AEROPANEL)
        **Remarks/Usage:**
            Cannot be used when type = MPT_1_AEROMESH. Use GetAeroMeshSet instead. See Section 5.53.2.4, "GetAeroMeshSet"
        **Input:**
            **entityTYPE:** The entity type:\n
        **Return Code:** True\n
        :type entityTYPE: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutAeroMeshSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads a set of Aero Mesh entity IDs into the Aero Mesh List
        **Remarks/Usage:**
            Only valid when type = MPT_1_AEROMESH. For all other types, use PutComponentSet. For more information, see Section 5.53.2.1, "PutComponentSet".
        **Input:**
            **nSetID:** The ID of the Set Object that will contain the IDs of the aero mesh entities. \n
        **Return Code:** False\n
        :type nSetID: int

        """
        ...

    def PutComponentSet(self, entityTYPE, pSelectedComponentSet) -> Any:
        """
        **Description:**
            This method loads Node IDs into the Node List (type = MPT_1_STRUCT or MPT_3), Element IDs into the Element List (type = MPT_3), or Aero Panels into the Aero Panel List (type = MPT_1_AEROPANEL) from a Set Object
        **Remarks/Usage:**
            Cannot be used when type = MPT_1_AEROMESH. Use PutAeroMeshSet instead. For more information, see Section 5.53.2.2, "PutAeroMeshSet"
        **Input:**
            **entityTYPE:** The entity type:\n
            **pSelectedComponentSet:** Set Object containing the IDs of the entities \n
        **Return Code:** True\n
        :type entityTYPE: int

        :type pSelectedComponentSet: Any

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetSumComponents(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetSumContributions(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Setxyz(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SumComponents(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def SumContributions(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def xyz(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...


class MatrixInput:
    CLSID: Any
    Active: Any
    AssignForm: Any
    ComplexForm: Any
    DataSource: Any
    FileInputForm: Any
    ID: Any
    InputForm: Any
    InputPrecision: Any
    Name: Any
    OutputPrecision: Any
    ScaleFactor: Any
    SetID: Any
    UnitID: Any
    colCount: Any
    matrixDir: Any
    title: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetCombination(self, nSetID, entID, dScale, MatrixInputID, InputName) -> Any:
        """
        **Description:**
            This method retrieves information from the matrix combinations in a combined Matrix Input entity
        **Remarks/Usage:**
            This method retrieves a single line from the Referenced Inputs section from a combined Matrix Input. The IDs of the combination can first be loaded into a Set Object using GetCombinationSet.
        **Input:**
            **nSetID:** The ID of the combined Matrix Input entity from where to retrieve the combination\n
            **entID:** The ID of the combination (i.e., place in the list of Referenced Inputs)\n
        **Output:**
            **dScale:** The scale factor of the combination \n
            **MatrixInputID:** The ID of the referenced Matrix Input (if it exists) \n
            **InputName:** The name of the matrix referenced by the combination (if specified as direct name input) \n
        **Return Code:** True\n
        :type nSetID: int

        :type entID: int

        :type dScale: float

        :type MatrixInputID: int

        :type InputName: str

        """
        ...

    def GetCombinationSet(self, pCombinationSet) -> Any:
        """
        **Description:**
            This method loads a Set Object with the IDs of matrix input entries in a combined Matrix Input entity currently loaded in the Matrix Input Object
        **Remarks/Usage:**
            None
        **Output:**
            **pCombinationSet:** The Set Object that will receive the IDs of the matrix combinations\n
        **Return Code:** True\n
        :type pCombinationSet: Any

        """
        ...

    def GetCombinations(self, MatrixComboEntityID, listcount, MatrixEntityIDs, DirectNameInputs, ScaleFactors) -> Any:
        """
        **Description:**
            This method retrieves information from the matrix combinations in a combined Matrix Input entity.
        **Remarks/Usage:**
            None
        **Output:**
            **listcount:** The number of matrix input entities in the combination. \n
            **MatrixEntityIDs:** The IDs of the matrix input entities in the combination.\n
            **DirectNameInputs:** The titles of the Direct Name Input.\n
        **Return Code:** True\n
        :type listcount: int

        :type MatrixEntityIDs: tuple[int]

        :type DirectNameInputs: tuple[str]

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetMatrixEntry(self, nSetID, NodeColumnIndex, NodeColumnComponent, NodeRowIndex, NodeRowComponent,
                       RealMatrixValue, ImagMatrixValue) -> Any:
        """
        **Description:**
            This method is used to retrieve the real and imaginary matrix entry values from an internalized Matrix Input entity, given its row and column index.
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** The ID of the Matrix Input entity to store the entry\n
            **NodeColumnIndex:** The ID for the node that represents the column index for the entry\n
            **NodeColumnComponent:** The component number for the node that represents the column index \n
            **NodeRowIndex:** The ID for the node that represents the row index \n
        **Output:**
            **RealMatrixValue:** The real (or amplitude) part of a matrix element \n
            **ImagMatrixValue:** The imaginary (or phase) part of a matrix element\n
        **Return Code:** True\n
        :type nSetID: int

        :type NodeColumnIndex: int

        :type NodeColumnComponent: int

        :type NodeRowIndex: int

        :type RealMatrixValue: float

        :type ImagMatrixValue: float

        """
        ...

    def GetMatrixList(self, listcount, NodeColumnIndex, NodeColumnComponent, NodeRowIndex, NodeRowComponent,
                      RealMatrixValue, ImagMatrixValue) -> Any:
        """
        **Description:**
            This method retrieves information from the matrix entries in a Matrix Input.
        **Remarks/Usage:**
            This method simply retrieves the information about the matrix entries from the current object. You must first load that data, either by using the Get method or by loading it yourself with PutMatrixList.
        **Output:**
            **listcount:** The number of entries in the other arrays.\n
            **NodeColumnIndex:** [0..listcount -1]\n
            **NodeColumnComponent:** [0..listcount -1]\n
            **RealMatrixValue:** [0..listcount-1]\n
            **ImagMatrixValue:** [0..listcount-1]\n
        **Return Code:** True\n
        :type listcount: int

        :type NodeColumnIndex: int

        :type NodeColumnComponent: int

        :type RealMatrixValue: int

        :type ImagMatrixValue: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutCombination(self, nSetID, dScale, MatrixInputID, InputName) -> Any:
        """
        **Description:**
            This method stores matrix combinations in a combined Matrix Input entity.
        **Remarks/Usage:**
            This method stores matrix combinations to a combined Matrix Input. The IDs of the combination must first be loaded into a Set Object using GetCombinationSet
        **Input:**
            **nSetID:** The ID of the combined Matrix Input entity where to store the combination\n
            **dScale:** The scale factor of the combination \n
            **MatrixInputID:** The ID of the referenced Matrix Input (if it exists) \n
            **InputName:** The name of the matrix referenced by the combination (if specified as direct name input) \n
        **Return Code:** True\n
        :type nSetID: int

        :type dScale: float

        :type MatrixInputID: int

        :type InputName: str

        """
        ...

    def PutCombinations(self, listcount, MatrixEntityIDs, DirectNameInputs, ScaleFactors) -> Any:
        """
        **Description:**
            This method stores matrix combinations in a combined Matrix Input entity.
        **Remarks/Usage:**
            None
        **Input:**
            **MatrixEntityIDs:** The IDs of the matrix input entities in the combination.\n
            **DirectNameInputs:** The titles of the Direct Name Input.\n
        **Return Code:** True\n
        :type MatrixEntityIDs: tuple[int]

        :type DirectNameInputs: tuple[str]

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def PutMatrixEntry(self, nSetID, NodeColumnIndex, NodeColumnComponent, NodeRowIndex, NodeRowComponent,
                       RealMatrixValue, ImagMatrixValue) -> Any:
        """
        **Description:**
            This method is used to store a matrix entry in an internalized Matrix Input entity.
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** The ID of the Matrix Input entity to store the entry\n
            **NodeColumnIndex:** The ID for the node that represents the column index for the entry\n
            **NodeColumnComponent:** The component number for the node that represents the column index \n
            **NodeRowIndex:** The ID for the node that represents the row index \n
            **RealMatrixValue:** The real (or amplitude) part of a matrix element \n
            **ImagMatrixValue:** The imaginary (or phase) part of a matrix element\n
        **Return Code:** True\n
        :type nSetID: int

        :type NodeColumnIndex: int

        :type NodeColumnComponent: int

        :type NodeRowIndex: int

        :type RealMatrixValue: float

        :type ImagMatrixValue: float

        """
        ...

    def PutMatrixList(self, listcount, NodeColumnIndex, NodeColumnComponent, NodeRowIndex, NodeRowComponent,
                      RealMatrixValue, ImagMatrixValue) -> Any:
        """
        **Description:**
            This method stores information to the matrix entries in a Matrix Input.
        **Remarks/Usage:**
            This method stores information into the list of the current object. Any previous list information in that object is lost. This method does not store that information to the model database. After using this function, you must call Put if you want to store the updated list in the database.
        **Input:**
            **listcount:** The number of entries in the other arrays.\n
            **NodeColumnIndex:** [0..listcount -1]\n
            **NodeColumnComponent:** [0..listcount -1]\n
            **RealMatrixValue:** [0..listcount-1]\n
            **ImagMatrixValue:** [0..listcount-1]\n
        **Return Code:** True\n
        :type listcount: int

        :type NodeColumnIndex: int

        :type NodeColumnComponent: int

        :type RealMatrixValue: int

        :type ImagMatrixValue: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class SolidEdit:
    CLSID: Any
    bAutoRemesh: Any
    bSelectColinear: Any
    bSelectConcentric: Any
    bSelectIdentical: Any
    bSelectOffset: Any
    bSelectTangentEdges: Any
    bSmartSelect: Any

    def SurfaceEdit(self, nSetID, bExtend, dValue) -> Any:
        """
        :type nSetID: Any
        :type bExtend: Any
        :type dValue: Any
        """
        ...

    def SurfaceMoveAlongVector(self, nSetID, dDistance, vdirection) -> Any:
        """
        :type nSetID: Any
        :type dDistance: Any
        :type vdirection: Any
        """
        ...

    def SurfaceOffset(self, nSetID, bExtend, dValue) -> Any:
        """
        :type nSetID: Any
        :type bExtend: Any
        :type dValue: Any
        """
        ...

    def SurfaceRotateAroundVector(self, nSetID, dAngle, vBase, vdirection) -> Any:
        """
        :type nSetID: Any
        :type dAngle: Any
        :type vBase: Any
        :type vdirection: Any
        """
        ...

    def clear(self) -> Any:
        """
        """
        ...


class MergeTool:
    CLSID: Any
    AlwaysCreateParentCSys: Any
    CondenseMergedGroups: Any
    CreateGroupForMerged: Any
    DuplicateFirstInPattern: Any
    KeepInOriginalSets: Any
    LimitToMergedEntities: Any
    UsePattern: Any

    def AddRelated(self, bAddAssociated) -> Any:
        """
        **Description:**
            Selects all entities that are related (used by) the entities that are already selected to be merged
        **Remarks/Usage:**
            Use of this method is usually required if you are adjusting the entity selection to insure that a complete/valid portion of your model will be merged. Otherwise, you can end up merging entities that still reference other entities that do not exist in the current model.
        **Input:**
            **bAddAssociated:** If True, additional associated entities will be added to the selection. For example, if you have selected surfaces, then if this is True any nodes and elements meshed on those surfaces are considered to be associated and will be included.\n
        **Return Code:** True\n
        :type bAddAssociated: bool

        """
        ...

    def AlongVector(self, vdirection) -> Any:
        """
        **Description:**
            Merges all of the selected entities into the current model and transforms them along a vector
        **Remarks/Usage:**
            None
        **Input:**
            **vdirection:** The components of a vector specifying the direction and distance to offset the merged entities. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type vdirection: tuple[float]

        """
        ...

    def BetweenCSys(self, nFromCSysID, nToCSysID) -> Any:
        """
        **Description:**
            Merges all of the selected entities into the current model and transforms them to align from one location and orientation to another
        **Remarks/Usage:**
            None
        **Input:**
            **nFromCSysID:** The ID of the Coordinate System to use as the From Coordinate System\n
            **nToCSysID:** The ID of the Coordinate System to use as the To Coordinate System\n
        **Return Code:** True\n
        :type nFromCSysID: int

        :type nToCSysID: int

        """
        ...

    def BetweenPlanes(self, vFromBase, vFromNormal, vFromX, vToBase, vToNormal, vToX) -> Any:
        """
        **Description:**
            Merges all of the selected entities into the current model and transforms them by aligning the From plane to the To plane, including the normal direction of the planes
        **Remarks/Usage:**
            None
        **Input:**
            **vFromBase:** The XYZ coordinates of location in the plane to align from during alignment. Must be specified in Global Rectangular coordinates.\n
            **vFromNormal:** The components of a vector normal to the plane to align from during alignment. Must be specified in Global Rectangular coordinates.\n
            **vFromX:** The components of a vector that specifies the X/control direction within the plane to align from during alignment. Must be specified in Global Rectangular coordinates.\n
            **vToBase:** The XYZ coordinates of location in the plane to align to during alignment. Must be specified in Global Rectangular coordinates.\n
            **vToNormal:** The components of a vector normal to the plane to align to during alignment. Must be specified in Global Rectangular coordinates.\n
            **vToX:** The components of a vector that specifies the X/control direction within the plane to align to during alignment. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type vFromBase: tuple[float]

        :type vFromNormal: tuple[float]

        :type vFromX: tuple[float]

        :type vToBase: tuple[float]

        :type vToNormal: tuple[float]

        :type vToX: tuple[float]

        """
        ...

    def BetweenVectors(self, vFromBase, vFromDir, vToBase, vToDir) -> Any:
        """
        **Description:**
            Merges all of the selected entities into the current model and transforms them by moving the FromBase location to the ToBase location and then aligning the FromDir vector to the ToDir vector
        **Remarks/Usage:**
            None
        **Input:**
            **vFromBase:** The XYZ coordinates of the location at the base of a vector to align from. Must be specified in Global Rectangular coordinates.\n
            **vFromDir:** The components of the vector to align from during merge. Must be specified in Global Rectangular coordinates.\n
            **vToBase:** The XYZ coordinates of the location at the base of a vector to align to. Must be specified in Global Rectangular coordinates.\n
            **vToDir:** The components of the vector to align to during merge. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type vFromBase: tuple[float]

        :type vFromDir: tuple[float]

        :type vToBase: tuple[float]

        :type vToDir: tuple[float]

        """
        ...

    def CreatePattern(self, vInitialOffset) -> Any:
        """
        **Description:**
            Merges multiple copies of the selected entities using the Pattern options specified by the SetVectorPattern or SetCSysPattern methods
        **Remarks/Usage:**
            None
        **Input:**
            **vInitialOffset:** The components of a vector used to offset the entire pattern from the merged entities location in the model being merged.\n
        **Return Code:** True\n
        :type vInitialOffset: tuple[float]

        """
        ...

    def GetEntityOptions(self, entityTYPE, nFromSetID, nToSetID, nRenumStrategy, nRenumStartAt,
                         bRenumberDuplicates) -> Any:
        """
        **Description:**
            Retrieves the status of the renumbering and duplicate options for a particular entity type.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def GetEntityStatus(self, entityTYPE, bStatus) -> Any:
        """
        **Description:**
            Retrieves the status of a entity type. The status specifies if the entity type will be merged or not into the To Model.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** Entity type to retrieve status. Use enum zDataType to select from available entity types. For entity information, see Section 3.3.6, "Entity Types".\n
        **Output:**
            **bStatus:** If True, entity type will be merged into the To Model. If False, entity type will not be merged into the To Model.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type bStatus: bool

        """
        ...

    def GetEntityTypes(self, nNumTypes, nAvailableTypes) -> Any:
        """
        **Description:**
            Returns available entity types found in the From Modelor the current model if the Copy in Current Model option is specified via SelectCurrentModel
        **Remarks/Usage:**
            If an entity type is not returned, then none of those entities exist in the From Model.
        **Output:**
            **nNumTypes:** Number of available entity types in the From Model.\n
            **nAvailableTypes:** [0.. nNumTypes -1] \n
        **Return Code:** True\n
        :type nNumTypes: int

        :type nAvailableTypes: int

        """
        ...

    def Merge(self) -> Any:
        """
        **Description:**
            Merges all of the selected entities into the current model
        **Remarks/Usage:**
            This method is used to merge entities into the current model at the same location where they exist in the selected model. Other methods allow you to specify transforms to apply during the merge.
        **Return Code:** True\n
        """
        ...

    def PointToPoint(self, vFrom, vTo) -> Any:
        """
        **Description:**
            Merges all of the selected entities into the current model and transforms them from one specified location to another
        **Remarks/Usage:**
            None
        **Input:**
            **vFrom:** The XYZ coordinates of the location at the base of a vector to move along. Must be specified in Global Rectangular coordinates.\n
            **vTo:** The XYZ coordinates of the location at the tip of a vector to move along. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type vFrom: tuple[float]

        :type vTo: tuple[float]

        """
        ...

    def Reflect(self, vAcrossBase, vAcrossDir) -> Any:
        """
        **Description:**
            Merges all of the selected entities into the current model and transforms them by reflecting across a specified plane
        **Remarks/Usage:**
            None
        **Input:**
            **vAcrossBase:** The XYZ coordinates of the location at the base of the reflection plane. Must be specified in Global Rectangular coordinates.\n
            **vAcrossDir:** The components of a vector normal to the reflection plane. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type vAcrossBase: tuple[float]

        :type vAcrossDir: tuple[float]

        """
        ...

    def RotateAroundVector(self, vAroundBase, vAroundDir, dAngle, dDistanceAlong) -> Any:
        """
        **Description:**
            Merges all of the selected entities into the current model and transforms them by rotating around and optionally moving along the specified vector
        **Remarks/Usage:**
            None
        **Input:**
            **vAroundBase:** The XYZ coordinates of the location at the base of a vector to rotate around. Must be specified in Global Rectangular coordinates.\n
            **vAroundDir:** The components of a vector to rotate around. Must be specified in Global Rectangular coordinates.\n
            **dAngle:** The angle of rotation, in degrees.\n
            **dDistanceAlong:** The total distance along the axis of rotation, typically zero.\n
        **Return Code:** True\n
        :type vAroundBase: tuple[float]

        :type vAroundDir: tuple[float]

        :type dAngle: float

        :type dDistanceAlong: float

        """
        ...

    def RotatePointToPoint(self, vAroundBase, vAroundDir, vFrom, vTo) -> Any:
        """
        **Description:**
            Merges all of the selected entities into the current model and transforms them by rotating around a specified vector from one location to another
        **Remarks/Usage:**
            None
        **Input:**
            **vAroundBase:** The XYZ coordinates of the location at the base of a vector to rotate around. Must be specified in Global Rectangular coordinates.\n
            **vAroundDir:** The components of a vector to rotate around. Must be specified in Global Rectangular coordinates.\n
            **vFrom:** The XYZ coordinates of the location to rotate/move from. Must be specified in Global Rectangular coordinates.\n
            **vTo:** The XYZ coordinates of the location to rotate/move to. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type vAroundBase: tuple[float]

        :type vAroundDir: tuple[float]

        :type vFrom: tuple[float]

        :type vTo: tuple[float]

        """
        ...

    def SelectCurrentModel(self) -> Any:
        """
        **Description:**
            Sets the Copy in Currentoption in the Merge/Extractsection of the Model Merge Manager dialog box.
        **Remarks/Usage:**
            Calling this method not only selects the model to be merged, it also scans the model and automatically sets up merging and renumbering information for the entities in the model. In many cases, if you wanted to merge this entire model, you will not need to call any further status or selection methods prior to merging.
        **Return Code:** True\n
        """
        ...

    def SelectEntity(self, bThisEntityOnly, entityTYPE, nFromSetID, bSetInCurrentModel, nRenumStrategy, nRenumStartAt,
                     bRenumberDuplicates) -> Any:
        """
        **Description:**
            Selects a Set of entities of a specified type to be merged. Also specifies the renumbering and overwriting options for that entity type.
        **Remarks/Usage:**
            Calling this method will automatically turn on the status for the specified entity type. There is no need for an additional call to SetEntityStatus.
        **Return Code:** True\n
        """
        ...

    def SelectFromGroup(self, bThisGroupOnly, bAllEntityTypes, entityTYPE, nFromGroupID, nRenumStrategy, nRenumStartAt,
                        bRenumberDuplicates) -> Any:
        """
        **Description:**
            Selects entities of one or more types that are included in a Group in the model to be merged. Also specifies the renumbering and overwriting options for those entity types.
        **Remarks/Usage:**
            Calling this method will automatically turn on the status for the specified entity types. There is no need for additional calls to SetEntityStatus.
        **Return Code:** True\n
        """
        ...

    def SelectModel(self, nModelID) -> Any:
        """
        **Description:**
            Specifies the From Modelin Merge/Extractsection of the Model Merge Managerdialog box using the ID of the model.
        **Remarks/Usage:**
            Calling this method not only selects the model to be merged, it also scans the model and automatically sets up merging and renumbering information for the entities in the model. In many cases, if you wanted to merge this entire model, you will not need to call any further status or selection methods prior to merging.
        **Input:**
            **nModelID:** The ID of the Model to be selected. \n
        **Return Code:** True\n
        :type nModelID: int

        """
        ...

    def SelectModelByName(self, fName) -> Any:
        """
        **Description:**
            Specifies the From Modelin Merge/Extractsection of the Model Merge Managerdialog box using the full name or partial name of the model.
        **Remarks/Usage:**
            Calling this method not only selects the model to be merged, it also scans the model and automatically sets up merging and renumbering information for the entities in the model. In many cases, if you wanted to merge this entire model, you will not need to call any further status or selection methods prior to merging.
        **Input:**
            **fName:** The name of the Model to be selected. To work properly under all conditions, this string should contain the full pathname to the model file. For example, C:\MyModels\MyModel.modfem. If you specify a string that is less than the full path name the model will still be selected as long as only one open model matches the string that you specify. Unsaved models can be selected by specifying an empty string, but again, only if there is only one model that is unsaved.\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def SetAllStatus(self, bStatus) -> Any:
        """
        **Description:**
            For the all entity types sets the option to merge or not merge the type
        **Remarks/Usage:**
            Normally this method is used to turn off merging of all entity types prior to selecting a few individual entity types to be merged. Since the status of most entity types is automatically set to True when a model is selected, it is often not necessary to call this method.
        **Input:**
            **bStatus:** If True, all available entity types will be merged. If False, no types will be merged.\n
        **Return Code:** True\n
        :type bStatus: bool

        """
        ...

    def SetCSysPattern(self, nPatternDirection, bOn, nNumberInPattern, dSpacing, nCSysID) -> Any:
        """
        **Description:**
            Specifies if pattern direction 1, 2, and/or 3, should be used when creating a pattern, as well as how many repetitions, spacing between duplicates, and coordinate system used to define pattern directions.
        **Remarks/Usage:**
            Once all the desired pattern directions and options have been specified, use CreatePattern to create duplicates in the specified pattern.
        **Input:**
            **nPatternDirection:** Pattern Direction:\n
            **bOn:** When True, the pattern direction specified with nPatternDirection will be used when creating a pattern. When False, the pattern direction specified will not be considered\n
            **nNumberInPattern:** Number of repetitions to make in the direction specified in nPatternDirection\n
            **dSpacing:** The distance between each duplicate created in the direction specified by nPatternDirection. The coordinate system axes are always considered as unit vectors so unlike the SetVectorPattern method, dSpacing is always the total distance between instances.\n
            **nCSysID:** Coordinate System used to define the 3 pattern directions.\n
        **Return Code:** True\n
        :type nPatternDirection: int

        :type bOn: bool

        :type nNumberInPattern: int

        :type dSpacing: float

        :type nCSysID: int

        """
        ...

    def SetEntityStatus(self, entityTYPE, bStatus) -> Any:
        """
        **Description:**
            For the specified entity type, sets the option to merge or ignore the type
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** Entity type to set status. Use enum zDataType to select from available entity types. For entity information, see Section 3.3.6, "Entity Types".\n
            **bStatus:** If True, the selected entity type will be merged. If False, that type will not be merged.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type bStatus: bool

        """
        ...

    def SetStatus(self, bGeometry, bModel, bConnection, bAeroElasticity, bAnalysisAndSimulation, bResults,
                  bOthers) -> Any:
        """
        **Description:**
            For categories of entity types sets the option to merge or ignore the type
        **Remarks/Usage:**
            None
        **Input:**
            **bGeometry:** If True, geometry types will be merged. This includes: Points, Curves, Surfaces, Solids and Mesh Points \n
            **bModel:** If True, model types will be merged. This includes: Coordinate Systems, Nodes, Elements, Materials, Properties, Layups, Global Plies, Load Sets, Constraint Sets, Functions, Tables and Data Surfaces\n
            **bConnection:** If True, connection types will be merged. This includes: Connection Properties, Regions and Connections\n
            **bAeroElasticity:** If True, aeroelasticity types will be merged. This includes: Aero Panels, Properties, Splines and Surfaces\n
            **bResults:** If True, analysis result types will be merged. This includes: Analysis Studies and Result Sets\n
            **bOthers:** If True, all other types will be merged. This includes: Text, Groups, Layers, Views and more.\n
        **Return Code:** True\n
        :type bGeometry: bool

        :type bModel: bool

        :type bConnection: bool

        :type bAeroElasticity: bool

        :type bResults: bool

        :type bOthers: bool

        """
        ...

    def SetVectorPattern(self, nPatternDirection, bOn, nNumberInPattern, dSpacing, vdirection) -> Any:
        """
        **Description:**
            Specifies if pattern direction 1, 2, and/or 3 should be used when creating a pattern, as well as how many repetitions, spacing between duplicates, and direction vector for each pattern direction.
        **Remarks/Usage:**
            Once all the desired pattern directions and options have been specified, use CreatePattern to create duplicates in the specified pattern.
        **Input:**
            **nPatternDirection:** Pattern Direction. 0 = Direction 1, 1 = Direction 2, 2 = Direction 3\n
            **bOn:** When True, the pattern direction specified with nPatternDirection will be used when creating a pattern. When False, the pattern direction specified will not be considered\n
            **nNumberInPattern:** Number of repetitions to make in the direction specified in nPatternDirection\n
            **dSpacing:** The distance between each duplicate created in the direction specified by nPatternDirection. The total distance between each instance in the pattern is the product of dSpacing and the magnitude of vDirection. dSpacing is only the actual distance if vDirection is specified as a unit vector.\n
            **vdirection:** The XYZ components of the vector to create copies along the direction specified in nPatternDirection. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type nPatternDirection: int

        :type bOn: bool

        :type nNumberInPattern: int

        :type dSpacing: float

        :type vdirection: tuple[float]

        """
        ...

    def ShowDialog(self) -> Any:
        """
        **Description:**
            Displays the same dialog used by the File, Mergecommand
        **Remarks/Usage:**
            You can use this method to display the dialog at any time. Any selections or changes to options that you do prior to calling this method will be shown in the dialog when it is displayed, and changes in the dialog will reflect in the object if you press OK.
        **Return Code:** True\n
        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            Clears everything in the MergeTool object.
        **Remarks/Usage:**
            Use to clear all values in the MergeTool object specified by the MergeTool Object Properties and MergeTool Object Options Methods. It may be a good idea to use this method to purge the object so no unwanted options are used, especially if performing a different Orientation/Transformoperation (i.e. a Copy after using Rotate or setting a different pattern). Calling this method also clears the selected model to be merged. You will have to reselect a model prior to calling Merge again.
        **Return Code:** False\n
        """
        ...


class PublishTable:
    CLSID: Any

    def AddColumn(self, sColumnTitle, nAlign, dWidth) -> Any:
        """
        **Description:**
            Adds an empty column to the table
        **Remarks/Usage:**
            The column ID returned by this method must be used when adding text/values to the column
        **Input:**
            **sColumnTitle:** A title to add to the column header\n
            **nAlign:** Alignment of text in the column 0=Left, 1=Right, 2=Center\n
            **dWidth:** Width of the column in inches. Specify as 0.0 for default width.\n
        **Return Code:** False\n
        :type sColumnTitle: str

        :type nAlign: int

        :type dWidth: float

        """
        ...

    def AddColumnGroupTitle(self, nStartColumn, nEndColumn, sColumnGroupTitle) -> Any:
        """
        **Description:**
            Adds a second title above a contiguous range of columns
        **Remarks/Usage:**
            This method adds a joined group title above all of the selected columns. This creates a second row of headers above the column titles. It is not possible to create additional rows of headers nor to add multiple group titles to the same column. Columns must be added prior to calling this method.
        **Input:**
            **nStartColumn:** The ID of the column where the Group Title starts\n
            **nEndColumn:** The ID of the column where the Group Title ends\n
            **sColumnGroupTitle:** The title to add above the headers of the selected columns\n
        **Return Code:** False\n
        :type nStartColumn: int

        :type nEndColumn: int

        :type sColumnGroupTitle: str

        """
        ...

    def AddRowNumbering(self, nFirstRowNumber) -> Any:
        """
        **Description:**
            Adds row numbers as a left side header in the table
        **Remarks/Usage:**
            Defining Row Numbering using this method does not change the way rows must be referenced by the other methods of this object. Actual row numbers always start at 0 and increase by 1. This method simply defines the values that are shown in the left side header.
        **Input:**
            **nFirstRowNumber:** The number used for the first row of the table. Typically, this would be either 0 or 1, however you may specify any positive value. Successive rows increment this number by 1. Specifying a negative value turns off row numbering.\n
        **Return Code:** False\n
        :type nFirstRowNumber: int

        """
        ...

    def Publish(self) -> Any:
        """
        **Description:**
            Adds the contents of the current table into the associated PublishTool object
        **Remarks/Usage:**
            This method must be called after the entire contents of the table have been defined. The contents of the table are inserted into the object as it is called just like the various "Add" methods in the PublishTool object.
        **Return Code:** False\n
        """
        ...

    def SetCellInteger(self, nRow, nColumn, nValue) -> Any:
        """
        **Description:**
            Adds an integer value to a cell
        **Remarks/Usage:**
            Only a single real, integer or text value can be assigned to a table cell.
        **Input:**
            **nRow:** The ID of the row to be updated. The first body row of the table is nRow=0\n
            **nColumn:** The ID of the column to be updated. This value is the return code from the AddColumn() method. However, just like rows, the first body column of the table is nColumn=0\n
            **nValue:** An integer value to assign to the specified cell\n
        **Return Code:** False\n
        :type nRow: int

        :type nColumn: int

        :type nValue: int

        """
        ...

    def SetCellReal(self, nRow, nColumn, dValue) -> Any:
        """
        **Description:**
            Adds a real number value to a cell
        **Remarks/Usage:**
            The format of the values shown in cells defined by this method is controlled by the SetRealFormat( ) method. Only a single real, integer or text value can be assigned to a table cell.
        **Input:**
            **nRow:** The ID of the row to be updated. The first body row of the table is nRow=0\n
            **nColumn:** The ID of the column to be updated. This value is the return code from the AddColumn() method. However, just like rows, the first body column of the table is nColumn=0\n
            **dValue:** A real number value to assign to the specified cell\n
        **Return Code:** False\n
        :type nRow: int

        :type nColumn: int

        :type dValue: float

        """
        ...

    def SetCellStyle(self, nRow, nColumn, nStyle) -> Any:
        """
        **Description:**
            Selects a style to apply to a table cell
        **Remarks/Usage:**
            This method merely defines potential styles to cells, the style is not applied until the table is published. Styles selected by this method override the header and body styles selected by SetTableStyle().
        **Input:**
            **nRow:** The ID of the row to be updated. The first body row of the table is nRow=0\n
            **nColumn:** The ID of the column to be updated. This value is the return code from the AddColumn() method. However, just like rows, the first body column of the table is nColumn=0\n
            **nStyle:** The ID of a style that is defined in the PublishTool object that is used for the selected cell.\n
        **Return Code:** False\n
        :type nRow: int

        :type nColumn: int

        :type nStyle: int

        """
        ...

    def SetCellText(self, nRow, nColumn, sText) -> Any:
        """
        **Description:**
            Adds a text string to a cell
        **Remarks/Usage:**
            Only a single real, integer or text value can be assigned to a table cell. If more are required, you must format them as a string and use this method to apply them to the cell.
        **Input:**
            **nRow:** The ID of the row to be updated. The first body row of the table is nRow=0\n
            **nColumn:** The ID of the column to be updated. This value is the return code from the AddColumn() method. However, just like rows, the first body column of the table is nColumn=0\n
            **sText:** A text string to assign to the specified cell\n
        **Return Code:** False\n
        :type nRow: int

        :type nColumn: int

        :type sText: str

        """
        ...

    def SetMultiCellInteger(self, nCount, vRow, vColumn, vvalue) -> Any:
        """
        **Description:**
            Adds integer values to multiple table cells
        **Remarks/Usage:**
            This method operates just like calling SetCellInteger( vRow(i), vColumn(i), vValue(i) ) multiple times.
        **Input:**
            **nCount:** The number of entries in the vRow, vColumn and vValue arrays\n
            **vRow:** The IDs of the rows to be updated. The first body row of the table is nRow=0\n
            **vColumn:** The IDs of the columns to be updated. This value is the return code from the AddColumn() method. However, just like rows, the first body column of the table is nColumn=0\n
            **vvalue:** The values to add to the specified cells.\n
        **Return Code:** False\n
        :type nCount: int

        :type vRow: tuple[int]

        :type vColumn: tuple[int]

        :type vvalue: tuple[int]

        """
        ...

    def SetMultiCellReal(self, nCount, vRow, vColumn, vvalue) -> Any:
        """
        **Description:**
            Adds real number values to multiple table cells
        **Remarks/Usage:**
            This method operates just like calling SetCelReal( vRow(i), vColumn(i), vValue(i) ) multiple times.
        **Input:**
            **nCount:** The number of entries in the vRow, vColumn and vValue arrays\n
            **vRow:** The IDs of the rows to be updated. The first body row of the table is nRow=0\n
            **vColumn:** The IDs of the columns to be updated. This value is the return code from the AddColumn() method. However, just like rows, the first body column of the table is nColumn=0\n
            **vvalue:** The values to add to the specified cells.\n
        **Return Code:** False\n
        :type nCount: int

        :type vRow: tuple[int]

        :type vColumn: tuple[int]

        :type vvalue: tuple[int]

        """
        ...

    def SetMultiCellStyle(self, nCount, vRow, vColumn, vStyle) -> Any:
        """
        **Description:**
            Selects a style to apply to multiple table cells
        **Remarks/Usage:**
            This method operates just like calling SetCellStyle( vRow(i), vColumn(i), vStyle(i) ) multiple times.
        **Input:**
            **nCount:** The number of entries in the vRow, vColumn and vStyle arrays\n
            **vRow:** The IDs of the rows to be updated. The first body row of the table is nRow=0\n
            **vColumn:** The IDs of the columns to be updated. This value is the return code from the AddColumn() method. However, just like rows, the first body column of the table is nColumn=0\n
            **vStyle:** The IDs of styles that are defined in the PublishTool object that is used for the selected cell.\n
        **Return Code:** False\n
        :type nCount: int

        :type vRow: tuple[int]

        :type vColumn: tuple[int]

        :type vStyle: tuple[int]

        """
        ...

    def SetMultiCellText(self, nCount, vRow, vColumn, vText) -> Any:
        """
        **Description:**
            Adds text values to multiple table cells
        **Remarks/Usage:**
            This method operates just like calling SetCellText( vRow(i), vColumn(i), vText(i) ) multiple times.
        **Input:**
            **nCount:** The number of entries in the vRow, vColumn and vText arrays\n
            **vRow:** The IDs of the rows to be updated. The first body row of the table is nRow=0\n
            **vColumn:** The IDs of the columns to be updated. This value is the return code from the AddColumn() method. However, just like rows, the first body column of the table is nColumn=0\n
            **vText:** The text to add to the specified cells.\n
        **Return Code:** False\n
        :type nCount: int

        :type vRow: tuple[int]

        :type vColumn: tuple[int]

        :type vText: tuple[int]

        """
        ...

    def SetRealFormat(self, nWidth, nPrecision) -> Any:
        """
        **Description:**
            Specifies how real numbers are formatted when added to the cells of the table
        **Remarks/Usage:**
            In the user interface, values shown in dialog boxes typically use a format similar to
        **Input:**
            **nWidth:** The number of characters to use in writing the value\n
            **nPrecision:** The number of digits beyond the decimal point when writing the value\n
        **Return Code:** False\n
        :type nWidth: int

        :type nPrecision: int

        """
        ...

    def SetRowTitle(self, nRow, sRowTitle) -> Any:
        """
        **Description:**
            Adds a string as a left side header for a particular row in the table
        **Remarks/Usage:**
            AddRowNumbering( ) is an alternative to this method that can be used if you simply want row numbers in the left side header.
        **Input:**
            **nRow:** The row of the table where the left side header is being defined. The first row in the table is always row 0\n
            **sRowTitle:** Title of the row header\n
        **Return Code:** False\n
        :type nRow: int

        :type sRowTitle: str

        """
        ...

    def SetTableStyle(self, nHeaderStyle, nBodyStyle) -> Any:
        """
        **Description:**
            Specifies the styles used by the header and body sections of the table
        **Remarks/Usage:**
            The styles specified must be defined using the AddStyle( ) method of the associated PublishTool object. These styles are generally applied, but can be overridden for specific cells using the SetCellStyle( ) method.
        **Input:**
            **nHeaderStyle:** The ID of a style that is defined in the PublishTool object that is used for both the top and left side header of the table\n
            **nBodyStyle:** The ID of a style that is defined in the PublishTool object that is used for the body portion of the table\n
        **Return Code:** False\n
        :type nHeaderStyle: int

        :type nBodyStyle: int

        """
        ...


class PublishTool:
    CLSID: Any

    def AddChart(self, nSizePct) -> Any:
        """
        **Description:**
            Adds an image of the current Charting Pane
        **Remarks/Usage:**
            The active alignments, left indent and spacing are applied to the image as it is added.
        **Input:**
            **nSizePct:** A scale factor that can be applied to the natural size of the image. If specified as 0 (or 100) the image will not be scaled.\n
        **Return Code:** False\n
        :type nSizePct: int

        """
        ...

    def AddDataTable(self, bCopyAllRows, bCopyHeader, bCopyFooter, nNumColumns, sColumnTitles) -> Any:
        """
        **Description:**
            Adds a copy of the current Data Table
        **Remarks/Usage:**
            The active alignments, left indent and spacing are applied to the data table as it is added.
        **Input:**
            **bCopyAllRows:** If True, all rows in the Data Table will be copied. If False, only selected rows will be copied.\n
            **bCopyHeader:** If True, any Data Table Column or Table header rows will be included\n
            **bCopyFooter:** If True, any Data Table Footer rows will be included\n
            **nNumColumns:** If 0, all Columns will be included. If >0, this is the number of titles included in sColumnTItles\n
        **Return Code:** False\n
        :type bCopyAllRows: bool

        :type bCopyHeader: bool

        :type bCopyFooter: bool

        :type nNumColumns: int

        """
        ...

    def AddEntityEditor(self) -> Any:
        """
        **Description:**
            Adds a copy of the current Entity Editor
        **Remarks/Usage:**
            The active alignments, left indent and spacing are applied to the image as it is added.
        **Return Code:** False\n
        """
        ...

    def AddFunctionTableEditor(self, bCopyHeader) -> Any:
        """
        **Description:**
            Adds a copy of the current Function/Table Editor
        **Remarks/Usage:**
            The active alignments, left indent and spacing are applied to the function or table as it is added.
        **Input:**
            **bCopyHeader:** If True, any Column or Table header rows will be included\n
        **Return Code:** False\n
        :type bCopyHeader: bool

        """
        ...

    def AddMessages(self, nFirstLine, nLastLine) -> Any:
        """
        **Description:**
            Adds selected text from the Message Window
        **Remarks/Usage:**
            The active alignments, left indent and spacing are applied to the image as it is added.
        **Return Code:** False\n
        """
        ...

    def AddParagraph(self, sText, nStyle) -> Any:
        """
        **Description:**
            Adds a paragraph of text to the Publish Tool
        **Remarks/Usage:**
            The active alignments, indents and spacing are applied to the paragraph as it is added.
        **Input:**
            **sText:** The text of the paragraph\n
            **nStyle:** The style to be applied to the paragraph. This is the value returned by the AddStyle( ) method. Specify as 0 to use the default style.\n
        **Return Code:** False\n
        :type sText: str

        :type nStyle: int

        """
        ...

    def AddPicture(self, sFilename, nFormat, nSizePct) -> Any:
        """
        **Description:**
            Adds an image from a file
        **Remarks/Usage:**
            The active alignments, left indent and spacing are applied to the image as it is added.
        **Input:**
            **sFilename:** The full pathname to the image file to be included.\n
            **nFormat:** 0=Bitmap, 1=JPEG, 2=PNG, 3=GIF, 4=TIFF \n
            **nSizePct:** A scale factor that can be applied to the natural size of the image. If specified as 0 (or 100) the image will not be scaled.\n
        **Return Code:** False\n
        :type sFilename: str

        :type nFormat: int

        :type nSizePct: int

        """
        ...

    def AddStyle(self, sFontName, nFontSize, nColor, nHighlightColor, bBold, bItalic, bUnderline,
                 bPreserveFormatting) -> Any:
        """
        **Description:**
            Defines a style that can then be applied to text that is added to the Tool
        **Remarks/Usage:**
            This method does not activate a style, it merely defines it. The "Style ID" that is returned is then used as text is defined to apply the style to the text.
        **Input:**
            **sFontName:** The name of a font to be used for text. This must match the name of an existing Font. Alternatively, this can be a blank string if you want to continue to use the current font.\n
            **nFontSize:** The size of the font to be used in points (1/72 inch). Specify as 0 to use the size of the current font\n
            **nColor:** The color of text\n
            **nHighlightColor:** The background color of text\n
            **bItalic:** Text will be italic if True\n
        **Return Code:** False\n
        :type sFontName: str

        :type nFontSize: int

        :type nColor: int

        :type nHighlightColor: int

        :type bItalic: bool

        """
        ...

    def AddView(self, nVuID, nSizePct) -> Any:
        """
        **Description:**
            Adds an image created from a View stored in the current model
        **Remarks/Usage:**
            The active alignments, left indent and spacing are applied to the image as it is added.
        **Input:**
            **nVuID:** The ID of the View to be used to create the image\n
            **nSizePct:** A scale factor that can be applied to the natural size of the image. If specified as 0 (or 100) the image will not be scaled.\n
        **Return Code:** False\n
        :type nVuID: int

        :type nSizePct: int

        """
        ...

    def PublishToClipboard(self) -> Any:
        """
        **Description:**
            Publishes the contents of the current object to the Clipboard for pasting to other applications
        **Remarks/Usage:**

        **Return Code:** False\n
        """
        ...

    def PublishToFile(self, sFilename) -> Any:
        """
        **Description:**
            Publishes the contents of the current object to a specified file
        **Remarks/Usage:**
            For easiest access later, the file extension of the specified file should match the normal usage for the publishing format. For example, .html for HTML format or .rtf for RTF format.
        **Input:**
            **sFilename:** The name of the file to contain the published data.\n
        **Return Code:** False\n
        :type sFilename: str

        """
        ...

    def SetFormat(self, nFormat) -> Any:
        """
        **Description:**
            Specifies the format of data to be published to the Clipboard or to a File
        **Remarks/Usage:**

        **Input:**
            **nFormat:** The format to publish (0=RTF, 1=HTML)\n
        **Return Code:** False\n
        :type nFormat: int

        """
        ...

    def SetParagraphAlignment(self, nAlign) -> Any:
        """
        **Description:**
            Specifies how paragraphs and other objects will be aligned as they are added to the Tool
        **Remarks/Usage:**
            This method can be called as many times as necessary, but must be called prior to adding the data that is supposed to be aligned. Default alignment is Left.
        **Input:**
            **nAlign:** 0=Left, 1=Right, 2=Center\n
        **Return Code:** False\n
        :type nAlign: int

        """
        ...

    def SetParagraphIndent(self, nLeftIndent, nRightIndent, nFirstLineIndent) -> Any:
        """
        **Description:**
            Specifies how paragraphs and other objects will be indented as they are added to the Tool
        **Remarks/Usage:**
            This method can be called as many times as necessary, but must be called prior to adding the data that is supposed to be indented.
        **Input:**
            **nLeftIndent:** The space between the margin and left side of a paragraph, image or table. This is specified in points (1/72 inch)\n
            **nRightIndent:** The space between the margin and right side of a paragraph. This is specified in points (1/72 inch)\n
            **nFirstLineIndent:** Additional space between the indented left side of the paragraph and the beginning of the first line. That is, the first line is indented by nLeftIndent+nFirstLineIndent. This is specified in points (1/72 inch)\n
        **Return Code:** False\n
        :type nLeftIndent: int

        :type nRightIndent: int

        :type nFirstLineIndent: int

        """
        ...

    def SetParagraphSpacing(self, nSpaceAbove, nSpaceBelow) -> Any:
        """
        **Description:**
            Specifies how space will be added above and below paragraphs and other objects as they are added to the Tool
        **Remarks/Usage:**
            This method can be called as many times as necessary, but must be called prior to adding the data that will have spacing above or below.
        **Input:**
            **nSpaceAbove:** The space above the top of a paragraph, image or table. This is specified in points (1/72 inch)\n
            **nSpaceBelow:** The space below the bottom of a paragraph, image or table. This is specified in points (1/72 inch)\n
        **Return Code:** False\n
        :type nSpaceAbove: int

        :type nSpaceBelow: int

        """
        ...

    def UserTable(self) -> Any:
        """
        **Description:**
            Creates and returns a PublishTable object
        **Remarks/Usage:**
            Refer to the documentation of the PublishTable object to configure and publish the table
        **Return Code:** False\n
        """
        ...

    def clear(self) -> Any:
        """
        **Description:**
            Clears everything in the PublishTool object
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...


class AnalysisStep:
    CLSID: Any
    Active: Any
    ContactOption: Any
    ContactSetType: Any
    CornerOutput: Any
    Destination: Any
    Echo: Any
    EndText: Any
    GlobalStepID: Any
    ID: Any
    Imaginary: Any
    IntegrationOutput: Any
    InternalStepID: Any
    NasCurvatureStrain: Any
    NasInlStepOptADJUST: Any
    NasInlStepOptCREEP: Any
    NasInlStepOptCTRLDEF: Any
    NasInlStepOptConvA: Any
    NasInlStepOptConvN: Any
    NasInlStepOptConvP: Any
    NasInlStepOptConvU: Any
    NasInlStepOptConvV: Any
    NasInlStepOptConvW: Any
    NasInlStepOptDAMP: Any
    NasInlStepOptDTINITF: Any
    NasInlStepOptDTINITFA: Any
    NasInlStepOptDTMAXF: Any
    NasInlStepOptDTMINF: Any
    NasInlStepOptEPSP: Any
    NasInlStepOptEPSU: Any
    NasInlStepOptEPSW: Any
    NasInlStepOptEnableCriteria: Any
    NasInlStepOptFSTRESS: Any
    NasInlStepOptGroupIDs: Any
    NasInlStepOptID: Any
    NasInlStepOptIDAMP: Any
    NasInlStepOptINTOUT: Any
    NasInlStepOptIPHYS: Any
    NasInlStepOptIncrements: Any
    NasInlStepOptKMETHOD: Any
    NasInlStepOptKSTEP: Any
    NasInlStepOptLIMTAR: Any
    NasInlStepOptLSTOL: Any
    NasInlStepOptLoadStepping: Any
    NasInlStepOptMAXALR: Any
    NasInlStepOptMAXBIS: Any
    NasInlStepOptMAXITER: Any
    NasInlStepOptMAXLS: Any
    NasInlStepOptMAXQN: Any
    NasInlStepOptMECH: Any
    NasInlStepOptMINALR: Any
    NasInlStepOptMINITER: Any
    NasInlStepOptMRCONV: Any
    NasInlStepOptMSTEP: Any
    NasInlStepOptMT1_i: Any
    NasInlStepOptMT2_i: Any
    NasInlStepOptMT3_i: Any
    NasInlStepOptMT4_i: Any
    NasInlStepOptNDESIR: Any
    NasInlStepOptNDESIRA: Any
    NasInlStepOptNINC: Any
    NasInlStepOptNO: Any
    NasInlStepOptNSMAX: Any
    NasInlStepOptNSMAXA: Any
    NasInlStepOptOn: Any
    NasInlStepOptRB: Any
    NasInlStepOptRBIG: Any
    NasInlStepOptRSMALL: Any
    NasInlStepOptSCALEA: Any
    NasInlStepOptSFACT: Any
    NasInlStepOptSkipNLSTEP: Any
    NasInlStepOptTOTTIM: Any
    NasInlStepOptTYPE: Any
    NasInlStepOptUTOL: Any
    NasInlStepOptYT1_i: Any
    NasInlStepOptYT2_i: Any
    NasInlStepOptYT3_i: Any
    NasInlStepOptYT4_i: Any
    NasModeDampOverall: Any
    NasModeDesiredRoots: Any
    NasModeEigrSet: Any
    NasModeEstRoots: Any
    NasModeMassForm: Any
    NasModeMethod: Any
    NasModeNormDOF: Any
    NasModeNormNode: Any
    NasModeNormOpt: Any
    NasModeOn: Any
    NasModeSolutionType: Any
    NasModesComplexConverge: Any
    NasModesComplexRegionWidth: Any
    NasModesSkipEigr: Any
    NasOmodes: Any
    NasOmodesOn: Any
    NasStepAlternateTextLocation: Any
    SetID: Any
    SkipStandard: Any
    StartText: Any
    StepAnalysisType: Any
    StepID: Any
    StepLabel: Any
    StepTitle: Any
    UseGlobalStep: Any
    caseID: Any
    vBCSet: Any
    vNasModeFreqRange: Any
    vNasModeImagFreqRange: Any
    vOutput: Any

    def ActiveContactEntities(self, bContact, nConnectorSetID, nRegionSetID, nConPropSetID) -> Any:
        """
        **Description:**
            This method is used to populate Set Objects with the Connectors, Connection Regions, and Connection Properties that will be exported for Contact or Glue Contact by an analysis step. This method takes into consideration the settings in the Contact Sets or Glue Sets section of the Boundary Conditions dialog box for Simcenter SOL 401/402 or setting for Contact/Glue Sets of the Boundary Conditions dialog box for MSC Nastran
        **Remarks/Usage:**
            It is important to use three uniques Set Objects when using this method, otherwise the IDs of different entity types may contaminate a Set. Also, it is recommend to use empty sets to insure that only the Connection entities from a single analysis step populate the three sets.
        **Input:**
            **bContact:** If True, populates sets with connection entities for Contact. If False, populates sets with connection entities for Glued Contact\n
            **nConnectorSetID:** Set ID of Set Object to populate with Connectors which will be exported by this analysis step\n
            **nRegionSetID:** Set ID of Set Object to populate with Connection Regions which will be exported by this analysis step\n
            **nConPropSetID:** Set ID of Set Object to populate with Connection Properties which will be exported by this analysis step\n
        **Return Code:** False\n
        :type bContact: bool

        :type nConnectorSetID: int

        :type nRegionSetID: int

        :type nConPropSetID: int

        """
        ...

    def BCSet(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteAnalysisStep(self, nSetID, nCaseID, nStepID) -> Any:
        """
        **Description:**
            Use this method to delete an analysis step.
        **Remarks/Usage:**
            This method takes care of deleting any start/end text or Marc contact table records that referenced the case.
        **Input:**
            **nSetID:** The Analysis Set ID (SetID) containing the case to be deleted\n
            **nCaseID:** The Analysis Case ID (CaseID) containing the step to be initialized\n
            **nStepID:** The Analysis Step ID (StepID) to be deleted\n
        **Return Code:** False\n
        :type nSetID: int

        :type nCaseID: int

        :type nStepID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def InitAnalysisStep(self, nSetID, nCaseID, nStepID) -> Any:
        """
        **Description:**
            This method initializes the default values for an analysis step
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** The Analysis Set ID (SetID) containing the case to be initialized\n
            **nCaseID:** The Analysis Case ID (CaseID) containing the step to be initialized\n
            **nStepID:** The Analysis Step ID (StepID) to be initialized\n
        **Return Code:** False\n
        :type nSetID: int

        :type nCaseID: int

        :type nStepID: int

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def Output(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetBCSet(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetOutput(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...


class GlobalStep:
    CLSID: Any
    Active: Any
    ContactOption: Any
    ContactSetType: Any
    CornerOutput: Any
    Destination: Any
    Echo: Any
    EndText: Any
    GlobalStepAnalysisType: Any
    GlobalStepID: Any
    GlobalStepLabel: Any
    GlobalStepTitle: Any
    ID: Any
    Imaginary: Any
    IntegrationOutput: Any
    NasCurvatureStrain: Any
    NasGlobalAlternateTextLocation: Any
    NasInlStepOptADJUST: Any
    NasInlStepOptCREEP: Any
    NasInlStepOptCTRLDEF: Any
    NasInlStepOptConvA: Any
    NasInlStepOptConvN: Any
    NasInlStepOptConvP: Any
    NasInlStepOptConvU: Any
    NasInlStepOptConvV: Any
    NasInlStepOptConvW: Any
    NasInlStepOptDAMP: Any
    NasInlStepOptDTINITF: Any
    NasInlStepOptDTINITFA: Any
    NasInlStepOptDTMAXF: Any
    NasInlStepOptDTMINF: Any
    NasInlStepOptEPSP: Any
    NasInlStepOptEPSU: Any
    NasInlStepOptEPSW: Any
    NasInlStepOptEnableCriteria: Any
    NasInlStepOptFSTRESS: Any
    NasInlStepOptGroupIDs: Any
    NasInlStepOptID: Any
    NasInlStepOptIDAMP: Any
    NasInlStepOptINTOUT: Any
    NasInlStepOptIPHYS: Any
    NasInlStepOptIncrements: Any
    NasInlStepOptKMETHOD: Any
    NasInlStepOptKSTEP: Any
    NasInlStepOptLIMTAR: Any
    NasInlStepOptLSTOL: Any
    NasInlStepOptLoadStepping: Any
    NasInlStepOptMAXALR: Any
    NasInlStepOptMAXBIS: Any
    NasInlStepOptMAXITER: Any
    NasInlStepOptMAXLS: Any
    NasInlStepOptMAXQN: Any
    NasInlStepOptMECH: Any
    NasInlStepOptMINALR: Any
    NasInlStepOptMINITER: Any
    NasInlStepOptMRCONV: Any
    NasInlStepOptMSTEP: Any
    NasInlStepOptMT1_i: Any
    NasInlStepOptMT2_i: Any
    NasInlStepOptMT3_i: Any
    NasInlStepOptMT4_i: Any
    NasInlStepOptNDESIR: Any
    NasInlStepOptNDESIRA: Any
    NasInlStepOptNINC: Any
    NasInlStepOptNO: Any
    NasInlStepOptNSMAX: Any
    NasInlStepOptNSMAXA: Any
    NasInlStepOptOn: Any
    NasInlStepOptRB: Any
    NasInlStepOptRBIG: Any
    NasInlStepOptRSMALL: Any
    NasInlStepOptSCALEA: Any
    NasInlStepOptSFACT: Any
    NasInlStepOptSkipNLSTEP: Any
    NasInlStepOptTOTTIM: Any
    NasInlStepOptTYPE: Any
    NasInlStepOptUTOL: Any
    NasInlStepOptYT1_i: Any
    NasInlStepOptYT2_i: Any
    NasInlStepOptYT3_i: Any
    NasInlStepOptYT4_i: Any
    NasModeDampOverall: Any
    NasModeDesiredRoots: Any
    NasModeEigrSet: Any
    NasModeEstRoots: Any
    NasModeMassForm: Any
    NasModeMethod: Any
    NasModeNormDOF: Any
    NasModeNormNode: Any
    NasModeNormOpt: Any
    NasModeOn: Any
    NasModeSolutionType: Any
    NasModesComplexConverge: Any
    NasModesComplexRegionWidth: Any
    NasModesSkipEigr: Any
    NasOmodes: Any
    NasOmodesOn: Any
    SetID: Any
    SkipStandard: Any
    StartText: Any
    vBCSet: Any
    vNasModeFreqRange: Any
    vNasModeImagFreqRange: Any
    vOutput: Any

    def ActiveContactEntities(self, bContact, nConnectorSetID, nRegionSetID, nConPropSetID) -> Any:
        """
        **Description:**
            This method is used to populate Set Objects with the Connectors, Connection Regions, and Connection Properties that will be exported for Contact or Glue Contact by an analysis step which references this global step. This method takes into consideration the settings in the Contact Sets or Glue Sets section of the Boundary Conditions dialog box for Simcenter SOL 401/402 or setting for Contact/Glue Sets of the Boundary Conditions dialog box for MSC Nastran.
        **Remarks/Usage:**
            It is important to use three uniques Set Objects when using this method, otherwise the IDs of different entity types may contaminate a Set. Also, it is recommend to use empty sets to insure that only the Connection entities from a single analysis step which references this global step populate the three sets.
        **Input:**
            **bContact:** If True, populates sets with connection entities for Contact. If False, populates sets with connection entities for Glued Contact\n
            **nConnectorSetID:** Set ID of Set Object to populate with Connectors which will be exported by this analysis step which references this global step\n
            **nRegionSetID:** Set ID of Set Object to populate with Connection Regions which will be exported by this analysis step which references this global step\n
            **nConPropSetID:** Set ID of Set Object to populate with Connection Properties which will be exported by this analysis step which references this global step\n
        **Return Code:** False\n
        :type bContact: bool

        :type nConnectorSetID: int

        :type nRegionSetID: int

        :type nConPropSetID: int

        """
        ...

    def BCSet(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteGlobalStep(self, nSetID, nCaseID) -> Any:
        """
        **Description:**
            Use this method to delete a global step.
        **Remarks/Usage:**

        **Input:**
            **nSetID:** The Global Step to be deleted\n
        **Return Code:** False\n
        :type nSetID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def InitGlobalStep(self, nSetID, nCaseID) -> Any:
        """
        **Description:**
            This method initializes the default values for a global step
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** The Global Step to be initialized\n
        **Return Code:** False\n
        :type nSetID: int

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def Output(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetBCSet(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetOutput(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...


class BodyMesher:
    CLSID: Any
    AssociateAngle: Any
    AssociateAngleOn: Any
    AssociateTo: Any
    CompatibilityRefinement: Any
    CurvatureAlignment: Any
    CurvatureRefinement: Any
    CurvatureRefinementLimit: Any
    CurvatureRefinementMaxPoints: Any
    EnhancedQualityMesh: Any
    FacetAngleError: Any
    FacetChordError: Any
    FacetCurveFactor: Any
    FacetDistanceError: Any
    FacetMaxSize: Any
    FeatureEdgeBreakAngle: Any
    GrowthFactor: Any
    GrowthFactorOn: Any
    KeepMeshOnFreeEdges: Any
    MergeNodes: Any
    MeshType: Any
    MidsideNodes: Any
    MinQuality: Any
    MinQualityOn: Any
    MinSizeFactor: Any
    MinSizeFactorOn: Any
    PointsAroundCircle: Any
    PointsAroundCircleOn: Any
    ProximityDirection: Any
    ProximityDistance: Any
    ProximityDistanceOn: Any
    ProximityElemAcross: Any
    ProximityElemAcrossOn: Any
    ProximityRefinement: Any
    RetainAssociativity: Any
    RetainColor: Any
    RetainCornerThickness: Any
    RetainElemType: Any
    RetainLayer: Any
    RetainNormalDirection: Any
    RetainOffset: Any
    RetainProperty: Any
    TargetSize: Any
    TetAllowVoids: Any
    TetGrowthRatio: Any
    TetMultipleThruThickness: Any
    TetMultipleThruThicknessOn: Any
    TetOptimizationLevel: Any
    TetSliverRemoval: Any
    UseCurveSizing: Any
    UseFaceter: Any
    UseSurfaceSizing: Any

    def Associate(self, nAssociateTo, nExtraCurveSetID, nExtraSurfaceSetID, bAssociateAngleOn, dAssociateAngle) -> Any:
        """
        **Description:**
            Single method to set properties on the object to set Mesh Associativity parameters and add extra geometry to be retained
        **Remarks/Usage:**
            None
        **Input:**
            **nAssociateTo:** Sets the level of automatic mesh associativity to be retained. 0=All Geometry, 1=Required Geometry Only, 2=Retain additional geometry selected by nExtraCurveSetID and/or nExtraSurfaceSetID\n
            **nExtraCurveSetID:** The ID of a Set object containing the IDs of additional Curves to be retained in the final mesh when nAssoicateTo is set to a value of 2. Use 0 for None.\n
            **nExtraSurfaceSetID:** The ID of a Set object containing the IDs of additional Surfaces to be retained in the final mesh when nAssoicateTo is set to a value of 2. Use 0 for None.\n
            **bAssociateAngleOn:** If True, select extra geometry to retain by the angle between surfaces adjacent to curves\n
        **Return Code:** True\n
        :type nAssociateTo: int

        :type nExtraCurveSetID: int

        :type nExtraSurfaceSetID: int

        :type bAssociateAngleOn: bool

        """
        ...

    def CalculateDefaultMeshSize(self, enDataType, nSolidOrElemSet, dSize) -> Any:
        """
        **Description:**
            Find the default mesh size that is used to initialize the target mesh size
        **Remarks/Usage:**
            Calling this method will return the default target size and will also update the target size in the object.
        **Input:**
            **enDataType:** Either FT_ELEM or FT_SOLID\n
            **nSolidOrElemSet:** The ID of a Set object containing the IDs of Solids (can include Sheet Solids and/or General Bodies) or Elements to be used to compute the target size. \n
        **Output:**
            **dSize:** The computed target size for meshing\n
        **Return Code:** True\n
        :type enDataType: Any

        :type nSolidOrElemSet: int

        :type dSize: float

        """
        ...

    def Dialog(self, bMeshingSolids, nSolidOrElemSet) -> Any:
        """
        **Description:**
            Displays the dialog box shown in the Mesh, Bodies and Mesh, Mesh on Mesh commands to collect parameter settings
        **Remarks/Usage:**
            The entities specified in nSolidOrElemSet are not remeshed or added to the object in this method, they are simply used to properly initialize the dialog box.
        **Input:**
            **bMeshingSolids:** If True displays the dialog box used by the Mesh, Bodies command. If False, displays the dialog box used by the Mesh, Mesh on Mesh command.\n
            **nSolidOrElemSet:** The ID of a Set object containing the IDs of Solids (can include Sheet Solids and General Bodies as well) or Elements to be meshed. Alternatively, if you specify a negative value, it is simply the ID of the single entity to mesh.\n
        **Return Code:** True\n
        :type bMeshingSolids: bool

        :type nSolidOrElemSet: int

        """
        ...

    def MeshBodies(self, nSolidSet, enElemShape, nPropID, nZeroAttrPropID) -> Any:
        """
        **Description:**
            Mesh Solids, Sheet Solids, and/or General Bodies with the selected parameters
        **Remarks/Usage:**
            Calls the Mesh, Bodies command programmatically using the Object Properties currently specified
        **Input:**
            **nSolidSet:** The ID of a Set object containing the IDs of Solids (can include Sheet Solids and General Bodies as well) to be meshed. Alternatively, if you specify a negative value, it is simply the ID of the single entity to mesh. \n
            **enElemShape:** The type of mesh to create. This can be FTO_TRIA3 (2), FTO_TRIA6 (3), FTO_QUAD4 (4), FTO_QUAD8 (5), FTO_TETRA4 (6), or FTO_TETRA10 (10).\n
            **nPropID:** The ID of an existing Property to apply to the mesh elements. Specify nPropID=0 to use the Meshing Attributes that have been previously applied to the geometry.\n
        **Return Code:** True\n
        :type nSolidSet: int

        :type enElemShape: Any

        :type nPropID: int

        """
        ...

    def MeshOnMesh(self, nElemSet, enElemShape) -> Any:
        """
        **Description:**
            Remesh Elements with the selected parameters
        **Remarks/Usage:**
            Calls the Mesh, Mesh on Mesh command programmatically using the Object Properties currently
        **Input:**
            **nElemSet:** The ID of a Set object containing the IDs of Elements to be remeshed. Alternatively, if you specify a negative value, it is simply the ID of the single entity to remesh.\n
            **enElemShape:** The type of mesh to create. This can be FTO_TRIA3 (2), FTO_TRIA6 (3), FTO_QUAD4 (4), or FTO_QUAD8 (5).\n
        **Return Code:** True\n
        :type nElemSet: int

        :type enElemShape: Any

        """
        ...

    def SetSizeOnCurves(self, nCurveSet, dSize) -> Any:
        """
        **Description:**
            Sets mesh sizing on selected curves
        **Remarks/Usage:**
            This method is equivalent to calling the feMeshSizeCurve method with no biasing or other options. Mesh size along curves are only used if UseCurveSizing is set to True and the curves are retained in the final mesh.
        **Input:**
            **nCurveSet:** The ID of a Set object containing the IDs of Curves to set sizing. Alternatively, if you specify a negative value, it is simply the ID of the single curve to be set.\n
            **dSize:** The nominal element size along the curves\n
        **Return Code:** True\n
        :type nCurveSet: int

        :type dSize: float

        """
        ...

    def SetSizeOnSurfaces(self, nSurfaceSet, dSize) -> Any:
        """
        **Description:**
            Sets mesh sizing on selected surfaces
        **Remarks/Usage:**
            This method is equivalent to calling the feMeshSizeSurface method with no options other than sizing. Mesh sizes on surfaces are only used if UseSurfaceSizing is True and the surfaces are retained in the final mesh.
        **Input:**
            **nSurfaceSet:** The ID of a Set object containing the IDs of Surfaces to set sizing. Alternatively, if you specify a negative value, it is simply the ID of the single surface to be set.\n
            **dSize:** The nominal element size along the curves of the surfaces.\n
        **Return Code:** True\n
        :type nSurfaceSet: int

        :type dSize: float

        """
        ...

    def Size(self, dTargetSize, dMinSizeFactor, dGrowthFactor, nPointsAroundCircle) -> Any:
        """
        **Description:**
            Single method to set multiple properties on the object to set mesh sizing parameters
        **Remarks/Usage:**
            None
        **Input:**
            **dTargetSize:** Sets value for TargetSize property on the object\n
            **dMinSizeFactor:** Sets the MinSizeFactorOn and MinSizeFactor properties on the object. If dMinSizeFactor=0.0, then MinSizeFactorOn = False\n
            **dGrowthFactor:** Sets the GrowthFactorOn and GrowthFactor properties on the object. If dGrowthFactor = 0.0, GrowthFactorOn = False\n
            **nPointsAroundCircle:** Sets the PointsAroundCircleOn and PointsAroundCircle properties on the object. If nPointsAroundCircle < 3, PointsAroundCircleOn = False\n
        **Return Code:** True\n
        :type dTargetSize: float

        :type dMinSizeFactor: float

        :type dGrowthFactor: float

        :type nPointsAroundCircle: int

        """
        ...

    def UseSizing(self, bUseCurveSizing, bUseSurfaceSizing) -> Any:
        """
        **Description:**
            Single method to set multiple properties on the object in the On Associated Geometry parameters
        **Remarks/Usage:**
            None
        **Input:**
            **bUseCurveSizing:** Sets the UseCurveSizing property on the object\n
            **bUseSurfaceSizing:** Sets the UseSurfaceSizing property on the object\n
        **Return Code:** False\n
        :type bUseCurveSizing: bool

        :type bUseSurfaceSizing: bool

        """
        ...

    def clear(self, bClearAll) -> Any:
        """
        **Description:**
            Reset the contents of the BodyMesher object.
        **Remarks/Usage:**
            Setting Clear (FALSE) allows the object to be reused for multiple meshes without resetting all of the parameters.
        **Input:**
            **bClearAll:** If True, resets all parameters and mesh contents in the BodyMesher object back to their default/empty state. If False, only the mesh contents are cleared.\n
        **Return Code:** False\n
        :type bClearAll: bool

        """
        ...


class DesignEquation:
    CLSID: Any
    Active: Any
    ID: Any
    SetID: Any
    title: Any

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class Joint:
    CLSID: Any
    Active: Any
    B1R: Any
    B1RTID: Any
    B1T: Any
    B1TTID: Any
    CF: Any
    CID1: Any
    CID2: Any
    CurveExpansionOpt: Any
    ElemExpansionOpt: Any
    FR0: Any
    G1: Any
    G2: Any
    G3: Any
    HasCID1: Any
    HasCID2: Any
    HasDAM1ROT: Any
    HasDAM1TRA: Any
    HasG3: Any
    HasSPR1ROT: Any
    HasSPR1TRA: Any
    HasTarget1List: Any
    HasTarget2List: Any
    ID: Any
    JointBehavior: Any
    JointLoc1_x: Any
    JointLoc1_y: Any
    JointLoc1_z: Any
    JointLoc2_x: Any
    JointLoc2_y: Any
    JointLoc2_z: Any
    K1R: Any
    K1RTID: Any
    K1T: Any
    K1TTID: Any
    KCF: Any
    KR: Any
    KT: Any
    LIBL: Any
    LR: Any
    LX: Any
    LY: Any
    LZ: Any
    NasExpansionOpt: Any
    OPT: Any
    PITCH: Any
    RegularizationOpt: Any
    SB1RTID: Any
    SB1TTID: Any
    SK1RTID: Any
    SK1TTID: Any
    SetID: Any
    SurfExpansionOpt: Any
    Target1SetID: Any
    Target1Type: Any
    Target2SetID: Any
    Target2Type: Any
    color: Any
    layer: Any
    pid: Any
    title: Any
    tol: Any
    type: Any
    vJointLoc1: Any
    vJointLoc2: Any

    def ClearMotionSet(self) -> Any:
        """
        **Description:**
            This method clears the array that contains the IDs of the Entities used by Motion Attachment
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def ClearReferenceSet(self) -> Any:
        """
        **Description:**
            This method clears the array that contains the IDs of the Entities used by Reference Attachment for Joint Connections
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetMotionSet(self, pMotionSet) -> Any:
        """
        **Description:**
            This method loads a Set object that contains the IDs of the Entities in the Entity List used for Motion Attachment for Joint Connections
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def GetReferenceSet(self, pReferenceSet) -> Any:
        """
        **Description:**
            This method loads a Set object that contains the IDs of the Entities in the Entity List used for Reference Attachment for Joint Connections
        **Remarks/Usage:**
            None
        **Output:**
            **pReferenceSet:** Set Object containing the IDs of the entities\n
        **Return Code:** False\n
        :type pReferenceSet: Any

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def JointLoc1(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def JointLoc2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def PutMotionSet(self, pMotionSet) -> Any:
        """
        **Description:**
            This method loads Entity IDs into the Entity List for Motion Attachment for Joint Connections
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def PutReferenceSet(self, pReferenceSet) -> Any:
        """
        **Description:**
            This method loads Entity IDs into the Entity List for Reference Attachment for Joint Connections
        **Remarks/Usage:**
            None
        **Input:**
            **pReferenceSet:** Set Object containing the IDs of the entities\n
        **Return Code:** False\n
        :type pReferenceSet: Any

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SetJointLoc1(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetJointLoc2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...


class FlexibleSlider:
    CLSID: Any
    Active: Any
    HasElemList: Any
    HasNodeList: Any
    ID: Any
    NasBGRPID: Any
    NasCF: Any
    NasDGID: Any
    NasDTID: Any
    NasDTYPE: Any
    NasDVAL: Any
    NasFOP: Any
    NasHasNLIM: Any
    NasKCF: Any
    NasNGRPID: Any
    NasNLIM: Any
    NasPROJ: Any
    NasSGID: Any
    NasTOL: Any
    NasTYPE: Any
    NodeSetID: Any
    SetID: Any
    color: Any
    elemSetID: Any
    layer: Any
    title: Any

    def ClearComponentSet(self, entityTYPE) -> Any:
        """
        **Description:**
            This method clears the array that contains the array that contains the IDs of the Nodes in the Node List used for Displacement Entities or IDs of the Elements in the Element List used for Slider Trajectory
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def CountSet(self) -> Any:
        """
        **Description:**
            Returns the number of entities in the database of the current type
        **Remarks/Usage:**
            This function only counts entities that are in the set specified by the SetID entity property. For most entities (Curves, Surfaces, Nodes, Elements, ...) this counts all entities in the model. For other set-based entities - like Loads and Constraints - it only counts the entities in the one set, so you must specify which set you want prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def Deletable(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if an entity can be deleted.
        **Remarks/Usage:**
            Entities are deletable only if there are no other entities in the model that require them to exist. For example, nodes cannot be deleted until after all elements that reference them have been deleted.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def Delete(self, nID) -> Any:
        """
        **Description:**
            This method deletes an entity from the model database.
        **Remarks/Usage:**
            Entities are not deletable if there are other entities in the FEMAP model that require them to exist. Certain objects, like LoadSet and BCSet objects, will also automatically delete all of the other entities that they contain if you delete them. For example, if you delete a LoadSet, all of the individual loads on nodes, elements or geometry in that set will also be deleted.
        **Input:**
            **nID:** The ID of the entity to delete. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def DeleteLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method deletes an entity from the selected index of the specified library file.
        **Remarks/Usage:**
            You must use this method with caution. There is no option to allow the user to confirm the deletion and no option to undo the operation. Once entities are deleted from a library, they cannot be recovered.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to delete.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Exist(self, nID) -> Any:
        """
        **Description:**
            This method checks to see if a specified entity currently exists.
        **Remarks/Usage:**
            This method does not load any data. It simply returns FE_OK if the entity exists, and FE_FAIL if it does not.
        **Input:**
            **nID:** The ID of the entity to check. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type nID: int

        """
        ...

    def First(self) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Next.
        **Return Code:** True\n
        """
        ...

    def FirstInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method loads the first (with the lowest ID) available entity that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by NextInSet()
        **Input:**
            **nSetID:** The ID of the set that contains the entities that you want to iterate through.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def Get(self, entID) -> Any:
        """
        **Description:**
            This method retrieves an entity from your model database with the specified ID.
        **Remarks/Usage:**
            This method retrieves the data for the selected entity and updates the ID property.
        **Input:**
            **entID:** ID of the entity to retrieve. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def GetComponentSet(self, entityTYPE, pSelectedComponentSet) -> Any:
        """
        **Description:**
            This method loads a Set object that contains the IDs of the Nodes in the Node List used for Displacement Entities or IDs of the Elements in the Element List used for Slider Trajectory
        **Remarks/Usage:**
            None
        **Output:**
            **pSelectedComponentSet:** Set Object containing the IDs of the entities\n
        **Return Code:** True\n
        :type pSelectedComponentSet: Any

        """
        ...

    def GetLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method retrieves an entity from the associated library.
        **Remarks/Usage:**
            When using this method with a Material object, you must set the Active Material Type using App.Info_ActiveType (FT_MATL) = Type of Material to Get from Library before calling the GetLibrary method. To avoid setting the Active Material Type, use the GetLibraryOfType method on the Material Object.
        **Input:**
            **libINDEX:** The index of the entity stored in the library. The first entity stored is libINDEX = 0, the second has libINDEX = 1, and so on. If you specify libINDEX = -1, a dialog box will be displayed showing all entities in the library, and will allow the user to select the entity to load.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def GetTitleIDList(self, bIncludeID, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is somewhat different than the other entity methods. It does not really operate on, or tell about the current entity. It simply uses it to select the type of entity that you are interested in, and to choose the setID of interest for certain entity types - like output objects.
        **Input:**
            **bIncludeID:** If True, the titles are in the form ID..title (for example, 1..Steel. If False, only the title, without the ID or separator is returned.\n
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type bIncludeID: bool

        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def GetTitleList(self, minID, maxID, Count, listID, listTITLE) -> Any:
        """
        **Description:**
            This method retrieves two arrays which contain the IDs and titles of all entities (in the selected ID range) with the same type as the current object.
        **Remarks/Usage:**
            This method is identical to calling GetTitleIDList( False, ....). See that method for more information.
        **Input:**
            **minID, maxID:** The minimum and maximum entity IDs to retrieve. You can set minID=maxID=0 to retrieve all available entities.\n
        **Output:**
            **Count:** The number of entities retrieved. This is the number of entries in listID and listTITLE.\n
            **listID:** The IDs of the available entities.\n
            **listTITLE:** The titles of the available entities. If the entity does not have a title, the string Untitled will be returned.\n
        **Return Code:** True\n
        :type minID: int

        :type maxID: int

        :type Count: int

        :type listID: tuple[int]

        :type listTITLE: tuple[str]

        """
        ...

    def Last(self) -> Any:
        """
        **Description:**
            This method loads the last (with the highest ID) available entity.
        **Remarks/Usage:**
            Calling this method is like calling Reset, followed by Prev.
        **Return Code:** True\n
        """
        ...

    def Next(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is greater than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def NextEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a higher ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def NextEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def NextExistingInSet(self, nSetID) -> Any:
        """
        :type nSetID: Any
        """
        ...

    def NextID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a higher ID.
        **Remarks/Usage:**
            This method is the same as Next, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def NextInSet(self, nSetID) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a larger ID that is referenced in the Set.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity that is in the specified Set object that has an ID that is greater than the current ID, and calls the Get method with that ID. So, to start at the beginning of the Set, first call the Reset() method on the current entity (not on the Set), or call FirstInSet()
        **Input:**
            **nSetID:** The ID of a Set object that contains the IDs of the entities that you want to iterate through. \n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def NextSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the next set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a higher ID.
        **Return Code:** True\n
        """
        ...

    def ParseTitleID(self, sTitleIDStr) -> Any:
        """
        **Description:**
            Returns the ID from a string that was formatted by GetTitleIDList in the form ID..title
        **Remarks/Usage:**
            None
        **Input:**
            **sTitleIDStr:** This must be a string in the format ID..title\n
        **Return Code:** True\n
        :type sTitleIDStr: str

        """
        ...

    def Prev(self) -> Any:
        """
        **Description:**
            This method retrieves the next available entity with a smaller ID.
        **Remarks/Usage:**
            Calling this method simply finds the next available entity with an ID that is smaller than the current ID, and calls the Get method with that ID.
        **Return Code:** True\n
        """
        ...

    def PrevEmptyID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next nonexisting entity with a lower ID.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def PrevEmptySet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set of this entity type that is empty.
        **Remarks/Usage:**
            If no more empty sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def PrevID(self) -> Any:
        """
        **Description:**
            This method finds the ID of the next available entity with a lower ID.
        **Remarks/Usage:**
            This method is the same as Prev, except that it does not update the current ID, nor does it load the data for the entity.
        **Return Code:** True\n
        """
        ...

    def PrevSet(self) -> Any:
        """
        **Description:**
            This method updates the setID to be the previous set that contains entities of this type.
        **Remarks/Usage:**
            If no more sets are found, setID remains unchanged. This method finds the next set with a lower ID.
        **Return Code:** True\n
        """
        ...

    def Put(self, entID) -> Any:
        """
        **Description:**
            This method stores an entity in the model database with the specified ID.
        **Remarks/Usage:**
            All of the data that has been currently loaded/updated is stored as the entity with the specified ID. The ID where you store the data does not have to be the same as the ID that you used in a previous Get. For example, calling Get(3), then Put(6), creates a new entity with an ID of 6 that is a copy of entity 3.
        **Input:**
            **entID:** The ID of the entity to store. If you specify id=0, then the current value of the ID property will be used instead.\n
        **Return Code:** True\n
        :type entID: int

        """
        ...

    def PutComponentSet(self, entityTYPE, pSelectedComponentSet) -> Any:
        """
        **Description:**
            This method loads Node IDs into the Node List for Displacement Entities or Element IDs into the Element List for Slider Trajectory
        **Remarks/Usage:**
            None
        **Input:**
            **pSelectedComponentSet:** Set Object containing the IDs of the entities\n
        **Return Code:** True\n
        :type pSelectedComponentSet: Any

        """
        ...

    def PutLibrary(self, libINDEX, libFILE) -> Any:
        """
        **Description:**
            This method stores an entity in the selected index of the specified library file.
        **Remarks/Usage:**
            For most entity types, the current data that you have loaded into the object can be stored directly to the library. There is no need to necessarily store it in the model database. For several entity types, such as functions and analysis sets, the object must first be stored in the database. For these entities, it is actually the data from the database that is written to the library, not the data in the current object. The ID of the current object must identify the database entity that you want written in the library.
        **Input:**
            **libINDEX:** If libINDEX = -1 (actually just < 0 ), the entity will be added to the end of the library. If a library does not exist, a new library will be created. If libINDEX = 0, the entity will be inserted as the first entry in the library. Also, if no library currently exists or the library is empty creates a new library. If libINDEX > 0, the entity is inserted before the libINDEX'th entry in the existing library.\n
        **Return Code:** True\n
        :type libINDEX: int

        """
        ...

    def Reset(self) -> Any:
        """
        **Description:**
            This method resets the Nextpointer so that the next call to Next will return the first (lowest ID) entity.
        **Remarks/Usage:**
            After calling Reset, Next will return the first entity and Prev will return the last (highest ID) entity.
        **Return Code:** False\n
        """
        ...

    def SelectID(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity.
        **Remarks/Usage:**
            This function displays one of two different dialog boxes, depending on the entity type that you choose. For entities that have titles, like properties or materials, the dialog box will contain a list of the available entities along with their titles. For other entities, like nodes or elements, a simple dialog box is displayed so that the ID can be typed or picked.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...

    def SelectIDWithNew(self, sTitle) -> Any:
        """
        **Description:**
            This function displays a selection dialog box (including the ability for the user to create a new entity from within the dialog, when applicable) to allow a user to choose a single entity of a specific type. The selected entity is automatically loaded into the calling entity
        **Remarks/Usage:**
            For supported entities, this method is identical to the SelectID method with the exceptions of a new entity icon being displayed in the dialog and the dialog will be displayed even if no entities of the specified type exist the database.
        **Input:**
            **sTitle:** A text string that will be added to the title bar of the dialog box to give the user more information about what is being selected.\n
        **Return Code:** True\n
        :type sTitle: str

        """
        ...


class model:
    CLSID: Any
    ConfigurationPath: Any
    CoordDialogMethod: Any
    DialogAutoAnswer: Any
    DialogAutoSkip: Any
    DialogAutoSkipMsg: Any
    ErrorHasBeenCalled: Any
    EventLParam: Any
    ExePath: Any
    FullScratchName: Any
    Info_CommandNumber: Any
    Info_ComplexSyncIncrement: Any
    Info_ComplexSyncMethod: Any
    Info_ComplexSyncPhase: Any
    Info_DefaultX: Any
    Info_DefaultY: Any
    Info_DefaultZ: Any
    Info_FacetAngleTolerance: Any
    Info_FacetChordTolerance: Any
    Info_FacetCurveFactor: Any
    Info_FreebodyReverse: Any
    Info_GeometryScale: Any
    Info_GroupAutomaticAdd: Any
    Info_LayerNoPick: Any
    Info_LineLength: Any
    Info_MatlAngle: Any
    Info_MatlAngleCSys: Any
    Info_MatlAngleDir: Any
    Info_MatlAngleMethod: Any
    Info_MatlUserType: Any
    Info_MeshSizeAutoDefault: Any
    Info_MeshSizeDefault: Any
    Info_MeshSizeMinElem: Any
    Info_MeshSizePropagation_EdgeOption: Any
    Info_MeshSizePropagation_On: Any
    Info_MeshSizePropagation_SameSolid: Any
    Info_MeshSizePropagation_SelMode: Any
    Info_MeshSizePropagation_SlavedMapped: Any
    Info_MeshSizePropagation_Tolerance: Any
    Info_MeshSizePropagation_UseTolerance: Any
    Info_ModelNeedBox: Any
    Info_NodeType: Any
    Info_OrientQuad4ForceOutput: Any
    Info_OrientQuad4StrainOutput: Any
    Info_OrientQuad4StressOutput: Any
    Info_OrientQuad8ForceOutput: Any
    Info_OrientQuad8StrainOutput: Any
    Info_OrientQuad8StressOutput: Any
    Info_OrientSolidAnisoOutput: Any
    Info_OrientSolidHyperOutput: Any
    Info_OrientSolidIsoOutput: Any
    Info_OrientTria3ForceOutput: Any
    Info_OrientTria3StrainOutput: Any
    Info_OrientTria3StressOutput: Any
    Info_OrientTria6ForceOutput: Any
    Info_OrientTria6StrainOutput: Any
    Info_OrientTria6StressOutput: Any
    Info_OutputCSys: Any
    Info_SnapCoordOnly: Any
    Info_SnapFullPrecision: Any
    Info_SnapSpacingMode: Any
    Info_SnapStyle: Any
    Info_SnapTo: Any
    Info_SplineOrder: Any
    Info_SuperelementID: Any
    Info_SuppressedCurveColor: Any
    Info_SuppressedSurfaceColor: Any
    Info_TextBorderColor: Any
    Info_TranslateNotes: Any
    Info_UpdateAllViews: Any
    Info_Version: Any
    Info_ViewShowAutoscale: Any
    Info_ViewShowColor: Any
    Info_ViewShowEntity: Any
    Info_ViewShowErase: Any
    Info_ViewShowLabel: Any
    Info_ViewShowNormal: Any
    Info_ViewShowTransparent: Any
    Info_ViewShowUseColor: Any
    Info_WorkplaneLabels: Any
    Info_WorkplaneModelAdjust: Any
    Info_WorkplaneOnSurface: Any
    Info_WorkplaneOnSurfacePrev: Any
    Info_WorkplaneSurfaceAdjust: Any
    Info_WorkplaneTics: Any
    InitializationPath: Any
    List_Destination: Any
    List_FileName: Any
    ModelFromPreviousVersion: Any
    ModelMigratedFromDB: Any
    ModelMigratedFromVersion: Any
    ModelName: Any
    PgSetup_BottomMargin: Any
    PgSetup_CustomHeight: Any
    PgSetup_CustomWidth: Any
    PgSetup_DefaultHdrFont: Any
    PgSetup_DefaultTextFont: Any
    PgSetup_FillMargins: Any
    PgSetup_Footer: Any
    PgSetup_HdrFont: Any
    PgSetup_HdrFontSize: Any
    PgSetup_Header: Any
    PgSetup_HorzAlign: Any
    PgSetup_IntegerScaling: Any
    PgSetup_LeftMargin: Any
    PgSetup_MaintainAspect: Any
    PgSetup_Monochrome: Any
    PgSetup_PenScale: Any
    PgSetup_PrintBorder: Any
    PgSetup_RenderScale: Any
    PgSetup_RightMargin: Any
    PgSetup_SwapBW: Any
    PgSetup_TextFont: Any
    PgSetup_TextFontSize: Any
    PgSetup_TopMargin: Any
    PgSetup_TransparentBkgd: Any
    PgSetup_VertAlign: Any
    PickBoundaryInternalMode: Any
    PickCombinedCurveInternalMode: Any
    PickVisibleOnly: Any
    PlaneDialogMethod: Any
    Pref_API_HonorWorkingDirectory: Any
    Pref_API_UseAlternateFileDialog: Any
    Pref_API_WarningInDialog: Any
    Pref_API_WarningLevel: Any
    Pref_Abaqus_PreserveCompressedLoads: Any
    Pref_AdjMidsideGeomLoad: Any
    Pref_AltAccelerator: Any
    Pref_AltSectionProp: Any
    Pref_AltTheme: Any
    Pref_AnalysisMonAutoLoad: Any
    Pref_AnalysisMonMaxLines: Any
    Pref_AnalysisProg: Any
    Pref_AnalysisType: Any
    Pref_AnimatePanes: Any
    Pref_AnimationFormat: Any
    Pref_AspectRatio: Any
    Pref_AssumeEngrStrain: Any
    Pref_AttachResultsDebug: Any
    Pref_AttachResultsTiming: Any
    Pref_AutoAttachResults: Any
    Pref_AutoConvertOdb: Any
    Pref_AutomaticTitles: Any
    Pref_BackupModel: Any
    Pref_CleanupModel: Any
    Pref_CompressBitmaps: Any
    Pref_ComputeAverageMidResults: Any
    Pref_ComputePrincipal: Any
    Pref_ConfirmDelete: Any
    Pref_ConstructionGeometry: Any
    Pref_CreateResultStudy: Any
    Pref_CustomToolsPath: Any
    Pref_DATASURF_TriMapHBSizeFactor: Any
    Pref_DATASURF_TriMapLayerExtent: Any
    Pref_DATASURF_TriMapTolerance: Any
    Pref_DBCacheBlocksPerPage: Any
    Pref_DBCacheMaxLabel: Any
    Pref_DBCacheMaxMemoryPct: Any
    Pref_DBLowDiskWarning: Any
    Pref_DBScratch: Any
    Pref_DBUndoLevels: Any
    Pref_DL_DecimalSeparator: Any
    Pref_DL_DigitGroupFlag: Any
    Pref_DL_DigitGroupOption: Any
    Pref_DL_DigitGroupSeparator: Any
    Pref_DL_ExponentChar: Any
    Pref_DL_ForcePlusSign: Any
    Pref_DL_ForceSingleZero: Any
    Pref_DL_NegativeBraces: Any
    Pref_DL_TrailingZeros: Any
    Pref_DL_UseIntlAll: Any
    Pref_DO_BaseExponent: Any
    Pref_DO_BeforeDecimalSeparator: Any
    Pref_DO_DecimalPlaces: Any
    Pref_DO_Exponent: Any
    Pref_DO_ExponentDigits: Any
    Pref_DO_LeadingZeros: Any
    Pref_DO_MaxDigits: Any
    Pref_DO_MinimumExponentSize: Any
    Pref_DO_Option: Any
    Pref_DO_OriginalDigits: Any
    Pref_DO_RoundToZero: Any
    Pref_DO_RoundToZeroValue: Any
    Pref_DO_SigFigs: Any
    Pref_DO_TrailingZeros: Any
    Pref_DefContourPalette: Any
    Pref_DefaultFreebodyReverse: Any
    Pref_DeleteRdScratchLdSets: Any
    Pref_DeleteScratchFile: Any
    Pref_DeltaAngle: Any
    Pref_ElemQualAltTaper: Any
    Pref_ElemQualAltTaperVal: Any
    Pref_ElemQualAspectRatio: Any
    Pref_ElemQualAspectRatioVal: Any
    Pref_ElemQualCombined: Any
    Pref_ElemQualCombinedVal: Any
    Pref_ElemQualExplicitTime: Any
    Pref_ElemQualExplicitTimeVal: Any
    Pref_ElemQualHexAspectRatio: Any
    Pref_ElemQualHexAspectRatioVal: Any
    Pref_ElemQualHexDetJ: Any
    Pref_ElemQualHexDetJVal: Any
    Pref_ElemQualHexEPIA: Any
    Pref_ElemQualHexEPIAVal: Any
    Pref_ElemQualHexEPLR: Any
    Pref_ElemQualHexEPLRVal: Any
    Pref_ElemQualHexWarp: Any
    Pref_ElemQualHexWarpVal: Any
    Pref_ElemQualIntAngles: Any
    Pref_ElemQualIntAnglesVal: Any
    Pref_ElemQualJacobian: Any
    Pref_ElemQualJacobianVal: Any
    Pref_ElemQualNastranWarping: Any
    Pref_ElemQualNastranWarpingVal: Any
    Pref_ElemQualPenAspectRatio: Any
    Pref_ElemQualPenAspectRatioVal: Any
    Pref_ElemQualPenDetJ: Any
    Pref_ElemQualPenDetJVal: Any
    Pref_ElemQualPenEPIA: Any
    Pref_ElemQualPenEPIAVal: Any
    Pref_ElemQualPenEPLR: Any
    Pref_ElemQualPenEPLRVal: Any
    Pref_ElemQualPenWarp: Any
    Pref_ElemQualPenWarpVal: Any
    Pref_ElemQualPyrAspectRatio: Any
    Pref_ElemQualPyrAspectRatioVal: Any
    Pref_ElemQualPyrDetJ: Any
    Pref_ElemQualPyrDetJVal: Any
    Pref_ElemQualPyrEPIA: Any
    Pref_ElemQualPyrEPIAVal: Any
    Pref_ElemQualPyrEPLR: Any
    Pref_ElemQualPyrEPLRVal: Any
    Pref_ElemQualPyrWarp: Any
    Pref_ElemQualPyrWarpVal: Any
    Pref_ElemQualQuadAR: Any
    Pref_ElemQualQuadARVal: Any
    Pref_ElemQualQuadIAMax: Any
    Pref_ElemQualQuadIAMaxVal: Any
    Pref_ElemQualQuadIAMin: Any
    Pref_ElemQualQuadIAMinVal: Any
    Pref_ElemQualQuadSkew: Any
    Pref_ElemQualQuadSkewVal: Any
    Pref_ElemQualQuadTaper: Any
    Pref_ElemQualQuadTaperVal: Any
    Pref_ElemQualQuadWarp: Any
    Pref_ElemQualQuadWarpVal: Any
    Pref_ElemQualSkew: Any
    Pref_ElemQualSkewVal: Any
    Pref_ElemQualTaper: Any
    Pref_ElemQualTaperVal: Any
    Pref_ElemQualTetAspectRatio: Any
    Pref_ElemQualTetAspectRatioVal: Any
    Pref_ElemQualTetCollapse: Any
    Pref_ElemQualTetCollapseVal: Any
    Pref_ElemQualTetDetJ: Any
    Pref_ElemQualTetDetJVal: Any
    Pref_ElemQualTetEPIA: Any
    Pref_ElemQualTetEPIAVal: Any
    Pref_ElemQualTetEPLR: Any
    Pref_ElemQualTetEPLRVal: Any
    Pref_ElemQualTriaAR: Any
    Pref_ElemQualTriaARVal: Any
    Pref_ElemQualTriaEPLR: Any
    Pref_ElemQualTriaEPLRVal: Any
    Pref_ElemQualTriaIAMax: Any
    Pref_ElemQualTriaIAMaxVal: Any
    Pref_ElemQualTriaSkew: Any
    Pref_ElemQualTriaSkewVal: Any
    Pref_ElemQualWarping: Any
    Pref_ElemQualWarpingVal: Any
    Pref_EnableLegacyAnsysInterface: Any
    Pref_Enable_Aeroelasticity: Any
    Pref_FBDefDispMode: Any
    Pref_FastHoleMeshing: Any
    Pref_FastOutputDelete: Any
    Pref_FastTriMesh: Any
    Pref_FileRefCheck: Any
    Pref_FileRefGeometry: Any
    Pref_FileRefModel: Any
    Pref_FileRefResults: Any
    Pref_Filter_ABAQUS: Any
    Pref_Filter_ANSYS: Any
    Pref_Filter_Analysis: Any
    Pref_Filter_Autodesk_Nastran: Any
    Pref_Filter_DYNA: Any
    Pref_Filter_MARC: Any
    Pref_Filter_MSC_Nastran: Any
    Pref_Filter_SC_Nastran_ADVNL: Any
    Pref_Filter_SC_Nastran_ADVNLE: Any
    Pref_Filter_SC_Nastran_Linear: Any
    Pref_Filter_SC_Nastran_MSNL: Any
    Pref_Filter_SC_Nastran_MSNLK: Any
    Pref_Filter_SINDA: Any
    Pref_GIFAnimationDelay: Any
    Pref_GIFColorOpt: Any
    Pref_GIFFrameSeries: Any
    Pref_GIFOptimized: Any
    Pref_GeomEngine: Any
    Pref_GeomLoadEdgeFactor: Any
    Pref_GeomLoadQuadFactor: Any
    Pref_GeomLoadTriFactor: Any
    Pref_GeomLogFile: Any
    Pref_GeomOptimize: Any
    Pref_GeomScaleAdjust: Any
    Pref_GeometryBooleanTolerance: Any
    Pref_GeometryScale: Any
    Pref_GlobalLanguage: Any
    Pref_GlobalUIScaling: Any
    Pref_GraphicsFont: Any
    Pref_GraphicsFontSize: Any
    Pref_GroupIncludeFiles: Any
    Pref_ImproveSinglePrecision: Any
    Pref_InterfaceStyle: Any
    Pref_JTFileVersion: Any
    Pref_KeepSolverWindow: Any
    Pref_LegacyXYPlotting: Any
    Pref_LengthBasedMeshSize: Any
    Pref_LibAnalysis: Any
    Pref_LibChart: Any
    Pref_LibConnectionProp: Any
    Pref_LibContPal: Any
    Pref_LibFunction: Any
    Pref_LibLayup: Any
    Pref_LibMatl: Any
    Pref_LibMatlDef: Any
    Pref_LibPalette: Any
    Pref_LibProp: Any
    Pref_LibReport: Any
    Pref_LibView: Any
    Pref_LibViewNumber: Any
    Pref_ListingFont: Any
    Pref_LoadModifyRotate: Any
    Pref_MemoryMappedFiles: Any
    Pref_MeshInMemory: Any
    Pref_MessageFont: Any
    Pref_MetafileToClip: Any
    Pref_MiddleMouseButtonOK: Any
    Pref_MinimizeDuringSolve: Any
    Pref_ModelInfoMaxEntity: Any
    Pref_ModelThumbnail: Any
    Pref_ModelTooltip: Any
    Pref_MsgWndBackColor: Any
    Pref_MsgWndCmdBold: Any
    Pref_MsgWndCmdColor: Any
    Pref_MsgWndErrorBold: Any
    Pref_MsgWndErrorColor: Any
    Pref_MsgWndFont: Any
    Pref_MsgWndFontSize: Any
    Pref_MsgWndHighBold: Any
    Pref_MsgWndHighColor: Any
    Pref_MsgWndRepeatedErrors: Any
    Pref_MsgWndTextBold: Any
    Pref_MsgWndTextColor: Any
    Pref_MsgWndWarnBold: Any
    Pref_MsgWndWarnColor: Any
    Pref_NXNastEntLicenseServer: Any
    Pref_NasAlternateContinue: Any
    Pref_NasDballScratch: Any
    Pref_NasResTrackRevsion: Any
    Pref_NastranMemory: Any
    Pref_NastranOutputPath: Any
    Pref_NastranOutputTo: Any
    Pref_NastranScratchLocation: Any
    Pref_NastranWriteAllLdbcSets: Any
    Pref_NetKeyDir: Any
    Pref_NeutralDigits: Any
    Pref_NeutralVersion: Any
    Pref_NewPick: Any
    Pref_NonmanifoldBooleans: Any
    Pref_OnlineHelp_Mode: Any
    Pref_OnlineHelp_Path: Any
    Pref_OpenMP: Any
    Pref_OpenMPThreads: Any
    Pref_OpenSaveMethod: Any
    Pref_OrientQuad4ForceOutput: Any
    Pref_OrientQuad4StrainOutput: Any
    Pref_OrientQuad4StressOutput: Any
    Pref_OrientQuad8ForceOutput: Any
    Pref_OrientQuad8StrainOutput: Any
    Pref_OrientQuad8StressOutput: Any
    Pref_OrientSolidAnisoOutput: Any
    Pref_OrientSolidHyperOutput: Any
    Pref_OrientSolidIsoOutput: Any
    Pref_OrientTria3ForceOutput: Any
    Pref_OrientTria3StrainOutput: Any
    Pref_OrientTria3StressOutput: Any
    Pref_OrientTria6ForceOutput: Any
    Pref_OrientTria6StrainOutput: Any
    Pref_OrientTria6StressOutput: Any
    Pref_OutputSetTitles: Any
    Pref_PaneAltDockSymbols: Any
    Pref_PaneCaptionsOnTop: Any
    Pref_PerformanceGraphics: Any
    Pref_PickAllInside: Any
    Pref_PickMethod: Any
    Pref_PictureCopyTextForXY: Any
    Pref_PictureFormat: Any
    Pref_PlaneWheelFactor: Any
    Pref_PreV10SurfaceMesh: Any
    Pref_PreserveIncludes: Any
    Pref_PreserveNextID: Any
    Pref_ProgramFont: Any
    Pref_ProgramFontSize: Any
    Pref_ReadComments: Any
    Pref_ReadDirCos: Any
    Pref_ReadTabSize: Any
    Pref_RecentlyUsedFiles: Any
    Pref_RememberDialogPos: Any
    Pref_RenderAutoRegen: Any
    Pref_RenderBeamEdges: Any
    Pref_RenderBestAvailable: Any
    Pref_RenderBitBltDelay: Any
    Pref_RenderBitmapAlignment: Any
    Pref_RenderBlockSize: Any
    Pref_RenderCaptureIconified: Any
    Pref_RenderCtrlGGroupEvaluate: Any
    Pref_RenderDebugAllTime: Any
    Pref_RenderDebugElapsedTime: Any
    Pref_RenderDebugFrameRate: Any
    Pref_RenderDebugOGLErrors: Any
    Pref_RenderDialogRefresh: Any
    Pref_RenderDisableAbort: Any
    Pref_RenderEdgesAsLines: Any
    Pref_RenderFastPick: Any
    Pref_RenderFastPickVisible: Any
    Pref_RenderHW: Any
    Pref_RenderMaxMagnification: Any
    Pref_RenderMaxVBOMB: Any
    Pref_RenderMemoryOpt: Any
    Pref_RenderMidside: Any
    Pref_RenderMinVBOB: Any
    Pref_RenderMultiModelMem: Any
    Pref_RenderPixelFormat: Any
    Pref_RenderSearchDepth: Any
    Pref_RenderSmoothLines: Any
    Pref_RenderTDRProtect: Any
    Pref_RenderTex2D: Any
    Pref_RenderTexAllTri: Any
    Pref_RenderTexNumber: Any
    Pref_RenderTexSmooth: Any
    Pref_RenderTiming: Any
    Pref_RenderTrailingZeroes: Any
    Pref_RenderVBOUsage: Any
    Pref_RenderVertexArrays: Any
    Pref_RenderXORPicking: Any
    Pref_RepeatCreate: Any
    Pref_RepeateCreate: Any
    Pref_ResCopySaveLogoScale: Any
    Pref_ResCopySaveMethod: Any
    Pref_ResCopySaveScale: Any
    Pref_ResFixedHeight: Any
    Pref_ResFixedWidth: Any
    Pref_ResFontScale: Any
    Pref_ResPenMethod: Any
    Pref_ResPenScale: Any
    Pref_ResPrintLogoScale: Any
    Pref_ResPrintMethod: Any
    Pref_ResPrintScale: Any
    Pref_ResScaleWithHeight: Any
    Pref_ResScaleWithWidth: Any
    Pref_ResScreenLogoScale: Any
    Pref_ResetNextID: Any
    Pref_ResultStudyTitle: Any
    Pref_ReverseMouseWheel: Any
    Pref_ReversePanZoom: Any
    Pref_RotateAroundCursor: Any
    Pref_RunProgNewModels: Any
    Pref_SC3DResultsDest: Any
    Pref_ScrollBackLines: Any
    Pref_SharedLibPath: Any
    Pref_Show0To360Angles: Any
    Pref_ShowAutoscale: Any
    Pref_ShowColor: Any
    Pref_ShowLabels: Any
    Pref_ShowMode: Any
    Pref_ShowNormals: Any
    Pref_SkipDMIGEntries: Any
    Pref_SnapTo: Any
    Pref_SolAbaqusCmd: Any
    Pref_SolAbaqusProgram: Any
    Pref_SolAnsysCmd: Any
    Pref_SolAnsysProgram: Any
    Pref_SolEchoCmd: Any
    Pref_SolLSDynaCmd: Any
    Pref_SolLSDynaProgram: Any
    Pref_SolMSCNastCmd: Any
    Pref_SolMSCNastProgram: Any
    Pref_SolNEINastCmd: Any
    Pref_SolNEINastProgram: Any
    Pref_SolNXNastCmd: Any
    Pref_SolNXNastProgram: Any
    Pref_SolverMemory: Any
    Pref_SpaceballDebug: Any
    Pref_SpaceballSensitivity: Any
    Pref_StartupProg: Any
    Pref_StudyAppendFemapTitles: Any
    Pref_SuppressScreenEntities: Any
    Pref_SynchronizedRotation: Any
    Pref_TabPasteIgnoreDelimeter: Any
    Pref_TbxAutomesh: Any
    Pref_TbxExpandActive: Any
    Pref_TimedSaveCommands: Any
    Pref_TimedSaveInterval: Any
    Pref_TimedSaveNotify: Any
    Pref_TimedSaveOn: Any
    Pref_TooltipDelay: Any
    Pref_TooltipDuration: Any
    Pref_TrackMousePick: Any
    Pref_UseMSCNastran2004: Any
    Pref_UseOldAnalysisInterfaces: Any
    Pref_UseRegionDecimalChar: Any
    Pref_UseSubcaseIdForOutput: Any
    Pref_UseVisQ: Any
    Pref_UserToolsPath: Any
    Pref_ViewBkgdBitmap: Any
    Pref_ViewDimetric: Any
    Pref_ViewDynamSpeed: Any
    Pref_ViewDynamicMode: Any
    Pref_ViewIsometric: Any
    Pref_ViewLogo: Any
    Pref_ViewLogoScreenRes: Any
    Pref_ViewPostDynamicMaxMin: Any
    Pref_ViewTrimetric: Any
    Pref_WorkplaneNotVisible: Any
    Pref_WriteComments: Any
    Pref_WtmassFactor: Any
    Pref_ZoomAroundCursor: Any
    Pref_nastran_param_ogeom: Any
    Print_Copies: Any
    ScratchName: Any
    SelectOutputSetsFromStudies: Any
    SerialNumber: Any
    SolidAllowNonManifold: Any
    Solid_UpdateActive: Any
    Solid_UpdateDelete: Any
    Solid_UpdateMaterialData: Any
    Solid_UpdateResizeMode: Any
    Solid_UpdateResizeTol: Any
    Solid_UpdateUseParasolidIdent: Any
    Tool_CursorSingle: Any
    Tool_MergeTolerance: Any
    Tool_MergeToleranceAuto: Any
    UndoGrayed: Any
    VectorDialogMethod: Any
    feAeroPanel: Any
    feAeroProp: Any
    feAeroSpline: Any
    feAeroSurf: Any
    feAnalysisCase: Any
    feAnalysisMgr: Any
    feAnalysisSet: Any
    feAnalysisStep: Any
    feAnalysisStudy: Any
    feBCDefinition: BCDefinition
    feBCEqn: BCEqn
    feBCGeom: Any
    feBCNode: BCNode
    feBCSet: BCSet
    feBeamCalculator: Any
    feBodyMesher: Any
    feCSys: Any
    feChart: Any
    feChartSeries: Any
    feConnection: Any
    feConnectionProp: Any
    feConnectionRegion: Any
    feContact: Any
    feCopyTool: Any
    feCurve: Any
    feDataSurf: Any
    feDataTable: Any
    feDesignEquation: Any
    feDiscreteValueSet: Any
    feDrawErase: Any
    feElem: Elem
    feElementQuality: Any
    feFibersim: Any
    feFlexibleSlider: Any
    feFreebody: Any
    feFreq: Any
    feFunction: Any
    feGFXArrow: Any
    feGFXLine: Any
    feGFXPoint: Any
    feGFXQuad4: Any
    feGFXTria3: Any
    feGlobalPly: Any
    feGlobalStep: Any
    feGroup: Any
    feInterpolate: Any
    feJoint: Any
    feLayer: Any
    feLayup: Any
    feLoadBolt: Any
    feLoadDefinition: Any
    feLoadETemp: Any
    feLoadGeom: Any
    feLoadMesh: Any
    feLoadNTemp: Any
    feLoadSet: Any
    feMapData: Any
    feMapOutput: Any
    feMatl: Any
    feMatrixInput: Any
    feMergeTool: Any
    feMeshHardPoint: Any
    feMeshHardPointDefinition: Any
    feMesher: Mesher
    feMidFaceCentroidModel: MidFaceCentroidModel
    feMonitorPoint: MonitorPoint
    feMoveTool: MoveTool
    feNode: Node
    feOptMC: OptMC
    feOptRel: OptRel
    feOptResp: OptResp
    feOptim: Optim
    feOutputSet: OutputSet
    fePlane: Plane
    fePoint: Point
    feProp: Prop
    fePublishTool: PublishTool
    feRead: Read
    feReference: Reference
    feReport: Report
    feResults: Results
    feResultsIDQuery: ResultsIDQuery
    feSEReference: SEReference
    feScratch: Scratch
    feSelector: Selector
    feSet: Set
    feSolid: Solid
    feSolidEdit: SolidEdit
    feSort: SortSet
    feStressLinear: StressLinear
    feSurface: Surface
    feTMGBC: TmgBC
    feTMGCtrl: TmgCtl
    feTMGInt: TmgInt
    feTMGOpt: TmgOpt
    feTMGReal: TmgReal
    feTableData: TableData
    feText: text
    feTrackData: TrackData
    feUserData: UserData
    feUserDefinedGraphics: UserDefinedGraphics
    feVar: Var
    feVector: vector
    feView: View
    feViewOrient: ViewOrient
    hListWnd: Any
    hMainWnd: Any
    vInfo_ActiveID: Any
    vInfo_ActiveType: Any
    vInfo_Color: Any
    vInfo_Count: Any
    vInfo_ElemFormulation1: Any
    vInfo_ElemFormulation2: Any
    vInfo_ElemFormulation3: Any
    vInfo_Increment: Any
    vInfo_MatlAngleVec: Any
    vInfo_MaxID: Any
    vInfo_MinID: Any
    vInfo_ModelSizeX: Any
    vInfo_ModelSizeY: Any
    vInfo_ModelSizeZ: Any
    vInfo_NextID: Any
    vInfo_PermBC: Any
    vInfo_SnapSpacing: Any
    vInfo_SurfDivisionsCurved: Any
    vInfo_SurfDivisionsLinear: Any
    vInfo_WorkplaneOrigin: Any
    vInfo_WorkplanePrevOrigin: Any
    vInfo_WorkplanePrevX: Any
    vInfo_WorkplanePrevY: Any
    vInfo_WorkplanePrevZ: Any
    vInfo_WorkplaneRuler: Any
    vInfo_WorkplaneSizeX: Any
    vInfo_WorkplaneSizeY: Any
    vInfo_WorkplaneX: Any
    vInfo_WorkplaneY: Any
    vInfo_WorkplaneZ: Any
    vPref_AngleDimetric: Any
    vPref_AngleIsometric: Any
    vPref_AngleTrimetric: Any
    vPref_EntityColor: Any
    vPref_FBDefComponents: Any
    vPref_FBDefContributions: Any
    vPref_FBDefNodalVectorMode: Any
    vPref_FBDefTotalVectorMode: Any
    vPref_NasQstOn: Any
    vPref_NasQstVal: Any
    vPref_RenderRotate: Any
    vPref_SpaceballFactors: Any
    vTool_CursorXYZ: Any

    def Get_Pref_font_CHARSET(self, piCHARSET) -> Any:
        """
        :type piCHARSET: Any
        """
        ...

    def Info_ActiveID(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_ActiveType(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_Color(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_Count(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_ElemFormulation1(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_ElemFormulation2(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_ElemFormulation3(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_Increment(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_MatlAngleVec(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_MaxID(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_MinID(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_ModelSizeX(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_ModelSizeY(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_ModelSizeZ(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_NextID(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_PermBC(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_SnapSpacing(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_SurfDivisionsCurved(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_SurfDivisionsLinear(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_WorkplaneOrigin(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_WorkplanePrevOrigin(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_WorkplanePrevX(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_WorkplanePrevY(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_WorkplanePrevZ(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_WorkplaneRuler(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_WorkplaneSizeX(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_WorkplaneSizeY(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_WorkplaneX(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_WorkplaneY(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Info_WorkplaneZ(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Pref_AngleDimetric(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Pref_AngleIsometric(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Pref_AngleTrimetric(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Pref_EntityColor(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Pref_FBDefComponents(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Pref_FBDefContributions(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Pref_FBDefNodalVectorMode(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Pref_FBDefTotalVectorMode(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Pref_NasQstOn(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Pref_NasQstVal(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Pref_RenderRotate(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def Pref_SpaceballFactors(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def SetInfo_ActiveID(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_ActiveType(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_Color(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_Count(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_ElemFormulation1(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_ElemFormulation2(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_ElemFormulation3(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_Increment(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_MatlAngleVec(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_MaxID(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_MinID(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_ModelSizeX(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_ModelSizeY(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_ModelSizeZ(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_NextID(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_PermBC(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_SnapSpacing(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_SurfDivisionsCurved(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_SurfDivisionsLinear(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_WorkplaneOrigin(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_WorkplanePrevOrigin(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_WorkplanePrevX(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_WorkplanePrevY(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_WorkplanePrevZ(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_WorkplaneRuler(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_WorkplaneSizeX(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_WorkplaneSizeY(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_WorkplaneX(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_WorkplaneY(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetInfo_WorkplaneZ(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPref_AngleDimetric(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPref_AngleIsometric(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPref_AngleTrimetric(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPref_EntityColor(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPref_FBDefComponents(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPref_FBDefContributions(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPref_FBDefNodalVectorMode(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPref_FBDefTotalVectorMode(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPref_NasQstOn(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPref_NasQstVal(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPref_RenderRotate(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetPref_SpaceballFactors(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def SetTool_CursorXYZ(self, nVectorIndex, arg1) -> Any:
        """
        :type nVectorIndex: Any
        :type arg1: Any
        """
        ...

    def Set_Pref_font_CHARSET(self, iCHARSET) -> Any:
        """
        :type iCHARSET: Any
        """
        ...

    def Tool_CursorXYZ(self, nVectorIndex) -> Any:
        """
        :type nVectorIndex: Any
        """
        ...

    def feAddToolbar(self, BarName, barLocation) -> Any:
        """
        **Description:**
            Creates a new toolbar
        **Remarks/Usage:**
            After creating a toolbar with this method, you can add commands to it using either feAddToolbarCommand or feAddToolbarUserCommand
        **Input:**
            **BarName:** The title assigned to the toolbar. This title must be unique, and will be used in other methods to access the toolbar.\n
            **barLocation:** The location where the bar will be docked. 0=Top, 1=Left, 2=Right, 3=Top, 4=Bottom\n
        **Return Code:** True\n
        :type BarName: str

        :type barLocation: int

        """
        ...

    def feAddToolbarCommand(self, BarName, cmdIndex, cmdID) -> Any:
        """
        **Description:**
            Adds a new button to a toolbar and associates it with a standard command.
        **Remarks/Usage:**
            None
        **Input:**
            **BarName:** The title of the toolbar where the command button will be placed.\n
            **cmdIndex:** The location on the toolbar for the button. 0=At the front of the toolbar before any other buttons. -1=At the end of the toolbar, after all other buttons. Any other positive value means after that button.\n
            **cmdID:** The command ID associated with the button\n
        **Return Code:** True\n
        :type BarName: str

        :type cmdIndex: int

        :type cmdID: int

        """
        ...

    def feAddToolbarSubmenu(self, BarName, cmdIndex, menuName, menuID) -> Any:
        """
        **Description:**
            Creates a new submenu in a toolbar
        **Remarks/Usage:**
            After creating a toolbar with this method, you can add commands to it using either feAddToolbarSubmenuCommand or feAddToolbarSubmenuUserCommand, or submenus using feAddToolbarSubmenuSubmenu
        **Input:**
            **BarName:** The title assigned to the toolbar. This title must be unique, and will be used in other methods to access the toolbar.\n
            **cmdIndex:** Location in barName to place the new menu. 0=Before first item, -1=After last item, N=After Nth item.\n
            **menuName:** Title to be used for the menu drop-down.\n
        **Output:**
            **menuID:** ID of the menu that was inserted - needed for feAddToolbarSubmenuSubmenu, feAddToolbarSubmenuCommand or feAddToolbarSubmenuUserCommand to add commands or submenus to this menu\n
        **Return Code:** True\n
        :type BarName: str

        :type cmdIndex: int

        :type menuName: str

        :type menuID: int

        """
        ...

    def feAddToolbarSubmenuCommand(self, menuID, cmdIndex, cmdID) -> Any:
        """
        **Description:**
            Adds a new button to a submenu on a toolbar and associates it with a standard command.
        **Remarks/Usage:**
            None
        **Input:**
            **menuID:** The ID of the menu where you want to place the command. This is returned by feAddToolbarSubmenu\n
            **cmdIndex:** The location in the menu for the button. 0=At the front of the menu before any other buttons. -1=At the end of the menu, after all other buttons. Any other positive value means after that button.\n
            **cmdID:** The command ID associated with the button\n
        **Return Code:** True\n
        :type menuID: int

        :type cmdIndex: int

        :type cmdID: int

        """
        ...

    def feAddToolbarSubmenuSubmenu(self, menuID, ctrlIndex, menuName, submenuID) -> Any:
        """
        **Description:**
            Adds a new submenu to a submenu on a toolbar.
        **Remarks/Usage:**
            None
        **Input:**
            **menuID:** The ID of the menu where you want to place the command. This is returned by feAddToolbarSubmenu\n
            **ctrlIndex:** The location in the menu for the submenu. 0=At the front of the menu before any other buttons. -1=At the end of the menu, after all other buttons. Any other positive value means after that button.\n
            **menuName:** Title to be used for the menu drop-down.\n
        **Output:**
            **menuID:** ID of the menu that was inserted - needed for feAddToolbarSubmenuCommand or feAddToolbarSubmenuUserCommand to add commands to this menu\n
        **Return Code:** True\n
        :type menuID: int

        :type ctrlIndex: int

        :type menuName: str

        :type menuID: int

        """
        ...

    def feAddToolbarSubmenuUserCommand(self, menuID, cmdIndex, cmdTitle, cmdBitmap, cmdID) -> Any:
        """
        **Description:**
            Adds a new button to a submenu and associates it with a user command.
        **Remarks/Usage:**
            None
        **Input:**
            **menuID:** The ID of the menu where the command button will be placed.\n
            **cmdIndex:** The location on the menu for the button. 0=At the front of the menu before any other buttons. -1=At the end of the menu, after all other buttons. Any other positive value means after that button.\n
            **cmdTitle:** The title of the user command to associate with the button. This is the title given to the command in feAddUserCommand.\n
            **cmdBitmap:** The full pathname of a Windows Bitmap file that will be the icon associated with the button. Specify an empty string () if you do not want the button to display as an icon - it will then display as text. Refer to feSetToolbarCommandBitmap for more information about defining the bitmap to be used for the icon.\n
        **Output:**
            **cmdID:** The command ID assigned to the button\n
        **Return Code:** True\n
        :type menuID: int

        :type cmdIndex: int

        :type cmdTitle: str

        :type cmdBitmap: str

        :type cmdID: int

        """
        ...

    def feAddToolbarUserCommand(self, BarName, cmdIndex, cmdTitle, cmdBitmap, cmdID) -> Any:
        """
        **Description:**
            Adds a new button to a toolbar and associates it with a user command.
        **Remarks/Usage:**
            None
        **Input:**
            **BarName:** The title of the toolbar where the command button will be placed.\n
            **cmdIndex:** The location on the toolbar for the button. 0=At the front of the toolbar before any other buttons. -1=At the end of the toolbar, after all other buttons. Any other positive value means after that button.\n
            **cmdTitle:** The title of the user command to associate with the button. This is the title given to the command in feAddUserCommand.\n
            **cmdBitmap:** The full pathname of a Windows Bitmap file that will be the icon associated with the button. Specify an empty string () if you do not want the button to display as an icon - it will then display as text. Refer to feSetToolbarCommandBitmap for more information about defining the bitmap to be used for the icon.\n
        **Output:**
            **cmdID:** The command ID assigned to the button\n
        **Return Code:** True\n
        :type BarName: str

        :type cmdIndex: int

        :type cmdTitle: str

        :type cmdBitmap: str

        :type cmdID: int

        """
        ...

    def feAddUserCommand(self, strTitle, strCmd, strArg, strStartDir) -> Any:
        """
        **Description:**
            Defines a user command that can then be used in the menu or toolbar
        **Remarks/Usage:**
            User commands defined with this method can be assigned to a toolbar using the feAddToolbarUserCommand method.
        **Input:**
            **strTitle:** The title assigned to the command. This title is used later to assign the command to the menu or toolbar. It must be unique when compared to all other user commands.\n
            **strCmd:** The command line used to execute the command\n
            **strArg:** Any command line arguments assigned to the command\n
            **strStartDir:** The starting directory, if any, for the command.\n
        **Return Code:** True\n
        :type strTitle: str

        :type strCmd: str

        :type strArg: str

        :type strStartDir: str

        """
        ...

    def feAlignBetweenCSys(self, entityTYPE, entitySET, nFromCSysID, nToCSysID) -> Any:
        """
        **Description:**
            Aligns entities from one coordinate system to another.
        **Remarks/Usage:**
            Using this API call is essentially the same as using the Modify, Align...commands in the user interface when the Between Coordinate Systems method is selected.
        **Input:**
            **entityTYPE:** The type of entities to be aligned. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_CSYS, FT_SURFACE, FT_VOLUME, FT_SOLID, FT_NODE or FT_ELEM. \n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be aligned. Alternatively, if you specify a negative value, this is simply the ID of the single entity to align. \n
            **nFromCSysID:** The ID of the Coordinate System to use as the From Coordinate System\n
            **nToCSysID:** The ID of the Coordinate System to use as the To Coordinate System\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type nFromCSysID: int

        :type nToCSysID: int

        """
        ...

    def feAlignTo(self, entityTYPE, entitySET, fromLoc, fromVec, toLoc, toVec) -> Any:
        """
        **Description:**
            Aligns entities from one vector to another.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities to be aligned. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_CSYS, FT_SURFACE, FT_VOLUME, FT_SOLID, FT_NODE or FT_ELEM. \n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be aligned. Alternatively, if you specify a negative value, this is simply the ID of the single entity to align. \n
            **fromLoc:** The coordinates of the origin of the original vector, in global rectangular coordinates.\n
            **fromVec:** The components of the original vector, in global rectangular coordinates.\n
            **toLoc:** The coordinates of the origin of the destination vector, in global rectangular coordinates.\n
            **toVec:** The components of the destination vector, in global rectangular coordinates.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type fromLoc: tuple[float]

        :type fromVec: tuple[float]

        :type toLoc: tuple[float]

        :type toVec: tuple[float]

        """
        ...

    def feAppAllowUVSurfaceForMeshFaces(self, bOn) -> Any:
        """
        :type bOn: Any
        """
        ...

    def feAppBringToTop(self, toTop, underWindow) -> Any:
        """
        **Description:**
            Allows you to position the FEMAP window on top of, or under other windows.
        **Remarks/Usage:**
            None
        **Input:**
            **toTop:** If True, the window is moved forward in the window list. If False, it is moved to the back of the window list, under all other windows.\n
            **underWindow:** Only used if toTop=True. If you want to move the window on top of all other windows, set this to 0. If you want to move it forward, but leave it behind another window, specify that window handle in this field.\n
        **Return Code:** False\n
        :type toTop: bool

        :type underWindow: int

        """
        ...

    def feAppColorCreate(self, enColor, enPattern, enLinestyle) -> Any:
        """
        **Description:**
            Returns a FEMAP color containing a base color, pattern and linestyle mask
        **Remarks/Usage:**
            Use the enumerations provided in zColor. Numbers outside of this range may have unintended results
        **Return Code:** True\n
        """
        ...

    def feAppColorGetBaseColor(self, nColor, penColor) -> Any:
        """
        **Description:**
            Extracts the base color from a FEMAP color ID.
        **Remarks/Usage:**
            Color IDs are a combination of colors and pattern / linestyle masks from the zColor enum. They can be created manually or obtained from feAppColorPalette / feAppColorCreate.
        **Input:**
            **nColor:** FEMAP color ID\n
        **Return Code:** False\n
        :type nColor: int

        """
        ...

    def feAppColorGetLinestyle(self, nColor, penLinestyle) -> Any:
        """
        **Description:**
            Extracts the pattern mask from a FEMAP color ID.
        **Remarks/Usage:**
            Color IDs are a combination of colors and pattern / linestyle masks from the zColor enum. They can be created manually or obtained from feAppColorPalette / feAppColorCreate.
        **Input:**
            **nColor:** FEMAP color ID\n
        **Return Code:** False\n
        :type nColor: int

        """
        ...

    def feAppColorGetPattern(self, nColor, penPattern) -> Any:
        """
        **Description:**
            Extracts the pattern mask from a FEMAP color ID.
        **Remarks/Usage:**
            Color IDs are a combination of colors and pattern / linestyle masks from the zColor enum. They can be created manually or obtained from feAppColorPalette / feAppColorCreate.
        **Input:**
            **nColor:** FEMAP color ID\n
        **Return Code:** False\n
        :type nColor: int

        """
        ...

    def feAppColorGetRGB(self, nColor, pnRed, pnGreen, pnBlue) -> Any:
        """
        **Description:**
            Returns the red, green and blue components from a FEMAP color ID
        **Remarks/Usage:**
            Color IDs are a combination of colors and pattern / linestyle masks from the zColor enum. They can be created manually or obtained from feAppColorPalette / feAppColorCreate.
        **Input:**
            **nColor:** FEMAP color ID\n
        **Output:**
            **pnRed:** Red component. Integer value 0-255\n
            **pnGreen:** Green component. Integer value 0-255\n
            **pnBlue:** Blue component. Integer value 0-255\n
        **Return Code:** False\n
        :type nColor: int

        :type pnRed: int

        :type pnGreen: int

        :type pnBlue: int

        """
        ...

    def feAppColorPalette(self, nDefault, nColor) -> Any:
        """
        **Description:**
            Displays the color palette dialog box allowing a user to pick a color.
        **Remarks/Usage:**
            None
        **Input:**
            **nDefault:** The default color, used to initialize the dialog box. This is a combination of the desired color, pattern and linestyle.\n
        **Output:**
            **nColor:** The color/pattern/linestyle that the user selected. If the user presses Cancel, this will be the same as nDefault\n
        **Return Code:** True\n
        :type nDefault: int

        :type nColor: int

        """
        ...

    def feAppCountModels(self, numModels) -> Any:
        """
        **Description:**
            Finds the number of models that are currently opened
        **Remarks/Usage:**
            None
        **Output:**
            **numModels:** The number of currently opened models. Could be 0 if no models are open.\n
        **Return Code:** True\n
        :type numModels: int

        """
        ...

    def feAppEmbed(self, windowID, x, y, cx, cy) -> Any:
        """
        **Description:**
            Embeds the FEMAP window(s) into another application
        **Remarks/Usage:**
            This method is normally used with FEMAP in a non-visible state. In that case, FEMAP becomes visible, and is embedded (parented) into the window you specify - normally the main window of your application. You may call this method multiple times to update the window where the windows are embedded, or to change the embedded region. Refer to Embedding FEMAP in your application on page113for more information.
        **Input:**
            **windowID:** The handle to your application main window/form, or any other window where you want the FEMAP window displayed.\n
            **x, y, cx, cy:** The coordinates of the upper left corner of the embedded window(s). These are specified in the client coordinates of the parent window specified by windowID\n

        **Return Code:** False\n
        :type windowID: int

        :type x: int

        :type y: int

        :type cx: int

        :type cy: int

        """
        ...

    def feAppEventCallback(self, eventID, callback) -> Any:
        """
        **Description:**
            Registers a program to be called when a particular event occurs
        **Remarks/Usage:**
            This method allows you to execute a particular task when an event occurs without having to implement complicated event handling code. From the time you register the callback, until you unregister it by calling with a blank string, your code will be called every time the event occurs. Only one callback can be registered per event. You can simply call this method with a different file for the same event to switch callbacks.
        **Input:**
            **eventID:** The ID of the event to watch. Refer to Section 6.4, "The FEMAP Events" for possible event values.\n
            **callback:** A full path to a FEMAP Program file, Basic program, or any executable that can be run from the operating system command line. Specify callback as a blank (zero length) string to unregister your callback.\n
        **Return Code:** True\n
        :type eventID: int

        :type callback: str

        """
        ...

    def feAppGetActiveView(self, nViewID) -> Any:
        """
        **Description:**
            Retrieves the ID of the active view in the active model.
        **Remarks/Usage:**
            This method allows you to retrieve the active view from the active model.
        **Output:**
            **nViewID:** The ID of the active view.\n
        **Return Code:** True\n
        :type nViewID: int

        """
        ...

    def feAppGetAllModels(self, numModels, nModelID) -> Any:
        """
        **Description:**
            Finds the number of models that are currently opened
        **Remarks/Usage:**
            This function will return the IDs of all currently opened models, which can then be used with feAppSetModel to activate any of those desired models.
        **Output:**
            **numModels:** The number of currently opened models.\n
            **nModelID:** The IDs of all of the currently opened models.\n
        **Return Code:** True\n
        :type numModels: int

        :type nModelID: tuple[int]

        """
        ...

    def feAppGetAllViews(self, numViews, nViewID) -> Any:
        """
        **Description:**
            Retrieves the IDs of all the visible views in the active model as well as the number of views that are visible.
        **Remarks/Usage:**
            This method allows you to return the IDs of all the views that are currently visible, which can then be activated with feAppSetActiveView.
        **Output:**
            **numViews:** The number of views visible in the active model.\n
            **nViewID:** The IDs of all of the views visible in the active model.\n
        **Return Code:** True\n
        :type numViews: int

        :type nViewID: tuple[int]

        """
        ...

    def feAppGetModel(self, nModelID) -> Any:
        """
        **Description:**
            Retrieves the internal ID of the active model
        **Remarks/Usage:**
            You can call this function after creating a New model, or Opening a model to retrieve its internal ID, so if you activate other models, you can reactivate the original by calling feAppSetModel
        **Output:**
            **nModelID:** The ID of the active model\n
        **Return Code:** True\n
        :type nModelID: int

        """
        ...

    def feAppGetModel32(self, nHiModelID, nLoModelID) -> Any:
        """
        **Description:**
            Retrieves the internal ID of the active model, which is a 64-bit integer, as a pair of 32-bit integers
        **Remarks/Usage:**
            You can call this function after creating a New model, or Opening a model to retrieve its internal ID as a pair of 32-bit integers, so if you activate other models, you can reactivate the original by calling feAppSetModel32 and using that pair of 32-bit integers
        **Output:**
            **nHiModelID:** The first 4-bytes of the 64-bit integer which is the ID of the active model\n
            **nLoModelID:** The second 4-bytes of the 64-bit integer which is the ID of the active model\n
        **Return Code:** True\n
        :type nHiModelID: int

        :type nLoModelID: int

        """
        ...

    def feAppGetModelByName(self, fName, nModelID) -> Any:
        """
        **Description:**
            Retrieves the ID of an open model using the model name or a portion of the model name with enough characters to identify only a single open model.
        **Remarks/Usage:**
            While it is possible to use only a portion of the model name to retrieve the model ID, enough of the title must be used to identify one and only model, otherwise the call will return FE_FAIL.
        **Input:**
            **fName:** The name of the model to retrieve the ID\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def feAppGetModelName(self, nModelID, ModelName) -> Any:
        """
        **Description:**
            Retrieves the name of the selected model
        **Remarks/Usage:**
            If the model has not yet been saved, it will not have a name, and the ModelName will be returned as Untitled. You can use this method in conjunction with feAppGetAllModels( ) to retrieve the names of all open models.
        **Input:**
            **nModelID:** The ID of the model to retrieve the name.\n
        **Output:**
            **ModelName:** The name of the specified model\n
        **Return Code:** True\n
        :type nModelID: int

        :type ModelName: str

        """
        ...

    def feAppGetRunningApplication(self, appName, processID, activeWindow, appObject) -> Any:
        """
        **Description:**
            Returns the top-level COM Application Object.
        **Remarks/Usage:**
            This method pairs with feAppRunningApplicationInfo.
        **Input:**
            **appName:** Set this equal to FEMAP.\n
            **processID:** The Process ID of the running Application.\n
            **activeWindow:** The open Model ID. Can also be an empty Variant.\n
        **Output:**
            **appObject:** The top-level Application Object. Also known as the IDispatch pointer.\n
        **Return Code:** True\n
        :type appName: str
        :type processID: int
        :type activeWindow: Any
        :type appObject: Any

        """
        ...

    def feAppLoadColorPalette(self, sPaletteFileName) -> Any:
        """
        **Description:**
            Loads a color palette.
        **Remarks/Usage:**

        **Input:**
            **sPaletteFileName:** Full path to a FEMAP color palette file.\n
        **Return Code:** True\n
        :type sPaletteFileName: str

        """
        ...

    def feAppLoadContourPalette(self, bUpdateViewPalette, sPaletteFileName) -> Any:
        """
        **Description:**
            Loads a contour color palette.
        **Remarks/Usage:**
            The selected palette will be loaded and will be used for any new View that is created. It will not however update any existing Views. If bUpdateViewPalette is True, the User Contour Palette in the Active View will also be updated and if "All Views" is enabled, all active views will be updated.
        **Input:**
            **bUpdateViewPalette:** If True, then the Contour Palette will be loaded for any new View.\n
            **sPaletteFileName:** Full path to a FEMAP Contour Palette file.\n
        **Return Code:** True\n
        :type bUpdateViewPalette: bool

        :type sPaletteFileName: str

        """
        ...

    def feAppLock(self) -> Any:
        """
        **Description:**
            Locks the FEMAP user interface.
        **Remarks/Usage:**
            This method locks the user interface so that the user cannot pick any commands from the FEMAP menus or toolbars. Some aspects of the FEMAP user interface (such as docking panes) will still remain active - there is no way to deactivate those, however they can be hidden. Add-in applications are active. When FEMAP is locked, the cursor is changed to be an hourglass with a lock. You must call feAppUnlock before FEMAP will again be active.
        **Return Code:** True\n
        """
        ...

    def feAppLockDraw(self) -> Any:
        """
        **Description:**
            Locks the FEMAP session so that redraws of the graphics windows do not occur.
        **Remarks/Usage:**
            This method locks the session so that redraws will not occur - even if you explicitly call API functions that cause redraws. Calling this function can improve the performance of other API functions since the on-screen graphics do not need to be updated, however when you are done with your processing, you must call feAppUnlockDraw, and then call feViewRedraw or feViewRegenerate.
        **Return Code:** True\n
        """
        ...

    def feAppLockExit(self) -> Any:
        """
        **Description:**
            Locks the FEMAP session so that a user can not exit.
        **Remarks/Usage:**
            This method locks the session so that the user cannot exit using the File->Exit command, or any of the normal system application close methods. This does not prevent the FEMAP process from being accidentally or intentionally terminated using Task Manager or other approaches.
        **Return Code:** True\n
        """
        ...

    def feAppLockModel(self) -> Any:
        """
        **Description:**
            Locks the FEMAP session so that a user can not start or open a different model.
        **Remarks/Usage:**
            This method locks the session so that the user cannot change to a new model using either the File->New or File->Open commands.
        **Return Code:** True\n
        """
        ...

    def feAppManageGraphicsTabs(self, Visible) -> Any:
        """
        **Description:**
            Sets the visibility of the tabs on the top of the graphics windows
        **Remarks/Usage:**
            The tabs controlled by this method are shown here:
        **Input:**
            **Visible:** If True, show the tabs, otherwise hide them\n
        **Return Code:** True\n
        :type Visible: bool

        """
        ...

    def feAppManagePanes(self, PaneName, action) -> Any:
        """
        **Description:**
            Changes the state of one or more of the docking panes
        **Remarks/Usage:**
            The names of the panes can be found in the title bars of the panes. Currently they are Entity Editor, Messages, Data Table, Model Info, Entity Info, Data Surface Editor, Meshing Toolbox, PostProcessing Toolbox, Charting, API Programming, and Program File.
        **Input:**
            **PaneName:** The name of the pane to manage\n
            **action:** 0=Hide, 1=Show/Visible, 2=Dock as a Tab, 3=Toggle Docking\n
        **Return Code:** True\n
        :type PaneName: str

        :type action: int

        """
        ...

    def feAppManageStatusBar(self, Visible) -> Any:
        """
        **Description:**
            Sets the visibility of the status bar
        **Remarks/Usage:**
            None
        **Input:**
            **Visible:** If True, show the status bar, otherwise hide it\n
        **Return Code:** True\n
        :type Visible: bool

        """
        ...

    def feAppManageToolbars(self, BarName, Visible) -> Any:
        """
        **Description:**
            Makes one or more toolbars visible (or hidden)
        **Remarks/Usage:**
            The names of the toolbars can be found by running FEMAP manually and looking on the Tools->Toolbars menu. In addition to the toolbars listed there, you can also control the visibility of the Menu using this method - simply use the barName of Menu Bar. If you want to set all possible toolbars in a single call, set barName to an empty string ().
        **Input:**
            **BarName:** The name of the toolbar to manage\n
            **Visible:** If True, the toolbar is made visible, otherwise it is hidden\n
        **Return Code:** True\n
        :type BarName: str

        :type Visible: bool

        """
        ...

    def feAppMessage(self, color, message) -> Any:
        """
        **Description:**
            Writes a message to the Messages and Lists window.
        **Remarks/Usage:**
            This message is only written to the Message Window, regardless of the location (or locations) that is currently specified in the listing destination.
        **Input:**
            **color:** The color/status of the message to write: 0=Normal, 1=Highlight, 2=Warning, 3=Error.\n
            **message:** The text of the message to write. Must be less than 160 characters.\n
        **Return Code:** False\n
        :type color: int

        :type message: str

        """
        ...

    def feAppMessageBox(self, msgmode, message) -> Any:
        """
        **Description:**
            Displays a message box, asking the user to press a button to continue.
        **Remarks/Usage:**
            This method is useful if your application is windowless since it insures the Message Box will be displayed on top of all FEMAP windows.
        **Input:**
            **msgmode:** Determines the buttons that will be available in the box. 0=OK, 1=OK and Cancel, 2 = Yes and No, 3 = Yes, No and Cancel\n
            **message:** The text of the message to write. Must be less than 160 characters.\n
        **Return Code:** True\n
        :type msgmode: int

        :type message: str

        """
        ...

    def feAppMessageClear(self) -> Any:
        """
        **Description:**
            Removes all items currently in the Messages and Lists window.
        **Remarks/Usage:**

        **Return Code:** False\n
        """
        ...

    def feAppMessageEndListing(self) -> Any:
        """
        **Description:**
            Ends a listing that was started by feAppMessageStartListing
        **Remarks/Usage:**
            NOTE: You MUST call feAppMessageEndListing() after your last call to feAppMessage(), so that the Message Window display is turned back on. If you are using the Printer as a destination, all text that is written between your call to feAppMessageStartListing() and feAppMessageEndListing() is sent to the printer as a single job when you call feAppMessageEndListing().
        **Return Code:** False\n
        """
        ...

    def feAppMessageStartListing(self) -> Any:
        """
        **Description:**
            Begins a listing to the active listing destinations
        **Remarks/Usage:**
            Calling this function initializes Listing Mode in the Message window. This means that text will appear in the Listing font - typically fixed pitch. It also means that the text will be written to whatever destinations are selected - Message Window, File and/or Printer. Finally it means that text written to the Message Window will not appear until you call feAppMessageEndListing(). Between these two calls redrawing of the Message Window is disabled to improve the speed of writing large blocks of text.
        **Return Code:** True\n
        """
        ...

    def feAppModelContents(self, bReport, emptyBlocks, entityBlocks) -> Any:
        """
        **Description:**
            Finds, and alternatively lists, the number of blocks of each entity type that are currently in the model
        **Remarks/Usage:**
            The number of bytes in a Database block can change from version to version, however currently one block is 4096 bytes.
        **Input:**
            **bReport:** If True, a report of the contents is written to the Message Window\n
        **Output:**
            **emptyBlocks:** The number of blocks which are allocated but unused because data has been deleted. These blocks will be reused as new data is added to the database.\n
            **entityBlocks:** An array of the number of blocks being used for each entity type. The index in this array is the Entity Type being reported. Common Entity types are define in Section 3.3.6, "Entity Types".\n
        **Return Code:** True\n
        :type bReport: bool

        :type emptyBlocks: int

        :type entityBlocks: tuple[int]

        """
        ...

    def feAppModelDefragment(self) -> Any:
        """
        **Description:**
            Rearranges data in the model so that it is organized with similar data grouped together.
        **Remarks/Usage:**
            This method will rearrange data in your model. Defragmenting should improve performance. Another way to accomplish this is to write a Neutral File and read it into a new model.
        **Return Code:** True\n
        """
        ...

    def feAppModelInfoShow(self) -> Any:
        """
        **Description:**
            Returns the current state of the Show When Selected menu in the Model Info Tree dockable pane
        **Remarks/Usage:**

        **Return Code:** True\n
        """
        ...

    def feAppPosition(self, move, Size, x, y, cx, cy) -> Any:
        """
        **Description:**
            Allows you to move and size the FEMAP window.
        **Remarks/Usage:**
            None
        **Input:**
            **move:** If True, the upper left corner of the window is moved to the new location specified by x,y.\n
            **Size:** If True, the window is resized to the size specified by cx,cy.\n
            **x:** The horizontal location of the upper left corner of the window. Specified as a percent of the total screen size.\n
            **y:** The vertical location of the upper left corner of the window. Specified as a percent of the total screen size.\n
            **x:** The horizontal size of the window. Specified as a percent of the total screen size.\n
            **y:** The vertical size of the window. Specified as a percent of the total screen size.\n
        **Return Code:** False\n
        :type move: bool

        :type Size: bool

        :type x: float

        :type y: float

        :type x: float

        :type y: float

        """
        ...

    def feAppRegisterAddIn(self, regster, windowID, messageID, tile, location) -> Any:
        """
        **Description:**
            Registers an add-in application with FEMAP.
        **Remarks/Usage:**
            Usually you will want to specify the same handle for windowID and messageID - unless you want some other window than your main window to receive FEMAP event messages.
        **Input:**
            **regster:** Set to True to register a new application, or False to unregister an add-in that is about to close.\n
            **windowID:** The handle to the add-in application main window/form.\n
            **messageID:** The handle to the add-in application window that is to receive event messages. This must be a window that has a message loop.\n
            **tile:** Not used\n
            **location:** Not used \n
        **Return Code:** False\n
        :type regster: bool

        :type windowID: int

        :type messageID: int

        :type tile: bool

        :type location: int

        """
        ...

    def feAppRegisterAddInPane(self, regster, windowID, messageID, bPreventClose, bPreventHide, location,
                               neighborID) -> Any:
        """
        **Description:**
            Registers an add-in application with FEMAP.
        **Remarks/Usage:**
            Usually you will want to specify the same handle for windowID and messageID - unless you want some other window than your main window to receive FEMAP event messages.
        **Input:**
            **regster:** Set to True to register a new application, or False to unregister an add-in that is about to close.\n
            **windowID:** The handle to the add-in application main window/form.\n
            **messageID:** The handle to the add-in application window that is to receive event messages. This must be a window that has a message loop.\n
            **bPreventClose:** If True, the pane will not include the X in the title bar to allow users to close the addin. If you set this option, you must provide some other method to allow users to close your application.\n
            **bPreventHide:** If True, the pane will not include the pin in the title bar to allow the window to be collapsed to a tab.\n
            **location:** 0 - floating window, 1 - dock left, 2 - dock right, 3 - dock top, 4 - dock bottom\n
            **neighborID:** 0-femap main window, 1-Message Pane, 2-Model Info Tree Pane, 3-Entity Editor Pane, 4-Data Table Pane, otherwise the handle to an existing add-in window. \n
        **Return Code:** False\n
        :type regster: bool

        :type windowID: int

        :type messageID: int

        :type bPreventClose: bool

        :type bPreventHide: bool

        :type location: int

        :type neighborID: int

        """
        ...

    def feAppRegisterAddInPaneWithFrame(self, regster, windowID, messageID, bPreventClose, bPreventHide, location,
                                        neighborID) -> Any:
        """
        **Description:**
            Registers an add-in application with FEMAP.
        **Remarks/Usage:**
            This method is essentially the same as feAppRegisterAddInPane, however it does not modify the window style of the window being added. This has both positive and negative effects. On the positive side, it allows some programs to be added that contain menus that disappear if you used feAppRegisterAddInPane. However, it also leaves window borders and forces you to do more in your add-in application to make sure sizes do not change and that your windows do not accidentally move or close. If you allow this and do not fully manage it, you can end up with a pane that contains only part of your application, or nothing. So, unless you absolutely need to keep menus or frames, use feAppRegisterAddInPane instead.
        **Input:**
            **regster:** Set to True to register a new application, or False to unregister an add-in that is about to close.\n
            **windowID:** The handle to the add-in application main window/form.\n
            **messageID:** The handle to the add-in application window that is to receive event messages. This must be a window that has a message loop.\n
            **bPreventClose:** If True, the pane will not include the X in the title bar to allow users to close the addin. If you set this option, you must provide some other method to allow users to close your application.\n
            **bPreventHide:** If True, the pane will not include the pin in the title bar to allow the window to be collapsed to a tab.\n
            **location:** 0 - floating window, 1 - dock left, 2 - dock right, 3 - dock top, 4 - dock bottom\n
            **neighborID:** 0-femap main window, 1-Message Pane, 2-Model Info Tree Pane, 3-Entity Editor Pane, 4-Data Table Pane, otherwise the handle to an existing add-in window. \n
        **Return Code:** False\n
        :type regster: bool

        :type windowID: int

        :type messageID: int

        :type bPreventClose: bool

        :type bPreventHide: bool

        :type location: int

        :type neighborID: int

        """
        ...

    def feAppRegisterMessageHandler(self, regster, windowID) -> Any:
        """
        **Description:**
            Registers your application to receive all of the text that is sent to the FEMAP Messages window.
        **Remarks/Usage:**
            This method allows you to capture the FEMAP messages and process them in any way you would like. You can display or modify them in any manner you would like. Refer to Capturing the FEMAP Messages on page115 for more information.
        **Input:**
            **regster:** If True, your application will start receiving messages as they are written to the window. If False, messages will no longer be sent.\n
            **windowID:** The handle your applications main window/form, or any other window that you want to receive the message text.\n
        **Return Code:** False\n
        :type regster: bool

        :type windowID: int

        """
        ...

    def feAppResetLocale(self) -> Any:
        """
        **Description:**
            Resets Locale
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def feAppRunningApplicationInfo(self, appName, processIDs, activeWindows, nint) -> Any:
        """
        **Description:**
            Returns information about running applications to use for API attachment.
        **Remarks/Usage:**
            This method is intended return information of the running application to be used by “feAppGetRunningApplication”. These methods overcome a pitfall of the Microsoft function “GetObject” that limits an external API program to only attach to the 1st running instance of an application. Reference Microsoft documentation about the Running Object Table for more information.
        **Return Code:** True\n
        **Input:**
            **appName:** Set this equal to “FEMAP”.
        **Output:**
            **processIDs** The Process IDs of each running application specified by appName. Where n is the total number of active windows.\n
            There may be duplicates in the array if an application has more than 1 active window. See the description for activeWindows.\n
            **activeWindows** Returns an array of the open Model IDs.\n
            (i.e. 2077739520, 30213888, etc.).\n
            For example, If there are 2 running FEMAPs, each with 3 open models, n will equal 6.\n
            **nint** Returns an array of the version number of the running windows.\n
        :type appName: str
        :type processIDs: tuple[int]
        :type activeWindows: tuple[int]
        :type nint: tuple[int]
        """
        ...

    def feAppSetActiveView(self, nViewID) -> Any:
        """
        **Description:**
            Activates a view in the active model chosen by its ID.
        **Remarks/Usage:**
            This method allows you to activate any existing view in the active model. Use feAppGetActiveView and feAppGetAllViews to retrieve the IDs of views that can be activated.
        **Input:**
            **nViewID:** The ID of the view that you want to activate.\n
        **Return Code:** False\n
        :type nViewID: int

        """
        ...

    def feAppSetModel(self, nModelID) -> Any:
        """
        **Description:**
            Activates a model chosen by its internal ID
        **Remarks/Usage:**
            You can find the ID of the active model using feAppGetModel, and that ID can then be passed to this method at a later time to reactivate the model.
        **Input:**
            **nModelID:** The ID of the model that you want to activate\n
        **Return Code:** True\n
        :type nModelID: int

        """
        ...

    def feAppSetModel32(self, nHiModelID, nLoModelID) -> Any:
        """
        **Description:**
            Activates a model chosen by a pair of 32-bit integers representing its internal ID, which is a 64-bit integer
        **Remarks/Usage:**
            You will need to find the nHiModelID and nLoModelID of the active model using feAppGetModel32, and those IDs can then be passed to this method at a later time to reactivate the model.
        **Input:**
            **nHiModelID:** The first 4-bytes of the 64-bit integer which is the ID of the model that you want to activate\n
            **nLoModelID:** The second 4-bytes of the 64-bit integer which is the ID of the model that you want to activate\n
        **Return Code:** True\n
        :type nHiModelID: int

        :type nLoModelID: int

        """
        ...

    def feAppSetModelByName(self, fName) -> Any:
        """
        **Description:**
            Activates a model chosen by specifying its filename
        **Remarks/Usage:**
            To use this method successfully, you must specify a complete filename, including the directory/path, and the .MOD extension. You can retrieve the full name of the active model from the ModelName parameter.
        **Input:**
            **fName:** The complete filename of the model that you want to activate\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def feAppSetModelInfoShow(self, bEnable) -> Any:
        """
        **Description:**
            Sets the Show Mode of the Show When Selected menu in the Model Info Tree dockable pane
        **Remarks/Usage:**
            To insure a particular Show Mode will be used, be sure to set some combination of the available Info_ViewShow... options before calling this method.
        **Input:**
            **bEnable:** IIf True, sets Show When Selected menu to Highlight, Transparent Highlight, or Show Selected Only, based on the setting in the current model for Window, Show Entities. If False, sets Show When Selected menu to Off. \n
        **Return Code:** False\n
        :type bEnable: bool

        """
        ...

    def feAppShowWindow(self, maximize) -> Any:
        """
        **Description:**
            Allows you to minimize and maximize the FEMAP window.
        **Remarks/Usage:**
            None
        **Input:**
            **maximize:** If True, the window will be maximized. If False, it will be minimized to an icon.\n
        **Return Code:** False\n
        :type maximize: bool

        """
        ...

    def feAppStatusRedraw(self) -> Any:
        """
        **Description:**
            Redraws the Status bar.
        **Remarks/Usage:**
            Simply redraws the Status bar to reflect any changes that have taken place - for example creation or deletion of nodes or elements.
        **Return Code:** False\n
        """
        ...

    def feAppStatusShow(self, Enable, max_status) -> Any:
        """
        **Description:**
            Enables or disables the status tracker inside the Status bar.
        **Remarks/Usage:**
            You must call feAppStatusShow( False, ...) after you are done with the status tracker to remove it from the display.
        **Input:**
            **Enable:** Set to True to enable/show the status tracker. Set to False to remove it.\n
            **max_status:** The value that you will use as 100% complete when sending feAppStatusUpdate commands. \n
        **Return Code:** False\n
        :type Enable: bool

        :type max_status: int

        """
        ...

    def feAppStatusUpdate(self, current_status) -> Any:
        """
        **Description:**
            Updates the status tracker to the specified level of completeness.
        **Remarks/Usage:**
            Although it is normal to send increasing values of current_status, starting at 0, and proceeding toward max_status, there is no requirement to do so. current_status values can be sent in any order.
        **Input:**
            **current_status:** The current completion value. This should be a number that is between 0, and the value you specified as max_status in the feAppStatusShow method. When you specify current_status=max_status, the status tracker will be drawn as fully complete.\n
        **Return Code:** False\n
        :type current_status: int

        """
        ...

    def feAppUndoCheckpoint(self, undoTitle) -> Any:
        """
        **Description:**
            Establishes a point that the Undo command can roll back to
        **Remarks/Usage:**
            None
        **Input:**
            **undoTitle:** Once an Undo checkpoint is set, the specified String will appear between Undoing and Command in the Messages window when the Tools, Undo command is used.\n
        **Return Code:** True\n
        :type undoTitle: str

        """
        ...

    def feAppUndoClear(self) -> Any:
        """
        **Description:**
            Clears the Undo Stack
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def feAppUnlock(self) -> Any:
        """
        **Description:**
            Unlocks the FEMAP user interface.
        **Remarks/Usage:**
            This method unlocks the user interface, after a call to feAppLock, so that the user can again use the FEMAP commands. It changes the cursor back to the standard FEMAP cursors. Actually, feAppLock increases a lock count, so if it has been called multiple times, then feAppUnlock must be called an equal number of times before the user interface will be unlocked. There is no harm in calling feAppUnlock extra times, or even if feAppLock was never called.
        **Return Code:** True\n
        """
        ...

    def feAppUnlockDraw(self) -> Any:
        """
        **Description:**
            Unlocks the FEMAP session so that redraws can occur in the graphics window.
        **Remarks/Usage:**
            This method unlocks drawing, after a call to feAppLockDraw, so that redraws can again be done. Actually, feAppLockDraw increases a lock count, so if it has been called multiple times, then feAppUnlockDraw must be called an equal number of times before drawing will be unlocked. There is no harm in calling feAppUnlockDraw extra times, or even if feAppLockDraw was never called.
        **Return Code:** True\n
        """
        ...

    def feAppUnlockExit(self) -> Any:
        """
        **Description:**
            Unlocks the FEMAP session so that the user can exit.
        **Remarks/Usage:**
            This method unlocks the session, after a call to feAppLockExit, so that the user can again exit FEMAP. Actually, feAppLockExit increases a lock count, so if it has been called multiple times, then feAppUnlockExit must be called an equal number of times before exit will be unlocked. There is no harm in calling feAppUnlockExit extra times, or even if feAppLockExit was never called.
        **Return Code:** True\n
        """
        ...

    def feAppUnlockModel(self) -> Any:
        """
        **Description:**
            Unlocks the FEMAP session so that the user can start or open a new model.
        **Remarks/Usage:**
            This method unlocks the session, after a call to feAppLockModel, so that the user can again start or open a different model. Actually, feAppLockModel increases a lock count, so if it has been called multiple times, then feAppUnlockModel must be called an equal number of times before the model will be unlocked. There is no harm in calling feAppUnlockModel extra times, or even if feAppLockModel was never called.
        **Return Code:** True\n
        """
        ...

    def feAppUpdateModelBox(self, bForceUpdate) -> Any:
        """
        **Description:**
            This function recomputes the size of the box around the model so scaling for graphics are correct. It is not normally necessary to call this function.
        **Remarks/Usage:**
            None
        **Input:**
            **bForceUpdate:** If True, the box is always recomputed. If False, only if necessary.\n
        **Return Code:** True\n
        :type bForceUpdate: bool

        """
        ...

    def feAppUpdatePanes(self, bFullRefresh) -> Any:
        """
        **Description:**
            Updates the contents of the docking panes
        **Remarks/Usage:**
            If called with fullRefresh=False, then it must be called after each command, before redraws occur, otherwise some changes may be lost.
        **Input:**
            **bFullRefresh:** If True, the Model Info pane is fully rebuilt, otherwise incremental changes are added to all panes.\n
        **Return Code:** False\n
        :type bFullRefresh: bool

        """
        ...

    def feAppVersion(self) -> Any:
        """
        **Description:**
            Returns the version of FEMAP
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def feAppVisible(self, Visible) -> Any:
        """
        **Description:**
            Makes a FEMAP session that was started with CreateObject visible (or invisible)
        **Remarks/Usage:**
            This method is required to make FEMAP visible if you started a new session with CreateObject. You can also make an existing session invisible with the appropriate call. You should not call this method with a session where you have embedded graphics or messages windows into your application.
        **Input:**
            **Visible:** If True, the session becomes visible, if False, invisible\n
        **Return Code:** False\n
        :type Visible: bool

        """
        ...

    def feArcAngleCenterStart(self, angle, center, Start, messages) -> Any:
        """
        **Description:**
            Creates an arc in the workplane by specifying the included angle of the arc, a location at the center, and a location on the perimeter.
        **Remarks/Usage:**
            None
        **Input:**
            **angle:** The included angle swept out by the arc.\n
            **center:** The locations used to define the arc. centeris at the center of the arc. start is a point on the perimeter and is used with centerto determine the radius.\n
            **Start:** BOOL messages\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type angle: float

        :type center: tuple[float]

        :type Start: tuple[float]

        :type messages: bool

        """
        ...

    def feArcAngleStartEnd(self, angle, Start, end, messages) -> Any:
        """
        **Description:**
            Creates an arc in the workplane by specifying the included angle of the arc, a starting location, and an ending location.
        **Remarks/Usage:**
            None
        **Input:**
            **angle:** The included angle swept out by the arc.\n
            **Start:** The locations used to define the arc. start is a point on the perimeter at the beginning of the arc, endis on the perimeter at the end of the arc. \n
            **end:** BOOL messages\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type angle: float

        :type Start: tuple[float]

        :type end: tuple[float]

        :type messages: bool

        """
        ...

    def feArcCenterPoints(self, center, Start, mid, end, messages) -> Any:
        """
        **Description:**
            Creates a 3D arc in space, about a center and defined by three additional points.
        **Remarks/Usage:**
            None
        **Input:**
            **center:** The location at the center of the arc.\n
            **Start:** The location at the start of the arc. This, along with center, determine the radius of the arc.\n
            **mid:** A location used to determine the direction of the arc from start- it does not necessarily lie on the arc.\n
            **end:** A location used to determine the ending angle of the arc - it does not necessarily lie on the arc.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type center: tuple[float]

        :type Start: tuple[float]

        :type mid: tuple[float]

        :type end: tuple[float]

        :type messages: bool

        """
        ...

    def feArcCenterStartEnd(self, center, Start, end, messages) -> Any:
        """
        **Description:**
            Creates an arc in the workplane by specifying the center of the arc, a starting location, and an ending location.
        **Remarks/Usage:**
            None
        **Input:**
            **center:** The locations used to define the arc. The centeris at the center of the arc. startis a point on the perimeter at the beginning of the arc, and defines the radius. end is not necessarily on the arc, but specifies the ending location.\n
            **Start:** REAL8 end[0..2]\n
            **end:** BOOL messages\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type center: tuple[float]

        :type Start: tuple[float]

        :type end: tuple[float]

        :type messages: bool

        """
        ...

    def feArcChordCenterStart(self, Length, center, Start, messages) -> Any:
        """
        **Description:**
            Creates an arc in the workplane by specifying the chord length of the arc, a location at the center, and a location on the perimeter.
        **Remarks/Usage:**
            None
        **Input:**
            **Length:** The chord length of the arc, used to determine the included angle.\n
            **center:** The locations used to define the arc. centeris at the center of the arc. startis a point on the perimeter and is used with center to determine the radius.\n
            **Start:** BOOL messages\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type Length: float

        :type center: tuple[float]

        :type Start: tuple[float]

        :type messages: bool

        """
        ...

    def feArcPoints(self, Start, mid, end, messages) -> Any:
        """
        **Description:**
            Creates a 3D arc in space, through the three points.
        **Remarks/Usage:**
            None
        **Input:**
            **Start:** The three points on the arc. The arc goes from start, toward mid and stops at end.\n
            **mid:** REAL8 end[0..2]\n
            **end:** BOOL messages\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type Start: tuple[float]

        :type mid: tuple[float]

        :type end: tuple[float]

        :type messages: bool

        """
        ...

    def feArcRadiusStartEnd(self, radius, Start, end, messages) -> Any:
        """
        **Description:**
            Creates an arc in the workplane by specifying the radius of the arc, a starting location and an ending location.
        **Remarks/Usage:**
            None
        **Input:**
            **radius:** The radius of the arc.\n
            **Start:** The locations used to define the arc. start is a point on the perimeter at the beginning of the arc, end is on the perimeter at the end of the arc. \n
            **end:** BOOL messages\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type radius: float

        :type Start: tuple[float]

        :type end: tuple[float]

        :type messages: bool

        """
        ...

    def feArcTangentStartEnd(self, Tangent, Start, end, messages) -> Any:
        """
        **Description:**
            Creates a 3D arc in space, from a point with a specified starting tangent.
        **Remarks/Usage:**
            None
        **Input:**
            **Tangent:** A vector in the direction of the starting tangent of the arc.\n
            **Start:** The location at the start of the arc. \n
            **end:** The location at the end of the arc.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type Tangent: tuple[float]

        :type Start: tuple[float]

        :type end: tuple[float]

        :type messages: bool

        """
        ...

    def feAutoMeshAssociativity(self, elemSetID, solidSetID, dTolerance, bClearPrevious, bCheckContainment,
                                bAttachMidside, bGroupExtra, bMessages, nUnattachedGroup) -> Any:
        """
        **Description:**
            Automatically associates both nodes and elements with geometry that is coincident in your model
        **Remarks/Usage:**
            None
        **Input:**
            **solidSetID:** The ID of a set that contains a list of solid IDs to which the mesh will be attached.\n
            **dTolerance:** The tolerance value. Nodes must be within this tolerance distance of the geometry that they will be associated too.\n
            **bClearPrevious:** If True, removes and previous atttachments from the nodes/elements prior to completing this command.\n
            **bCheckContainment:** If True and you are associating to multiple solids this will first find the solid that you an element is in by checking the containment of the location of its centroid.\n
            **bMessages:** If True, status and warning messages will be written during the processing\n
        **Output:**
            **nUnattachedGroup:** The ID of a group that will receive any geometry that could not be attached fully\n
        **Return Code:** False\n
        :type solidSetID: int

        :type dTolerance: float

        :type bClearPrevious: bool

        :type bCheckContainment: bool

        :type bMessages: bool

        :type nUnattachedGroup: int

        """
        ...

    def feBCCombine(self, fromSET, toSET, overwrite) -> Any:
        """
        **Description:**
            Combines a Constraint set into another set
        **Remarks/Usage:**
            The functionality of this method is identical to the Model, Constraint, Combine command. All restrictions on combinations that apply to that command apply equally to this method.
        **Input:**
            **fromSET:** The ID of the Constraint Set to be combined\n
            **toSET:** The ID of the Constraint Set which will contain the combined constraints.\n
            **overwrite:** If True, constraints in the toSET will be overwritten with any duplicate constraints on the same node. If False, degrees of freedom on the common nodes will be combined to form a new constraint. Does not apply to constraint equations.\n
        **Return Code:** True\n
        :type fromSET: int

        :type toSET: int

        :type overwrite: bool

        """
        ...

    def feBoundaryAddSurfaces(self, nBoundaryID, surfaceSET, bAddToExisting) -> Any:
        """
        **Description:**
            Adds surfaces to an already defined multi-surface boundary
        **Remarks/Usage:**
            The ID of the boundary created will use the next available surface ID.
        **Input:**
            **nBoundaryID:** The ID of the boundary to update\n
            **surfaceSET:** The ID of a set that contains a list of Surface IDs used to define the boundary. Alternatively, if you specify a negative value, this is simply the ID of the single surface to use.\n
            **bAddToExisting:** Set to True, to add the new surfaces into the existing boundary.\n
        **Return Code:** True\n
        :type nBoundaryID: int

        :type surfaceSET: int

        :type bAddToExisting: bool

        """
        ...

    def feBoundaryFromCurves(self, curveSET) -> Any:
        """
        **Description:**
            Creates a boundary surface from a group of connected curves.
        **Remarks/Usage:**
            The ID of the boundary created will use the next available surface ID. The curves selected must form one or more closed loops. If there are multiple loops, there must be one outer loop, and one or more internal loops which are used as holes. Loops may not be nested inside holes.
        **Input:**
            **curveSET:** The ID of a set that contains a list of Curve IDs used to define the boundary. Alternatively, if you specify a negative value, this is simply the ID of the single curve to write (which must be closed).\n
        **Return Code:** True\n
        :type curveSET: int

        """
        ...

    def feBoundaryFromPoints(self, nCSys, nPoints, pXYZ, nBoundaryID) -> Any:
        """
        **Description:**
            Creates a boundary surface from a group of locations specified in order around the surface
        **Remarks/Usage:**
            This method creates points at the locations specified, and lines between them to form a loop. The points must define a single loop. If you need to create a boundary with multiple loops (holes), then you must use feBoundaryFromCurves. The ID of the boundary created will use the next available surface ID.
        **Input:**
            **nCSys:** The ID of a Coordinate System that the pXYZ coordinates are defined in. 0=Global Rectangular\n
            **nPoints:** The number of locations specified in the pXYZ array\n
            **pXYZ:** The coordinates of the points used to define the boundary, specified in the selected Coordinate System. The array must be stored as [x0,y0,z0,x1,y1,z1,...xN,yN,zN]\n
        **Output:**
            **nBoundaryID:** The ID of the boundary that is created.\n
        **Return Code:** True\n
        :type nCSys: int

        :type nPoints: int

        :type pXYZ: tuple[float]

        :type nBoundaryID: int

        """
        ...

    def feBoundaryFromSurfaces(self, surfaceSET) -> Any:
        """
        **Description:**
            Creates a boundary surface from a group of adjacent surfaces on a solid.
        **Remarks/Usage:**
            The ID of the boundary created will use the next available surface ID.
        **Input:**
            **surfaceSET:** The ID of a set that contains a list of Surface IDs used to define the boundary. Alternatively, if you specify a negative value, this is simply the ID of the single surface to use.\n
        **Return Code:** True\n
        :type surfaceSET: int

        """
        ...

    def feBoundaryFromSurfaces2(self, surfaceSET, bMessages) -> Any:
        """
        :type surfaceSET: Any
        :type bMessages: Any
        """
        ...

    def feBoundaryUpdateSurfaces(self, boundaryID) -> Any:
        """
        **Description:**
            Updates a boundary that was defined from surfaces, when the underlying surfaces have changed.
        **Remarks/Usage:**
            None
        **Input:**
            **boundaryID:** The ID of the boundary surface to update.\n
        **Return Code:** True\n
        :type boundaryID: int

        """
        ...

    def feChartPaneCopy(self, bCopyPicture, bCopyText) -> Any:
        """
        **Description:**
            This function will send a copy of the image currently shown in the charting pane and/or text of the data currently being displayed in the charting pane to the clipboard.
        **Remarks/Usage:**
            If both the image and the text are sent to the clipboard at the same time with this call, only the text will be available to paste into some applications, while other applications will give the user a choice to paste either the image or the text.
        **Input:**
            **bCopyPicture:** If True, a copy of the image currently displayed in the Charting Pane will be sent to the clipboard.\n
            **bCopyText:** If True, text representing the data currently being displayed in the Charting Pane will be sent to the clipboard.\n
        **Return Code:** True\n
        :type bCopyPicture: bool

        :type bCopyText: bool

        """
        ...

    def feChartPaneGetDisplayed(self) -> Any:
        """
        **Description:**
            This function gets the ID of the chart object displayed in the charting pane
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def feChartPaneSetDisplayed(self, nChartID) -> Any:
        """
        **Description:**
            This function sets the displayed chart in the charting pane
        **Remarks/Usage:**
            None
        **Input:**
            **nChartID:** ID of the chart object to display in the charting pane\n
        **Return Code:** True\n
        :type nChartID: int

        """
        ...

    def feCheckCoincidentCurve(self, curveSET, tolerance) -> Any:
        """
        **Description:**
            This function checks and merges coincident curves.
        **Remarks/Usage:**
            None
        **Input:**
            **curveSET:** The ID of a selection set that contains the IDs of the curves to check for coincidence. Alternatively, if you specify a negative value, this is simply the ID of the single curve to check. \n
            **tolerance:** The distance below which curves (and their endpoints) will be considered to be coincident.\n
        **Return Code:** False\n
        :type curveSET: int

        :type tolerance: float

        """
        ...

    def feCheckCoincidentElem(self, elemSET, chkTYPE, chkSHAPE, chkMASS, doLIST, makeGROUP1, makeGROUP2) -> Any:
        """
        **Description:**
            This function checks a set of elements to see if any of them are coincident (share the same nodes).
        **Remarks/Usage:**
            This function only finds coincident elements that share the same nodes - not ones that may be coincident in physical location, but still have different nodes.
        **Input:**
            **elemSET:** The ID of a selection set that contains the IDs of the elements to check. Alternatively, if you specify a negative value, this is simply the ID of the single element to check. \n
            **chkTYPE:** If True, elements of different type can still be considered coincident.\n
            **chkSHAPE:** If True, elements of different shape can be considered coincident if all of the nodes of one of the elements are on the other element.\n
            **chkMASS:** If True, mass elements are included in the check.\n
            **doLIST:** If True, coincident elements are listed in the Messages and Lists window.\n
            **makeGROUP1:** If True, a group is made of the first element in the coincident pair.\n
            **makeGROUP2:** If True, a group is made of the second element in the coincident pair.\n
        **Return Code:** False\n
        :type elemSET: int

        :type chkTYPE: bool

        :type chkSHAPE: bool

        :type chkMASS: bool

        :type doLIST: bool

        :type makeGROUP1: bool

        :type makeGROUP2: bool

        """
        ...

    def feCheckCoincidentLoads(self, LoadSet, mergeLOADS) -> Any:
        """
        **Description:**
            This function checks loads from a group of load sets to see if similar loads are applied to the same geometry or mesh.
        **Remarks/Usage:**
            Unlike the Tools, Check, Coincident Loadscommand, this command does not give you the opportunity to selectively merge individual types of loads - either all types, or no types, are merged.
        **Input:**
            **LoadSet:** The ID of a selection set that contains the IDs of the load sets to check. Alternatively, if you specify a negative value, this is simply the ID of the single load set to check. \n
            **mergeLOADS:** If True and coincident loads are found, an attempt is made to merge/combine them.\n
        **Return Code:** False\n
        :type LoadSet: int

        :type mergeLOADS: bool

        """
        ...

    def feCheckCoincidentNode(self, keepSET, mergeSET, tolerance, Merge, messages, coinCount, coinNodes) -> Any:
        """
        **Description:**
            This function checks, and optionally merges, coincident nodes. This method is obsolete and should be replaced by feCheckCoincidentNode3.
        **Remarks/Usage:**
            None
        **Input:**
            **keepSET:** The ID of a selection set that contains the IDs of the nodes to check for coincidence. Alternatively, if you specify a negative value, this is simply the ID of the single node to check. The nodes in this set are retained if they are merged with a node in the mergeSET.\n
            **mergeSET:** The ID of a selection set that contains the IDs of the nodes to check for coincidence. Alternatively, if you specify a negative value, this is simply the ID of the single node to check. The nodes in this set are removed if they are merged with a node in the keepSET. You can specify the same value for both the keepSET and the mergeSET.\n
            **tolerance:** The distance below which nodes will be considered to be coincident.\n
            **Merge:** If True, coincident nodes will be merged.\n
            **messages:** If True, messages will be printed listing all coincident nodes that are found.\n
        **Output:**
            **coinCount:** The number of pairs of coincident nodes in coinNodes.\n
            **coinNodes:** The IDs of the nodes that are found to be coincident. The entries in this array come in pairs. That is, coinNodes[0] and coinNodes[1] are coincident with each other, as are coinNodes[2] and coinNodes[3]. The entries in coinNodes[0], coinNodes[2], coinNodes[4]... come from the keepSET, coinNodes[1], coinNodes[3]... come from the mergeSET. There are coinCount pairs. \n
        **Return Code:** True\n
        :type keepSET: int

        :type mergeSET: int

        :type tolerance: float

        :type Merge: bool

        :type messages: bool

        :type coinCount: int

        :type coinNodes: tuple[int]

        """
        ...

    def feCheckCoincidentNode2(self, mergeSET, tolerance, Merge, nMergeMode, nMergeLoc, bMergeAcrossConnections,
                               nMessageMode, bSaveGroups) -> Any:
        """
        **Description:**
            This function checks, and optionally merges, coincident nodes. This method is obsolete and should be replaced by feCheckCoincidentNode3.
        **Remarks/Usage:**
            None
        **Input:**
            **mergeSET:** The ID of a selection set that contains the IDs of the nodes to check for coincidence. \n
            **tolerance:** The distance below which nodes will be considered to be coincident.\n
            **Merge:** If True, coincident nodes will be merged, otherwise just checked for coincidence\n
            **Merge:** Select Nodes to Keep 0=Automatic, 1=LowerID, 2=HigherID\n
            **Merge:** Location of merged nodes 0=Original, 1=LowerID, 2=HigherID, 3=Middle\n
            **nMessageMode:** Message Mode 0=Off, 1=On, 2=Detailed\n
            **bSaveGroups:** If True, groups are created of the nodes to be kept, and if merge=False of the nodes to be merged.\n
        **Return Code:** True\n
        :type mergeSET: int

        :type tolerance: float

        :type Merge: bool

        :type Merge: int

        :type Merge: int

        :type nMessageMode: int

        :type bSaveGroups: bool

        """
        ...

    def feCheckCoincidentNode3(self, mergeSET, tolerance, Merge, nMergeMode, nMergeLoc, bMergeAcrossConnections,
                               nMergeAcrossOutputCSys, nMergeAcrossCSysID, nMessageMode, bSaveGroups) -> Any:
        """
        **Description:**
            This function checks, and optionally merges, coincident nodes. This method supersedes both feCheckCoincidentNode and feCheckCoincidentNode2
        **Remarks/Usage:**
            None
        **Input:**
            **mergeSET:** The ID of a selection set that contains the IDs of the nodes to check for coincidence. \n
            **tolerance:** The distance below which nodes will be considered to be coincident.\n
            **Merge:** If True, coincident nodes will be merged, otherwise just checked for coincidence\n
            **Merge:** Select Nodes to Keep 0=Automatic, 1=LowerID, 2=HigherID\n
            **Merge:** Location of merged nodes 0=Original, 1=LowerID, 2=HigherID, 3=Middle\n
            **nMergeAcrossCSysID:** ID of coordinate system to use for nodes merged which had different output coordinate systems before merging. Set to -1 to use the output coordinate system of the node that was kept after the merge.\n
            **nMessageMode:** Message Mode 0=Off, 1=On, 2=Detailed\n
            **bSaveGroups:** If True, groups are created of the nodes to be kept, and if merge=False of the nodes to be merged.\n
        **Return Code:** True\n
        :type mergeSET: int

        :type tolerance: float

        :type Merge: bool

        :type Merge: int

        :type Merge: int

        :type nMergeAcrossCSysID: int

        :type nMessageMode: int

        :type bSaveGroups: bool

        """
        ...

    def feCheckCoincidentNode4(self, mergeSET, bMergeIntoAll, tolerance, Merge, nMergeMode, nMergeLoc,
                               bMergeAcrossConnections, nMergeAcrossOutputCSys, nMergeAcrossCSysID, nMessageMode,
                               bSaveGroups) -> Any:
        """
        **Description:**
            This function checks, and optionally merges, coincident nodes. This method supersedes both feCheckCoincidentNode, feCheckCoincidentNode2 and feCheckCoincidentNode3.
        **Remarks/Usage:**
            None
        **Input:**
            **mergeSET:** The ID of a selection set that contains the IDs of the nodes to check for coincidence. \n
            **bMergeIntoAll:** If True, all nodes in mergeSet will be checked against all other coincident nodes whether also in mergeSet or not. If False, only nodes within mergeSet will be checked for coincidence against other nodes in mergeSet. \n
            **tolerance:** The distance below which nodes will be considered to be coincident.\n
            **Merge:** If True, coincident nodes will be merged, otherwise just checked for coincidence\n
            **Merge:** Select Nodes to Keep 0=Automatic, 1=LowerID, 2=HigherID\n
            **Merge:** Location of merged nodes 0=Original, 1=LowerID, 2=HigherID, 3=Middle\n
            **nMergeAcrossCSysID:** ID of coordinate system to use for nodes merged which had different output coordinate systems before merging. Set to -1 to use the output coordinate system of the node that was kept after the merge.\n
            **nMessageMode:** Message Mode 0=Off, 1=On, 2=Detailed\n
        **Return Code:** True\n
        :type mergeSET: int

        :type bMergeIntoAll: bool

        :type tolerance: float

        :type Merge: bool

        :type Merge: int

        :type Merge: int

        :type nMergeAcrossCSysID: int

        :type nMessageMode: int

        """
        ...

    def feCheckCoincidentNode5(self, mergeSET, bMergeIntoAll, tolerance, max_midside_angle_distortion, Merge,
                               nMergeMode, nMergeLoc, bMergeAcrossConnections, nMergeAcrossOutputCSys,
                               nMergeAcrossCSysID, nMessageMode, bSaveGroups) -> Any:
        """
        **Description:**
            This function checks, and optionally merges, coincident nodes. This method supersedes both feCheckCoincidentNode, feCheckCoincidentNode2 and feCheckCoincidentNode3.
        **Remarks/Usage:**
            None
        **Input:**
            **mergeSET:** The ID of a selection set that contains the IDs of the nodes to check for coincidence. \n
            **bMergeIntoAll:** If True, all nodes in mergeSet will be checked against all other coincident nodes whether also in mergeSet or not. If False, only nodes within mergeSet will be checked for coincidence against other nodes in mergeSet. \n
            **tolerance:** The distance below which nodes will be considered to be coincident.\n
            **Merge:** If True, coincident nodes will be merged, otherwise just checked for coincidence\n
            **Merge:** Select Nodes to Keep 0=Automatic, 1=LowerID, 2=HigherID\n
            **Merge:** Location of merged nodes 0=Original, 1=LowerID, 2=HigherID, 3=Middle\n
            **nMessageMode:** Message Mode 0=Off, 1=On, 2=Detailed\n
            **bSaveGroups:** If True, groups are created of the nodes to be kept, and if merge=False of the nodes to be merged.\n
        **Return Code:** True\n
        :type mergeSET: int

        :type bMergeIntoAll: bool

        :type tolerance: float

        :type Merge: bool

        :type Merge: int

        :type Merge: int

        :type nMessageMode: int

        :type bSaveGroups: bool

        """
        ...

    def feCheckCoincidentPoint(self, keepSET, mergeSET, tolerance, Merge, messages, coinCount, coinPoints) -> Any:
        """
        **Description:**
            This function checks, and optionally merges, coincident points.
        **Remarks/Usage:**
            None
        **Input:**
            **keepSET:** The ID of a selection set that contains the IDs of the points to check for coincidence. Alternatively, if you specify a negative value, this is simply the ID of the single point to check. The points in this set are retained if they are merged with a point in the mergeSET.\n
            **mergeSET:** The ID of a selection set that contains the IDs of the points to check for coincidence. Alternatively, if you specify a negative value, this is simply the ID of the single point to check. The points in this set are removed if they are merged with a point in the keepSET. You can specify the same value for both the keepSET and the mergeSET.\n
            **tolerance:** The distance below which points will be considered to be coincident.\n
            **Merge:** If True, coincident points will be merged.\n
            **messages:** If True, messages will be printed listing all coincident points that are found.\n
        **Output:**
            **coinCount:** The number of pairs of coincident points in coinPoints.\n
            **coinPoints:** The IDs of the points that are found to be coincident. The entries in this array come in pairs. That is, coinPoints[0] and coinPoints[1] are coincident with each other, as are coinPoints[2] and coinPoints[3]. The entries in coinPoints[0], coinPoints[2], coinPoints[4]... come from the keepSET, coinPoints[1], coinPoints[3]... come from the mergeSET. There are coinCount pairs. \n
        **Return Code:** True\n
        :type keepSET: int

        :type mergeSET: int

        :type tolerance: float

        :type Merge: bool

        :type messages: bool

        :type coinCount: int

        :type coinPoints: tuple[int]

        """
        ...

    def feCheckConstraints(self, doPERM, doLIST, bcSUM, bcSEP) -> Any:
        """
        **Description:**
            This function checks constraints in the active constraint set.
        **Remarks/Usage:**
            Automatically uses whichever constraint set is active.
        **Input:**
            **doPERM:** If True, permanent nodal constraints are included in the check.\n
            **doLIST:** If True, a summary report is listed.\n
        **Output:**
            **bcSUM:** The sum of the constraint values in each of the six degrees of freedom.\n
            **bcSUM:** The max separation of constraints. [0],[1],[2] are the max XYZ separation of the X constraints. [3],[4],[5] are the XYZ separation of the Y constraints, [6],[7],[8] are the XYZ separation of the Z constraints.\n
        **Return Code:** True\n
        :type doPERM: bool

        :type doLIST: bool

        :type bcSUM: tuple[float]

        :type bcSUM: tuple[float]

        """
        ...

    def feCheckElemDistortion(self, elemSET, doLIST, makeGROUP, chkASPECT, chkTAPER, chkANGLE, chkWARP, chkNasWARP,
                              chkALTTAPER, chkTET, chkJDet, chkComb, maxASPECT, maxTAPER, maxANGLE, maxWARP, maxNasWARP,
                              maxALTTAPER, maxTET, minJDet, minComb) -> Any:
        """
        **Description:**
            This function checks a set of elements to see if any of them are distorted.
        **Remarks/Usage:**
            This function is just like the Tools, Check, Distortion command. The checks performed and the limit values are identical to that command.
        **Input:**
            **elemSET:** The ID of a selection set that contains the IDs of the elements to check. Alternatively, if you specify a negative value, this is simply the ID of the single element to check. \n
            **doLIST:** If True, distorted elements are listed in the Messages and Lists window.\n
            **makeGROUP:** If True, a group is made of the distorted elements.\n
            **chkASPECT:** If True, the aspect ratio check is performed.\n
            **chkTAPER:** If True, element taper is checked.\n
            **chkANGLE:** If True, the element internal angle check is performed.\n
            **chkWARP:** If True, the element warping check is performed.\n
            **chkNasWARP:** If True, the alternate element taper check is performed.\n
            **chkALTTAPER:** If True, tetrahedral elements are checked for collapse.\n
            **chkTET:** If True, checks element Jacobian\n
            **chkJDet:** If True, checks for combined element distortion factor\n
            **chkComb:** Limit for aspect ratio check.\n
            **maxASPECT:** Limit for taper check.\n
            **maxTAPER:** Limit for internal angle check.\n
            **maxANGLE:** Limit for warping check.\n
            **maxWARP:** Limit for alternate element taper check.\n
            **maxNasWARP:** Limit for tet collapse check.\n
            **maxALTTAPER:** Limit for Jacobian check\n
            **maxTET:** Limit for Combined Element Distortion check\n
        **Return Code:** True\n
        :type elemSET: int

        :type doLIST: bool

        :type makeGROUP: bool

        :type chkASPECT: bool

        :type chkTAPER: bool

        :type chkANGLE: bool

        :type chkWARP: bool

        :type chkNasWARP: bool

        :type chkALTTAPER: bool

        :type chkTET: bool

        :type chkJDet: bool

        :type chkComb: float

        :type maxASPECT: float

        :type maxTAPER: float

        :type maxANGLE: float

        :type maxWARP: float

        :type maxNasWARP: float

        :type maxALTTAPER: float

        :type maxTET: float

        """
        ...

    def feCheckElemDistortion2(self, elemSET, doLIST, makeGROUP, chkASPECT, chkTAPER, chkANGLE, chkWARP, chkNasWARP,
                               chkALTTAPER, chkTET, chkJDet, chkComb, chkExpTime, maxASPECT, maxTAPER, maxANGLE,
                               maxWARP, maxNasWARP, maxALTTAPER, maxTET, minJDet, minComb, minExpTime) -> Any:
        """
        **Description:**
            This function checks a set of elements to see if any of them are distorted.
        **Remarks/Usage:**
            This function is just like the Tools, Check, Distortion command. The checks performed and the limit values are identical to that command.
        **Input:**
            **elemSET:** The ID of a selection set that contains the IDs of the elements to check. Alternatively, if you specify a negative value, this is simply the ID of the single element to check. \n
            **doLIST:** If True, distorted elements are listed in the Messages and Lists window.\n
            **makeGROUP:** If True, a group is made of the distorted elements.\n
            **chkASPECT:** If True, the aspect ratio check is performed.\n
            **chkTAPER:** If True, element taper is checked.\n
            **chkANGLE:** If True, the element internal angle check is performed.\n
            **chkWARP:** If True, the element warping check is performed.\n
            **chkNasWARP:** If True, the alternate element taper check is performed.\n
            **chkALTTAPER:** If True, tetrahedral elements are checked for collapse.\n
            **chkTET:** If True, checks element Jacobian\n
            **chkJDet:** If True, checks for combined element distortion factor\n
            **chkComb:** If True, checks for Explicit Time Step factors\n
            **chkExpTime:** Limit for aspect ratio check.\n
            **maxASPECT:** Limit for taper check.\n
            **maxTAPER:** Limit for internal angle check.\n
            **maxANGLE:** Limit for warping check.\n
            **maxWARP:** Limit for alternate element taper check.\n
            **maxNasWARP:** Limit for tet collapse check.\n
            **maxALTTAPER:** Limit for Jacobian check\n
            **maxTET:** Limit for Combined Element Distortion check\n
            **minJDet:** Limit for Explicit Time Step check\n
        **Return Code:** True\n
        :type elemSET: int

        :type doLIST: bool

        :type makeGROUP: bool

        :type chkASPECT: bool

        :type chkTAPER: bool

        :type chkANGLE: bool

        :type chkWARP: bool

        :type chkNasWARP: bool

        :type chkALTTAPER: bool

        :type chkTET: bool

        :type chkJDet: bool

        :type chkComb: bool

        :type chkExpTime: float

        :type maxASPECT: float

        :type maxTAPER: float

        :type maxANGLE: float

        :type maxWARP: float

        :type maxNasWARP: float

        :type maxALTTAPER: float

        :type maxTET: float

        :type minJDet: float

        """
        ...

    def feCheckElemFixup(self, elemSET) -> Any:
        """
        **Description:**
            This function checks and attempts to fix a set of elements to see if any of them are invalid.
        **Remarks/Usage:**
            This function is just like the fixup option in the Tools, Check, Distortion command. Checks include zero length, twisted faces, inverted solids, and element/property mismatch.
        **Input:**
            **elemSET:** The ID of a selection set that contains the IDs of the elements to check. Alternatively, if you specify a negative value, this is simply the ID of the single element to check. \n
        **Return Code:** False\n
        :type elemSET: int

        """
        ...

    def feCheckElemInterference(self, nSetID, bFreeFaceSolids, bMakeGroup) -> Any:
        """
        **Description:**
            This function checks the interferences of a give set of elements.
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** The ID of the set of elements to check.\n
            **bFreeFaceSolids:** If True, limits to free faces of solid elements. If False, all faces are checked.\n
        **Return Code:** False\n
        :type nSetID: int

        :type bFreeFaceSolids: bool

        """
        ...

    def feCheckElemInterference2(self, elSetID, bFreeFaceSolids, bMakeGroup, bIntFactor, dTol) -> Any:
        """
        **Description:**
            This function checks the interferences of a give set of elements.
        **Remarks/Usage:**
            None
        **Input:**
            **elSetID:** The ID of the set of elements to check.\n
            **bFreeFaceSolids:** If True, limits to free faces of solid elements. If False, all faces are checked.\n
            **bMakeGroup:** If True, a group will be made with the elements that interfere.\n
            **bIntFactor:** If True, use Interference Factor. If False, use Proximity Factor.\n
        **Return Code:** False\n
        :type elSetID: int

        :type bFreeFaceSolids: bool

        :type bMakeGroup: bool

        :type bIntFactor: bool

        """
        ...

    def feCheckElemNormal(self, elemSET, csysID, doLIST, swapNORMAL, autonormal, manNORMAL) -> Any:
        """
        **Description:**
            This function checks and optionally reverses element normals.
        **Remarks/Usage:**
            Only works with planar elements.
        **Input:**
            **elemSET:** The ID of a selection set that contains the IDs of the elements to check. Alternatively, if you specify a negative value, this is simply the ID of the single element to check. \n
            **csysID:** The coordinate system in which the check is done. If you are specifying manNORMAL, it must be in this coordinate system.\n
            **doLIST:** If True, swapped elements are listed in the Messages and Lists window.\n
            **swapNORMAL:** If True, elements with normals that are opposite to the desired normal are reversed.\n
            **autonormal:** If True, the desired normal direction is automatically determined from the first selected element. If False, the normal must be specified in manNORMAL.\n
            **manNORMAL:** A unit vector, with coordinates in CSys csysID, in the direction of the desired normal. Only used if autoNORMAL=False.\n
        **Return Code:** True\n
        :type elemSET: int

        :type csysID: int

        :type doLIST: bool

        :type swapNORMAL: bool

        :type autonormal: bool

        :type manNORMAL: tuple[float]

        """
        ...

    def feCheckPlanarNodes(self, nodeSET, messages, Project, tolerance, askPlane, planeBase, planeNormal) -> Any:
        """
        **Description:**
            This function checks a set of nodes to see if they are planar. The nodes can also be projected onto the plane.
        **Remarks/Usage:**
            None
        **Input:**
            **nodeSET:** The ID of a selection set that contains the IDs of the nodes to check. Alternatively, if you specify a negative value, this is simply the ID of the single node to check. \n
            **messages:** If True, status messages are written showing the nodes that are not on the plane.\n
            **Project:** If True, nodes that are not in the plane but are less than the tolerance distance out of the plane will be projected onto the plane. Nodes that are greater than the tolerance distance away from the plane will remain in their current location.\n
            **tolerance:** The maximum distance from the plane for nodes to be moved onto the plane. Only used if project=True.\n
            **askPlane:** If True, a dialog box will be displayed asking the user to pick a plane. If False, the planeBase and planeNormal will be used to specify the plane location.\n
            **planeBase:** A location (in global rectangular coordinates) on the plane.\n
            **planeNormal:** A vector that is normal to the plane.\n
        **Return Code:** False\n
        :type nodeSET: int

        :type messages: bool

        :type Project: bool

        :type tolerance: float

        :type askPlane: bool

        :type planeBase: tuple[float]

        :type planeNormal: tuple[float]

        """
        ...

    def feCheckSumForces(self, expandGEOM, doLIST, useSETS, nodeSET, elemSET, basePOINT, csysID, summedFORCES) -> Any:
        """
        **Description:**
            This function checks loads from the active load set and sums the forces around a specific location. This function is obsolete and has been superseded by feCheckSumForces2.
        **Remarks/Usage:**
            Uses the loads in the active load set.
        **Input:**
            **expandGEOM:** If True, geometric loads are expanded before the check. If not, nonexpanded geometric loads will be ignored.\n
            **doLIST:** If True, a summary report is written.\n
            **useSETS:** If True, nodeSET and elemSET must specify the nodes and elements to consider in the summation. If False, the full model is used.\n
            **nodeSET:** The ID of a selection set that contains the IDs of the nodes to check. Alternatively, if you specify a negative value, this is simply the ID of the single node to check. Only used if useSETS=True.\n
            **elemSET:** The ID of a selection set that contains the IDs of the elements to check. Alternatively, if you specify a negative value, this is simply the ID of the single element to check. Only used if useSETS=True.\n
            **basePOINT:** The coordinates of the location to sum about. Must be in global rectangular coordinates.\n
            **csysID:** The coordinate system used to report and returned the summed loads.\n
        **Return Code:** False\n
        :type expandGEOM: bool

        :type doLIST: bool

        :type useSETS: bool

        :type nodeSET: int

        :type elemSET: int

        :type basePOINT: tuple[float]

        :type csysID: int

        """
        ...

    def feCheckSumForces2(self, useBodyLoad, expandGEOM, doLIST, useSETS, nodeSET, elemSET, loaddefSET, basePOINT,
                          csysID, summedFORCES) -> Any:
        """
        **Description:**
            This function checks loads from the active load set and sums the forces around a specific location.
        **Remarks/Usage:**
            Uses the loads in the active load set.
        **Input:**
            **useBodyLoad:** If True, body loads will be included in the calculation. If not, body loads will be ignored\n
            **expandGEOM:** If True, geometric loads are expanded before the check. If not, nonexpanded geometric loads will be ignored.\n
            **doLIST:** If True, a summary report is written.\n
            **useSETS:** If True, nodeSET and elemSET OR loaddefSET must specify the nodes and elements OR load definitions to consider in the summation. To use nodeSET and elemSET, set loaddefSET = 0, otherwise, loaddefSET will be used. If False, the full model is used.\n
            **nodeSET:** The ID of a selection set that contains the IDs of the nodes to check. Alternatively, if you specify a negative value, this is simply the ID of the single node to check. Only used if useSETS=True and loaddefSET = 0\n
            **elemSET:** The ID of a selection set that contains the IDs of the elements to check. Alternatively, if you specify a negative value, this is simply the ID of the single element to check. Only used if useSETS=True and loaddefSET = 0.\n
            **loaddefSET:** The ID of a selection set that contains the IDs of the load definitions to check. Alternatively, if you specify a negative value, this is simply the ID of the single load definition. Only used if useSETS=True.\n
            **csysID:** The coordinate system used to report and returned the summed loads.\n
        **Return Code:** False\n
        :type useBodyLoad: bool

        :type expandGEOM: bool

        :type doLIST: bool

        :type useSETS: bool

        :type nodeSET: int

        :type elemSET: int

        :type loaddefSET: int

        :type csysID: int

        """
        ...

    def feCircle2Point(self, radius, Start, mid, messages) -> Any:
        """
        **Description:**
            Creates a circle in the workplane defined by two points on the circle, and the radius.
        **Remarks/Usage:**
            None
        **Input:**
            **radius:** The radius of the circle. Specify a positive number to go in a counterclockwise direction from pt1 to pt2. Specify a negative number to go in a clockwise direction. This is used to pick which of the two possible circles through the two points that you are trying to define.\n
            **Start:** The locations on the circle.\n
            **mid:** BOOL messages\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type radius: float

        :type Start: tuple[float]

        :type mid: tuple[float]

        :type messages: bool

        """
        ...

    def feCircle3Point(self, Start, mid, end, messages) -> Any:
        """
        **Description:**
            Creates a circle, in 3D space, through three points.
        **Remarks/Usage:**
            None
        **Input:**
            **Start:** The locations on the circle.\n
            **mid:** REAL8 pt3[0..2]\n
            **end:** BOOL messages\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type Start: tuple[float]

        :type mid: tuple[float]

        :type end: tuple[float]

        :type messages: bool

        """
        ...

    def feCircleCenter(self, radius, center, messages) -> Any:
        """
        **Description:**
            Creates a circle in the workplane defined a center location and the radius.
        **Remarks/Usage:**
            None
        **Input:**
            **radius:** The radius of the circle.s\n
            **center:** The location of the center of the circle.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type radius: float

        :type center: tuple[float]

        :type messages: bool

        """
        ...

    def feCircleCenterPoints(self, center, Start, mid, messages) -> Any:
        """
        **Description:**
            Creates a circle, in 3D space, using a center location, and specified by two other points.
        **Remarks/Usage:**
            None
        **Input:**
            **center:** The center of the circle.\n
            **Start:** Two additional points on the circle. pt1is used to define the radius of the circle. Both points (and the center) are used to define the plane of the circle.\n
            **mid:** BOOL messages\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type center: tuple[float]

        :type Start: tuple[float]

        :type mid: tuple[float]

        :type messages: bool

        """
        ...

    def feCircleCenterTangent(self, curveID, center, messages) -> Any:
        """
        **Description:**
            Creates a circle in the workplane that is tangent to a selected curve and uses the specified center.
        **Remarks/Usage:**
            None
        **Input:**
            **curveID:** ID of the curve that this circle will be tangent to.\n
            **center:** The center of the circle.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type curveID: int

        :type center: tuple[float]

        :type messages: bool

        """
        ...

    def feCircleConcentric(self, radius, curveID, messages) -> Any:
        """
        **Description:**
            Creates a circle in the workplane, with a specified radius, that is concentric with another arc or circle.
        **Remarks/Usage:**
            None
        **Input:**
            **radius:** The radius of the circle.\n
            **curveID:** The ID of another arc or circle - used to define the center.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type radius: float

        :type curveID: int

        :type messages: bool

        """
        ...

    def feCircleDiameter(self, Start, dia, messages) -> Any:
        """
        **Description:**
            Creates a circle in the workplane defined by two locations at the opposite ends of a diameter.
        **Remarks/Usage:**
            None
        **Input:**
            **Start:** The locations at the opposite ends of the diameter of the circle.\n
            **dia:** BOOL messages\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type Start: tuple[float]

        :type dia: tuple[float]

        :type messages: bool

        """
        ...

    def feCircleRadius(self, center, Start, messages) -> Any:
        """
        **Description:**
            Creates a circle in the workplane defined by a location at the center and one on the perimeter.
        **Remarks/Usage:**
            None
        **Input:**
            **center:** The location at the center of the circle.\n
            **Start:** A location on the perimeter of the circle.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type center: tuple[float]

        :type Start: tuple[float]

        :type messages: bool

        """
        ...

    def feCircleTangentTangent(self, curve1, curve2, radius, nearloc, messages) -> Any:
        """
        **Description:**
            Creates a circle in the workplane that is tangent to two other curves, with a specified radius.
        **Remarks/Usage:**
            None
        **Input:**
            **curve1:** IDs of the curves that this circle will be tangent to.\n
            **curve2:** REAL8 radius\n
            **radius:** The radius of the circle being created.\n
            **nearloc:** A location near the tangency. This is used to select which tangency to use when there are several possible circles that meet the tangency and radius criteria.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type curve1: int

        :type curve2: int

        :type radius: float

        :type nearloc: tuple[float]

        :type messages: bool

        """
        ...

    def feCompute2DInvariants(self, bStress, dTensor, dInvariant) -> Any:
        """
        **Description:**
            This method is used to compute Stress or Strain Invariant values for a 2D element using 3 Stress or Strain Tensor Values (Plate Top/Bottom X Normal, Plate Top/Bottom Y Normal, Plate Top/Bottom XY Shear).
        **Remarks/Usage:**
            None
        **Input:**
            **bStress:** Flag to indicate which invariant values to compute. True = Stress, False = Strain\n
            **dTensor:** Array of Stress or Strain Tensor values:\n
        **Output:**
            **dInvariant:** Returns Stress of Strain invariant values in a variant: \n
        **Return Code:** True\n
        :type bStress: bool

        :type dTensor: tuple[float]

        :type dInvariant: Any

        """
        ...

    def feCompute3DInvariants(self, bStress, dTensor, dInvariant) -> Any:
        """
        **Description:**
            This method is used to compute Stress or Strain Invariant values for a 3D element using 6 Tensor Stress or Strain Values (Solid X Normal, Solid Y Normal, Solid Z Normal, Solid XY Shear, Solid YZ Shear, and Solid ZX Shear)
        **Remarks/Usage:**
            None
        **Input:**
            **bStress:** Flag to indicate which invariant values to compute. True = Stress, False = Strain\n
            **dTensor:** Array of Stress or Strain Tensor values:\n
        **Output:**
            **dInvariant:** Returns Stress of Strain invariant values in a variant: \n
        **Return Code:** True\n
        :type bStress: bool

        :type dTensor: tuple[float]

        :type dInvariant: Any

        """
        ...

    def feConnectAuto(self, solidSET, linearTolerance, angleTolerance, strategy, bSelfConnect, bCombineAll,
                      nConnectProp, bGlued) -> Any:
        """
        **Description:**
            This function is obsolete. It is the same as calling feConnectAuto2( ) with connectType = 1. Refer to the documentation for that function for more information.
        **Return Code:** False\n
        """
        ...

    def feConnectAuto2(self, solidSET, connectTYPE, linearTolerance, angleTolerance, strategy, bSelfConnect,
                       bCombineAll, nConnectProp, bGlued) -> Any:
        """
        **Description:**
            Automatically generates connections between solids
        **Remarks/Usage:**
            None
        **Input:**
            **solidSET:** The ID of a Set object that contains the IDs of solids to connect. Alternatively, if solidSET is negative, it is the ID of a single solid to use (although this will not do anything unless bSelfConnect is also True)\n
            **connectTYPE:** The type of connections to search for 0=All, 1=Face to Face, 2=Edge to Face\n
            **linearTolerance:** The maximum distance between adjacent faces to find connections. If 0.0, then use default.\n
            **strategy:** A value between 1 and 5 that indicates the search strategy. You can also specify strategy = 0 to use the default strategy\n
            **bSelfConnect:** If True, allow connections between surfaces of the same solid\n
            **bCombineAll:** If True, connections between faces of the same two solids will be combined into a single connection\n
            **nConnectProp:** The ID of a Connection Property to be used for the connections (if nonzero, this Connection Property must exist). If specified as 0, a new default property will be created.\n
            **bGlued:** Only used if nConnectProp is 0. If True, the default property will be a Glued type, otherwise a Contact type.\n
        **Return Code:** True\n
        :type solidSET: int

        :type connectTYPE: int

        :type linearTolerance: float

        :type strategy: int

        :type bSelfConnect: bool

        :type bCombineAll: bool

        :type nConnectProp: int

        :type bGlued: bool

        """
        ...

    def feConnectLinearParabolic(self, enType, nSetID, bAddMidside, bMerge, bGroupBadMidnodes,
                                 bGroupUpdatedElements) -> Any:
        """
        **Description:**
            The method connects linear to parabolic elements.
        **Remarks/Usage:**
            None.
        **Input:**
            **enType:** The entity type for connecting selection. 5 = FT_SURFACE, 7 = FT_NODE, 8 = FT_ELEM, 39 = FT_SOLID. \n
            **nSetID:** The ID of the set of entities to use for connecting.\n
            **bAddMidside:** If True, the midside nodes are added to the linear elements. If False, the midside nodes are removed from the parabolic elements.\n
            **bMerge:** If True, nodes will be merged before updating. \n
            **bGroupBadMidnodes:** If True, disconnected nodes will be added to a group. \n
        **Return Code:** True\n
        :type enType: int

        :type nSetID: int

        :type bAddMidside: bool

        :type bMerge: bool

        :type bGroupBadMidnodes: bool

        """
        ...

    def feCoordAlongCurve(self, cuID, fromstart, cuLENGTH, xyz) -> Any:
        """
        **Description:**
            This function finds the coordinates that are located at specified distance along a curve.
        **Remarks/Usage:**
            None
        **Input:**
            **cuID:** The ID of the curve to measure along.\n
            **fromstart:** If True, then the length is measured from the start of the curve; otherwise, it is measured from the end of the curve.\n
            **cuLENGTH:** The length, along the curve, from the selected endpoint to the coordinates.\n
        **Output:**
            **xyz:** The coordinates selected. Always returned in the global rectangular coordinate system.\n
        **Return Code:** True\n
        :type cuID: int

        :type fromstart: bool

        :type cuLENGTH: float

        :type xyz: tuple[float]

        """
        ...

    def feCoordArrayTransform(self, Count, fromCSYS, toCSYS, xyz) -> Any:
        """
        **Description:**
            This function transforms an array of coordinates from one coordinate system to another.
        **Remarks/Usage:**
            NOTE: This method will not work with .NET because the xyz argument can not be used for both input and output. Use the feCoordArrayTransform2( ) method instead.
        **Input:**
            **Count:** The number of sets of coordinates in xyz. There must be 3*count entries in xyz.\n
            **fromCSYS:** The ID of the coordinate system in which the coordinates are currently specified. Specify 0 for global rectangular.\n
            **toCSYS:** The ID of the coordinate system to transform into.\n
        **Output:**
            **xyz:** On input, this array contains the original coordinates. On output, it contains the transformed coordinates, returned in the toCSYS coordinate system. Coordinates in this array must be in the order X0,Y0,Z0,X1,Y1,Z1,...,Xcount,Ycount,Zcount.\n
        **Return Code:** True\n
        :type Count: int

        :type fromCSYS: int

        :type toCSYS: int

        :type xyz: tuple[float]

        """
        ...

    def feCoordArrayTransform2(self, Count, fromCSYS, toCSYS, inXYZ, xyz) -> Any:
        """
        **Description:**
            This function transforms an array of coordinates from one coordinate system to another.
        **Remarks/Usage:**
            This method replaces the feCoordArrayTransform( ) method which will not work with .NET
        **Input:**
            **Count:** The number of sets of coordinates in xyz. There must be 3*count entries in xyz.\n
            **fromCSYS:** The ID of the coordinate system in which the coordinates are currently specified. Specify 0 for global rectangular.\n
            **toCSYS:** The ID of the coordinate system to transform into.\n
            **inXYZ:** This array contains the original coordinates that will be transformed. Coordinates in this array must be in the order X0,Y0,Z0,X1,Y1,Z1,...,Xcount,Ycount,Zcount.\n
        **Output:**
            **xyz:** Contains the transformed coordinates, returned in the toCSYS coordinate system. Coordinates in this array are in the same order as in inXYZ.\n
        **Return Code:** True\n
        :type Count: int

        :type fromCSYS: int

        :type toCSYS: int

        :type inXYZ: tuple[float]

        :type xyz: tuple[float]

        """
        ...

    def feCoordCenterOfPoints(self, vXYZ1, vXYZ2, vXYZ3, xyz) -> Any:
        """
        :type vXYZ1: Any
        :type vXYZ2: Any
        :type vXYZ3: Any
        :type xyz: Any
        """
        ...

    def feCoordColinear(self, xyz1, xyz2, xyz3, isColinear) -> Any:
        """
        **Description:**
            This function checks three sets of coordinates and determines if they are colinear.
        **Remarks/Usage:**
            None
        **Input:**
            **xyz1:** The coordinates of the first point. This, and the other coordinates, must be stored in rectangular coordinates.\n
            **xyz2:** The coordinates of the second point.\n
            **xyz3:** The coordinates of the third point.\n
        **Output:**
            **isColinear:** True if the points are colinear (within the tolerance specified internally); False otherwise.\n
        **Return Code:** False\n
        :type xyz1: tuple[float]

        :type xyz2: tuple[float]

        :type xyz3: tuple[float]

        :type isColinear: bool

        """
        ...

    def feCoordCurveCenter(self, cuID, xyz) -> Any:
        """
        **Description:**
            This function finds the coordinates that are located at the center of an arc, circle, or solid curve that forms an arc or circle.
        **Remarks/Usage:**
            This function will return FE_FAIL if you give it any other curve type except an arc, circle or solid. If you choose a solid curve, this function assumes it is an arc/circle and returns the appropriate radius. No checking is done to ensure that it is an arc or circle.
        **Input:**
            **cuID:** The ID of the curve to find the center.\n
        **Output:**
            **xyz:** The coordinates selected. Always returned in the global rectangular coordinate system.\n
        **Return Code:** True\n
        :type cuID: int

        :type xyz: tuple[float]

        """
        ...

    def feCoordCurveMidpoint(self, cuID, xyz) -> Any:
        """
        **Description:**
            This function finds the coordinates that are located at the midpoint of a curve.
        **Remarks/Usage:**
            None
        **Input:**
            **cuID:** The ID of the curve to measure along. The midpoint is halfway (along the curve) between the start and end of the curve.\n
        **Output:**
            **xyz:** The coordinates selected. Always returned in the global rectangular coordinate system.\n
        **Return Code:** True\n
        :type cuID: int

        :type xyz: tuple[float]

        """
        ...

    def feCoordFromWorkplane(self, wpXYZ, xyz) -> Any:
        """
        **Description:**
            This function converts coordinates from workplane coordinates to global rectangular coordinates.
        **Remarks/Usage:**
            None
        **Input:**
            **wpXYZ:** The original workplane coordinates. Although three coordinates can be specified, normally wpXYZ[2] is 0.0 if the location is actually on the workplane.\n
        **Output:**
            **xyz:** The coordinates selected. Always returned in the global rectangular coordinate system.\n
        **Return Code:** False\n
        :type wpXYZ: tuple[float]

        :type xyz: tuple[float]

        """
        ...

    def feCoordInSurface(self, suID, suXY, xyz) -> Any:
        """
        **Description:**
            This function returns coordinates located at the parametric coordinates of a surface.
        **Remarks/Usage:**
            None
        **Input:**
            **suID:** The ID of the surface to use.\n
            **suXY:** The parametric coordinates on the surface.\n
        **Output:**
            **xyz:** The coordinates selected. Always returned in the global rectangular coordinate system.\n
        **Return Code:** True\n
        :type suID: int

        :type suXY: tuple[float]

        :type xyz: tuple[float]

        """
        ...

    def feCoordIntersectCurves(self, cuID1, cuID2, nearXYZ, xyz) -> Any:
        """
        **Description:**
            This function finds the coordinates at the intersection of two curves.
        **Remarks/Usage:**
            None
        **Input:**
            **cuID1:** The ID of the first curve to intersect.\n
            **cuID2:** The ID of the second curve to intersect.\n
            **nearXYZ:** A location near the desired intersection. This is not used unless there are multiple intersections detected.\n
        **Output:**
            **xyz:** The coordinates selected. Always returned in the global rectangular coordinate system.\n
        **Return Code:** True\n
        :type cuID1: int

        :type cuID2: int

        :type nearXYZ: tuple[float]

        :type xyz: tuple[float]

        """
        ...

    def feCoordIntersectLines(self, infLine, pA1, pA2, pB1, pB2, pIntersect) -> Any:
        """
        **Description:**
            This function finds the coordinates at the intersection of two lines which are specified by their endpoint coordinates.
        **Remarks/Usage:**
            None
        **Input:**
            **infLine:** Set to True if you want the intersection calculation to consider the lines as infinite. Set to False if you want to only consider the line segments between the endpoints that you provided.\n
            **pA1:** The coordinates of the first point on the first line.\n
            **pA2:** The coordinates of the second point on the first line.\n
            **pA1:** The coordinates of the first point on the second line.\n
            **pA1:** The coordinates of the second point on the second line.\n
        **Output:**
            **pIntersect:** The coordinates of the intersection point.\n
        **Return Code:** True\n
        :type infLine: bool

        :type pA1: tuple[float]

        :type pA2: tuple[float]

        :type pA1: tuple[float]

        :type pA1: tuple[float]

        :type pIntersect: tuple[float]

        """
        ...

    def feCoordOnNode(self, ndID, xyz) -> Any:
        """
        **Description:**
            This function returns the coordinates of a node.
        **Remarks/Usage:**
            None
        **Input:**
            **ndID:** The ID of the node to locate.\n
        **Output:**
            **xyz:** The coordinates selected. Always returned in the global rectangular coordinate system.\n
        **Return Code:** True\n
        :type ndID: int

        :type xyz: tuple[float]

        """
        ...

    def feCoordOnPoint(self, ptID, xyz) -> Any:
        """
        **Description:**
            This function returns the coordinates of a point.
        **Remarks/Usage:**
            None
        **Input:**
            **ptID:** The ID of the point to locate.\n
        **Output:**
            **xyz:** The coordinates selected. Always returned in the global rectangular coordinate system.\n
        **Return Code:** True\n
        :type ptID: int

        :type xyz: tuple[float]

        """
        ...

    def feCoordOntoCurve(self, cuID, fromxyz, xyz) -> Any:
        """
        **Description:**
            This function projects coordinates onto a curve.
        **Remarks/Usage:**
            None
        **Input:**
            **cuID:** The ID of the curve to project onto.\n
            **fromxyz:** The original location that is to be projected onto the curve.\n
        **Output:**
            **xyz:** The coordinates selected. Always returned in the global rectangular coordinate system.\n
        **Return Code:** True\n
        :type cuID: int

        :type fromxyz: tuple[float]

        :type xyz: tuple[float]

        """
        ...

    def feCoordOntoLine(self, xyz, p1, p2, xyzLine) -> Any:
        """
        **Description:**
            This function takes a coordinate location and projects it onto a line specified by two endpoint locations.
        **Remarks/Usage:**
            All coordinates and vector components must be specified in the same rectangular coordinate system - normally global rectangular. The line which the coordinates are projected onto is considered to be infinite.
        **Input:**
            **xyz:** The original unprojected coordinates - must be specified in rectangular coordinates.\n
            **p1:** The first set of coordinates along the line.\n
            **p2:** The second set of coordinates along the line.\n
        **Output:**
            **xyz:** The projected coordinates.\n
        **Return Code:** False\n
        :type xyz: tuple[float]

        :type p1: tuple[float]

        :type p2: tuple[float]

        :type xyz: tuple[float]

        """
        ...

    def feCoordOntoPlane(self, xyz, projDir, planePt, planeNorm, xyzPlane) -> Any:
        """
        **Description:**
            This function takes a coordinate location and projects it along a vector onto a plane.
        **Remarks/Usage:**
            All coordinates and vector components must be specified in the same rectangular coordinate system - normally global rectangular.
        **Input:**
            **xyz:** The original unprojected coordinates - must be specified in rectangular coordinates.\n
            **projDir:** The components of the vector to project along.\n
            **planePt:** The coordinates of any point on the plane.\n
            **planeNorm:** The components of the normal vector of the plane.\n
        **Output:**
            **xyz:** The projected coordinates.\n
        **Return Code:** True\n
        :type xyz: tuple[float]

        :type projDir: tuple[float]

        :type planePt: tuple[float]

        :type planeNorm: tuple[float]

        :type xyz: tuple[float]

        """
        ...

    def feCoordOntoSurface(self, suID, fromxyz, xyz) -> Any:
        """
        **Description:**
            This function projects coordinates onto a selected surface.
        **Remarks/Usage:**
            None
        **Input:**
            **suID:** The ID of the surface to project onto.\n
            **fromxyz:** The original coordinate which will be projected.\n
        **Output:**
            **xyz:** The coordinates selected. Always returned in the global rectangular coordinate system.\n
        **Return Code:** True\n
        :type suID: int

        :type fromxyz: tuple[float]

        :type xyz: tuple[float]

        """
        ...

    def feCoordPick(self, dlgTITLE, xyz) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to pick or enter coordinates.
        **Remarks/Usage:**
            The default coordinate values that are displayed when the dialog is displayed can be set using the global parameters Info_DefaultX, Info_DefaultY, and Info_DefaultZ before calling this function.
        **Input:**
            **dlgTITLE:** A string that specifies a title to be added to the dialog box title.\n
        **Output:**
            **xyz:** The coordinates selected. Always returned in the global rectangular coordinate system.\n
        **Return Code:** True\n
        :type dlgTITLE: str

        :type xyz: tuple[float]

        """
        ...

    def feCoordPickByMethod(self, method, dlgTITLE, xyz) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to pick or enter coordinates. Same as feCoordPick, but lets you specify the initial dialog box method
        **Remarks/Usage:**
            The default coordinate values that are displayed when the dialog is displayed can be set using the global parameters Info_DefaultX, Info_DefaultY, and Info_DefaultZ before calling this function.
        **Input:**
            **method:** The initial dialog box method. Refer to Coordinate Dialog Methods for possible values.\n
            **dlgTITLE:** A string that specifies a title to be added to the dialog box title.\n
        **Output:**
            **xyz:** The coordinates selected. Always returned in the global rectangular coordinate system.\n
        **Return Code:** True\n
        :type method: int

        :type dlgTITLE: str

        :type xyz: tuple[float]

        """
        ...

    def feCoordPlaneIntersect(self, baseA, normA, baseB, normB, baseC, normC, baseV) -> Any:
        """
        **Description:**
            This function finds the coordinate location at the intersection of three planes.
        **Remarks/Usage:**
            All coordinates and vector components must be specified in the same rectangular coordinate system - normally global rectangular.
        **Input:**
            **baseA:** The coordinates of a point on the first plane.\n
            **normA:** The components of the normal of the first plane.\n
            **baseB:** The coordinates of a point on the second plane.\n
            **normB:** The components of the normal of the second plane.\n
            **baseC:** The coordinates of a point on the third plane.\n
            **normC:** The components of the normal of the third plane.\n
        **Output:**
            **baseV:** The coordinates at the intersection location.\n
        **Return Code:** True\n
        :type baseA: tuple[float]

        :type normA: tuple[float]

        :type baseB: tuple[float]

        :type normB: tuple[float]

        :type baseC: tuple[float]

        :type normC: tuple[float]

        :type baseV: tuple[float]

        """
        ...

    def feCoordRotate(self, xyz, angle, origin, Axis, xyzROT) -> Any:
        """
        **Description:**
            This function takes a coordinate location and rotates it through a prescribed angle about a vector.
        **Remarks/Usage:**
            All coordinates and vector components must be specified in the same rectangular coordinate system - normally global rectangular.
        **Input:**
            **xyz:** The original unrotated coordinates - must be specified in rectangular coordinates.\n
            **angle:** The angle of rotation.\n
            **origin:** The coordinates at the origin/base of the rotation axis vector.\n
            **Axis:** The components of the rotation axis vector.\n
        **Output:**
            **xyz:** The rotated coordinates.\n
        **Return Code:** False\n
        :type xyz: tuple[float]

        :type angle: float

        :type origin: tuple[float]

        :type Axis: tuple[float]

        :type xyz: tuple[float]

        """
        ...

    def feCoordSurfaceIntersect(self, cuID, suID, nearXYZ, xyz) -> Any:
        """
        **Description:**
            This function returns coordinates located at the intersection of a curve and surface.
        **Remarks/Usage:**
            None
        **Input:**
            **cuID:** The ID of the curve to use.\n
            **suID:** The ID of the surface to use.\n
        **Output:**
            **xyz:** The coordinates selected. Always returned in the global rectangular coordinate system.\n
        **Return Code:** True\n
        :type cuID: int

        :type suID: int

        :type xyz: tuple[float]

        """
        ...

    def feCoordToDirCos(self, origin, xaxis, xyplane, dircos) -> Any:
        """
        **Description:**
            This function converts three coordinates into a 3x3 direction cosine matrix.
        **Remarks/Usage:**
            All coordinates must be specified in rectangular coordinates. The direction cosine matrix is relative to whatever coordinate system the original points were specified in.
        **Input:**
            **origin:** The location at the origin.\n
            **xaxis:** A location along the positive X axis.\n
            **xyplane:** A location in the positive quadrant of the XY plane.\n
        **Output:**
            **dircos:** The 3x3 direction cosine matrix. Data is stored in row-order. [0,0]=[0], [0,1]=[1], [0,2]=[2], [1,0]=3 ... [2,2]=[8]\n
        **Return Code:** False\n
        :type origin: tuple[float]

        :type xaxis: tuple[float]

        :type xyplane: tuple[float]

        :type dircos: tuple[float]

        """
        ...

    def feCoordToWorkplane(self, xyz, wpXYZ) -> Any:
        """
        **Description:**
            This function converts coordinates from Global Rectangular coordinates to Workplane Coordinates.
        **Remarks/Usage:**
            None
        **Input:**
            **xyz:** The original coordinates. Must be specified in global rectangular coordinates.\n
        **Output:**
            **wpXYZ:** The workplane coordinates. Three coordinates are returned. wpXYZ[2] is the elevation off of the workplane. Ignore this value to get the coordinates in the workplane.\n
        **Return Code:** False\n
        :type xyz: tuple[float]

        :type wpXYZ: tuple[float]

        """
        ...

    def feCoordTransform(self, fromCSYS, fromxyz, toCSYS, xyz) -> Any:
        """
        **Description:**
            This function transforms coordinates from one coordinate system to another.
        **Remarks/Usage:**
            None
        **Input:**
            **fromCSYS:** The ID of the coordinate system in which the fromXYZ coordinates are currently specified. Specify 0 for global rectangular.\n
            **fromxyz:** The coordinates to transform, specified in fromCSYS.\n
            **toCSYS:** The ID of the coordinate system to transform into.\n
        **Output:**
            **xyz:** The transformed coordinates, returned in the toCSYS coordinate system. The two sets of coordinates MAY NOT be specified as the same variable.\n
        **Return Code:** True\n
        :type fromCSYS: int

        :type fromxyz: tuple[float]

        :type toCSYS: int

        :type xyz: tuple[float]

        """
        ...

    def feCoordVectorPlaneIntersect(self, xyz, projDir, planePt, planeNorm, xyzPlane) -> Any:
        """
        **Description:**
            This function finds the coordinate location at the intersection of a vector and a plane.
        **Remarks/Usage:**
            All coordinates and vector components must be specified in the same rectangular coordinate system - normally global rectangular.
        **Input:**
            **xyz:** The coordinates of a point on the vector\n
            **projDir:** The components of direction along the vector\n
            **planePt:** The coordinates of a point on the plane.\n
            **planeNorm:** The components of the normal of the plane.\n
        **Output:**
            **xyzPlane:** The coordinates at the intersection location.\n
        **Return Code:** True\n
        :type xyz: tuple[float]

        :type projDir: tuple[float]

        :type planePt: tuple[float]

        :type planeNorm: tuple[float]

        :type xyzPlane: tuple[float]

        """
        ...

    def feCreateFunction(self, nNumAvailableTypes, AvailableTypes, nID) -> Any:
        """
        **Description:**
            Displays the standard Create Function dialog box and has an option to restrict which function types
        **Remarks/Usage:**
            None
        **Input:**
            **nNumAvailableTypes:** The number of different function types that will be shown in the Type drop-down list. Use a value of 0\n
            **AvailableTypes:** [0..nNumberAvaliableTypes-1]\n
        **Output:**
            **nID:** ID of newly created function.\n
        **Return Code:** True\n
        :type nNumAvailableTypes: int

        :type AvailableTypes: int

        :type nID: int

        """
        ...

    def feCrossSectionReport(self, nPropID, bDoEndA, bCopyToClipboard, fName, nFileFormat) -> Any:
        """
        **Description:**
            Copies a picture of the cross-section and the section property information from the Cross Section Definitiondialog box to the clipboard for a specified bar, beam, or curved beam property. Alternatively, the picture and section information can be saved to a file.
        **Remarks/Usage:**
            None
        **Input:**
            **nPropID:** ID of bar, beam, or curved beam property\n
            **bDoEndA:** When True, copies or saves the picture and section properties for End A of the selected property. When False, copies or saves the picture and section properties of End B\n
            **bCopyToClipboard:** When True, copies picture and information to the clipboard. When False, saves picture and information to a file using the format selected in nFileFormat.\n
            **fName:** The complete filename of the picture file to save the picture and section information.\n
            **nFileFormat:** Format of save picture file: 0=Bitmap (FPM2_BMP), 1=JPEG (FPM2_JPEG), 2=GIF (FPM2_GIF), 3=TIFF (FPM2_TIF), 4=PNG (FPM2_PNG).\n
        **Return Code:** True\n
        :type nPropID: int

        :type bDoEndA: bool

        :type bCopyToClipboard: bool

        :type fName: str

        :type nFileFormat: int

        """
        ...

    def feCurveBreak(self, curveID, nearloc) -> Any:
        """
        **Description:**
            Breaks a curve at a specified location.
        **Remarks/Usage:**
            This call mimics the behavior of the Modify, Break, At Location command
        **Input:**
            **nearloc:** The coordinates, in global rectangular, of the location at which the curve will be broken. The location does not have to lie on the curve; it is automatically projected to the break location.\n
        **Return Code:** True\n
        :type nearloc: tuple[float]

        """
        ...

    def feCurveChamfer(self, len1, len2, curve1, curve2, nearloc, update1, update2) -> Any:
        """
        **Description:**
            Chamfers the intersection of two curves.
        **Remarks/Usage:**
            This call mimics the behavior of the Modify, Chamfer command.
        **Input:**
            **len2:** The chamfer length along curve2.\n
            **curve1:** The ID of the first curve to be chamfered.\n
            **curve2:** The ID of the second curve to be chamfered.\n
            **nearloc:** The coordinates, in global rectangular, of the location near which the curves will be chamfered. Specification of this location is very important. It chooses the quadrant of the intersection that is going to be chamfered.\n
            **update1:** If True, curve1 is extended or trimmed to the fillet location. If False, curve1 is left unchanged.\n
            **update2:** If True, curve2 is extended or trimmed to the fillet location. If False, curve2 is left unchanged.\n
        **Return Code:** True\n
        :type len2: float

        :type curve1: int

        :type curve2: int

        :type nearloc: tuple[float]

        :type update1: bool

        :type update2: bool

        """
        ...

    def feCurveExtend(self, curveID, nearloc) -> Any:
        """
        **Description:**
            Extends a curve to a specified location.
        **Remarks/Usage:**
            This call mimics the behavior of the Modify, Extend command
        **Input:**
            **nearloc:** The coordinates, in global rectangular, of the location to which the curve will be extended. The location does not have to lie on the extended curve; it is automatically projected as the curve is extended.\n
        **Return Code:** True\n
        :type nearloc: tuple[float]

        """
        ...

    def feCurveFillet(self, radius, curve1, curve2, nearloc, update1, update2) -> Any:
        """
        **Description:**
            Fillets the intersection of two curves.
        **Remarks/Usage:**
            This call mimics the behavior of the Modify, Fillet command.
        **Input:**
            **curve1:** The ID of the first curve to be filleted.\n
            **curve2:** The ID of the second curve to be filleted.\n
            **nearloc:** The coordinates, in global rectangular, of the location near which the curves will be filleted. Specification of this location is very important. It chooses the quadrant of the intersection that is going to be filleted.\n
            **update1:** If True, curve1 is extended or trimmed to the fillet location. If False, curve1 is left unchanged.\n
            **update2:** If True, curve2 is extended or trimmed to the fillet location. If False, curve2 is left unchanged.\n
        **Return Code:** True\n
        :type curve1: int

        :type curve2: int

        :type nearloc: tuple[float]

        :type update1: bool

        :type update2: bool

        """
        ...

    def feCurveIntersectSolids(self, solid1, solid2) -> Any:
        """
        **Description:**
            This method creates curves along the intersections of two solids. It can also be used to intersect two solid surfaces.
        **Remarks/Usage:**
            If feCurveUpdateSurfaces is True, the surfaces of the solids will be split at the intersection curves.
        **Input:**
            **solid1, solid2:** The IDs of the two solids to intersect. These solids can be regular solids, or sheet solids (solids with one or more surfaces, but no enclosed volume).\n
        **Return Code:** True\n
        :type solid1: int

        :type solid2: int

        """
        ...

    def feCurveJoin(self, curve1, curve2, nearloc, update1, update2) -> Any:
        """
        **Description:**
            Extends or trims two curves to their intersection location.
        **Remarks/Usage:**
            This call mimics the behavior of the Modify, Join command. Also, do not set update1=update2=False. In this case, nothing will be changed.
        **Input:**
            **curve2:** The ID of the second curve to be joined.\n
            **nearloc:** The coordinates, in global rectangular, of the location near which the curves will be joined. This helps to resolve ambiguities of which end of the curves to trim/extend, and to choose between multiple intersections of the curves.\n
            **update1:** If True, curve1 is extended or trimmed to the join location. If False, curve1 is left unchanged.\n
            **update2:** If True, curve2 is extended or trimmed to the join location. If False, curve2 is left unchanged.\n
        **Return Code:** True\n
        :type curve2: int

        :type nearloc: tuple[float]

        :type update1: bool

        :type update2: bool

        """
        ...

    def feCurveOffsetCurveWasher(self, curveSET, faceID, nMode, bAutoSelect, bSaveSplit, bExtend, dOffset) -> Any:
        """
        **Description:**
            This method is obsolete and should no longer be used. It has been replaced by feCurveOffsetCurveWasher2. Creates curves by offsetting selected curves on a surface
        **Remarks/Usage:**
            None
        **Input:**
            **curveSET:** The ID of the set of existing curves to create a washer or offset curve.\n
            **faceID:** The ID of the surface to offset the curves on.\n
            **nMode:** Offset Type: 0 = Curve, 1 = Washer\n
            **bAutoSelect:** Offset Only: Flag to automatically offset the selected curves to all of the surfaces connected to those curves\n
            **bSaveSplit:** Flag to keep split lines used when creating washer or offset curves.\n
            **bExtend:** Offset Only: Flag to extend offset curves to closest edge.\n
            **dOffset:** Distance to offset curves.\n
        **Return Code:** True\n
        :type curveSET: int

        :type faceID: int

        :type nMode: int

        :type bAutoSelect: bool

        :type bSaveSplit: bool

        :type bExtend: bool

        :type dOffset: float

        """
        ...

    def feCurveOffsetCurveWasher2(self, curveSET, faceID, nMode, bAutoSelect, bSaveSplit, bExtend, dOffset,
                                  nOffsetmode) -> Any:
        """
        **Description:**
            Creates curves by offsetting selected curves on a surface
        **Remarks/Usage:**
            None
        **Input:**
            **curveSET:** The ID of the set of existing curves to create a washer or offset curve.\n
            **faceID:** The ID of the surface to offset the curves on.\n
            **nMode:** Offset Type: 0 = Curve, 1 = Washer\n
            **bAutoSelect:** Offset Only: Flag to automatically offset the selected curves to all of the surfaces connected to those curves\n
            **bSaveSplit:** Flag to keep split lines used when creating washer or offset curves.\n
            **bExtend:** Offset Only: Flag to extend offset curves to closest edge.\n
            **dOffset:** Distance to offset curves or washer factor\n
            **nOffsetmode:** nMode=0 - nOffMode: 1 = Offset Distance\n
        **Return Code:** True\n
        :type curveSET: int

        :type faceID: int

        :type nMode: int

        :type bAutoSelect: bool

        :type bSaveSplit: bool

        :type bExtend: bool

        :type dOffset: float

        :type nOffsetmode: int

        """
        ...

    def feCurvePad(self, nCurve, dValue, enPadOffsetType, enPadAlignment, bPadAddWasher, nPadAlignCurve,
                   bSetupMappedMeshing, alignVEC) -> Any:
        """
        **Description:**
            Creates a rectangular Pad around a circular hole.
        **Remarks/Usage:**
            None
        **Input:**
            **nCurve:** The ID of the set of existing curves to create a pad.\n
            **dValue:** Factor or Offset distance for Pad creation.\n
            **bPadAddWasher:** Flag to add washer around circular hole.\n
            **bSetupMappedMeshing:** Flag to set up mapped meshing approaches and sizing.\n
            **alignVEC:** The components of the vector to align pad. Ignored unless enPadAlignment = FPAD_VECTOR. \n
        **Return Code:** True\n
        :type nCurve: int

        :type dValue: float

        :type bPadAddWasher: bool

        :type bSetupMappedMeshing: bool

        :type alignVEC: tuple[float]

        """
        ...

    def feCurveParametricOnSurface(self, surfID, uDir, location, messages) -> Any:
        """
        **Description:**
            Creates a curve on a surface along one of the parametric directions of the surface.
        **Remarks/Usage:**
            If feCurveUpdateSurfaces is True, the surface will be split at the parametric curve.
        **Input:**
            **surfID:** The ID of the surface used to define the curve.\n
            **uDir:** If True, the curve will be along the surface U parametric direction. If False, the V parametric direction will be used.\n
            **location:** A location that the curve will pass through. This location is projected onto the surface and used to find the parametric value used to define the curve.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type surfID: int

        :type uDir: bool

        :type location: tuple[float]

        :type messages: bool

        """
        ...

    def feCurveProjectCurvesOntoSurfaces(self, cuSetID, suSetID, extendMode, attrib_trans) -> Any:
        """
        **Description:**
            This method mimics the functionality of the Meshing Toolbox's Geometry Editing Tool - Project Curve Operation, which projects any number of selected curves onto any number of selected surfaces
        **Remarks/Usage:**
            None
        **Input:**
            **cuSetID:** The ID of the set of existing curves to project. Alternatively, specify as a negative value to project a single curve.\n
            **suSetID:** The ID of the set of existing surfaces to project onto. Alternatively, specify as a negative value to project onto a single surface.\n
            **extendMode:** Specifies the Imprint Mode, 0=Impint (no extension of curves), 1=Imprint, Extend, 2=Imprint, Extend, Clean\n
            **attrib_trans:** If True, will assign any meshing attributes on the curves in cuSetID and assign them to the new curves created by the projection.\n
        **Return Code:** False\n
        :type cuSetID: int

        :type suSetID: int

        :type extendMode: int

        :type attrib_trans: bool

        """
        ...

    def feCurveProjectOntoSolid(self, projectNormal, along, solidID, curveSET, messages) -> Any:
        """
        **Description:**
            Creates curves by projecting one or more curves onto a solid.
        **Remarks/Usage:**
            If feCurveUpdateSurfaces is True, the surfaces of the solids will be split at the projected curves.
        **Input:**
            **projectNormal:** If True, the projection is done to the closest location on the solid. If False, the projection is along the along vector.\n
            **along:** The components of the vector to project along. Ignored unless projectNormal is False.\n
            **solidID:** The ID of the solid to project onto.\n
            **curveSET:** The ID of the set of existing curves to project onto the solid. Specify as a negative value to project a single curve.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type projectNormal: bool

        :type along: tuple[float]

        :type solidID: int

        :type curveSET: int

        :type messages: bool

        """
        ...

    def feCurveProjectOntoSurfaces(self, projectNormal, along, faceSET, curveSET, messages) -> Any:
        """
        **Description:**
            Creates curves by projecting one or more curves onto one or more surfaces.
        **Remarks/Usage:**
            If feCurveUpdateSurfaces is True, the surfaces will be split at the projected curves.
        **Input:**
            **projectNormal:** If True, the projection is done to the closest location on the surface. If False, the projection is along the along vector.\n
            **along:** The components of the vector to project along. Ignored unless projectNormal is False.\n
            **faceSET:** The ID of the set of existing surfaces to project onto. Specify as a negative value to project onto a single surface.\n
            **curveSET:** The ID of the set of existing curves to project onto the surfaces. Specify as a negative value to project a single curve.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type projectNormal: bool

        :type along: tuple[float]

        :type faceSET: int

        :type curveSET: int

        :type messages: bool

        """
        ...

    def feCurveSlice(self, solidID, planeBase, planeNormal, planeX) -> Any:
        """
        **Description:**
            Creates curves by slicing a solid with a plane.
        **Remarks/Usage:**
            If feCurveUpdateSurfaces is True, the surfaces of the solid will be split at the slicing plane. This does not slice the solid into two solids. It simply splits the surfaces.
        **Input:**
            **solidID:** The ID of the solid being sliced.\n
            **planeBase:** Any location that lies on the plane used to slice the solid.\n
            **planeNormal:** The components of a vector that is normal to the plane.\n
            **planeX:** The components of a reference vector that lies in the plane - must be perpendicular to planeNORMAL.\n
        **Return Code:** True\n
        :type solidID: int

        :type planeBase: tuple[float]

        :type planeNormal: tuple[float]

        :type planeX: tuple[float]

        """
        ...

    def feCurveSolidToFEMAP(self, cuSetID) -> Any:
        """
        **Description:**
            Creates new FEMAP curves with FEMAP points matching the selected Parasolid curves.
        **Remarks/Usage:**
            If both Parasolid curves and FEMAP curves are selected, the FEMAP curves will be ignored.
        **Input:**
            **cuSetID:** ID of set containing Parasolid curves. Alternatively, specify a negative value to choose the ID of a single Parasolid Curve.\n
        **Return Code:** True\n
        :type cuSetID: int

        """
        ...

    def feCurveSplitEdgeToEdge(self, nLongEdge, nShortEdgeSet) -> Any:
        """
        **Description:**
            Splits a surface between a long edge and the endpoints of one or more selected other edges
        **Remarks/Usage:**
            The surface is split from the endpoints of the selected edges to point to the closest location on the long edge. All edges must lie on the same surface.
        **Input:**
            **nLongEdge:** The ID of the edge to be split\n
            **nShortEdgeSet:** The ID of a Set that contains the IDs of the edges whose endpoints will be used to split the long edge and associated surface. Alternatively, specify a negative value to choose the ID of a single short edge.\n
        **Return Code:** True\n
        :type nLongEdge: int

        :type nShortEdgeSet: int

        """
        ...

    def feCurveSplitPointToEdge(self, nPtA, nCuID) -> Any:
        """
        **Description:**
            Splits a surface between a point and an edge
        **Remarks/Usage:**
            The surface is split from the point to the closest location on the curve. Both the point and the edge must lie on the same surface.
        **Input:**
            **nPtA:** The points to split the surface from\n
            **nCuID:** The ID of the curve to split to\n
        **Return Code:** True\n
        :type nPtA: int

        :type nCuID: int

        """
        ...

    def feCurveSplitPointToPoint(self, nPtA, nPtB) -> Any:
        """
        **Description:**
            Splits a surface between two selected points
        **Remarks/Usage:**
            Both points must be on the same surface.
        **Input:**
            **nPtA, nPtB:** The two points to split the surface between\n

        **Return Code:** True\n
        :type nPtA: int

        :type nPtB: int

        """
        ...

    def feCurveTrim(self, curveID, TrimID, nearloc, extend) -> Any:
        """
        **Description:**
            Trims a curve to its intersection with another curve.
        **Remarks/Usage:**
            This call mimics the behavior of the Modify, Trim command
        **Input:**
            **TrimID:** The ID of the curve to use as the trimming boundary.\n
            **nearloc:** The coordinates, in global rectangular, of the location near which the curve will be trimmed. This helps to resolve ambiguities of which end of the curve to trim, and to choose between multiple intersections of the curves.\n
            **extend:** If True, the trim curve is considered infinite and intersections are found anywhere along its length. If False, intersections must be between the curve endpoints.\n
        **Return Code:** True\n
        :type TrimID: int

        :type nearloc: tuple[float]

        :type extend: bool

        """
        ...

    def feCurveUpdateSurfaces(self, update, messages) -> Any:
        """
        **Description:**
            This method sets the flag that decides whether the Curves from Surfaces methods will update their underlying surface.
        **Remarks/Usage:**
            None
        **Input:**
            **update:** Set to True to update/split the underlying surfaces as curves are projected or created on the surfaces. If False, then the curves will be created at the same locations, but the surfaces will remain unchanged.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** False\n
        :type update: bool

        :type messages: bool

        """
        ...

    def feCurvesBreakAtIntersections(self, curveSET) -> Any:
        """
        **Description:**
            Breaks all curves in a given set at all intersections between the curves in the set.
        **Remarks/Usage:**
            This call mimics the behavior of the Modify, Break, At All Intersections command
        **Return Code:** True\n
        """
        ...

    def feDelete(self, entityTYPE, entitySET) -> Any:
        """
        **Description:**
            This method deletes selected entities from your model.
        **Remarks/Usage:**
            Entities will only be deleted if they are not referenced by other entities. You should always delete entities in the order of their references to each other in the model. For example, delete elements first, properties next, and materials last.
        **Input:**
            **entityTYPE:** The entity type to delete:\n
            **entitySET:** The ID of the set containing the IDs of the entities to delete.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        """
        ...

    def feDeleteAll(self, geometry, Mesh, Output, confirm) -> Any:
        """
        **Description:**
            This method deletes entire portions of your model - either geometry or the finite element mesh.
        **Remarks/Usage:**
            Coordinate systems will only be deleted if both geometry and the mesh are deleted.
        **Input:**
            **geometry:** If True, all geometry in the model will be deleted - points, curves, surfaces, solids, volumes, etc.\n
            **Mesh:** If True, the entire finite element mesh, including all loads, constraints, properties, all results, etc. will be deleted.\n
            **Output:** If True, all results will be deleted. If you set mesh=True, then this is ignored and results will always be deleted.\n
            **confirm:** If False, the user will be asked to confirm the delete operation. If True, the selected portions of the model will be deleted without warning.\n
        **Return Code:** False\n
        :type geometry: bool

        :type Mesh: bool

        :type Output: bool

        :type confirm: bool

        """
        ...

    def feDeleteConstraints(self, bcSetID, entityTYPE, entitySET, deleteBC, deleteBE) -> Any:
        """
        **Description:**
            This method deletes selected constraints from your model.
        **Remarks/Usage:**
            None
        **Input:**
            **bcSetID:** The ID of the Constraint Set containing the constraints to be deleted.\n
            **entityTYPE:** The entity type of the entities specified in entitySET. Constraints will be deleted from these entities. Valid values are : 3=Point, 4=Curve, 5=Surface, 7=Node\n
            **entitySET:** The ID of the set containing the IDs of the entities where constraints will be deleted. If entitySET<0, it is the ID of the single entity where constraints will be deleted.\n
            **deleteBC:** If True, normal constraints will be deleted\n
            **deleteBE:** If True, constraint equations will be deleted\n
        **Return Code:** True\n
        :type bcSetID: int

        :type entityTYPE: int

        :type entitySET: int

        :type deleteBC: bool

        :type deleteBE: bool

        """
        ...

    def feDeleteLoads(self, loadSetID, entityTYPE, entitySET, loadType) -> Any:
        """
        **Description:**
            This method deletes selected loads from your model.
        **Remarks/Usage:**
            None
        **Input:**
            **loadSetID:** The ID of the Load Set containing the loads to be deleted.\n
            **entityTYPE:** The entity type of the entities specified in entitySET. Loads of loadTYPE will be deleted from these entities. Valid values are : 3=Point, 4=Curve, 5=Surface, 7=Node, 8=Element\n
            **entitySET:** The ID of the set containing the IDs of the entities where loads will be deleted. If entitySET<0, it is the ID of the single entity where loads will be deleted.\n
            **loadType:** The type of loads to delete. Any=-1, Nodal Heat Gen=2, Nodal Heat Flux=4, Force=16, Displacement=32, Acceleration=64, LineLoad=128, Pressure=256, Elem Heat Gen=512, Elem Heat Flux=1024, Velocity=2048, Nodal Temp=4096, Elem Temp=8192, Convection=16384, Radiation=32768, Transient=65536, Fluid Pressure=131072, Fluid Tracking = 262144, Fluid Unknown=524288, Fluid Slip=1048576, Fluid Fan=2097152, Fluid Periodic=4194304\n
        **Return Code:** True\n
        :type loadSetID: int

        :type entityTYPE: int

        :type entitySET: int

        :type loadType: int

        """
        ...

    def feDeleteMesh(self, enNodeOrElem, elemSET, bDeleteUnused) -> Any:
        """
        **Description:**
            This method deletes entire meshes from your model.
        **Remarks/Usage:**
            If you specify elements, those will be deleted. If you specify nodes, any element referencing any of the specified nodes will be deleted.
        **Input:**
            **enNodeOrElem:** Must be either 7=Node or 8=Element\n
            **elemSET:** The ID of the set containing the IDs of the nodes/elements which define the mesh to be deleted. If entitySET<0, it is the ID of the single entity where the mesh will be deleted.\n
            **bDeleteUnused:** If True, then any unused Properties and Materials will also be deleted.\n
        **Return Code:** True\n
        :type enNodeOrElem: int

        :type elemSET: int

        :type bDeleteUnused: bool

        """
        ...

    def feDeleteOutput2V2(self, outputSetSET, vectorSET) -> Any:
        """
        **Description:**
            This method deletes selected output vectors from selected output sets. This method replaces feDeleteOutput2. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            This function offers the same capabilities as the Delete, Output, Vectorcommand in the User Interface. It may be helpful to use the AddComponentOutputVectors (Section 4.6.2.36, "AddComponentOutputVectorsV2"), AddSimilarOutputVectors (Section 4.6.2.37, "AddSimilarOutputVectorsV2"), and/or AddComplexOutputVectors (Section 4.6.2.38, "AddComplexOutputVectorsV2") methods on the Set Object to select all desired output vectors.
        **Input:**
            **outputSetSET:** The ID of the set containing the IDs of the output sets to delete output vectors from. Alternatively, if you specify a negative value, this is simply the ID of a single output set to delete output vectors from. \n
            **vectorSET:** The ID of the set containing the IDs of the output vectors to delete. Alternatively, if you specify a negative value, this is simply the ID of a single output vector to delete. \n
        **Return Code:** False\n
        :type outputSetSET: int

        :type vectorSET: int

        """
        ...

    def feDeleteOutputEntryV2(self, setSET, vectorSET, nodeSET, elemSET) -> Any:
        """
        **Description:**
            This method deletes selected output on individual nodes and/or elements from selected output vectors in selected output sets. This method replaces feDeleteOutputEntry. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            This function offers the same capabilities as the Delete, Output, Entrycommand in the User Interface. It may be helpful to use the AddComponentOutputVectors (Section 4.6.2.36, "AddComponentOutputVectorsV2"), AddSimilarOutputVectors (Section 4.6.2.37, "AddSimilarOutputVectorsV2"), and/or AddComplexOutputVectors (Section 4.6.2.38, "AddComplexOutputVectorsV2") methods on the Set Object to select all desired output vectors.
        **Input:**
            **vectorSET:** The ID of the set containing the IDs of the output vectors. Alternatively, if you specify a negative value, this is simply the ID of a single output vector. \n
            **elemSET:** The ID of the set containing the IDs of the elements to delete output from. Alternatively, if you specify a negative value, this is simply the ID of a single element to delete output from.\n
        **Return Code:** False\n
        :type vectorSET: int

        :type elemSET: int

        """
        ...

    def feDeleteOutputV2(self, outputSetID, vectorSET) -> Any:
        """
        **Description:**
            This method deletes selected output vectors from a single output set. To delete output vectors from any number of selected output sets, use feDeleteOutput2. This method replaces feDeleteOutput. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            It may be helpful to use the AddComponentOutputVectors (Section 4.6.2.36, "AddComponentOutputVectorsV2"), AddSimilarOutputVectors (Section 4.6.2.37, "AddSimilarOutputVectorsV2"), and/or AddComplexOutputVectors (Section 4.6.2.38, "AddComplexOutputVectorsV2") methods on the Set Object to select all desired output vectors.
        **Input:**
            **outputSetID:** The ID of the Output Set from which to delete the vectors\n
            **vectorSET:** The ID of the set containing the IDs of the output vectors to delete. Alternatively, if you specify a negative value, this is simply the ID of a single output vector to delete. \n
        **Return Code:** False\n
        :type outputSetID: int

        :type vectorSET: int

        """
        ...

    def feDeleteToolbar(self, BarName) -> Any:
        """
        **Description:**
            Deletes a toolbar
        **Remarks/Usage:**
            None
        **Input:**
            **BarName:** The title of the toolbar to be deleted.\n
        **Return Code:** True\n
        :type BarName: str

        """
        ...

    def feDeleteUserCommand(self, strTitle) -> Any:
        """
        **Description:**
            Deletes a user command
        **Remarks/Usage:**
            None
        **Input:**
            **strTitle:** The title of the command to be deleted.\n
        **Return Code:** True\n
        :type strTitle: str

        """
        ...

    def feEdgesOfFreeFaces(self, elemSetID, bParabolicEdges, bPlaneElem, nFreeCount, nFreeData) -> Any:
        """
        **Description:**
            Allows you to find the Edges of Free Faces in a set of elements
        **Remarks/Usage:**
            None
        **Input:**
            **elemSetID:** The ID of a Set Object that contains the IDs of the elements to be used to compute the Free Faces. If 0, all elements in the model are used.\n
            **bParabolicEdges:** If True, the computation of Free Faces includes checking the midside nodes (if any). If False, only corner nodes are considered.\n
            **bPlaneElem:** If True, then any selected plane elements are considered when deciding if the face is free.\n
        **Output:**
            **nFreeCount:** The number of Edges of Free Faces returned\n
            **nFreeData:** Data that defines the Edges of Free Faces. This is an array, stored as follows...[nodeA_of_edge1, nodeB_of_edge1, nodeA_of_edge2, nodeB_of_edge2, nodeA_of_edge3, nodeB_of_edge3,...]. Each edge of a free face is defined by 2 entries in the array - two corner nodes on the edge of each free face.\n
        **Return Code:** True\n
        :type elemSetID: int

        :type bParabolicEdges: bool

        :type bPlaneElem: bool

        :type nFreeCount: int

        :type nFreeData: tuple[int]

        """
        ...

    def feElemCountOnProp(self, nPropSetID, vPropID, vElemCount) -> Any:
        """
        **Description:**
            Returns the element count for each property in the specified set
        **Remarks/Usage:**
            None
        **Output:**
            **vPropID:** This Variant contains an array with the property IDs. \n
            **vElemCount:** This Variant contains an array with the element count for each property ID.\n
        **Return Code:** True\n
        :type vPropID: Any

        :type vElemCount: Any

        """
        ...

    def feElementFreeEdge(self, elemSetID, bParabolicEdges, bLineElem, nFreeCount, nFreeData) -> Any:
        """
        **Description:**
            Allows you to find the Free Edges in a set of elements
        **Remarks/Usage:**
            None
        **Input:**
            **elemSetID:** The ID of a Set Object that contains the IDs of the elements to be used to compute the Free Edges. If 0, all elements in the model are used.\n
            **bParabolicEdges:** If True, the computation of Free Edges includes checking the midside nodes (if any). If False, only corner nodes are considered.\n
            **bLineElem:** If True, then any line elements that lie along an edge are considered when deciding if the edge is free.\n
        **Output:**
            **nFreeCount:** The number of Free Edges returned\n
            **nFreeData:** Data that defines the Free Edges. This is an array, stored as follows...\n
        **Return Code:** True\n
        :type elemSetID: int

        :type bParabolicEdges: bool

        :type bLineElem: bool

        :type nFreeCount: int

        :type nFreeData: tuple[int]

        """
        ...

    def feElementFreeFace(self, elemSetID, bParabolicEdges, bPlaneElem, nFreeCount, nFreeData) -> Any:
        """
        **Description:**
            Allows you to find the Free Faces in a set of elements
        **Remarks/Usage:**
            None
        **Input:**
            **elemSetID:** The ID of a Set Object that contains the IDs of the elements to be used to compute the Free Faces. If 0, all elements in the model are used.\n
            **bParabolicEdges:** If True, the computation of Free Faces includes checking the midside nodes (if any). If False, only corner nodes are considered.\n
            **bPlaneElem:** If True, then any selected plane elements are considered when deciding if the face is free.\n
        **Output:**
            **nFreeCount:** The number of Free Faces returned\n
            **nFreeData:** Data that defines the Free Faces. This is an array, stored as follows...\n
        **Return Code:** True\n
        :type elemSetID: int

        :type bParabolicEdges: bool

        :type bPlaneElem: bool

        :type nFreeCount: int

        :type nFreeData: tuple[int]

        """
        ...

    def feEntityGetVisibility(self, visType, visSetID, bIsVisible) -> Any:
        """
        **Description:**
            This function populates a set object with the IDs of entities which are visible or blanked. It is not view dependent but always applies to all views.
        **Remarks/Usage:**
            When using FVIS_ELEM_TYPE, the set object will be filled with the IDs of the Element Types which are currently visible or blanked (1-42). For instance, if only linear plate elements are blanked, and bIsVisible is set to False, then only the Type ID for linear plate elements (17) would be in the set object. If bIsVisible is set to True, then all IDs from 1-42 except 17 would be in the set object.
        **Input:**
            **visType:** The type of entity - can be FVIS_POINT, FVIS_CURVE, FVIS_SURFACE, FVIS_SOLID, FVIS_CSYS, FVIS_CONNECTION_REGION, FVIS_CONNECTION, FVIS_PROP, FVIS_MATL, FVIS_ELEM, FVIS_ELEM_TYPE, FVIS_ELEM_SHAPE, FVIS_FREEBODY, FVIS_AERO_PANE, FVIS_AERO_SPLINE, FVIS_AERO_SURFACE\n
            **visSetID:** The ID of set object to populate with visible or blanked entities.\n
            **bIsVisible:** Set to True to get visible entities, False to get hidden entities.\n
        **Return Code:** True\n
        :type visType: int

        :type visSetID: int

        :type bIsVisible: bool

        """
        ...

    def feEntitySetVisibility(self, visType, visID, bIsVisible, bRedraw) -> Any:
        """
        **Description:**
            This function sets entities to be visible or blanked. It is not view dependent but always applies to all views. This call is identical to feEntityVisiblity, which should no longer be used.
        **Remarks/Usage:**
            The visibility of any points, curves, or surfaces associated with a solid will have their visibility controlled by the visibility setting of the solid
        **Input:**
            **visType:** The type of entity to blank - can be FVIS_POINT, FVIS_CURVE, FVIS_SURFACE, FVIS_SOLID, FVIS_CSYS, FVIS_CONNECTION_REGION, FVIS_CONNECTION, FVIS_PROP, FVIS_MATL, FVIS_ELEM, FVIS_ELEM_TYPE, FVIS_ELEM_SHAPE, FVIS_FREEBODY, FVIS_AERO_PANE, FVIS_AERO_SPLINE, FVIS_AERO_SURFACE\n
            **visID:** The ID of a set which contains the IDs/types/shapes of the entity to show or blank. For the element visTypes the set must contain element types or shapes, not element IDs. Alternatively, specify a negative value to select a single ID/type/shape.\n
            **bIsVisible:** Set to True to make entity visible, False to hide it.\n
            **bRedraw:** If True, the model is redrawn after the visibility change is made\n
        **Return Code:** True\n
        :type visType: int

        :type visID: int

        :type bIsVisible: bool

        :type bRedraw: bool

        """
        ...

    def feEntitySetVisibility2(self, visType, nCount, visEnt, entVisible, bRedraw) -> Any:
        """
        **Description:**
            This function sets entities to be visible or blanked using arrays. It is not view dependent but always applies to all views.
        **Remarks/Usage:**
            The visibility of any points, curves, or surfaces associated with a solid will have their visibility controlled by the visibility setting of the solid
        **Input:**
            **visType:** The type of entity to blank - can be FVIS_POINT, FVIS_CURVE, FVIS_SURFACE, FVIS_SOLID, FVIS_CSYS, FVIS_CONNECTION_REGION, FVIS_CONNECTION, FVIS_PROP, FVIS_MATL, FVIS_ELEM, FVIS_ELEM_TYPE, FVIS_ELEM_SHAPE, FVIS_FREEBODY, FVIS_AERO_PANE, FVIS_AERO_SPLINE, FVIS_AERO_SURFACE\n
            **nCount:** Number of different visibility items to set using visEnt and entVisible arrays.\n
            **visEnt:** Array containing different types of entities of the specified visType. For instance, when visType is set to FVIS_ELEM_SHAPE, the visEnt can be filled with different element topologies, while when it is set to FVIS_PROP, it would contain different property types.\n
            **entVisible:** Array of visibility flags corresponding to each type specified in the visEnt array. Set to True to make an entity visible, False to hide.\n
            **bRedraw:** If True, the model is redrawn after the visibility change is made\n
        **Return Code:** True\n
        :type visType: int

        :type nCount: int

        :type visEnt: tuple[int]

        :type entVisible: tuple[bool]

        :type bRedraw: bool

        """
        ...

    def feEntityVisibility(self, visType, visID, bIsVisible, bRedraw) -> Any:
        """
        :type visType: Any
        :type visID: Any
        :type bIsVisible: Any
        :type bRedraw: Any
        """
        ...

    def feFileAttachByOutset(self, nSetID) -> Any:
        """
        **Description:**
            This method returns the ID of the Attached Results. This is the same ID that is displayed in the Manage Results Files Dialog Box.
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of Output Set.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def feFileAttachInfo(self, nID, status, ModelName, pOutSets) -> Any:
        """
        **Description:**
            This method retrieves information for the selected Attached Results.
        **Remarks/Usage:**
            For any method where API objects are returned as parameters, such as this one, it is your responsibility to free that object when you are finished using the object. Some programming languages like Basic will do this automatically, but others like C++, require you to do this manually. The objects are only created or returned when the Return Code is FE_OK.
        **Input:**
            **nID:** ID of Attached Results to retrieve info.\n
        **Output:**
            **status:** Status of the Results:\n
            **ModelName:** The filename of the selected Attached Results. \n
        **Return Code:** True\n
        :type nID: int

        :type status: int

        :type ModelName: str

        """
        ...

    def feFileAttachManage(self, nSetID, OPT, fName) -> Any:
        """
        **Description:**
            This method is used to Manage Attached Results.
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID if Femap Set that contains the Attached IDs. Alternatively, if you specify a negative value, this is simply the ID of a single Attached Results Set.\n
            **OPT:** Manage Options:\n
            **fName:** The filename and path of the Results file.\n
        **Return Code:** True\n
        :type nSetID: int

        :type OPT: int

        :type fName: str

        """
        ...

    def feFileAttachResults(self, analysis_program, fName, bMmf) -> Any:
        """
        **Description:**
            This method is used to Attach a Results File to Femap for postprocessing.
        **Remarks/Usage:**
            None
        **Input:**
            **analysis_program:** Analysis Program of Results File to Attach. 4 = MSC Nastran (FAP_MSC_NASTAN), 31 = NEi Nastran (FAP_NE_NASTRAN), 36 = NX Nastran (FAP_NX_NASTRAN), 16 = ABAQUS (FAP_ABAQUS), 12 = CSV File (FAP_TABLE), 1 = FNO File (FAP_FEMAP_GEN)\n
            **fName:** The filename and path of the Results File to Attach.\n
            **bMmf:** If True Operating System attempts to load file into System RAM \n
        **Return Code:** True\n
        :type analysis_program: int

        :type fName: str

        :type bMmf: bool

        """
        ...

    def feFileAttachSave2V2(self, nID, outSET, outVec, ndSet, elSet, bDetach) -> Any:
        """
        **Description:**
            This method will store Results from an Attached File to the Femap Database. This method replace feFileAttachSave2. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above"
        **Remarks/Usage:**
            If bDetach is False then selected Output Sets will be saved to a new ids. If true then Femap will preserve the Femap Output Set and automatically detach the Results File when finished.
        **Input:**
            **nID:** ID of Femap Set that contains the IDs of the Attached Results to Save to the Femap Database. Alternatively, if you specify a negative value, this is simply the ID of a single Attached Results Set. \n
            **nID:** ID of Femap Set that contains Output Sets to Save. If you specify a zero all Output Sets in the Result File will be saved. If you specify a negative value, this is simply the ID of a single Results Set.\n
            **nID:** ID of Femap Set that contains Output Vectors to Save. If you specify a zero all Output Vectors in the Result File will be saved. If you specify a negative value, this is simply the ID of a single Output Vector.\n
            **nID:** ID of Femap Set that contains the nodes where output will be saved. Alternatively, if you specify a zero, results for all nodes in the Result File will be saved.\n
            **nID:** ID of Femap Set that contains elements where output will be saved. Alternatively, if you specify a zero, results for all elements in the Result File will be saved.\n
            **bDetach:** If True, result file will be detached after save operation.\n
        **Return Code:** True\n
        :type nID: int

        :type nID: int

        :type nID: int

        :type nID: int

        :type nID: int

        :type bDetach: bool

        """
        ...

    def feFileAttachSaveV2(self, nID, outSET, outVec, ndSet, elSet) -> Any:
        """
        **Description:**
            This method will store Results from an Attached File to the Femap Database. The method replaces feFileAttachSave. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            When saving results Femap will preserve the Femap Output Set and automatically detach the Results File when finished.
        **Input:**
            **nID:** ID of Femap Set that contains the IDs of the Attached Results to Save to the Femap Database. Alternatively, if you specify a negative value, this is simply the ID of a single Attached Results Set. \n
            **nID:** ID of Femap Set that contains Output Sets to Save. Alternatively, if you specify a zero all Output Sets in the Result File will be saved.\n
            **nID:** ID of Femap Set that contains Output Vectors to Save. Alternatively, if you specify a zero all Output Vectors in the Result File will be saved.\n
            **nID:** ID of Femap Set that contains the nodes where output will be saved. Alternatively, if you specify a zero, results for all nodes in the Result File will be saved.\n
            **nID:** ID of Femap Set that contains elements where output will be saved. Alternatively, if you specify a zero, results for all elements in the Result File will be saved.\n
        **Return Code:** True\n
        :type nID: int

        :type nID: int

        :type nID: int

        :type nID: int

        :type nID: int

        """
        ...

    def feFileClose(self, bSaveChanges) -> Any:
        """
        **Description:**
            This function closes the active model
        **Remarks/Usage:**
            This function will always display a dialog box asking for a filename if you are saving changes to a model that has never been saved previously. To prevent this, you must either discard the changes, or save the model prior to calling this method.
        **Input:**
            **bSaveChanges:** If True, any changes in the model will be saved. If False, the model will simply close, discarding any changes.\n
        **Return Code:** False\n
        :type bSaveChanges: bool

        """
        ...

    def feFileCurrentDirectory(self, sCurDir) -> Any:
        """
        **Description:**
            This function sets the current directory for a model
        **Remarks/Usage:**
            None
        **Input:**
            **sCurDir:** The directory to set as current\n
        **Return Code:** True\n
        :type sCurDir: str

        """
        ...

    def feFileExecute(self, cmdline, waitForCompletion) -> Any:
        """
        **Description:**
            Allows you to run a program or other object as a separate process.
        **Remarks/Usage:**
            None
        **Input:**
            **cmdline:** The full command line used to launch the program.\n
            **waitForCompletion:** If True, this method will wait until the other process completes before returning. If False, it will return as soon as the process starts.\n
        **Return Code:** False\n
        :type cmdline: str

        :type waitForCompletion: bool

        """
        ...

    def feFileExit(self) -> Any:
        """
        **Description:**
            This function causes FEMAP to exit.
        **Remarks/Usage:**
            This function will always display a dialog box asking for confirmation to save the current model unless it has not been modified since the last save. Therefore, to exit with no user interaction, you must either use one of the FileSave functions or feFileNew immediately prior to calling this function.
        **Return Code:** True\n
        """
        ...

    def feFileGetName(self, title, filterName, filterStr, openForRead, fName) -> Any:
        """
        **Description:**
            Allows you to display a dialog box to retrieve a filename.
        **Remarks/Usage:**
            None
        **Input:**
            **title:** A text string to be displayed as the title of the dialog box.\n
            **filterName:** A text string describing the type of files that you will be looking for.\n
            **filterStr:** A text string used to limit the types of files displayed. This should be of the form *.XXX to display all files with an XXX file extension. Use *.* to display all files.\n
            **openForRead:** If True, the name of an existing file must be selected. \n
        **Output:**
            **fName:** The name of the file chosen by the user.\n
        **Return Code:** False\n
        :type title: str

        :type filterName: str

        :type filterStr: str

        :type openForRead: bool

        :type fName: str

        """
        ...

    def feFileIsModified(self) -> Any:
        """
        """
        ...

    def feFileJTHierarchy(self, iHier1, iHier2, iHier3, iHier4, iHier5, iHier6, iHier7) -> Any:
        """
        :type iHier1: Any
        :type iHier2: Any
        :type iHier3: Any
        :type iHier4: Any
        :type iHier5: Any
        :type iHier6: Any
        :type iHier7: Any
        """
        ...

    def feFileJTName(self, fName) -> Any:
        """
        :type fName: Any
        """
        ...

    def feFileJTUnits(self, iUnits) -> Any:
        """
        :type iUnits: Any
        """
        ...

    def feFileJTVersion(self, iVersion) -> Any:
        """
        :type iVersion: Any
        """
        ...

    def feFileMessageCopy(self) -> Any:
        """
        **Description:**
            This function copies the selected messages from the Messages and Lists window to the clipboard.
        **Remarks/Usage:**
            If no messages are selected, then all messages will be copied; otherwise, only the selected ones are copied.
        **Return Code:** False\n
        """
        ...

    def feFileMessageLineNumber(self, CurrentLine) -> Any:
        """
        **Description:**
            This function returns the line number of the last line currently in the message window
        **Remarks/Usage:**
            You can use this function to retrieve the current line number in the Messages and Lists window. You can then save this value and later use it as a line number to call feFileMessageSelect.
        **Output:**
            **CurrentLine:** The line number of the last line in the message window\n
        **Return Code:** True\n
        :type CurrentLine: int

        """
        ...

    def feFileMessageSave(self, useDlg, fName) -> Any:
        """
        **Description:**
            This function copies the selected messages to a file.
        **Remarks/Usage:**
            If no messages are selected, then all messages will be copied; otherwise, only the selected ones are copied.
        **Input:**
            **useDlg:** If True, this function runs interactively and displays a dialog box to ask the user to define the filename.\n
        **Return Code:** True\n
        :type useDlg: bool

        """
        ...

    def feFileMessageSelect(self, firstLine, lastLine) -> Any:
        """
        **Description:**
            This function selects the specified lines in the Messages and Lists window.
        **Remarks/Usage:**
            If either firstLine or lastLine are -1, the selection will be reset - no lines will be selected. Setting firstLine = 0, will automatically select starting at the first available line. Setting lastLine = 0 will automatically select up to the last available line.
        **Input:**
            **firstLine:** The line number of the first line of text to be selected.\n
        **Return Code:** True\n
        :type firstLine: int

        """
        ...

    def feFileNew(self) -> Any:
        """
        **Description:**
            This function starts a new model. It works like the File, New command.
        **Remarks/Usage:**
            In releases prior to v9, this API function required 2 arguments because multiple models were not supported and the previous model needed to be closed prior to opening the new model.
        **Return Code:** True\n
        """
        ...

    def feFileOpen(self, useDlg, fName) -> Any:
        """
        **Description:**
            This function opens an existing model, or starts a new model and loads the contents of a file in one of the supported analysis formats. It works like the File, Open command.
        **Remarks/Usage:**
            feFileOpen( True, wing.mod ) - interactive use, even though you specified a filename, it will not be opened - the user will be asked to choose a model.
        **Input:**
            **useDlg:** If True, fName is ignored and the standard dialog boxes are displayed allowing the user to choose a model to open. If False, the model specified in fName is opened.\n
            **fName:** The filename of the file to be opened. In general, this name should be specified with a complete path. If no path is supplied, the file will be opened from the current FEMAP directory.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fName: str

        """
        ...

    def feFilePageSetupReset(self) -> Any:
        """
        **Description:**
            This function sets all of the page setup settings back to their default values. It is the same as pressing the Resetbutton in the Page Setup command.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def feFilePageSetupSave(self) -> Any:
        """
        **Description:**
            This function permanently saves the current page setup settings. It is the same as pressing the Permanentbutton in the Page Setup command.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def feFilePictureCopy(self) -> Any:
        """
        **Description:**
            This function copies the contents of the current Graphics window to the clipboard.
        **Remarks/Usage:**
            This method is obsolete. For new applications you should use feFilePictureCopy2( )
        **Return Code:** False\n
        """
        ...

    def feFilePictureCopy2(self, saveRegion) -> Any:
        """
        **Description:**
            This function copies portions of the screen to the clipboard.
        **Remarks/Usage:**
            If you are copying a bitmap, then view that you are copying must be visible on the screen. If it is partially or fully obscured by other applications, then the picture that you copy will not be correct.
        **Input:**
            **saveRegion:** 0=Graphics Window, 1=Layout, 2=Entire Desktop\n
        **Return Code:** False\n
        :type saveRegion: int

        """
        ...

    def feFilePictureReplay(self, fName) -> Any:
        """
        **Description:**
            This function replays an existing bitmap or metafile.
        **Remarks/Usage:**
            This function displays the picture using the FEMAP Replay program, which is launched in a separate window. There is no function available to automatically close this replay window. The Replay program can only replay bitmaps and metafiles. Other picture file formats can be saved, but cannot be replayed using this method.
        **Input:**
            **fName:** The name of the picture to replay - must be a bitmap or metafile.\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def feFilePictureSave(self, useDlg, saveDesktop, format, fName) -> Any:
        """
        **Description:**
            This function copies the contents of the current Graphics window (or the entire desktop) to a file.
        **Remarks/Usage:**
            This method is obsolete - you should use feFilePictureSave2 for new applications.
        **Input:**
            **useDlg:** If True, this function runs interactively and displays a dialog box to ask the user to define the format and fName options.\n
            **saveDesktop:** If True, the entire desktop (screen) is copied to the file. If False, only the contents of the active Graphics window are copied. If you are copying the desktop, the only valid formats are Bitmap, JPEG, PNG, GIF, and TIFF\n
            **format:** The format of the file to create. 1=Bitmap, 2=Metafile, 3=Placeable Metafile, 4=JPEG, 5=Bitmap Series, 6=AVI, 7=JT, 8=Reserved for internal use, 9=GIF, 10=Animated GIF, 11=TIF, 12=PNG. Bitmap Series, Animated GIF, and AVI formats are only available for animating windows. Metafiles and Placeable Metafiles are only available for non-Render windows.\n
            **fName:** The name of the file to create.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type saveDesktop: bool

        :type format: int

        :type fName: str

        """
        ...

    def feFilePictureSave2(self, useDlg, saveRegion, format, fName) -> Any:
        """
        **Description:**
            This function copies the contents of the current Graphics window (or the entire desktop) to a file.
        **Remarks/Usage:**
            If you are saving a bitmap, then view that you are saving must be visible on the screen. If it is partially or fully obscured by other applications, then the file that you create will not be correct.
        **Input:**
            **useDlg:** If True, this function runs interactively and displays a dialog box to ask the user to define the format and fName options.\n
            **saveRegion:** 0=Graphics Window, 1=Layout, 2=Entire Desktop\n
            **format:** The format of the file to create. 1=Bitmap, 2=Metafile, 3=Placeable Metafile, 4=JPEG, 5=Bitmap Series, 6=AVI, 7=JT, 8=Reserved for internal use, 9=GIF, 10=Animated GIF, 11=TIF, 12=PNG. Bitmap Series, Animated GIF, and AVI formats are only available for animating windows. Metafiles and Placeable Metafiles are only available for non-Render windows.\n
            **fName:** The name of the file to create.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type saveRegion: int

        :type format: int

        :type fName: str

        """
        ...

    def feFilePictureSaveJT(self, useDlg, fName, eJTFileVersion, eJTFileUnits, JTHierarchy, eLoadSetOption, LoadSets,
                            eBCSetOption, BCSets, LinesAsCylinders, dCylinderFactor) -> Any:
        """
        **Description:**
            This function saves a Standard Output JT visualization file using the specified options
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, this function runs interactively and displays a dialog box to ask the user to define fName and all other available options to create a JT visualization file.\n
            **fName:** The name of JT visualization file.\n
            **eJTFileUnits:** JT Units - use enum zJT_FileUnits:\n
            **eLoadSetOption:** Load Set option - use enum zJT_SetOption:\n
            **eBCSetOption:** Constraint Set option - use enum zJT_SetOption (see eLoadSetOption)\n
            **BCSets:** Only used when eBCSetOption is set to JT_SETS_SELECT and contains the IDs of the Load Sets to include in the JT File\n
            **LinesAsCylinders:** When True, enables the Draw Lines as Cylinders option\n
            **dCylinderFactor:** Specifies value for Diameter\n
        **Return Code:** False\n
        :type useDlg: bool

        :type fName: str

        :type eJTFileUnits: Any

        :type eLoadSetOption: Any

        :type eBCSetOption: Any

        :type BCSets: Any

        :type LinesAsCylinders: bool

        :type dCylinderFactor: float

        """
        ...

    def feFilePictureSaveJTMultiResults(self, useDlg, fName, eJTFileVersion, eJTFileUnits, OutputSets, OutputVectors,
                                        bRaw, bAverage, bTransform, bCorners) -> Any:
        """
        **Description:**
            This function saves a Multi Result Output JT visualization file using the specified options
        **Remarks/Usage:**
            Not all applications which allow visualization of JT data have the ability to display the CAE data created using the options in the Multi Result section. If a warning stating The current service level doesnt support displaying multiple CAE results. or similar, then this functionality is not available.
        **Input:**
            **useDlg:** If True, this function runs interactively and displays a dialog box to ask the user to define fName and all other available options to create a JT visualization file.\n
            **fName:** The name of JT visualization file.\n
            **eJTFileUnits:** JT Units - use enum zJT_FileUnits:\n
            **OutputSets:** IDs of the Output Sets to include in the JT visualization file\n
            **OutputVectors:** IDs of the Output Vectors to include in the JT visualization file\n
            **bRaw:** When True, the Raw Output Data option is specified. When False, Collated Vectors and Tensors is specified.\n
            **bTransform:** When True, enables the Use Transformation Options option. Only used when bRaw = False\n
            **bCorners:** When True, enables the Use Corner Data option. Only used when bRaw = False\n
        **Return Code:** False\n
        :type useDlg: bool

        :type fName: str

        :type eJTFileUnits: Any

        :type OutputSets: Any

        :type OutputVectors: Any

        :type bRaw: bool

        :type bTransform: bool

        :type bCorners: bool

        """
        ...

    def feFilePreferencesReset(self) -> Any:
        """
        **Description:**
            This function permanently resets the preference settings back to their default values. It is the same as pressing the Resetbutton in the File, Preferences command.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def feFilePreferencesSave(self) -> Any:
        """
        **Description:**
            This function permanently saves the current preference settings. It is the same as saving the preferences when you leave the File, Preferences command.
        **Remarks/Usage:**
            This command does not allow you to change the preference settings. All preference settings can be accessed and changed using global variables. You should change the settings that you want to modify, then call this function to make those changes permanent.
        **Return Code:** True\n
        """
        ...

    def feFilePrint(self, useDlg, asBitmap, source, fromFile, toFile) -> Any:
        """
        **Description:**
            This function is obsolete. You should use feFilePrint2( ) instead
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, the function runs interactively and displays a dialog box to allow the user to define the options. If False, the other parameters automatically define the printing options.\n
            **asBitmap:** If True, printing is done at screen (bitmap) resolution. If False, printing is in printer resolution.\n
            **source:** Selects the data to print. (Active View=0, Desktop=1, File=2, MultiView Layout=3, Messages=4, Program File=5, Entity Info=6, API Programming=7, Data Table=8) \n
            **fromFile:** Only used if source=2, print from file. In this case, this is the full pathname of the file to print.\n
            **toFile:** Complete path/filename of print destination. If blank, print will go to the current printer.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type asBitmap: bool

        :type source: int

        :type fromFile: str

        :type toFile: str

        """
        ...

    def feFilePrint2(self, useDlg, source, toFile) -> Any:
        """
        **Description:**
            This function invokes the printing function.
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, the function runs interactively and displays a dialog box to allow the user to define the options. If False, the other parameters automatically define the printing options.\n
            **source:** Selects the data to print. (Active View=0, Desktop=1, File=2, MultiView Layout=3, Messages=4, Program File=5, Entity Info=6, API Programming=7, Data Table=8, Charting=9) \n
            **toFile:** Complete path/filename of print destination. If blank, print will go to the current printer.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type source: int

        :type toFile: str

        """
        ...

    def feFileProgramRun(self, useDlg, init, isFile, buff) -> Any:
        """
        **Description:**
            This function selects and runs a program file.
        **Remarks/Usage:**
            Refer to the Section later in this document on Program Files for more information on the syntax required. When you call this function, the program file is started, however the function returns immediately, it can not wait for the program file to complete. Refer to the feFileProgramRunning( ) method, and the chapter on events for possible methods for determining when a program file finishes.
        **Input:**
            **useDlg:** If True, this function runs interactively and displays a dialog box to ask the user to define the filename of the program file to run.\n
            **init:** If True, any previously running program file is terminated and other variables are reinitialized. In most cases, this should be True.\n
            **isFile:** If True, the buff variable must contain the full name of the program file to run. If False, buff contains the actual text of the program file. Ignored if useDlg=True.\n
            **buff:** Either the name or the contents of the program file to run (depends on the isFile parameter).\n
        **Return Code:** True\n
        :type useDlg: bool

        :type init: bool

        :type isFile: bool

        :type buff: str

        """
        ...

    def feFileProgramRunning(self) -> Any:
        """
        **Description:**
            This function can be called to see if a program file is still running.
        **Remarks/Usage:**
            Refer to the Section later in this document on Program Files for more information on the syntax required. You can call this method, see if the program file is running, and if it is, wait for some period and then check again, until the program file finishes.
        **Return Code:** True\n
        """
        ...

    def feFileReadAbaqus(self, brand, fName) -> Any:
        """
        **Description:**
            This function loads finite element model data from an existing ABAQUS file.
        **Remarks/Usage:**
            None
        **Input:**
            **brand:** Used to select the format of the ABAQUS file. 0=Abaqus Input File (.INP), 1=Abaqus Results File (.FIL)\n
            **fName:** The filename of the ABAQUS input file to read.\n
        **Return Code:** True\n
        :type brand: int

        :type fName: str

        """
        ...

    def feFileReadAbaqusResults(self, brand, fName) -> Any:
        """
        **Description:**
            This function loads finite element results data from an existing ABAQUS file.
        **Remarks/Usage:**
            None
        **Input:**
            **brand:** Used to select the format of the ABAQUS file. Currently this MUST be specified as 1=Abaqus Results file.\n
            **fName:** The filename of the ABAQUS results file to read.\n
        **Return Code:** True\n
        :type brand: int

        :type fName: str

        """
        ...

    def feFileReadAcis(self, fName) -> Any:
        """
        **Description:**
            Short form of feFileReadAcisOpt( ).
        **Remarks/Usage:**
            Using this function is equivalent to calling:
        **Input:**
            **fName:** The filename/path of the ACIS file to be read.\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def feFileReadAcisOpt(self, useDlg, fName, title, layer, color, increment_layer, increment_color, assign_color,
                          convert_to_splines, convert_format, clean, heal, check, stringent, delete_invalid, faces,
                          Scale) -> Any:
        """
        **Description:**
            This function loads geometry from an ACIS .SAT file. It works like File, Import, Geometry,when you pick an ACIS file. The file is loaded into the current model.
        **Remarks/Usage:**
            In general, you will not want to convert geometry to Parasolid format. In that case, all of the parameters after convert_format are ignored.
        **Input:**
            **useDlg:** If True, the function runs interactively and displays a dialog box to allow the user to define the options. Only the fName option is used; all others are ignored.\n
            **fName:** The filename/path of the ACIS file to be read.\n
            **title:** The title that is assigned to created layers and the solid.\n
            **layer:** The ID of the layer for new geometry. Set to -1 to use the active layer.\n
            **color:** The color used for the geometry that is created. Set to -1 to use the active solid color. Only used if assign_color=True\n
            **layer:** If True and you read an assembly, geometry for each solid is placed on a different layer; otherwise all geometry is on the specified layer.\n
            **color:** If True and you read an assembly, geometry for each solid is colored differently.\n
            **color:** If True, the specified color value is used for geometry; otherwise the default colors are used.\n
            **convert_format:** Should always be set to True. ACIS geometry can no longer be read in native format - it is always converted to Parasolid.\n
            **clean:** Only used if convert_format=True. If True, this attempts to detect and remove sliver faces or other geometric problems.\n
            **heal:** Only used if convert_format=True. If True, attempts to close gaps and correct geometric inaccuracies.\n
            **check:** Only used if convert_format=True. If True, checks converted Parasolid geometry to find and report any problems.\n
            **stringent:** Only used if convert_format=True. If True, checks for surface discontinuities or irregularities in the converted Parasolid geometry.\n
            **delete_invalid:** Only used if convert_format=True. If True and geometry was checked, this deletes any geometry that failed the checking.\n
            **faces:** Only used if convert_format=True. If True and it was not possible to convert a complete solid, this will allow unstitched, free surfaces to be retained. \n
            **Scale:** Only used if convert_format=True. This is a scale factor that is applied to the geometry during conversion. It is used to ensure that the geometry lies inside the Parasolid modeling box (+/- 500 units).\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fName: str

        :type title: str

        :type layer: int

        :type color: int

        :type layer: bool

        :type color: bool

        :type color: bool

        :type convert_format: bool

        :type clean: bool

        :type heal: bool

        :type check: bool

        :type stringent: bool

        :type delete_invalid: bool

        :type faces: bool

        :type Scale: float

        """
        ...

    def feFileReadAnsys(self, brand, fName) -> Any:
        """
        **Description:**
            This function loads finite element model data from an existing ANSYS file.
        **Remarks/Usage:**
            None
        **Input:**
            **brand:** Used to select the format of the ANSYS input file. 4 = Version 4, 5 = Version 5+.\n
            **fName:** The filename of the ANSYS input file to read.\n
        **Return Code:** True\n
        :type brand: int

        :type fName: str

        """
        ...

    def feFileReadAnsysResults(self, brand, fName) -> Any:
        """
        **Description:**
            This function loads finite element results data from an existing ANSYS file.
        **Remarks/Usage:**
            This function can read results files from structural (.RST) and thermal analyses (.RTH).
        **Input:**
            **brand:** Used to select the format of the ANSYS results file. 4 = Version 4, 5 = Version 5..9, 10 = 10 and up.\n
            **fName:** The filename of the ANSYS results file to read.\n
        **Return Code:** True\n
        :type brand: int

        :type fName: str

        """
        ...

    def feFileReadCSVResults(self, fName) -> Any:
        """
        **Description:**
            This function loads finite element results data from an existing CSV (comma-separated values) file formatted for use with FEMAP.
        **Remarks/Usage:**
            This call automatically determines if output is stored using the Comma-Separated Table Format or Extended Comma-Separated Table Format, then reads the results. See Section 8.l0.3 The Comma-Separated Table Format or Section 8.10.4 The Extended Comma-Separated Table Format in the FEMAP User Guide for more information.
        **Input:**
            **fName:** The filename of the CSV results file to read.\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def feFileReadCatia(self, useDlg, fName, rdAnalytical, rdTopology, rdCurves, stitch, heal) -> Any:
        """
        **Description:**
            This function loads geometry from a CATIA (.model, mdl, .exp) file. It works like File, Import, Geometry, when you pick a CATIA file. The file is loaded into the current model.
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, the function runs interactively and displays a dialog box to allow the user to define the options. Only the fName option is used; all others are ignored.\n
            **fName:** The filename/path of the CATIA file to be read.\n
            **rdAnalytical:** Set to True to read the analytical definition for surfaces defined as splines.\n
            **rdTopology:** Set to True to read the CATIA topology to create a solid. Generally, it is better to set to False to read the surfaces as individual surfaces. \n
            **rdCurves:** Set to True to read 3D trimming curves, or False to read 2D trimming curves.\n
            **stitch:** Set to True to automatically stitch surfaces into a solid. If False, individual surfaces will be read.\n
            **heal:** Set to True to attempt to repair tolerance and gap problems.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fName: str

        :type rdAnalytical: bool

        :type rdTopology: bool

        :type rdCurves: bool

        :type stitch: bool

        :type heal: bool

        """
        ...

    def feFileReadCatia2(self, useDlg, fName, rdAnalytical, rdTopology, rdCurves, rdNoShow, rdNoPick, rdWorkplanes,
                         stitch, heal, check) -> Any:
        """
        **Description:**
            This function loads geometry from a CATIA (.model, mdl, .exp) file. It works like File, Import, Geometry, when you pick a CATIA file. The file is loaded into the current model.
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, the function runs interactively and displays a dialog box to allow the user to define the options. Only the fName option is used; all others are ignored.\n
            **fName:** The filename/path of the CATIA file to be read.\n
            **rdAnalytical:** Set to True to read the analytical definition for surfaces defined as splines.\n
            **rdTopology:** Set to True to read the CATIA topology to create a solid. Generally, it is better to set to False to read the surfaces as individual surfaces. \n
            **rdCurves:** Set to True to read 3D trimming curves, or False to read 2D trimming curves.\n
            **rdNoShow:** If True, entities that are marked as No Show in the Catia model will be read\n
            **rdNoPick:** If True, entities on the No Pick layer will be read\n
            **stitch:** Set to True to automatically stitch surfaces into a solid. If False, individual surfaces will be read.\n
            **heal:** Set to True to attempt to repair tolerance and gap problems.\n
            **check:** If True, the geometry will be checked for validity.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fName: str

        :type rdAnalytical: bool

        :type rdTopology: bool

        :type rdCurves: bool

        :type rdNoShow: bool

        :type rdNoPick: bool

        :type stitch: bool

        :type heal: bool

        :type check: bool

        """
        ...

    def feFileReadCatiaV5(self, useDlg, fName, fPath, rdNoShow, rdInactiveLayers, rdPoints, rdCurves, rdSurfaces,
                          rdBodies, simplify) -> Any:
        """
        **Description:**
            This function loads geometry from a CATIA V5 (.CATpart or .CATproduct) file. It works like File, Import, Geometry, when you pick a CATIA V5 file. The file is loaded into the current model.
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, the function runs interactively and displays a dialog box to allow the user to define the options. The fName and fPath options can not be set using this method, other options set the defaults for the dialog box. If False, the other parameters automatically define the CATIA V5 read options.\n
            **fName:** The filename/path of the CATIA V5 file to be read.\n
            **fPath:** The search path for other assembly parts. If all parts are in the same directory as the file you specify, you can pass this as a blank string. If you need to search multiple directories, you must separate the paths with semicolons in this string.\n
            **rdNoShow:** If True, reads No Show geometry.\n
            **rdInactiveLayers:** If True, reads geometry from layers marked as Inactive.\n
            **rdPoints:** Set to True to read points\n
            **rdCurves:** Set to True to read curves\n
            **rdSurfaces:** Set to True to read surfaces\n
            **rdBodies:** Set to True to read bodies\n
            **simplify:** If True, simplifies the underlying geometry for curves and surfaces\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fName: str

        :type fPath: str

        :type rdNoShow: bool

        :type rdInactiveLayers: bool

        :type rdPoints: bool

        :type rdCurves: bool

        :type rdSurfaces: bool

        :type rdBodies: bool

        :type simplify: bool

        """
        ...

    def feFileReadDxf(self, useDlg, fName, read_TEXT, read_3DFACE, read_BLOCKS, read_POLYELEM, read_TRACE_boundary,
                      read_TRACE_centerline, read_LAYER, first_layer, merge_points, merge_distance) -> Any:
        """
        **Description:**
            This function loads geometry (and other entities) from a DXF formatted file. It works like File, Import, Geometry, when you pick a DXF file. The file is loaded into the current model.
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, the function runs interactively and displays a dialog box to allow the user to define the options. Only the fName option is used; all others are ignored.\n
            **fName:** The filename/path of the DXF file to be read.\n
            **read_TEXT:** If True, reads text or notes. Skipped if False.\n
            **read_3DFACE:** If True, reads 3DFaces as elements. If False, lines are created to form the outline of the face.\n
            **read_BLOCKS:** If True, entities inside block references will be read.\n
            **read_POLYELEM:** If True, reads polygon meshes as elements.\n
            **read_TRACE_boundary:** If True, creates lines to represent the edges of a traceline.\n
            **read_LAYER:** If True, reads color and layer information and assigns it to the geometry.\n
            **first_layer:** If rdLayer=True, this is the ID of the first layer that will be created. A unique layer is created for each unique layer name in the DXF file.\n
            **merge_points:** If True, coincident points will be merged after geometry is read.\n
            **merge_distance:** If mergePoints=True, this is the distance used to determine coincident points. Points that are closer than this distance from each other will be merged.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fName: str

        :type read_TEXT: bool

        :type read_3DFACE: bool

        :type read_BLOCKS: bool

        :type read_POLYELEM: bool

        :type read_TRACE_boundary: bool

        :type read_LAYER: bool

        :type first_layer: int

        :type merge_points: bool

        :type merge_distance: float

        """
        ...

    def feFileReadDyna(self, brand, fName) -> Any:
        """
        **Description:**
            This function loads finite element model data from an existing LS-DYNA file.
        **Remarks/Usage:**
            None
        **Input:**
            **brand:** Used to select the format of the DYNA file. Currently this MUST be specified as 1=DYNA Results file.\n
            **fName:** The filename of the DYNA file to read.\n
        **Return Code:** True\n
        :type brand: int

        :type fName: str

        """
        ...

    def feFileReadDynaResults(self, brand, fName) -> Any:
        """
        **Description:**
            This function loads finite element results data from an existing LS-DYNA file.
        **Remarks/Usage:**
            None
        **Input:**
            **brand:** Used to select the format of the DYNA file. Currently this MUST be specified as 1=DYNA Results file.\n
            **fName:** The filename of the DYNA results file to read.\n
        **Return Code:** True\n
        :type brand: int

        :type fName: str

        """
        ...

    def feFileReadIdeas(self, fName) -> Any:
        """
        **Description:**
            This function loads finite element data from an existing I-DEAS Universal (.UNV) file. It works like File, Import, Analysis Model, when you pick I-DEAS file. The file is loaded into the current model.
        **Remarks/Usage:**
            This call replaces an older version of feFileReadIdeas, which was used to import I-DEAS Geometry (.IDI) files. It is no longer possible to import *IDI files into FEMAP and another geometry format, such as STEP or IGES, should be used to transfer geometry from I-DEAS to FEMAP.
        **Input:**
            **fName:** The filename/path of the I-DEAS Universal file to be read.\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def feFileReadIges(self, useDlg, fName, merge_points, read_LAYER, read_geom_only, read_surface_data,
                       trim_preference, min_resolution) -> Any:
        """
        **Description:**
            This function loads geometry from a IGES (.IGS) file. It works like File, Import, Geometry, when you pick an IGES file, and you do not choose the Alternate/Advanced interface. The file is loaded into the current model.
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, the function runs interactively and displays a dialog box to allow the user to define the options. Only the fName option is used; all others are ignored.\n
            **fName:** The filename/path of the IGES file to be read.\n
            **merge_points:** Set to True to merge all coincident points that are created.\n
            **read_LAYER:** Set to True to read layer information and assign geometry to the appropriate layers.\n
            **read_geom_only:** Set to True to only read data marked as geometry.\n
            **read_surface_data:** Set to True to read trimmed surface data. If you set this to True, you must have the appropriate license.\n
            **trim_preference:** =0 for Default Trim curves per the IGES file specification. =1 for 2D trim curves, =2 for 3D trim curves.\n
            **min_resolution:** Set to the minimum resolution for coincident points in the file. Used for tolerances of surface data, and for merging coincident points.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fName: str

        :type merge_points: bool

        :type read_LAYER: bool

        :type read_geom_only: bool

        :type read_surface_data: bool

        :type trim_preference: int

        :type min_resolution: float

        """
        ...

    def feFileReadIgesAdv(self, useDlg, fName, read_curves, read_untrimmed_surfaces, read_trimmed_surfaces, read_solids,
                          flavor, trim_curve_option) -> Any:
        """
        **Description:**
            This function loads geometry from a IGES (.IGS) file. It works like File, Import, Geometry,when you pick an IGES file, and choose the Alternate/Advanced interface. The file is loaded into the current model.
        **Remarks/Usage:**
            If you are having trouble reading solid data, try turning off read_solids, and just read the trimmed surfaces. These surfaces can then be stitched into a solid.
        **Input:**
            **useDlg:** If True, the function runs interactively and displays a dialog box to allow the user to define the options. Only the fName option is used; all others are ignored.\n
            **fName:** The filename/path of the IGES file to be read.\n
            **read_curves:** Set to True to read free curves (curves that are not connected to surfaces or solids).\n
            **read_trimmed_surfaces:** Set to True to read free trimmed surfaces.\n
            **read_solids:** Set to True to read solid data.\n
            **flavor:** =0 for No flavoring, =1 for AutoCAD customization (old versions of AutoCAD only).\n
            **trim_curve_option:** =0 for default trim curves, =1 for 2D trim curves, =2 for 3D trim curves\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fName: str

        :type read_curves: bool

        :type read_trimmed_surfaces: bool

        :type read_solids: bool

        :type flavor: int

        :type trim_curve_option: int

        """
        ...

    def feFileReadJT(self, fName) -> Any:
        """
        **Description:**
            This function loads geometry from a JT file. It works like File, Import, Geometry, when you pick a JT file. The file is loaded into the current model.
        **Remarks/Usage:**
            None
        **Input:**
            **fName:** The filename/path of the JT file to be read.\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def feFileReadMarc(self, brand, fName) -> Any:
        """
        **Description:**
            This function loads finite element model data from an existing Marc file.
        **Remarks/Usage:**
            None
        **Input:**
            **brand:** Used to select the format of the Marc file. Currently this MUST be specified as 1=Marc Results file.\n
            **fName:** The filename of the Marc file to read.\n
        **Return Code:** True\n
        :type brand: int

        :type fName: str

        """
        ...

    def feFileReadMarcResults(self, brand, fName) -> Any:
        """
        **Description:**
            This function loads finite element results data from an existing Marc file.
        **Remarks/Usage:**
            None
        **Input:**
            **brand:** Used to select the format of the Marc file. Currently this MUST be specified as 1=Marc Results file.\n
            **fName:** The filename of the Marc file to read.\n
        **Return Code:** True\n
        :type brand: int

        :type fName: str

        """
        ...

    def feFileReadNastran(self, brand, fName) -> Any:
        """
        **Description:**
            This function loads finite element model data from an existing NASTRAN file.
        **Remarks/Usage:**
            None
        **Input:**
            **brand:** Used to select the format of the NASTRAN input file: 0=MSC, 1=NE, 2=UAI, 3=CSA, 4=SSS, 5=Cosmic, 6=ME, 7=VR, 8=NX.\n
            **fName:** The filename of the NASTRAN input file to read.\n
        **Return Code:** True\n
        :type brand: int

        :type fName: str

        """
        ...

    def feFileReadNastranResults(self, brand, fName) -> Any:
        """
        **Description:**
            This function loads finite element results data from an existing NASTRAN file.
        **Remarks/Usage:**
            This function can read both NASTRAN printed results file (.F06) or OUTPUT2 files (.OP2).
        **Input:**
            **brand:** Used to select the format of the NASTRAN results file: 0=MSC, 1=NE, 2=UAI, 3=CSA, 4=SSS, 5=Cosmic, 6=ME, 7=VR, 8=NX.\n
            **fName:** The filename of the NASTRAN results file to read.\n
        **Return Code:** True\n
        :type brand: int

        :type fName: str

        """
        ...

    def feFileReadNeutral(self, brand, fName, read_geometry, read_model, read_output, status_messages, offsetID) -> Any:
        """
        **Description:**
            This method is the same as calling feFileReadNeutral2 with read_groups and read_views equal to read_model. Refer to that method for more information.
        **Return Code:** True\n
        """
        ...

    def feFileReadNeutral2(self, brand, fName, read_geometry, read_model, read_output, read_groups, read_views,
                           status_messages, offsetID) -> Any:
        """
        **Description:**
            This method is the same as calling feFileReadNeutral3 with renumber_layers and renumber_load_bc set to True, and create_new_output set to False.
        **Return Code:** True\n
        """
        ...

    def feFileReadNeutral3(self, brand, fName, read_geometry, read_model, read_output, read_groups, read_views,
                           status_messages, offsetID, renumber_layers, renumber_load_bc, always_new_output_sets) -> Any:
        """
        **Description:**
            This function reads a FEMAP Neutral file.
        **Remarks/Usage:**
            None
        **Input:**
            **brand:** Used to select the format of the Neutral file. Not currently used.\n
            **fName:** The filename of the Neutral file to read.\n
            **read_geometry:** If True, geometry is read from the file.\n
            **read_model:** If True, finite element model data is read from the file.\n
            **read_output:** If True, analysis results will be read from the file.\n
            **read_groups:** If True, groups will be read from the file.\n
            **read_views:** If True, views will be read from the file.\n
            **status_messages:** If True, status messages will be written to the Messages and Lists window to show how many entities are read.\n
            **offsetID:** Normally set to 0. If you specify another value, all IDs that are read are offset by this value.\n
            **renumber_layers:** If True, layers will be renumbered by the offsetID along with the rest of the model. If False, they are not renumbered.\n
            **renumber_load_bc:** If True, Load and Constraint sets are renumbered by offsetID along with the rest of the model. If False, they are not renumbered.\n
            **always_new_output_sets:** If True, Output Sets are never overwritten - new ones are always created. The Output Set IDs in the file are used to determine the order in which they are created - the ID is added to the previous maximum Output Set ID in the model. For example, if your model already contained Output Sets up to 10, then if you read Output Set 1 it would be stored as 11, Set 2 would become 12 and so on. If your model did not contain output, this option has no effect.\n
        **Return Code:** True\n
        :type brand: int

        :type fName: str

        :type read_geometry: bool

        :type read_model: bool

        :type read_output: bool

        :type read_groups: bool

        :type read_views: bool

        :type status_messages: bool

        :type offsetID: int

        :type renumber_layers: bool

        :type renumber_load_bc: bool

        :type always_new_output_sets: bool

        """
        ...

    def feFileReadParasolid(self, fName) -> Any:
        """
        **Description:**
            Short form of feFileReadParasolidOpt( ).
        **Remarks/Usage:**
            Using this function is equivalent to calling:
        **Input:**
            **fName:** The filename/path of the Parasolid file to be read.\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def feFileReadParasolidOpt(self, useDlg, fName, title, layer, color, increment_layer, increment_color, assign_color,
                               convert_format, clean, heal, check, stringent, delete_invalid, faces, Scale) -> Any:
        """
        **Description:**
            This function loads geometry from a Parasolid .X_T file. It works like File, Import, Geometry, when you pick a Parasolid file. The file is loaded into the current model.
        **Remarks/Usage:**
            In general, you will not want to convert geometry to ACIS format. In that case, all of the parameters after convert_format are ignored.
        **Input:**
            **useDlg:** If True, the function runs interactively and displays a dialog box to allow the user to define the options. Only the fName option is used; all others are ignored.\n
            **fName:** The filename/path of the Parasolid file to be read.\n
            **title:** The title that is assigned to created layers and the solid.\n
            **layer:** The ID of the layer for new geometry. Set to -1 to use the active layer.\n
            **color:** The color used for the geometry that is created. Set to -1 to use the active solid color. Only used if assign_color=True.\n
            **layer:** If True and you read an assembly, geometry for each solid is placed on a different layer; otherwise, all geometry is on the specified layer.\n
            **color:** If True and you read an assembly, geometry for each solid is colored differently.\n
            **color:** If True, the specified color value is used for geometry; otherwise, the default colors are used.\n
            **clean:** Only used if convert_format=True. If True, this attempts to detect and remove sliver faces or other geometric problems.\n
            **heal:** Only used if convert_format=True. If True, attempts to close gaps and correct geometric inaccuracies.\n
            **check:** Only used if convert_format=True. If True, checks converted ACIS geometry to find and report any problems.\n
            **stringent:** Only used if convert_format=True. If True, checks for surface discontinuities or irregularities in the converted ACIS geometry.\n
            **delete_invalid:** Only used if convert_format=True. If True and geometry was checked, this deletes any geometry that failed the checking.\n
            **faces:** Only used if convert_format=True. If True and it was not possible to convert a complete solid, this will allow unstitched, free surfaces to be retained. \n
            **Scale:** Only used if convert_format=True. This is a scale factor that is applied to the geometry during conversion. It is used to ensure that the geometry lies inside the ACIS modeling box.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fName: str

        :type title: str

        :type layer: int

        :type color: int

        :type layer: bool

        :type color: bool

        :type color: bool

        :type clean: bool

        :type heal: bool

        :type check: bool

        :type stringent: bool

        :type delete_invalid: bool

        :type faces: bool

        :type Scale: float

        """
        ...

    def feFileReadPatran(self, fName, bSaveZeroDispAsBC) -> Any:
        """
        **Description:**
            This function loads finite element model data from an existing Patran file.
        **Remarks/Usage:**
            None
        **Input:**
            **fName:** The filename of the Patran input file to read.\n
            **bSaveZeroDispAsBC:** If True, Zero Nodal Displacements are stored as Constraints. If False, they are stored as loads.\n
        **Return Code:** True\n
        :type fName: str

        :type bSaveZeroDispAsBC: bool

        """
        ...

    def feFileReadProe(self, fName) -> Any:
        """
        **Description:**
            This function loads geometry from a Pro/E (.PRT) file. It works like File, Import, Geometry, when you pick a Pro/E file. The file is loaded into the current model.
        **Remarks/Usage:**
            None
        **Input:**
            **fName:** The filename/path of the Pro/E file to be read.\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def feFileReadSolidEdge(self, fName) -> Any:
        """
        **Description:**
            This function loads geometry from a Solid Edge (.PAR) file. It works like File, Import, Geometry, when you pick a Solid Edge file. The file is loaded into the current model.
        **Remarks/Usage:**
            None
        **Input:**
            **fName:** The filename/path of the Solid Edge file to be read.\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def feFileReadSolidWorks(self, fName) -> Any:
        """
        **Description:**
            This function loads geometry from a SolidWorks part (.sldprt) or assembly (.sldasm) file. It works like File, Import, Geometry, when you pick a SolidWorks file. The file is loaded into the current model
        **Remarks/Usage:**
            None
        **Input:**
            **fName:** The filename/path of the SolidWorks part or assembly file to be read.\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def feFileReadStep(self, fName) -> Any:
        """
        **Description:**
            Short form of feFileReadStepOpt2( ).
        **Remarks/Usage:**
            Using this function is equivalent to calling:
        **Input:**
            **fName:** The filename/path of the STEP file to be read.\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def feFileReadStepOpt(self, useDlg, fName, title, layer, color, increment_layer, increment_color, assign_color,
                          class_VI, class_V, class_IV, class_III, class_II_wf, class_II_curv, class_II_rect,
                          class_II_2d, smooth_g1, explode, analytics, stitch, closed_orient, pro_e, check_input,
                          check_output) -> Any:
        """
        **Description:**
            This method is obsolete and should no longer be used. Use feFileReadStepOpt2 instead.
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, the function runs interactively and displays a dialog box to allow the user to define the options. Only the fName option is used; all others are ignored.\n
            **fName:** The filename/path of the STEP file to be read.\n
            **title:** The title that is assigned to created layers and the solid.\n
            **layer:** The ID of the layer for new geometry. Set to -1 to use the active layer.\n
            **color:** The color used for the geometry that is created. Set to -1 to use the active solid color. Only used if assign_color=True.\n
            **layer:** If True and you read an assembly, geometry for each solid is placed on a different layer; otherwise all geometry is on the specified layer.\n
            **color:** If True and you read an assembly, geometry for each solid is colored differently.\n
            **color:** If True, the specified color value is used for geometry; otherwise, the default colors are used.\n
            **class_VI:** Set to True if you want to read Class VI solids.\n
            **class_V:** Set to True if you want to read Class V faceted solids.\n
            **class_IV:** Set to True if you want to read Class IV surfaces.\n
            **class_III:** Set to True if you want to read Class III wireframe - edge based and shell based wireframe geometry.\n
            **class_II_wf:** Set to True if you want to read Class II wireframe - wireframe without topology or other underlying surfaces.\n
            **class_II_curv:** Set to True if you want to read Class II curve bounded surfaces.\n
            **class_II_rect:** Set to True if you want to read Class II rectangular trimmed surfaces. Normally this is False, because these surfaces are usually used for construction geometry, not part geometry.\n
            **class_II_2d:** Set to True to read 2D trimming curves for surfaces. These are curves in the surface parametric coordinates. If you set this to False, 3D trimming curves will be read.\n
            **smooth_g1:** If True, attempts to eliminate discontinuities in the STEP geometry which cannot be represented in Parasolid. Set this to True for the best conversion.\n
            **explode:** If True, STEP geometry will be read as independent faces, then Parasolid will be used to restitch the solid. If False, the topology will be constructed directly from the data in the STEP file. Setting this to True will help to eliminate geometric tolerancing problems.\n
            **analytics:** If True, geometry will be simplified to analytical surfaces whenever possible.\n
            **stitch:** If True, surfaces will be stitched into a solid.\n
            **closed_orient:** If True, extra checking is done to eliminate problems that can occur in closed analytical (sphere and torus) surfaces that produce complementary surfaces.\n
            **pro_e:** If True, forces angle units to degrees to work around a problem in old Pro/E STEP files. Always set to False unless you are having specific problems with Pro/E files.\n
            **check_input:** If True, syntax checking of the STEP file is done prior to reading.\n
            **check_output:** If True, the Parasolid geometry is checked for validity after the conversion.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fName: str

        :type title: str

        :type layer: int

        :type color: int

        :type layer: bool

        :type color: bool

        :type color: bool

        :type class_VI: bool

        :type class_V: bool

        :type class_IV: bool

        :type class_III: bool

        :type class_II_wf: bool

        :type class_II_curv: bool

        :type class_II_rect: bool

        :type class_II_2d: bool

        :type smooth_g1: bool

        :type explode: bool

        :type analytics: bool

        :type stitch: bool

        :type closed_orient: bool

        :type pro_e: bool

        :type check_input: bool

        :type check_output: bool

        """
        ...

    def feFileReadStepOpt2(self, useDlg, fName, layer, color, increment_layer, increment_color, assign_color, bodies,
                           faceted, Surfaces, Curves, Points, optimize, simplify) -> Any:
        """
        **Description:**
            This function loads geometry from a STEP (.STP) file. It works like File, Import, Geometry, when you pick a STEP file. The file is loaded into the current model.
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, the function runs interactively and displays a dialog box to allow the user to define the options. Only the fName option is used; all others are ignored.\n
            **fName:** The filename/path of the STEP file to be read.\n
            **layer:** The ID of the layer for new geometry. Set to -1 to use the active layer. GUI specifies the active layer\n
            **color:** The color used for the geometry that is created. Set to -1 to use the active solid color. Only used if assign_color=True.\n
            **layer:** If True and you read an assembly, geometry for each solid is placed on a different layer; otherwise all geometry is on the specified layer. Default in GUI is False\n
            **color:** If True and you read an assembly, geometry for each solid is colored differently. Default in GUI is True\n
            **color:** If True, the specified color value is used for geometry; otherwise, the default colors are used. Default in GUI is True\n
            **bodies:** Set to True if you want to read Bodies. Default in GUI is True.\n
            **faceted:** Set to True if you want to read Faceted Bodies. Default in GUI is True.\n
            **Surfaces:** Set to True if you want to read Surfaces. Default in GUI is True.\n
            **Curves:** Set to True if you want to read Curves. Default in GUI is True.\n
            **Points:** Set to True if you want to read Points. Default in GUI is True.\n
            **optimize:** Set to True if you want to Optimize Bodies. Default in GUI is True.\n
            **simplify:** Set to True if you want to Simplify Geometry. Default in GUI is False.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fName: str

        :type layer: int

        :type color: int

        :type layer: bool

        :type color: bool

        :type color: bool

        :type bodies: bool

        :type faceted: bool

        :type Surfaces: bool

        :type Curves: bool

        :type Points: bool

        :type optimize: bool

        :type simplify: bool

        """
        ...

    def feFileReadStl(self, useDlg, fName, skip_short_edges, merge_nodes, close_gaps, PATRAN_file, min_distance) -> Any:
        """
        **Description:**
            This function loads geometry from a Stereolithography (.STL) file. It works like File, Import, Geometry,when you pick an STL file. The file is loaded into the current model.
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, the function runs interactively and displays a dialog box to allow the user to define the options. Only the fName option is used; all others are ignored.\n
            **fName:** The filename/path of the STL file to be read.\n
            **skip_short_edges:** Set to True to skip edges that are shorter than the min_distance setting.\n
            **merge_nodes:** Set to True to merge all coincident nodes after the file is loaded.\n
            **close_gaps:** Set to True to attempt to close gaps in the STL mesh.\n
            **PATRAN_file:** Set to True to read a PATRAN generated STL file where negative coordinates can run together with no spaces between them.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fName: str

        :type skip_short_edges: bool

        :type merge_nodes: bool

        :type close_gaps: bool

        :type PATRAN_file: bool

        """
        ...

    def feFileReadUg(self, useDlg, fName, rdBlanked, rdLayers) -> Any:
        """
        **Description:**
            This function loads geometry from a Unigraphics (.PRT) file. It works like File, Import, Geometry, when you pick a Unigraphics file. The file is loaded into the current model.
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, the function runs interactively and displays a dialog box to allow the user to define the options. Only the fName option is used; all others are ignored.\n
            **fName:** The filename/path of the Unigraphics file to be read.\n
            **rdBlanked:** Set to True to read parts that are blanked. If False, only unblanked parts will be read.\n
            **rdLayers:** Set to True to read parts that are on invisible layers. If False, only parts on visible layers will be read.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fName: str

        :type rdBlanked: bool

        :type rdLayers: bool

        """
        ...

    def feFileRebuild(self, useDlg, fullRebuild) -> Any:
        """
        **Description:**
            This function is similar to the File,Rebuildcommand. It rebuilds the current FEMAP database and checks it for integrity.
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, this function runs interactively and displays a dialog box to ask whether to do a full or partial rebuild. An additional dialog box may also be displayed if solid geometry is found that cannot be loaded.\n
            **fullRebuild:** Only used if useDlg=False. If True, a full rebuild is performed and all internal database pointers are reconstructed. If False, a partial rebuild is performed. This simply checks data references to make sure that all required entities still exist, and resets all usage counters.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fullRebuild: bool

        """
        ...

    def feFileRecoverDBData(self, useDlg, fName) -> Any:
        """
        **Description:**
            This function is a low-level attempt to recover whatever data is still available in the scratch file of a corrupted model. It will not fully recover the model.
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, this function runs interactively and displays a dialog box to choose the file to recover\n
            **fName:** Only used if useDlg=False. The filename/path of the _DBData file to attempt to recover\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fName: str

        """
        ...

    def feFileSave(self, useDlg) -> Any:
        """
        **Description:**
            This function saves the current model to the current model name, like the File, Save command.
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, the function runs interactively. In this mode, if the model name has not been specified, the Save Asdialog will be displayed to allow you to choose the name. If a model filename has been specified, the model will simply be saved.\n
        **Return Code:** True\n
        :type useDlg: bool

        """
        ...

    def feFileSaveAs(self, useDlg, fName) -> Any:
        """
        **Description:**
            This function saves the current model, like the File, Save As command. The filename can either be specified or chosen interactively.
        **Remarks/Usage:**
            feFileSaveAs( True,   ) - ask the user for a filename and save the current model to that file.
        **Input:**
            **useDlg:** If True, the filename to be used to save the current model will be chosen interactively by display the Save As dialog box.\n
            **fName:** The filename to use to save the current model. This is only used if useDlg=False.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type fName: str

        """
        ...

    def feFileTimedSave(self, useDlg, saving, notify, Interval, commands) -> Any:
        """
        **Description:**
            This function controls whether or not timed save is turned on, and sets the available parameters for timed save operation. It works like the File, Timed Save command.
        **Remarks/Usage:**
            Calling this function automatically stops any previous timed save operations. When the function is complete, if timed save is turned on, it is reinitialized.
        **Input:**
            **useDlg:** If True, the function runs interactively and displays the dialog box displayed by the File, Timed Savecommand. In this case, all other parameters are ignored.\n
            **saving:** Turns on/off timed save ( True = on, False = off).\n
            **notify:** If this is on, then the user will be notified prior to a timed save taking place.\n
            **Interval:** Time in minutes between timed saves ( 1..999 ).\n
            **commands:** Number of commands between timed saves ( 0, 1..999 ). If you set this to 0, then timed saves will be done based on time only.\n
        **Return Code:** True\n
        :type useDlg: bool

        :type saving: bool

        :type notify: bool

        :type Interval: int

        :type commands: int

        """
        ...

    def feFileWriteAbaqus(self, brand, fName) -> Any:
        """
        **Description:**
            This function writes an ABAQUS input file.
        **Remarks/Usage:**
            If you have an active analysis set, preferably one that has ABAQUS selected as the solver, then no dialog boxes will be displayed. If not, this function will display dialog boxes to collect whatever data that it needs to complete the file using the legacy analysis translator. The global variable Pref_AnalysisType is used to determine the type of analysis that is to be performed by the file.
        **Input:**
            **brand:** Not currently used.\n
            **fName:** The filename of the ABAQUS input file to write.\n
        **Return Code:** False\n
        :type brand: int

        :type fName: str

        """
        ...

    def feFileWriteAcis(self, useDlg, fName, version, solidSET) -> Any:
        """
        **Description:**
            This function writes solids from your model into a ACIS SAT file.
        **Remarks/Usage:**
            None
        **Input:**
            **useDlg:** If True, the function runs interactively. The dialog box that asks you to pick the solids to write will be displayed. \n
            **fName:** The filename of the ACIS SAT file to write.\n
            **version:** The ACIS version number of the file to be written. Set this to 0 to use the current version of ACIS. Available previous versions are the same numbers as displayed in the dialog box when you run the File, Export, Geometry command.\n
            **solidSET:** The ID of a selection set that contains the IDs of the solids to write. Alternatively, if you specify a negative value, this is simply the ID of the single solid to write. Not used if useDlg=True.\n
        **Return Code:** False\n
        :type useDlg: bool

        :type fName: str

        :type version: float

        :type solidSET: int

        """
        ...

    def feFileWriteAnsys(self, brand, fName) -> Any:
        """
        **Description:**
            This function writes an ANSYS input file.
        **Remarks/Usage:**
            If you have an active analysis set, preferably one that has ANSYS selected as the solver, then no dialog boxes will be displayed. If not, this function will display dialog boxes to collect whatever data that it needs to complete the file using the legacy analysis translator. The global variable Pref_AnalysisType is used to determine the type of analysis that is to be performed by the file.
        **Input:**
            **brand:** Not currently used.\n
            **fName:** The filename of the ANSYS input file to write.\n
        **Return Code:** False\n
        :type brand: int

        :type fName: str

        """
        ...

    def feFileWriteDyna(self, brand, fName) -> Any:
        """
        **Description:**
            This function writes an LS-DYNA input file.
        **Remarks/Usage:**
            If you have an active analysis set, preferably one that has LS-DYNA selected as the solver, then no dialog boxes will be displayed. If not, this function will display dialog boxes to collect whatever data that it needs to complete the file using the legacy analysis translator. The global variable Pref_AnalysisType is used to determine the type of analysis that is to be performed by the file.
        **Input:**
            **brand:** Not currently used.\n
            **fName:** The filename of the DYNA file to write.\n
        **Return Code:** False\n
        :type brand: int

        :type fName: str

        """
        ...

    def feFileWriteFNO2V2(self, nSetSet, nVectorSet, nOutputOnGroup, nElementConnectivityGroup, fName) -> Any:
        """
        **Description:**
            This function writes a FEMAP Neutral Output File (.FNO) with option to also include element connectivity records in the file. This method replaces feFileWriteFNO2. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            This method allows you to extract all or a subset of results from the FEMAP database or other attached results files and write it to a FEMAP Neutral Output File which can then be either read into the FEMAP database or attached. It also allows element connectivity records to be written to the FNO.
        **Input:**
            **nSetSet:** The ID of a Set Object that contains the IDs of the Output Sets to write to the FNO File. If you simply want to write all available Output Sets, specify 0.\n
            **nVectorSet:** The ID of a Set Object that contains the IDs of the Output Vectors to write to the FNO File. If you simply want to write all available Output Vectors, specify 0.\n
            **fName:** The filename of the FNO file to write.\n
        **Return Code:** True\n
        :type nSetSet: int

        :type nVectorSet: int

        :type fName: str

        """
        ...

    def feFileWriteFNO3V2(self, nSetSet, nVectorSet, nOutputOnGroup, nElementConnectivityGroup, nFileVersion,
                          fName) -> Any:
        """
        **Description:**
            This function writes a FEMAP Neutral Output File (.FNO) with option to also include element connectivity records in the file. The file version must be specified for the map of output vector IDs. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            This method allows you to extract all or a subset of results from the FEMAP database or other attached results files and write it to a FEMAP Neutral Output File which can then be either read into the FEMAP database or attached. It also allows element connectivity records to be written to the FNO.
        **Input:**
            **nSetSet:** The ID of a Set Object that contains the IDs of the Output Sets to write to the FNO File. If you simply want to write all available Output Sets, specify 0.\n
            **nVectorSet:** The ID of a Set Object that contains the IDs of the Output Vectors to write to the FNO File. If you simply want to write all available Output Vectors, specify 0.\n
            **nFileVersion:** The filename of the FNO file to write.\n
        **Return Code:** True\n
        :type nSetSet: int

        :type nVectorSet: int

        :type nFileVersion: str

        """
        ...

    def feFileWriteFNOV2(self, nSetSet, nVectorSet, nGroup, fName) -> Any:
        """
        **Description:**
            This function writes a FEMAP Neutral Output File (.FNO). This method replaces feFileWriteFNO. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            This method allows you to extract all or a subset of results from the FEMAP database or other attached results files and write it to a FEMAP Neutral Output File which can then be either read into the FEMAP database or attached.
        **Input:**
            **nSetSet:** The ID of a Set Object that contains the IDs of the Output Sets to write to the FNO File. If you simply want to write all available Output Sets, specify 0.\n
            **nVectorSet:** The ID of a Set Object that contains the IDs of the Output Vectors to write to the FNO File. If you simply want to write all available Output Vectors, specify 0.\n
            **nGroup:** The ID of a Group that contains the nodes and/or elements whose output will be written. If you specify 0, output for all nodes/elements will be written. If the Group contains only elements and no nodes, and you choose to write nodal vectors, only output on the nodes connected to the selected elements will be written. If the Group contains nodes, then output on only those nodes will be written.\n
            **fName:** The filename of the FNO file to write.\n
        **Return Code:** True\n
        :type nSetSet: int

        :type nVectorSet: int

        :type nGroup: int

        :type fName: str

        """
        ...

    def feFileWriteIdeas(self, fName, PartName, WriteGroups, AbsoluteTempScale, UnitSystem, UserLengthFactor,
                         UserForceOrMass, UserForceOrMassFactor, UserTempFactor, UserTempOffset) -> Any:
        """
        **Description:**
            This function writes an I-DEAS universal file.
        **Remarks/Usage:**
            This function matches using the File, Export, Analysis Modelcommand and I-DEAS has been selected.
        **Input:**
            **fName:** The filename of the I-DEAS universal file to write.\n
            **PartName:** The Part Name specified in the universal file.\n
            **WriteGroups:** When True, groups in the model will be written to the universal file. When False, no groups are written.\n
            **AbsoluteTempScale:** When True, sets the Temperature Mode to Kelvin or Rankine (depends on option set in UnitSystem), while False sets it to either Celsius or Fahrenheit.\n
            **UnitSystem:** Sets Unit Systems. 1=SI: Meter (newton), 2=BG: Foot (pound f), 3=MG: Meter (kilogram f), 4=BA: Foot (poundal), 5=MM: mm (milli-newton), 6=CM: cm (centi-newton), 7=IN: Inch (pound f), 8=GM: mm (kilogram f), 9=MN: mm (newton), 10=US: User Defined (User values below only used when set to 10)\n
            **UserLengthFactor:** units/meter scale factor\n
            **UserForceOrMass:** When True, uses units/force. When False, uses units/mass \n
            **UserTempFactor:** units/degree scale factor (UnitSystem = User Defined only)\n
            **UserTempOffset:** offset from temperature (UnitSystem = User Defined only)\n
        **Return Code:** True\n
        :type fName: str

        :type PartName: str

        :type WriteGroups: bool

        :type AbsoluteTempScale: bool

        :type UnitSystem: int

        :type UserLengthFactor: float

        :type UserForceOrMass: bool

        :type UserTempFactor: float

        :type UserTempOffset: float

        """
        ...

    def feFileWriteIges(self, fName, spline_curves, spline_surfaces, bounded_surfaces, customization, surface_options,
                        export_as, solidSET) -> Any:
        """
        **Description:**
            This function writes selected solids to an IGES file.
        **Remarks/Usage:**
            Only Parasolid solids can be written to an IGES file.
        **Input:**
            **spline_surfaces:** If True, surfaces are written as splines.\n
            **bounded_surfaces:** If True, surfaces will be written as Type 143, bounded surfaces. Otherwise, Type 144 trimmed surfaces will be written.\n
            **customization:** Controls the IGES customization options: 0=None, 1=AutoCAD, 2=JAMA-IS, 3=I-DEAS.\n
            **export_as:** Controls how to write solids: 0=Solid MSBO, 1=Trimmed Surfaces, 2=Wireframe.\n
            **solidSET:** The ID of a selection set that contains the IDs of the solids to write. Alternatively, if you specify a negative value, this is simply the ID of the single solid to write.\n
        **Return Code:** True\n
        :type spline_surfaces: bool

        :type bounded_surfaces: bool

        :type customization: int

        :type export_as: int

        :type solidSET: int

        """
        ...

    def feFileWriteJT(self, fName, solidSET) -> Any:
        """
        **Description:**
            This function writes selected solids to a JT file.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def feFileWriteMarc(self, brand, fName) -> Any:
        """
        **Description:**
            This function writes a Marc input file.
        **Remarks/Usage:**
            If you have an active analysis set, preferably one that has MARC selected as the solver, then no dialog boxes will be displayed. If not, this function will display dialog boxes to collect whatever data that it needs to complete the file using the legacy analysis translator. The global variable Pref_AnalysisType is used to determine the type of analysis that is to be performed by the file.
        **Input:**
            **brand:** Not currently used.\n
            **fName:** The filename of the Marc file to read.\n
        **Return Code:** False\n
        :type brand: int

        :type fName: str

        """
        ...

    def feFileWriteNastran(self, brand, fName) -> Any:
        """
        **Description:**
            This function writes a NASTRAN input file.
        **Remarks/Usage:**
            If you have an active analysis set, preferably one that has the appropriate brand of NASTRAN selected as the solver, then no dialog boxes will be displayed. If not, this function will display dialog boxes to collect whatever data that it needs to complete the file using the specified legacy analysis translator. The global variable Pref_AnalysisType is used to determine the type of analysis that is to be performed by the file.
        **Input:**
            **brand:** Used to select the format of the NASTRAN file. 0=MSC, 1=NE, 2=UAI, 3=CSA, 4=SSS, 5=Cosmic, 6=ME, 7=VR, 8=NX.\n
            **fName:** The filename of the NASTRAN input file to write.\n
        **Return Code:** True\n
        :type brand: int

        :type fName: str

        """
        ...

    def feFileWriteNeutral(self, brand, fName, write_geometry_model, write_analysis_model, write_output,
                           write_addl_info, expand_geometric, minimize_size, digits, version, groupID) -> Any:
        """
        **Description:**
            This method is the same as calling feFileWriteNeutral2 with write_selector and write_palette equal to True, and write_groups and write_views equal to write_analysis_model. Refer to that method for more information.
        **Return Code:** False\n
        """
        ...

    def feFileWriteNeutral2(self, brand, fName, write_geometry_model, write_analysis_model, write_output,
                            write_selector, write_palette, write_groups, write_views, write_addl_info, expand_geometric,
                            minimize_size, digits, version, groupID) -> Any:
        """
        **Description:**
            This function writes a FEMAP Neutral file.
        **Remarks/Usage:**
            None
        **Input:**
            **brand:** Used to select the format of the Neutral file: 0=FEMAP Neutral (the default), 1=CAEFEM, 2=CDA/Sprint, 3=CFDesign, 4=SINDA. The formats other than 0 should not be used unless you are writing a file specifically to be used with that program.\n
            **fName:** The filename of the Neutral file to write.\n
            **write_geometry_model:** If True, geometry is written to the file.\n
            **write_analysis_model:** If True, finite element model data is written to the file.\n
            **write_output:** If True, analysis results will be written to the file.\n
            **write_palette:** If True, color palette information will be written to the file\n
            **write_groups:** If True, groups will be written to the file\n
            **write_views:** If True, views will be written to the file\n
            **expand_geometric:** If True, geometric loads and constraints will be expanded before being written.\n
            **minimize_size:** If True, spaces are compressed out of the file to reduce its size.\n
            **digits:** The number of digits of precision for all real numbers (must be 2 to 20).\n
            **version:** The version of the Neutral file to produce. Set to 0.0 to create the latest version. If you do not use 0.0, some model data may not be compatible with the file you write and will be lost.\n
            **groupID:** The ID of the group to write to the file. Specify 0 to write the entire model.\n
        **Return Code:** True\n
        :type brand: int

        :type fName: str

        :type write_geometry_model: bool

        :type write_analysis_model: bool

        :type write_output: bool

        :type write_palette: bool

        :type write_groups: bool

        :type write_views: bool

        :type expand_geometric: bool

        :type minimize_size: bool

        :type digits: int

        :type version: float

        :type groupID: int

        """
        ...

    def feFileWriteParasolid(self, useDlg, fName, version, solidSET) -> Any:
        """
        **Description:**
            This function writes solids from your model into a Parasolid X_T file.
        **Remarks/Usage:**
             None
        **Input:**
            **useDlg:** If True, the function runs interactively. The dialog box that asks you to pick the solids to write will be displayed. \n
            **fName:** The filename of the Parasolid X_T file to write.\n
            **version:** The Parasolid version number of the file to be written. Set this to 0 to use the current version of Parasolid. Available previous versions are the same numbers as displayed in the dialog box when you run the File, Export, Geometry command.\n
            **solidSET:** The ID of a selection set that contains the IDs of the solids to write. Alternatively, if you specify a negative value, this is simply the ID of the single solid to write. Not used if useDlg=True.\n
        **Return Code:** False\n
        :type useDlg: bool

        :type fName: str

        :type version: float

        :type solidSET: int

        """
        ...

    def feFileWriteSEPost(self, fName, bOutputSurfaceMap) -> Any:
        """
        :type fName: Any
        :type bOutputSurfaceMap: Any
        """
        ...

    def feFileWriteSTAAD(self, fName, AnalysisType, sStructType, sLengthUnits, sForceUnits, sPropUnits, dGravConstant,
                         bModalCalc, dModalCutOffFreq, nModalCutOffMode, bPrintModel, bPrintDisp, bPrintReactions,
                         bPrintMemberForces, bPrintMemberStresses, bPrintElemForces, bPrintJointForces, bPostDisp,
                         bPostSectionDisp, bPostMemberForces, bPostStresses) -> Any:
        """
        **Description:**
            This function writes a STAAD input file.
        **Remarks/Usage:**
            None
        **Input:**
            **fName:** The filename of the STAAD input file to write.\n
            **AnalysisType:** 1=Static, 2=Modes\n
            **sStructType:** PLANE, SPACE, TRUSS, FLOOR or DATA\n
            **sLengthUnits:** INCHES, FEET, CM, METER, MMS, DME or KM\n
            **sForceUnits:** KIP, POUND, KG, MTON, NEWTON, KNS, MNS or DNS\n
            **sPropUnits:** INCHES, FEET, CM, METER, MMS, DME or KM\n
            **dGravConstant:** The gravity constant\n
            **bModalCalc:** True=MODAL CALCULATION REQUESTED, False=CALCULATE NATURAL FREQUENCY. Only used if AnalysisType is Modes.\n
            **dModalCutOffFreq:** The maximum frequency requested. Only used if AnalysisType is Modes.\n
            **nModalCutOffMode:** The maximum mode number requested. Only used if AnalysisType is Modes.\n
        **Return Code:** True\n
        :type fName: str

        :type AnalysisType: int

        :type sStructType: str

        :type sLengthUnits: str

        :type sForceUnits: str

        :type sPropUnits: str

        :type dGravConstant: float

        :type bModalCalc: bool

        :type dModalCutOffFreq: float

        :type nModalCutOffMode: int

        """
        ...

    def feFileWriteStep(self, fName, solidSET) -> Any:
        """
        **Description:**
            This method is obsolete and should no longer be used. Use feFileWriteStepOpt2 instead.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def feFileWriteStep2(self, fName, solidSET, format) -> Any:
        """
        **Description:**
            This function writes selected solids to a STEP file.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def feFileWriteStl(self, fName, elemSET) -> Any:
        """
        **Description:**
            This function writes elements, or the faces of elements (solids) into a stereolithography (STL) file.
        **Remarks/Usage:**
            All entities written to the STL file are in the form of triangles. Any quadrilateral faces that are selected are split into two triangles. Faces with midside nodes are split into multiple triangles. Planar elements are written as-is, while solid elements are combined and only their free-faces are written.
        **Return Code:** False\n
        """
        ...

    def feFileWriteTopologyStl(self, fName) -> Any:
        """
        **Description:**
            This function writes elements from criteria plot into a stereolithography (STL) file.
        **Remarks/Usage:**
            A criteria plot of the model must be shown in the active view to write an STL file. All entities written to the STL file are in the form of triangles. Any quadrilateral faces that are selected are split into two triangles. Faces with midside nodes are split into multiple triangles. Planar elements are written as-is, while solid elements are combined and only their free-faces are written.
        **Return Code:** True\n
        """
        ...

    def feFileWriteVrml(self, fName, version, write_solid, single_color, write_deformed, write_contour,
                        write_background, background_color, color, solidSET) -> Any:
        """
        **Description:**
            This function writes either elements or solids to a VRML file.
        **Remarks/Usage:**
            None
        **Input:**
            **version:** Either 1.0 or 2.0. Specifies the version of VRML to write.\n
            **write_solid:** If True, the solids selected in solidSET will be written to the VRML file; otherwise, the elements displayed in the active view will be written.\n
            **single_color:** If True, all entities are written in the color specified.\n
            **write_deformed:** If True and elements are written and the current view style is deformed, then the geometry written is in its deformed location.\n
            **write_contour:** If True and elements are written and the current view style is contour, then the geometry written will include contour information.\n
            **background_color:** If the background is written, this is its color.\n
            **color:** If single_color=True, this is the color used for all entities.\n
            **solidSET:** If write_solid=True, then this is the ID of a selection set that contains the solids to write. Alternatively, you can specify a negative number that will be the ID of a single solid to write.\n
        **Return Code:** True\n
        :type version: float

        :type write_solid: bool

        :type single_color: bool

        :type write_deformed: bool

        :type write_contour: bool

        :type background_color: int

        :type color: int

        :type solidSET: int

        """
        ...

    def feFormatReal(self, dValue, nWidth, nDecimal, nFormat, strValue) -> Any:
        """
        **Description:**
            Formats a real number into a text string using the options used internally by FEMAP
        **Remarks/Usage:**
            None
        **Input:**
            **dValue:** The real value to format\n
            **nWidth:** The overall width of the text string to produce\n
            **nDecimal:** The number of significant figures to attempt to format. Must be able to fit within the specified width\n
            **nFormat:** The formatting method to use 0=Normal, 1=Force Exponential, 2=Nastran\n
        **Output:**
            **strValue:** The text string containing the formatted real number\n
        **Return Code:** False\n
        :type dValue: float

        :type nWidth: int

        :type nDecimal: int

        :type nFormat: int

        :type strValue: str

        """
        ...

    def feGFXDelete(self, bAllSets, nSetID) -> Any:
        """
        **Description:**
            Deletes all User Graphics entities (points, lines, arrows, triangles and quads) in one or more sets
        **Remarks/Usage:**
            Calling this method deletes the User Graphics data from your model, however if User Graphics were selected for display, they will continue to be displayed even after calling this method (even though the underlying data has been deleted). You must call "feGFXReset" (Section 3.17.2.3) to remove the graphics from the display.
        **Input:**
            **bAllSets:** If True, all entities, in all sets are deleted. If False, then all entities in Set nSetID are deleted\n
            **nSetID:** The setID to delete if bAllSets=False\n
        **Return Code:** True\n
        :type bAllSets: bool

        :type nSetID: int

        """
        ...

    def feGFXEnableView(self, bEnableAll, nVuID) -> Any:
        """
        **Description:**
            Enables display of User Graphics in one or more selected views.
        **Remarks/Usage:**
            This method is only needed if you only want to enable display of User Graphics in certain views. To display in every view, simply specify bEnableAll=True when you call "feGFXSelect" (Section 3.17.2.1)to select the data to display.
        **Input:**
            **bEnableAll:** If True, then display of User Graphics will be enabled for all active views. If False, only the view specified by nVuID will be enabled.\n
            **nVuID:** The ID of the View to enable. Only used if bEnableAll=False\n
        **Return Code:** True\n
        :type bEnableAll: bool

        :type nVuID: int

        """
        ...

    def feGFXLoad(self, nSetID, nxyz, xyz, npoly, poly, color, edgecolor, symbol) -> Any:
        """
        **Description:**
            Creates User Graphics Data containing points, lines, triangles and/or quads
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** The User Graphics Set to create\n
            **nxyz:** The number of locations specified in the coordinate table (xyz)\n
            **xyz:** The coordinates used to define the endpoints/corners of the graphics data. This data is referenced by the entries in poly. All values must be in global rectangular coordinates. \n
            **npoly:** The number of entries in the poly array\n
            **poly:** This array contains 4 entries for each graphics entity to be created. The values must be the index in the xyz array of the coordinates for that endpoint/corner. For points, only the first of the four entries is used. For lines, the first two are used. For triangles, the first three are used. ALL UNUSED ENTRIES MUST BE SET TO -1 (that is what indicates which shape you are describing). The array must contain data in the following order (Entity1Corner1, Entity1Corner2, Entity1Corner3, Entity1Corner4, Entity2Corner1, Entity2Corner2...). Note that the first coordinate in the xyz array is index 0, not 1.\n
            **color:** The color of the entities created. For triangles and quads this is the fillcolor\n
            **color:** Only used for triangles and quads. The color of the edges.\n
            **symbol:** Only used for points. The symbol to be displayed for points.\n
        **Return Code:** True\n
        :type nSetID: int

        :type nxyz: int

        :type xyz: tuple[float]

        :type npoly: int

        :type poly: tuple[int]

        :type color: int

        :type color: int

        :type symbol: int

        """
        ...

    def feGFXReset(self) -> Any:
        """
        **Description:**
            Disables display of User Graphics in all views.
        **Remarks/Usage:**
            This method resets the display of User Graphics. It does not delete the data from your model. You must call "feGFXDelete" (Section 3.17.1.2)or one of the User Graphics Entity delete methods to delete the data. After calling this method, you can redisplay the data by calling "feGFXSelect" (Section 3.17.2.1).
        **Return Code:** True\n
        """
        ...

    def feGFXSelect(self, nSetID, bEnableAll, bRedraw) -> Any:
        """
        **Description:**
            Selects a predefined set of User Graphics entities for display.
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** The setID to be selected for display\n
            **bEnableAll:** If True, then display of User Graphics will be enabled for all active views. If False, you must subsequently call "feGFXEnableView" (Section 3.17.2.2) to enable display for the views you want.\n
            **bRedraw:** Once selected User Graphics will only be displayed after a Redraw. If True, this forces an immediate redraw. Otherwise you will have to redraw later to see your graphics.\n
        **Return Code:** True\n
        :type nSetID: int

        :type bEnableAll: bool

        :type bRedraw: bool

        """
        ...

    def feGenerateCopy(self, entityTYPE, entitySET, alongVEC, nodeINC, Match) -> Any:
        """
        **Description:**
            Creates new entities by copying existing entities along a vector. This call behaves identically to feGenerateCopy2 when matchColorLayer argument is set to False.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The entity type to copy: \n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be copied. Alternatively, if you specify a negative value, this is simply the ID of the single entity to copy.\n
            **alongVEC:** The components of the vector used to copy the entities. Components must be specified in global rectangular coordinates. This is not a unit vector; the entities are copied a distance equal to the length of the vector.\n
            **nodeINC:** Only used if entityTYPE=Element. When you are copying elements, there are two possible approaches that you can take. You can either copy the elements and all of the nodes that they are used to define them, or you can just copy the element connectivity onto another existing set of nodes. If you want to copy the nodes and elements, set nodeINC=0. If you want to copy the elements onto existing nodes, you should set nodeINC equal to the difference in nodeIDs from the nodes on the existing elements to the nodes on the new elements.\n
            **Match:** If True, then loads and constraints on the original entities are copied to the newly created entities. If False, only the selected entities are duplicated.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type alongVEC: tuple[float]

        :type nodeINC: int

        :type Match: bool

        """
        ...

    def feGenerateCopy2(self, entityTYPE, entitySET, alongVEC, nodeINC, Match, matchColorLayer) -> Any:
        """
        **Description:**
            Creates new entities by copying existing entities along a vector. When matchColorLayer argument is set to False, behaves identical to feGenerateCopy.
        **Remarks/Usage:**
            Additional parameters included when matchColorLayer is True for Nodes include definition coordinate system, output coordinate system, permanent constraints, and Superelement ID, while additional parameters for Elements include formulation and material orientation angle
        **Input:**
            **entityTYPE:** The entity type to copy: \n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be copied. Alternatively, if you specify a negative value, this is simply the ID of the single entity to copy.\n
            **alongVEC:** The components of the vector used to copy the entities. Components must be specified in global rectangular coordinates. This is not a unit vector; the entities are copied a distance equal to the length of the vector.\n
            **nodeINC:** Only used if entityTYPE=Element. When you are copying elements, there are two possible approaches that you can take. You can either copy the elements and all of the nodes that they are used to define them, or you can just copy the element connectivity onto another existing set of nodes. If you want to copy the nodes and elements, set nodeINC=0. If you want to copy the elements onto existing nodes, you should set nodeINC equal to the difference in nodeIDs from the nodes on the existing elements to the nodes on the new elements.\n
            **Match:** If True, then loads and constraints on the original entities are copied to the newly created entities. If False, only the selected entities are duplicated.\n
            **Match:** If True, then color, layer, and some additional parameters of original entities are transferred to the newly created entities. If False, active parameters for the entity type will be used for the new entities.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type alongVEC: tuple[float]

        :type nodeINC: int

        :type Match: bool

        :type Match: bool

        """
        ...

    def feGenerateRadialCopy(self, entityTYPE, entitySET, origVEC, Length, Match) -> Any:
        """
        **Description:**
            Creates new entities by radially copying existing entities about an origin. This call behaves identically to feGenerateRadialCopy2 when matchColorLayer and bScaleAroundVec arguments are set to False.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The entity type to copy:\n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be copied. Alternatively, if you specify a negative value, this is simply the ID of the single entity to copy.\n
            **origVEC:** The coordinates of the origin around which the radial copy will be performed. The coordinates must be in global rectangular.\n
            **Length:** The radial distance to copy the entities. A positive value increases the distance from the origin. A negative value decreases the distance.\n
            **Match:** If True, then loads and constraints on the original entities are copied to the newly created entities. If False, only the selected entities are duplicated.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type origVEC: tuple[float]

        :type Length: float

        :type Match: bool

        """
        ...

    def feGenerateRadialCopy2(self, entityTYPE, entitySET, origXYZ, aroundVEC, Length, bScaleAroundVec, Match,
                              matchColorLayer) -> Any:
        """
        **Description:**
            Creates new entities by radially copying existing entities about an origin or about a vector. When both matchColorLayer and bScaleAroundVec arguments are set to False, behaves identical to feGenerateRadialCopy.
        **Remarks/Usage:**
            Additional parameters included when matchColorLayer is True for Nodes include definition coordinate system, output coordinate system, permanent constraints, and Superelement ID, while additional parameters for Elements include formulation and material orientation angle
        **Input:**
            **entityTYPE:** The entity type to copy:\n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be copied. Alternatively, if you specify a negative value, this is simply the ID of the single entity to copy.\n
            **origXYZ:** When bScaleAroundVec=True, coordinates of the origin of the axis around which the radial copy will be performed. When bScaleArouncVec=False, coordinates of the origin around which the radial copy will be performed. In both cases, the coordinates must be defined in global rectangular.\n
            **aroundVEC:** When bScaleAroundVec=True, components of the axis of radial copy, in global rectangular coordinates. When bScaleAroundVec=False, argument is ignored.\n
            **Length:** The radial distance to copy the entities. A positive value increases the distance from the origin. A negative value decreases the distance.\n
            **bScaleAroundVec:** If True, radial copy is performed around vector defined by both origXYZ and aroundVec. If False, radial copy is performed around location specified in origXYZ only.\n
            **Match:** If True, then loads and constraints on the original entities are copied to the newly created entities. If False, only the selected entities are duplicated.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type origXYZ: tuple[float]

        :type aroundVEC: tuple[float]

        :type Length: float

        :type bScaleAroundVec: bool

        :type Match: bool

        """
        ...

    def feGenerateReflect(self, entityTYPE, entitySET, origVEC, normVEC, trapWIDTH, Match) -> Any:
        """
        **Description:**
            Creates new entities by reflecting entities about a plane. This call behaves identically to feGenerateReflect2 when matchColorLayer argument is set to False.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The entity type to reflect:\n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be reflected. Alternatively, if you specify a negative value, this is simply the ID of the single entity to reflect.\n
            **origVEC:** The coordinates of the origin of the reflection plane. Must be specified in global rectangular coordinates.\n
            **normVEC:** The components of the normal to the reflection plane, in global rectangular coordinates. It is not necessary for this axis to point toward (or away from) the existing entities - either vector will yield the same result.\n
            **trapWIDTH:** The trapWIDTH of the reflection plane. Entities that fall within this distance from the reflection plane will not be reflected.\n
            **Match:** If True, then loads and constraints on the original entities are copied to the newly created entities. If False, only the selected entities are duplicated.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type origVEC: tuple[float]

        :type normVEC: tuple[float]

        :type trapWIDTH: float

        :type Match: bool

        """
        ...

    def feGenerateReflect2(self, entityTYPE, entitySET, origVEC, normVEC, trapWIDTH, Match, matchColorLayer) -> Any:
        """
        **Description:**
            Creates new entities by reflecting entities about a plane. When matchColorLayer argument is set to False, behaves identical to feGenerateReflect.
        **Remarks/Usage:**
            Additional parameters included when matchColorLayer is True for Nodes include definition coordinate system, output coordinate system, permanent constraints, and Superelement ID, while additional parameters for Elements include formulation and material orientation angle
        **Input:**
            **entityTYPE:** The entity type to reflect:\n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be reflected. Alternatively, if you specify a negative value, this is simply the ID of the single entity to reflect.\n
            **origVEC:** The coordinates of the origin of the reflection plane. Must be specified in global rectangular coordinates.\n
            **normVEC:** The components of the normal to the reflection plane, in global rectangular coordinates. It is not necessary for this axis to point toward (or away from) the existing entities - either vector will yield the same result.\n
            **trapWIDTH:** The trapWIDTH of the reflection plane. Entities that fall within this distance from the reflection plane will not be reflected.\n
            **Match:** If True, then loads and constraints on the original entities are copied to the newly created entities. If False, only the selected entities are duplicated.\n
            **Match:** If True, then color, layer, and some additional parameters of original entities are transferred to the newly created entities. If False, active parameters for the entity type will be used for the new entities.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type origVEC: tuple[float]

        :type normVEC: tuple[float]

        :type trapWIDTH: float

        :type Match: bool

        :type Match: bool

        """
        ...

    def feGenerateRotate(self, entityTYPE, entitySET, origVEC, axisVEC, rotANGLE, transDIST, Match) -> Any:
        """
        **Description:**
            Creates new entities by rotating entities about an axis. This call behaves identically to feGenerateRotate2 when matchColorLayer argument is set to False.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The entity type to rotate:\n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be rotated. Alternatively, if you specify a negative value, this is simply the ID of the single entity to rotate.\n
            **origVEC:** The coordinates of the origin of the axis of rotation. Must be specified in global rectangular coordinates.\n
            **axisVEC:** The components of the axis of rotation, in global rectangular coordinates. The rotation will be in positive, right-hand rule sense about this axis.\n
            **rotANGLE:** The angle of rotation about the axis vector, in degrees.\n
            **transDIST:** The translation distance, through which the entities are translated along the rotation axis, as they are rotated. Usually this is zero.\n
            **Match:** If True, then loads and constraints on the original entities are copied to the newly created entities. If False, only the selected entities are duplicated.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type origVEC: tuple[float]

        :type axisVEC: tuple[float]

        :type rotANGLE: float

        :type transDIST: float

        :type Match: bool

        """
        ...

    def feGenerateRotate2(self, entityTYPE, entitySET, origVEC, axisVEC, rotANGLE, transDIST, Match,
                          matchColorLayer) -> Any:
        """
        **Description:**
            Creates new entities by rotating entities about an axis. When matchColorLayer argument is set to False, behaves identical to feGenerateRotate.
        **Remarks/Usage:**
            Additional parameters included when matchColorLayer is True for Nodes include definition coordinate system, output coordinate system, permanent constraints, and Superelement ID, while additional parameters for Elements include formulation and material orientation angle
        **Input:**
            **entityTYPE:** The entity type to rotate:\n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be rotated. Alternatively, if you specify a negative value, this is simply the ID of the single entity to rotate.\n
            **origVEC:** The coordinates of the origin of the axis of rotation. Must be specified in global rectangular coordinates.\n
            **axisVEC:** The components of the axis of rotation, in global rectangular coordinates. The rotation will be in positive, right-hand rule sense about this axis.\n
            **rotANGLE:** The angle of rotation about the axis vector, in degrees.\n
            **transDIST:** The translation distance, through which the entities are translated along the rotation axis, as they are rotated. Usually this is zero.\n
            **Match:** If True, then loads and constraints on the original entities are copied to the newly created entities. If False, only the selected entities are duplicated.\n
            **Match:** If True, then color, layer, and some additional parameters of original entities are transferred to the newly created entities. If False, active parameters for the entity type will be used for the new entities.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type origVEC: tuple[float]

        :type axisVEC: tuple[float]

        :type rotANGLE: float

        :type transDIST: float

        :type Match: bool

        :type Match: bool

        """
        ...

    def feGenerateScale(self, entityTYPE, entitySET, origVEC, scaleVEC, csysID, Match) -> Any:
        """
        **Description:**
            Creates new entities by scaling entities about a location. This call behaves identically to feGenerateScale2 when matchColorLayer argument is set to False.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The entity type to scale:\n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be scaled. Alternatively, if you specify a negative value, this is simply the ID of the single entity to scale.\n
            **origVEC:** The coordinates of the origin around which the scale will be performed. The coordinates must be in the coordinate system specified in csysID - not necessarily global rectangular.\n
            **scaleVEC:** The scaling values. The entries in this vector are the scale factors in the X,Y and Z coordinate directions of the csysID coordinate system. If you want a uniform scale, you must still set all three values to the same scale factor.\n
            **csysID:** The ID of a coordinate system that will be used to perform the scaling. Usually this will be 0=Global rectangular, unless you want to scale about some rotated set of axes.\n
            **Match:** If True, then loads and constraints on the original entities are copied to the newly created entities. If False, only the selected entities are duplicated.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type origVEC: tuple[float]

        :type scaleVEC: tuple[float]

        :type csysID: int

        :type Match: bool

        """
        ...

    def feGenerateScale2(self, entityTYPE, entitySET, origVEC, scaleVEC, csysID, Match, matchColorLayer) -> Any:
        """
        **Description:**
            Creates new entities by scaling entities about a location. When matchColorLayer argument is set to False, behaves identical to feGenerateScale.
        **Remarks/Usage:**
            Additional parameters included when matchColorLayer is True for Nodes include definition coordinate system, output coordinate system, permanent constraints, and Superelement ID, while additional parameters for Elements include formulation and material orientation angle
        **Input:**
            **entityTYPE:** The entity type to scale:\n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be scaled. Alternatively, if you specify a negative value, this is simply the ID of the single entity to scale.\n
            **origVEC:** The coordinates of the origin around which the scale will be performed. The coordinates must be in the coordinate system specified in csysID - not necessarily global rectangular.\n
            **scaleVEC:** The scaling values. The entries in this vector are the scale factors in the X,Y and Z coordinate directions of the csysID coordinate system. If you want a uniform scale, you must still set all three values to the same scale factor.\n
            **csysID:** The ID of a coordinate system that will be used to perform the scaling. Usually this will be 0=Global rectangular, unless you want to scale about some rotated set of axes.\n
            **Match:** If True, then loads and constraints on the original entities are copied to the newly created entities. If False, only the selected entities are duplicated. (only available in v8.2 and later)\n
            **Match:** If True, then color, layer, and some additional parameters of original entities are transferred to the newly created entities. If False, active parameters for the entity type will be used for the new entities.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type origVEC: tuple[float]

        :type scaleVEC: tuple[float]

        :type csysID: int

        :type Match: bool

        :type Match: bool

        """
        ...

    def feGetBuildInfo(self, bPrint, pbRelease, pnPreReleaseNum, pnBuildNum) -> Any:
        """
        :type bPrint: Any
        :type pbRelease: Any
        :type pnPreReleaseNum: Any
        :type pnBuildNum: Any
        """
        ...

    def feGetCurrentLibraryName(self, entityTYPE, libraryTYPE, libraryNAME) -> Any:
        """
        **Description:**
            Retrieves the name of the current library file (*.esp file) being used for a particular entity type.
        **Remarks/Usage:**
             The full directory path to the library file is included in libraryNAME
        **Output:**
            **libraryNAME:** Name of current library being used by specified entity type.\n
        **Return Code:** True\n
        :type libraryNAME: str

        """
        ...

    def feGetElemDistortion(self, elemID, valASPECT, valTAPER, valANGLE, valWARP, valNasWARP, valALTTAPER, valTET,
                            valJDet, valComb) -> Any:
        """
        **Description:**
            This function checks an element and returns the distortion values.
        **Remarks/Usage:**
            This function is just like the Tools, Check, Distortioncommand. The checks performed and the returned values are identical to that command.
        **Input:**
            **elemID:** The ID of the element to check for distortion.\n
        **Output:**
            **valASPECT:** Result of aspect ratio check.\n
            **valTAPER:** Result of taper check.\n
            **valANGLE:** Result of internal angle check.\n
            **valWARP:** Result of warping check.\n
            **valNasWARP:** Result of Nastran warping check\n
            **valALTTAPER:** Result of alternate element taper check.\n
            **valTET:** Result of tet collapse check.\n
            **valJDet:** Result of Jacobian check.\n
            **valComb:** Results of Combined Quality check\n
        **Return Code:** False\n
        :type elemID: int

        :type valASPECT: float

        :type valTAPER: float

        :type valANGLE: float

        :type valWARP: float

        :type valNasWARP: float

        :type valALTTAPER: float

        :type valTET: float

        :type valJDet: float

        :type valComb: float

        """
        ...

    def feGetElemDistortion2(self, elemID, valASPECT, valTAPER, valANGLE, valWARP, valNasWARP, valALTTAPER, valTET,
                             valJDet, valComb, valExpTime) -> Any:
        """
        **Description:**
            This function checks an element and returns the distortion values.
        **Remarks/Usage:**
            This function is just like the Tools, Check, Distortioncommand. The checks performed and the returned values are identical to that command.
        **Input:**
            **elemID:** The ID of the element to check for distortion.\n
        **Output:**
            **valASPECT:** Result of aspect ratio check.\n
            **valTAPER:** Result of taper check.\n
            **valANGLE:** Result of internal angle check.\n
            **valWARP:** Result of warping check.\n
            **valNasWARP:** Result of Nastran warping check\n
            **valALTTAPER:** Result of alternate element taper check.\n
            **valTET:** Result of tet collapse check.\n
            **valJDet:** Result of Jacobian check.\n
            **valComb:** Results of Combined Quality check\n
            **valExpTime:** Results of Explicit Time Step check\n
        **Return Code:** False\n
        :type elemID: int

        :type valASPECT: float

        :type valTAPER: float

        :type valANGLE: float

        :type valWARP: float

        :type valNasWARP: float

        :type valALTTAPER: float

        :type valTET: float

        :type valJDet: float

        :type valComb: float

        :type valExpTime: float

        """
        ...

    def feGetElementAdjacentFaces(self, nElemID, nFaceID, nFromElemSetID, dTolerance, bMatchNormals, nNumFaces, nElems,
                                  nFaces) -> Any:
        """
        **Description:**
            This function will get all adjacent faces within a specified tolerance from a given element and face ID.
        **Remarks/Usage:**
            This mimics the Adjacent option in the Face Selection dialog.
        **Input:**
            **nElemID:** The ID of the element. \n
            **nFaceID:** The ID of the face from the element. \n
            **nFromElemSetID:** Selection from specific elements. \n
            **dTolerance:** The angle tolerance of which to select adjacent faces.\n
            **bMatchNormals:** If True, only faces with matching normals will be selected.\n
        **Output:**
            **nNumFaces:** The number of faces selected. \n
            **nElems:** An array of the IDs of the elements selected. \n
            **nFaces:** An array of the IDs of the faces from the elements selected. \n
        **Return Code:** True\n
        :type nElemID: int

        :type nFaceID: int

        :type nFromElemSetID: int

        :type dTolerance: float

        :type bMatchNormals: bool

        :type nNumFaces: int

        :type nElems: tuple[int]

        :type nFaces: tuple[int]

        """
        ...

    def feGetElementEdges(self, title, orig_nCount, orig_elemID, orig_faceID, nCount, elemID, faceID) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to select element edges.
        **Remarks/Usage:**
            Element edges are paired in the elemID/edgeID arrays. The edge ID corresponds to the element ID at the same index in the array. The edgeID is the same as the faceID on the edge of planar elements. This method simply limits selection to those edge faces.
        **Input:**
            **title:** A string that specifies a title to be used as the dialog box title.\n
            **orig_nCount:** The number of elements/edges that are contained in orig_elemID and orig_faceID. These element faces are displayed in the dialog box when it is opened. Specify 0 to display an empty dialog box.\n
            **orig_elemID:** The element IDs to be loaded when the dialog is opened\n
            **orig_faceID:** The edgeIDs to be loaded when the dialog is opened\n
        **Output:**
            **nCount:** The number of elements/edges that have been selected. Unless some or all of the orig edges were deleted, they will also be contained in this list.\n
            **elemID:** The element IDs that were selected\n
            **faceID:** The edge IDs that were selected\n
        **Return Code:** True\n
        :type title: str

        :type orig_nCount: int

        :type orig_elemID: tuple[int]

        :type orig_faceID: tuple[int]

        :type nCount: int

        :type elemID: tuple[int]

        :type faceID: tuple[int]

        """
        ...

    def feGetElementFaces(self, title, orig_nCount, orig_elemID, orig_faceID, nCount, elemID, faceID) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to select element faces.
        **Remarks/Usage:**
            Element faces are paired in the elemID/faceID arrays. The face ID corresponds to the element ID at the same index in the array.
        **Input:**
            **title:** A string that specifies a title to be used as the dialog box title.\n
            **orig_nCount:** The number of elements/faces that are contained in orig_elemID and orig_faceID. These element faces are displayed in the dialog box when it is opened. Specify 0 to display an empty dialog box.\n
            **orig_elemID:** The element IDs to be loaded when the dialog is opened\n
            **orig_faceID:** The face IDs to be loaded when the dialog is opened\n
        **Output:**
            **nCount:** The number of elements/faces that have been selected. Unless some or all of the orig faces were deleted, they will also be contained in this list.\n
            **elemID:** The element IDs that were selected\n
            **faceID:** The face IDs that were selected\n
        **Return Code:** True\n
        :type title: str

        :type orig_nCount: int

        :type orig_elemID: tuple[int]

        :type orig_faceID: tuple[int]

        :type nCount: int

        :type elemID: tuple[int]

        :type faceID: tuple[int]

        """
        ...

    def feGetElementFacesFromSet(self, title, nElemSetID, nCount, elemID, faceID) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to select element faces with the added option to limit the face selection using a set object loaded with element IDs
        **Remarks/Usage:**
            Element faces are paired in the elemID/faceID arrays. The face ID corresponds to the element ID at the same index in the array.
        **Input:**
            **title:** A string that specifies a title to be used as the Face Selection dialog box title.\n
            **nElemSetID:** The ID of a Set object containing element IDs which will be used to limit face selection. Alternatively, specify 0 to display a standard entity selection dialog box for Element selection.\n
        **Output:**
            **nCount:** The number of elements/faces that have been selected.\n
            **elemID:** The element IDs that were selected\n
            **faceID:** The face IDs that were selected\n
        **Return Code:** True\n
        :type title: str

        :type nElemSetID: int

        :type nCount: int

        :type elemID: tuple[int]

        :type faceID: tuple[int]

        """
        ...

    def feGetInt(self, title, lowerlimit, upperlimit, value) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to enter an integer number.
        **Remarks/Usage:**
            None
        **Input:**
            **title:** A string that specifies a title to be used as the dialog box title.\n
            **lowerlimit:** The minimum acceptable value for the number\n
            **upperlimit:** The maximum acceptable value for the number\n
        **Output:**
            **value:** The number entered by the user. On input, value is displayed as the default.\n
        **Return Code:** True\n
        :type title: str

        :type lowerlimit: int

        :type upperlimit: int

        :type value: int

        """
        ...

    def feGetMenuCommand(self, menuName1, menuName2, menuName3, cmdID) -> Any:
        """
        **Description:**
            Retrieves the ID of a specified command
        **Remarks/Usage:**
            When specifying the menu names, you should always leave off the ... characters and shortcut key specifications. Also do not include any special characters to represent the underlined letters - just specify the title as if nothing was underlined.
        **Input:**
            **menuName1:** The menu name you see at the top level (for example, File). \n
            **menuName2:** The menu name you see inside the top level menu (for example, Save As if menuName1=File). Specify an empty string here to retrieve a command on the top level of the menu.\n
            **menuName3:** The menu name you see inside the first level drop-down menu (for example, Analysis Results if menuName1=File, and menuName2=Import). Specify an empty string here to retrieve a command on the first level drop-down menu.\n
        **Output:**
            **cmdID:** The ID of the command associated with the menu item. The cmdID of any item on the menu that is a drop-down (rather than a command) will be -1.\n
        **Return Code:** True\n
        :type menuName1: str

        :type menuName2: str

        :type menuName3: str

        :type cmdID: int

        """
        ...

    def feGetMenuCommands(self, menuName1, menuName2, numCmds, cmdID, cmdTitle) -> Any:
        """
        **Description:**
            Retrieves information about all commands on a selected menu
        **Remarks/Usage:**
            When specifying the menu names, you should always leave off the ... characters and shortcut key specifications. Also do not include any special characters to represent the underlined letters - just specify the title as if nothing was underlined.
        **Input:**
            **menuName1:** The menu name you see at the top level (for example, File). Specify an empty string () here to retrieve information about the commands at the top level (File, Tools, ...)\n
            **menuName2:** The menu name you see inside the top level menu (for example, Import if menuName1=File). Specify an empty string here to retrieve the commands on the drop down from the top level.\n
        **Output:**
            **numCmds:** The number of commands on this menu, and the number of entries in the other arrays.\n
            **cmdID:** The IDs of the commands associated with each menu item. The cmdID of any item on the menu that is a drop-down (rather than a command) will be -1.\n
            **cmdTitle:** The titles of the commands associated with each menu item.\n
        **Return Code:** True\n
        :type menuName1: str

        :type menuName2: str

        :type numCmds: int

        :type cmdID: tuple[int]

        :type cmdTitle: tuple[str]

        """
        ...

    def feGetNodalAreaOnSurface(self, nSurface, bAdjustMidside, bUnitArea, pnNumNodes, pvNodes, pvAreas) -> Any:
        """
        **Description:**
            Extracts the area or unit area for the nodes of associated elements of a given surface.
        **Remarks/Usage:**
            None
        **Input:**
            **bUnitArea:** If True, unit area is found. If False, portion of the surface area is found. \n
        **Output:**
            **pnNumNodes:** The number of nodes found on the given surface\n
            **pvNodes:** An array with the node IDs. \n
            **pvAreas:** An array with the corresponding values of area or length\n
        **Return Code:** False\n
        :type bUnitArea: bool

        :type pnNumNodes: int

        :type pvNodes: tuple[int]

        :type pvAreas: tuple[float]

        """
        ...

    def feGetNodalAreaOrLength(self, nNumElem, nElems, nFaces, bAdjustMidside, bUnitArea, pnNumNodes, pvNodes,
                               pvAreaOrLength) -> Any:
        """
        **Description:**
            Extracts the area, unit area, or length for the nodes of a given set of elements and face ID.
        **Remarks/Usage:**
            None
        **Input:**
            **nNumElem:** The number of elements to get. \n
            **nElems:** An array with the element IDs.\n
            **nFaces:** An array with the corresponds face ID of the element.\n
            **bUnitArea:** If True, unit area is found. If False, the portion of the entire area defined by the given elements is found.\n
        **Output:**
            **pnNumNodes:** The number of nodes found on the given elements.\n
            **pvNodes:** An array with the node IDs. \n
        **Return Code:** False\n
        :type nNumElem: int

        :type nElems: tuple[int]

        :type nFaces: tuple[int]

        :type bUnitArea: bool

        :type pnNumNodes: int

        :type pvNodes: tuple[int]

        """
        ...

    def feGetReal(self, title, lowerlimit, upperlimit, value) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to enter a real number.
        **Remarks/Usage:**
            None
        **Input:**
            **title:** A string that specifies a title to be used as the dialog box title.\n
            **lowerlimit:** The minimum acceptable value for the number\n
            **upperlimit:** The maximum acceptable value for the number\n
        **Output:**
            **value:** The number entered by the user. On input, value is displayed as the default.\n
        **Return Code:** True\n
        :type title: str

        :type lowerlimit: float

        :type upperlimit: float

        :type value: float

        """
        ...

    def feGetRealLength(self, title, value) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to enter a real number or use an icon button to measure a distance using the Tools, Measure Distance functionality.
        **Remarks/Usage:**
            None
        **Input:**
            **title:** A string that specifies a title to be used as the dialog box title.\n
        **Output:**
            **value:** The value entered by the user or distance returned when using the icon button. On input, value is displayed as the default.\n
        **Return Code:** True\n
        :type title: str

        :type value: float

        """
        ...

    def feGetToolbarCommand(self, BarName, cmdIndex, cmdID) -> Any:
        """
        **Description:**
            Finds the ID of the command associated with a toolbar button
        **Remarks/Usage:**
            Setting the value of cmdIndex to the number of commands on the toolbar, visible or hidden, will always return Toolbar Options command which is available on every toolbar. It will always have a cmdID value of 9148. Therefore, if there are a total of 3 commands on the toolbar, setting cmdIndex to 3 will return the command ID of 9148 (Toolbar Options).
        **Input:**
            **BarName:** The title of the toolbar to be searched.\n
            **cmdIndex:** The index of the button to retrieve. The first button on the toolbar is button 0, the second is 1, and so on.\n
        **Output:**
            **cmdID:** The command ID associated with the button\n
        **Return Code:** True\n
        :type BarName: str

        :type cmdIndex: int

        :type cmdID: int

        """
        ...

    def feGetToolbarCommands(self, BarName, numCmds, cmdID, cmdVisible, cmdSubmenu, cmdTitle) -> Any:
        """
        **Description:**
            Retrieves information about all commands on a selected toolbar
        **Remarks/Usage:**
            The value of numCmds will always be the number of all commands added to a toolbar, visible or hidden, + 1. The extra command is the Toolbar Options command which is available on every toolbar and will always be the final command in the returned arrays or variants. It always has a cmdID value of 9148 and a cmdTitle value of Toolbar Options.
        **Input:**
            **BarName:** The title of the toolbar containing the commands to be retrieved.\n
        **Output:**
            **numCmds:** The number of commands on this toolbar, and the number of entries in the other arrays.\n
            **cmdID:** The IDs of the commands associated with each toolbar item. \n
            **cmdTitle:** The titles of the commands associated with each toolbar item.\n
        **Return Code:** True\n
        :type BarName: str

        :type numCmds: int

        :type cmdID: tuple[int]

        :type cmdTitle: tuple[str]

        """
        ...

    def feGetToolbarSubCommands(self, cmdID, numSubCmds, subcmdID, subcmdVisible, subcmdTitle) -> Any:
        """
        **Description:**
            Retrieves information about all commands on a menu that drops-down from a toolbar button.
        **Remarks/Usage:**
            None
        **Input:**
            **cmdID:** The ID of the toolbar button that drops down the menu\n
        **Output:**
            **numSubCmds:** The number of commands on this menu, and the number of entries in the other arrays.\n
            **cmdID:** The IDs of the commands associated with each menu item. \n
            **subcmdTitle:** The titles of the commands associated with each menu item.\n
        **Return Code:** True\n
        :type cmdID: int

        :type numSubCmds: int

        :type cmdID: tuple[int]

        :type subcmdTitle: tuple[str]

        """
        ...

    def feGetToolbars(self, numBars, barID, barVisible, barTitle) -> Any:
        """
        **Description:**
            Retrieves all toolbars that have been defined
        **Remarks/Usage:**
            Toolbars do not need to be visible on the screen to be accessed by this method.
        **Output:**
            **numBars:** The number of toolbars that are current defined, and the number of entries in the other arrays.\n
            **barID:** The ID of each toolbar\n
            **barVisible:** A flag indicating whether the toolbar is currently visible. True=Visible.\n
            **barTitle:** The title of the toolbar.\n
        **Return Code:** True\n
        :type numBars: int

        :type barID: tuple[int]

        :type barVisible: tuple[bool]

        :type barTitle: tuple[str]

        """
        ...

    def feGetUserCommands(self, numCmd, strTitle, strCmd, strArg, strStartDir) -> Any:
        """
        **Description:**
            Retrieves all user commands that have been defined
        **Remarks/Usage:**
            None
        **Output:**
            **numCmd:** The number of user commands that are current defined, and the number of entries in the other arrays\n
            **strTitle:** The title assigned to each command\n
            **strCmd:** The command line used to execute the command\n
            **strArg:** Any command line arguments assigned to the command\n
            **strStartDir:** The starting directory, if any, for the command.\n
        **Return Code:** True\n
        :type numCmd: int

        :type strTitle: tuple[str]

        :type strCmd: tuple[str]

        :type strArg: tuple[str]

        :type strStartDir: tuple[str]

        """
        ...

    def feGraphicsHardware(self, Vendor, Renderer, version) -> Any:
        """
        :type Vendor: Any
        :type Renderer: Any
        :type version: Any
        """
        ...

    def feGroupBoolean(self, opperation, grID1, grID2, grCreate, grTitle) -> Any:
        """
        **Description:**
            This method is obsolete - use feGroupBoolean2() instead.
        **Remarks/Usage:**
            This method accomplishes the same tasks as the Group, Operations, And, Group, Operations, Or, Group, Operations, Exclusive Or,and Group, Operation, Not commands.
        **Input:**
            **opperation:** The operation to be done: 0=And, 1=Or, 2=Exclusive Or, 3=Invert.\n
            **grID1:** The first group to use in the operation.\n
            **grID2:** The second group to use in the operation. (This should be 0 for the Invert operation, because only the first group is used.)\n
            **grCreate:** The ID of the group to create.\n
            **grTitle:** The title of the group that is created.\n
        **Return Code:** True\n
        :type opperation: int

        :type grID1: int

        :type grID2: int

        :type grCreate: int

        :type grTitle: str

        """
        ...

    def feGroupBoolean2(self, GroupsToProcessSetID, GroupToSubtractFromID, opperation, GroupToCreateID,
                        GroupTitle) -> Any:
        """
        **Description:**
            This method takes a set of Groups and creates a new group based on a specified operation.
        **Remarks/Usage:**
            This method accomplishes the same tasks as the Group, Operations, Booleans command.
        **Input:**
            **GroupsToProcessSetID:** The ID of a Set that contains the IDs of the Groups to Process\n
            **GroupToSubtractFromID:** The ID of a Group to Subtract the other Groups From. This value is ignored, but must be specified, unless GroupOp=1\n
            **GroupToCreateID:** The ID of the group to create. If this is specified as 0, or the ID of an existing group, a new group will be created with an arbitrary ID\n
            **GroupTitle:** The title of the group that is created. If you specify this title a blank a default title will be created\n
        **Return Code:** True\n
        :type GroupsToProcessSetID: int

        :type GroupToSubtractFromID: int

        :type GroupToCreateID: int

        :type GroupTitle: str

        """
        ...

    def feGroupCombine(self, groupSET, groupID) -> Any:
        """
        **Description:**
            This method takes one or more existing groups and combines them to create a new group
        **Remarks/Usage:**
            None
        **Input:**
            **groupSET:** The ID of a Set Object that contains the IDs of the groups to combine.\n
        **Output:**
            **groupID:** The ID of the group that is created\n
        **Return Code:** True\n
        :type groupSET: int

        :type groupID: int

        """
        ...

    def feGroupCondense(self, groupSET) -> Any:
        """
        **Description:**
            This function takes a group and condenses all clipping and related rules into ID rules in a new group
        **Remarks/Usage:**

        **Input:**
            **groupSET:** ID of set of groups to condense.\n
        **Return Code:** False\n
        :type groupSET: int

        """
        ...

    def feGroupEvaluate(self, groupSET, forceEval) -> Any:
        """
        **Description:**
            This method evaluates all of the selection rules, clipping and other operations defined in one or more groups.
        **Remarks/Usage:**
            This method accomplishes the same tasks as the Group, Operations, Evaluate command.
        **Input:**
            **forceEval:** If True, the group will always be evaluated. If False, the group will only be evaluated if it is marked as needing evaluation.\n
        **Return Code:** True\n
        :type forceEval: bool

        """
        ...

    def feGroupFromCriteria(self, vuID, bVisibleOnly, nGroupID) -> Any:
        """
        **Description:**
            This method automatically makes a group containing only the elements which pass the current criteria when displaying a Criteria plot
        **Remarks/Usage:**
            Same as the Group, Operations, Generate From Criteria command.
        **Input:**
            **vuID:** ID of view, which must be currently displaying a Criteria plot, to use to automatically create group of elements which pass the criteria specified for that view. Enter a value of 0 to select the active view.\n
            **bVisibleOnly:** When True, only elements which are visible in the view specified for vuID and pass the criteria specified for the view will be included in the automatically created group. When False, all elements in the model which pass the criteria specified for the view specified for vuID will be included in the automatically created group.\n
        **Output:**
            **nGroupID:** ID of the automatically created group.\n
        **Return Code:** True\n
        :type vuID: int

        :type bVisibleOnly: bool

        :type nGroupID: int

        """
        ...

    def feGroupGenElemShape(self, elemSET) -> Any:
        """
        **Description:**
            This method automatically makes one or more groups by subdividing a mesh based on element shape.
        **Remarks/Usage:**
            Same as the Group, Operations, Generate Elem Shape command. A group is created for each element shape used by the selected elements.
        **Input:**
            **elemSET:** The ID of the set of elements to be used in defining the groups.\n
        **Return Code:** False\n
        :type elemSET: int

        """
        ...

    def feGroupGenElemType(self, elemSET) -> Any:
        """
        **Description:**
            This method automatically makes one or more groups by subdividing a mesh based on element type.
        **Remarks/Usage:**
            Same as the Group, Operations, Generate Elem Typecommand. A group is created for each element type used by the selected elements.
        **Input:**
            **elemSET:** The ID of the set of elements to be used in defining the groups.\n
        **Return Code:** False\n
        :type elemSET: int

        """
        ...

    def feGroupGenMatl(self, elemSET) -> Any:
        """
        **Description:**
            This method automatically makes one or more groups by subdividing a mesh based on material IDs.
        **Remarks/Usage:**
            Same as the Group, Operations, Generate Materialcommand. A group of elements is created that use each selected material.
        **Input:**
            **elemSET:** The ID of the set of materials to be used in defining the groups.\n
        **Return Code:** False\n
        :type elemSET: int

        """
        ...

    def feGroupGenProp(self, elemSET) -> Any:
        """
        **Description:**
            This method automatically makes one or more groups by subdividing a mesh based on property IDs.
        **Remarks/Usage:**
            Same as the Group, Operations, Generate Propertycommand. A group of elements is created that use each selected property.
        **Input:**
            **elemSET:** The ID of the set of properties to be used in defining the groups.\n
        **Return Code:** False\n
        :type elemSET: int

        """
        ...

    def feGroupGenSolid(self, solidSET) -> Any:
        """
        **Description:**
            This method automatically makes one or more groups by subdividing geometry based on the solids that it defines.
        **Remarks/Usage:**
            Same as the Group, Operations, Generate Solid command. A group is created for each solid that contains the solid, its surfaces, curves and points.
        **Input:**
            **solidSET:** The ID of the set of solids to be used in defining the groups.\n
        **Return Code:** False\n
        :type solidSET: int

        """
        ...

    def feGroupGenVisible(self, nGroupID, bIncludePropAndMatl, title) -> Any:
        """
        **Description:**
            This method automatically makes a group containing only the entities currently visible in the active view.
        **Remarks/Usage:**
            Same as the Group, Operations, Generate Visible command.
        **Input:**
            **nGroupID:** ID of group to create with visible entities. Setting this value to -1 will use the next available group ID, while setting this value to 0 will display the dialog boxes associated with the Group, Operations, Generate Visible command.\n
            **bIncludePropAndMatl:** When True, Properties and Materials associated with any visible elements will be added to the new group. When False, the Properties and Materials associated to visible elements will not be placed into the new group.\n
            **title:** Title of created group\n
        **Return Code:** True\n
        :type nGroupID: int

        :type bIncludePropAndMatl: bool

        :type title: str

        """
        ...

    def feGroupGenerate(self, elemSET, planer, brkPropMatl, brkLayer, brkColor, brkAngle, addLayers) -> Any:
        """
        **Description:**
            This method automatically makes one or more groups by subdividing the elements you select based on one or more criteria.
        **Remarks/Usage:**
            Same as the Group, Operations, Generate command for FEMAP versions prior to version 11.1. For full access to all the options now available, use feGroupGenerate2.
        **Input:**
            **elemSET:** The ID of the set of elements to be used in defining the groups.\n
            **planer:** If true, only planar elements will be used. If False, only solid elements will be used.\n
            **brkPropMatl:** Set to 0 to ignore property or material discontinuities. Set to 1 to start a new group when property IDs change. Set to 2 to start a new group when material IDs change.\n
            **brkLayer:** Set to nonzero to start a new group when layers change.\n
            **brkColor:** Set to nonzero to start a new group when element colors change.\n
            **brkAngle:** Set to the maximum angle between planar elements for them to still be in the same group. Ignored for solid elements. Specified in degrees.\n
            **addLayers:** Set to True if you not only want to create groups, but move the elements in each group to a separate layer.\n
        **Return Code:** False\n
        :type elemSET: int

        :type planer: bool

        :type brkPropMatl: int

        :type brkLayer: int

        :type brkColor: int

        :type brkAngle: float

        :type addLayers: bool

        """
        ...

    def feGroupGenerate2(self, elemSET, planer, brkPropMatl, brkLayer, brkColor, brkAngle, brkMatchNormal,
                         brkNonManifold, addLayers, nExpandGroup) -> Any:
        """
        **Description:**
            This method automatically makes one or more groups by subdividing the elements you select based on one or more criteria.
        **Remarks/Usage:**
            Same as the Group, Operations, Generate command in FEMAP 11.1 and above.
        **Input:**
            **elemSET:** The ID of the set of elements to be used in defining the groups.\n
            **planer:** If true, only planar elements will be used. If False, only solid elements will be used.\n
            **brkPropMatl:** Set to 0 to ignore property or material discontinuities. Set to 1 to start a new group when property IDs change. Set to 2 to start a new group when material IDs change.\n
            **brkLayer:** Set to nonzero to start a new group when layers change.\n
            **brkColor:** Set to nonzero to start a new group when element colors change.\n
            **brkAngle:** Set to the maximum angle between planar elements for them to still be in the same group. Ignored for solid elements. Specified in degrees. Setting this value to 0.0 turns off all geometry breaks unless brkMatchNormal is set to True.\n
            **brkMatchNormal:** If True, the normal direction of planar elements will be considered when determining how many groups to make. If False, the normal direction of planar elements will not be considered.\n
            **brkNonManifold:** If True, any non-manifold edges found between planar elements will be used to create additional groups and is independent of the brkAngle value. If False, non-manifold edges between planar elements will not be considered.\n
            **addLayers:** Set to True if you not only want to create groups, but move the elements in each group to a separate layer.\n
            **nExpandGroup:** Specifies the Group Expansion option. 0=Elements Only, 1=Elements and Nodes, 2=All (Elements, Nodes, Materials, Properties, Loads on Nodes, Loads on Elements, Constraints referencing Nodes, and Constraint Equations referencing Nodes).\n
        **Return Code:** False\n
        :type elemSET: int

        :type planer: bool

        :type brkPropMatl: int

        :type brkLayer: int

        :type brkColor: int

        :type brkAngle: float

        :type brkMatchNormal: bool

        :type brkNonManifold: bool

        :type addLayers: bool

        :type nExpandGroup: int

        """
        ...

    def feGroupMoveToLayer(self, nGroupID, nLayerID) -> Any:
        """
        **Description:**
            Assigns all entities in the selected group to the specified layer.
        **Remarks/Usage:**
            None
        **Input:**
            **nGroupID:** The ID of the Group to use to place entities onto a layer\n
            **nLayerID:** The ID of the Layer to assign entities to from the specified group\n
        **Return Code:** False\n
        :type nGroupID: int

        :type nLayerID: int

        """
        ...

    def feGroupPeel(self, elemSET, peelLayers, keepPeel, keepCore) -> Any:
        """
        **Description:**
            This method automatically makes one or more groups by peeling layers of solid elements from the outside of a mesh.
        **Remarks/Usage:**
            Same as the Group, Operations, Peel command.
        **Input:**
            **elemSET:** The ID of the set of elements to be used in defining the groups.\n
            **peelLayers:** The number of layers of elements to remove from the mesh.\n
            **keepPeel:** If True, each layer that is removed will be placed into a group.\n
            **keepCore:** If True, the remaining elements, after the number of layers have been removed, will be placed into a group.\n
        **Return Code:** False\n
        :type elemSET: int

        :type peelLayers: int

        :type keepPeel: bool

        :type keepCore: bool

        """
        ...

    def feGroupsContaining(self, enDataType, nEntityID, nGroupSetID) -> Any:
        """
        **Description:**
            This method does not mimic a command in the group menu, but instead populates an existing set object with the IDs of every group in which the specified entities (or single entity) currently reside
        **Remarks/Usage:**
            None
        **Input:**
            **enDataType:** The type of entity to be checked for group inclusion. For entity information, see Section 3.3.6, "Entity Types".\n
            **nEntityID:** The ID of a set that contains a list of entity IDs to determine in which groups the entities reside. Alternatively, if you specify a negative value, this is simply the ID of the single entity to determine in which groups that entity resides. \n
        **Output:**
            **nGroupSetID:** The ID of set to be populated with group IDs. The set will always be cleared and then repopulated.\n
        **Return Code:** False\n
        :type enDataType: int

        :type nEntityID: int

        :type nGroupSetID: int

        """
        ...

    def feImprintLocationInSurface(self, vXYZ, nSurfaceID) -> Any:
        """
        **Description:**
            This method imprints an internal point on a parasolid surface.
        **Remarks/Usage:**

        **Input:**
            **vXYZ:** A variant with the location the point to imprint.\n
            **nSurfaceID:** The ID of the surface to imprint a point in.\n
        **Return Code:** True\n
        :type vXYZ: tuple[float]

        :type nSurfaceID: int

        """
        ...

    def feLayerGet(self, layID, layColor, layTitle) -> Any:
        """
        **Description:**
            This function retrieves information about a layer.
        **Remarks/Usage:**
            None
        **Input:**
            **layID:** The ID of the layer to create or update.\n
        **Output:**
            **layColor:** The layer color.\n
            **layTitle:** The title of the layer.\n
        **Return Code:** True\n
        :type layID: int

        :type layColor: int

        :type layTitle: str

        """
        ...

    def feLayerPut(self, layID, layColor, layTitle) -> Any:
        """
        **Description:**
            This function creates or updates a layer.
        **Remarks/Usage:**
            None
        **Input:**
            **layID:** The ID of the layer to create or update.\n
            **layColor:** The color used for the layer that is created. Set to -1 to use the active layer color.\n
            **layTitle:** The title to be used for the layer.\n
        **Return Code:** False\n
        :type layID: int

        :type layColor: int

        :type layTitle: str

        """
        ...

    def feLicenseExpiration(self, nDays) -> Any:
        """
        **Description:**
            Returns the number of days until your current license expires
        **Remarks/Usage:**
            nDays is returned as -1 for perpetual licenses.
        **Output:**
            **nDays:** The number of days until the license expires\n
        **Return Code:** False\n
        :type nDays: int

        """
        ...

    def feLicenseGetInfo(self, nFeature, bUser, pnLic, pFeatures, pLicAvail, pLicInUse, pUsers) -> Any:
        """
        **Description:**
            Indicates whether a specific feature is licensed with this copy of FEMAP
        **Remarks/Usage:**
            None
        **Input:**
            **nFeature:** The feature to check licensing status. \n
            **bUser:** If True, the user will be returned. If False, just the license types will be returned. \n
        **Output:**
            **pnLic:** The number of license returned. \n
            **pFeatures:** An array of the features. \n
            **pLicAvail:** Total number of licenses for each feature returned.\n
            **pLicInUse:** Number of used license for each feature returned. \n
            **pUsers:** An array of users corresponding to the licenses in use. \n
        **Return Code:** False\n
        :type nFeature: int

        :type bUser: bool

        :type pnLic: int

        :type pFeatures: tuple[int]

        :type pLicAvail: tuple[int]

        :type pLicInUse: tuple[int]

        :type pUsers: tuple[str]

        """
        ...

    def feLicenseIsAvailable(self, nFeature) -> Any:
        """
        **Description:**
            Indicates whether a specific feature is licensed with this copy of FEMAP
        **Remarks/Usage:**
            None
        **Input:**
            **nFeature:** The feature to check licensing status. \n
        **Return Code:** True\n
        :type nFeature: int

        """
        ...

    def feLicenseMethod(self, nLicenseType) -> Any:
        """
        **Description:**
            Returns the method of licensing currently being used
        **Remarks/Usage:**
            None
        **Output:**
            **nLicenseType:** The type of licensing currently being used\n
        **Return Code:** True\n
        :type nLicenseType: int

        """
        ...

    def feLicensePrintInfo(self, nFeature, bUser) -> Any:
        """
        **Description:**
            Print the features and licenses in use to the messages window.
        **Remarks/Usage:**
            None
        **Input:**
            **nFeature:** The feature to check licensing status.\n
        **Return Code:** True\n
        :type nFeature: int

        """
        ...

    def feLine2Tangent(self, curve1, curve2, p1, messages) -> Any:
        """
        **Description:**
            Creates a line that is tangent to two selected curves.
        **Remarks/Usage:**
            None
        **Input:**
            **curve1:** The IDs of the curves that the line will be tangent to.\n
            **curve2:** REAL8 side[0..2]\n
            **p1:** A location on the side of the first curve where the line will be tangent. The line does not normally pass through this point; it is just used to determine which tangent to select.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type curve1: int

        :type curve2: int

        :type p1: tuple[float]

        :type messages: bool

        """
        ...

    def feLineAtAngle(self, angle, curveID, p1, p2, messages) -> Any:
        """
        **Description:**
            Creates a line at an angle to the workplane, or another curve.
        **Remarks/Usage:**
            None
        **Input:**
            **angle:** The angle from the workplane X axis, or the selected curve.\n
            **curveID:** The ID of the curve used to measure the angle. Set to 0 if you want to specify the angle from the workplane X axis (toward the Y axis).\n
            **p1:** The coordinates at the start of the line. These are projected onto the curve to find location where the tangent vector is determined and at which the angle is measured.\n
            **p2:** A location on the side of the curve where the line will be drawn toward. Not used if you are measuring from the workplane X axis. The line does not necessarily pass through this point; it is just used to determine which direction to go from the origin location.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type angle: float

        :type curveID: int

        :type p1: tuple[float]

        :type p2: tuple[float]

        :type messages: bool

        """
        ...

    def feLineHorzVert(self, horizontal, p1, Length, messages) -> Any:
        """
        **Description:**
            Creates a horizontal or vertical line in the workplane.
        **Remarks/Usage:**
            None
        **Input:**
            **horizontal:** If True, the line will be horizontal (workplane X axis). If False, the line will be vertical (workplane Y axis).\n
            **p1:** Coordinates that will be projected onto the workplane at the center of the line.\n
            **Length:** The overall length of the line.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type horizontal: bool

        :type p1: tuple[float]

        :type Length: float

        :type messages: bool

        """
        ...

    def feLineMidline(self, curve1, curve2, messages) -> Any:
        """
        **Description:**
            Creates a line that is midway between two other lines.
        **Remarks/Usage:**
            None
        **Input:**
            **curve1:** The two reference curves used to determine the midline location.\n
            **curve2:** BOOL messages\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type curve1: int

        :type curve2: int

        :type messages: bool

        """
        ...

    def feLineParallel(self, offset, curveID, p1, messages) -> Any:
        """
        **Description:**
            Creates a line parallel to another in the workplane.
        **Remarks/Usage:**
            None
        **Input:**
            **offset:** The perpendicular distance from the selected curve used to locate the new curve.\n
            **curveID:** The ID of the reference curve.\n
            **p1:** A location on the side of the curve where the line will be drawn. The line does not necessarily pass through this point; it is just used to determine which direction to go from the reference curve location.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type offset: float

        :type curveID: int

        :type p1: tuple[float]

        :type messages: bool

        """
        ...

    def feLinePointIDs(self, p1, p2, messages) -> Any:
        """
        **Description:**
            Creates a line that joins two points.
        **Remarks/Usage:**
            None
        **Input:**
            **p1:** The ID of the point at the start of the line.\n
            **p2:** The ID of the point at the end of the line.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type p1: int

        :type p2: int

        :type messages: bool

        """
        ...

    def feLinePointTangent(self, curveID, p1, p2, messages) -> Any:
        """
        **Description:**
            Creates a line through an origin that is tangent to a selected curve.
        **Remarks/Usage:**
            None
        **Input:**
            **curveID:** The ID of the curve that the line will be tangent to.\n
            **p1:** The location at the start of the line. The line will pass through this location and be tangent to the curve.\n
            **p2:** A location on the side of the curve where the line will be tangent. The line does not normally pass through this point; it is just used to determine which tangent to select.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type curveID: int

        :type p1: tuple[float]

        :type p2: tuple[float]

        :type messages: bool

        """
        ...

    def feLinePoints(self, ontoWorkplane, p1, p2, messages) -> Any:
        """
        **Description:**
            Creates a line between two coordinate locations.
        **Remarks/Usage:**
            None
        **Input:**
            **ontoWorkplane:** If True, the coordinates specified are projected onto the workplane before the line is created.\n
            **p1:** Coordinates at the first end of the line.\n
            **p2:** Coordinates at the second end of the line.\n
            **messages:** If True, messages are written to the Message and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type ontoWorkplane: bool

        :type p1: tuple[float]

        :type p2: tuple[float]

        :type messages: bool

        """
        ...

    def feLineRectangle(self, p1, p2, messages) -> Any:
        """
        **Description:**
            Creates four lines that form a rectangle in the workplane between two diagonal locations.
        **Remarks/Usage:**
            None
        **Input:**
            **p1:** The diagonal locations that define the corners of the rectangle. These locations are projected onto the workplane.\n
            **p2:** BOOL messages\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type p1: tuple[float]

        :type p2: tuple[float]

        :type messages: bool

        """
        ...

    def feLoadCombine(self, fromSET, toSET, Scale) -> Any:
        """
        **Description:**
            Combines a Load set into another set
        **Remarks/Usage:**
            The functionality of this method is identical to the Model, Load, Combinecommand. All restrictions on combinations and scale factors that apply to that command apply equally to this method.
        **Input:**
            **fromSET:** The ID of the Load Set to be combined\n
            **toSET:** The ID of the Load Set which will contain the combined loads.\n
            **Scale:** A scale factor to apply to the loads being combined. Normally set to 1.0 to simply combine loads.\n
        **Return Code:** True\n
        :type fromSET: int

        :type toSET: int

        :type Scale: float

        """
        ...

    def feLoadFromFreebody(self, freebodyID, NodeSetID, outSetID, loadSetID, doSummation, doNodes,
                           overrideNodeCheck) -> Any:
        """
        **Description:**
            Creates applied loads from freebody loads
        **Remarks/Usage:**
            feLoadFromFreebody creates applied loads from freebody loads. The load components and contributions to be included in the created loads are obtained from the specified freebody. Up four load definitions will be created in the specified load set based on the options specified in this command and the attributes set in the freebody: total resultant forces, total resultant moments, nodal forces, and nodal moments.
        **Input:**
            **freebodyID:** ID of freebody to use to determine load values\n
            **NodeSetID:** Set ID containing node IDs to load; note that given nodes must exist in the specified freebody \n
            **outSetID:** Output set ID from which to retrieve load values\n
            **loadSetID:** Load set ID to store load definitions\n
            **doSummation:** Create loads for total summation\n
            **doNodes:** Create loads for nodal summations\n
        **Return Code:** True\n
        :type freebodyID: int

        :type NodeSetID: int

        :type outSetID: int

        :type loadSetID: int

        :type doSummation: bool

        :type doNodes: bool

        """
        ...

    def feLoadToolbarLayout(self, fName) -> Any:
        """
        **Description:**
            Loads a toolbar and menu definition and layout from a file
        **Remarks/Usage:**
            None
        **Input:**
            **fName:** The full pathname of the file to load, that was either created with feSaveToolbarLayout or through File->Preferences\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def feLockAbort(self) -> Any:
        """
        """
        ...

    def feMaxInt(self, Int1, Int2) -> Any:
        """
        :type Int1: Any
        :type Int2: Any
        """
        ...

    def feMaxReal(self, Real1, Real2) -> Any:
        """
        :type Real1: Any
        :type Real2: Any
        """
        ...

    def feMeasureAngle(self, center, p1, p2, angle) -> Any:
        """
        **Description:**
            This function measures the angle between three coordinate locations.
        **Remarks/Usage:**
            The coordinate locations must be in the same rectangular coordinate system for this function to work properly - preferably in global rectangular. The center location is the point about which the angle is measured. The angle is the angle between the vector from the center to p1 and the vector from the center to p2. The angle returned is always less than 180 degrees. There is no indication of the direction swept by the angle.
        **Input:**
            **center:** The coordinates of the center location.\n
            **p1:** The first coordinate location.\n
            **p2:** The second coordinate location.\n
        **Output:**
            **angle:** The angle between the coordinate locations (in degrees).\n
        **Return Code:** False\n
        :type center: tuple[float]

        :type p1: tuple[float]

        :type p2: tuple[float]

        :type angle: float

        """
        ...

    def feMeasureAngleBetweenNodesV2(self, nVertex, nFrom, nTo, nOutSetID, nOutVecID, nCSysID, vecBASE, vecNormal,
                                     magAngle) -> Any:
        """
        **Description:**
            This function measures the angle between three coordinate locations. This method replaces feMeasureAngleBetweenNodes. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            None
        **Input:**
            **nVertex:** The ID of a node at the vertex of the angle\n
            **nFrom:** The ID of a node to measure the angle from\n
            **nTo:** The ID of a node to measure the angle to\n
            **nOutSetID:** The ID of the output set which contains the results to use to deform the nodes. If 0, use the undeformed location of the nodes.\n
            **nOutVecID:** The ID of the output vector in nOutSetID which contains the results to use to deform the nodes. If 0, use the undeformed locations.\n
            **nCSysID:** The ID of the coordinate system in which the results are returned.\n
        **Output:**
            **vecBASE:** The coordinates of the nVertex node (possibly deformed) in CSys nCSysID\n
            **vecNormal:** The components of the vector that is normal to the plane formed by the three (possibly deformed) nodes, in CSys nCSysID\n
            **magAngle:** The angle between the nodes\n
        **Return Code:** False\n
        :type nVertex: int

        :type nFrom: int

        :type nTo: int

        :type nOutSetID: int

        :type nOutVecID: int

        :type nCSysID: int

        :type vecBASE: tuple[float]

        :type vecNormal: tuple[float]

        :type magAngle: float

        """
        ...

    def feMeasureCurve(self, curveSET, totalLength) -> Any:
        """
        **Description:**
            This function measures the length of one or more curves.
        **Remarks/Usage:**
            The total length of the curves is simply the sum of the lengths of the individual curves, it does not account for any overlap in the curves.
        **Input:**
            **curveSET:** The ID of a selection set that contains the IDs of the curves to measure. Alternatively, if you specify a negative value, this is simply the ID of the single curve to measure.\n
        **Output:**
            **totalLength:** The total length of all the curves. \n
        **Return Code:** False\n
        :type curveSET: int

        :type totalLength: float

        """
        ...

    def feMeasureDistance(self, p1, p2, dist) -> Any:
        """
        **Description:**
            This function measures the distance between two coordinates.
        **Remarks/Usage:**
            The coordinate locations must be in the same rectangular coordinate system for this function to work properly - preferably in global rectangular.
        **Input:**
            **p1:** The first coordinate location.\n
            **p2:** The second coordinate location.\n
        **Output:**
            **dist:** The distance between the coordinate locations.\n
        **Return Code:** False\n
        :type p1: tuple[float]

        :type p2: tuple[float]

        :type dist: float

        """
        ...

    def feMeasureDistanceBetweenGeometry(self, enFromType, nFromSet, enToType, nToSet, bMinimum, nFromID, nToID, vFrom,
                                         vTo, dDistance) -> Any:
        """
        **Description:**
            This function measures the distance between two sets of geometric entities or a set of nodes and a set of geometric entities. The maximum or minimum distance is calculated using any combination of sets containing only points, curves, surfaces, or solids.
        **Remarks/Usage:**
            Offers similar functionality to the Tools, Measure, Distance Between Geometry command.
        **Input:**
            **enFromType:** The type of entities to measure From. For entity information, Section 3.3.6, "Entity Types". Can be FT_NODE (7), FT_POINT (3), FT_CURVE (4), FT_SURFACE (5), or FT_SOLID (39).\n
            **nFromSet:** The ID of a set that contains a list of point, curve, surface, or solid IDs. Alternatively, if you specify a negative value, this is simply the ID of the single entity to measure From.\n
            **enToType:** The type of entities to measure To. Can be FT_POINT (3), FT_CURVE (4), FT_SURFACE (5), or FT_SOLID (39).\n
            **nToSet:** The ID of a set that contains a list of point, curve, surface, or solid IDs. Alternatively, if you specify a negative value, this is simply the ID of the single entity to measure To\n
            **bMinimum:** When True, calculates the minimum distance between geometric entities. When False, calculates the maximum distance.\n
        **Output:**
            **nFromID:** The ID of the geometric entity used as the From entity to determine minimum/maximum distance\n
            **nToID:** The ID of the geometric entity used as the To entity to determine minimum/maximum distance\n
            **vFrom:** The coordinates of the location on the nFromID entity used to determine minimum/maximum distance\n
            **vTo:** The coordinates of the location on the nToID entity used to determine minimum/maximum distance\n
            **dDistance:** The distance between the vFrom and vTo coordinates\n
        **Return Code:** True\n
        :type enFromType: int

        :type nFromSet: int

        :type enToType: int

        :type nToSet: int

        :type bMinimum: int

        :type nFromID: int

        :type nToID: int

        :type vFrom: tuple[float]

        :type vTo: tuple[float]

        :type dDistance: float

        """
        ...

    def feMeasureDistanceBetweenLines(self, pA1, pA2, pB1, pB2, dist) -> Any:
        """
        **Description:**
            This function measures the minimum distance between two line segments in space which are specified by the coordinates of their endpoints.
        **Remarks/Usage:**
            The coordinate locations must be in the same rectangular coordinate system for this function to work properly - preferably in global rectangular. The minimum distance will be the perpendicular distance if the closest point of approach lies within the lengths of the segments. If it does not, then the distance will be the distance from one of the endpoints to the other line.
        **Input:**
            **pA1:** The coordinates at the first end of the first line.\n
            **pA2:** The coordinates at the second end of the first line.\n
            **pB1:** The coordinates at the first end of the second line.\n
            **pB2:** The coordinates at the second end of the second line.\n
        **Output:**
            **dist:** The minimum distance between the two line segments.\n
        **Return Code:** False\n
        :type pA1: tuple[float]

        :type pA2: tuple[float]

        :type pB1: tuple[float]

        :type pB2: tuple[float]

        :type dist: float

        """
        ...

    def feMeasureDistanceBetweenNodes2V2(self, nFrom, nTo, nOutSetID, nOutVecID, nCSysID, vecBASE, vecTip, vecDist,
                                         magDist) -> Any:
        """
        **Description:**
            This function measures the distance between two nodes which are optionally deformed using selected results.This function is supersedes by feMeasureDistanceBetweenNodes. This method replaces feMeasureDistanceBetweenNodes2. For more information, seeSection 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            None
        **Input:**
            **nFrom:** The ID of the node to measure from\n
            **nTo:** The ID of the node to measure to\n
            **nOutSetID:** The ID of the output set which contains the results to use to deform the nodes. If 0, use the undeformed location of the nodes.\n
            **nOutVecID:** The ID of the output vector in nOutSetID which contains the results to use to deform the nodes. If 0, use the undeformed locations.\n
            **nCSysID:** The ID of the coordinate system in which the results are returned.\n
        **Output:**
            **vecBASE:** The coordinates of the nFrom node (possibly deformed) in CSys nCSysID\n
            **vecTip:** The coordinates of the nTo node (possibly deformed) in CSys nCSysID\n
            **vecDist:** The components of the vector from nFrom to nTo in CSys nCSysID\n
            **magDist:** The distance between the nodes\n
        **Return Code:** True\n
        :type nFrom: int

        :type nTo: int

        :type nOutSetID: int

        :type nOutVecID: int

        :type nCSysID: int

        :type vecBASE: tuple[float]

        :type vecTip: float

        :type vecDist: tuple[float]

        :type magDist: float

        """
        ...

    def feMeasureDistanceBetweenNodesV2(self, nFrom, nTo, nOutSetID, nOutVecID, nCSysID, vecBASE, vecDist,
                                        magDist) -> Any:
        """
        **Description:**
            This function measures the distance between two nodes which are optionally deformed using selected results. This function is superseded by feMeasureDistanceBetweenNodes2. This method replaces feMeasureDistanceBetweenNodes. For more information, seeSection 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            None
        **Input:**
            **nFrom:** The ID of the node to measure from\n
            **nTo:** The ID of the node to measure to\n
            **nOutSetID:** The ID of the output set which contains the results to use to deform the nodes. If 0, use the undeformed location of the nodes.\n
            **nOutVecID:** The ID of the output vector in nOutSetID which contains the results to use to deform the nodes. If 0, use the undeformed locations.\n
            **nCSysID:** The ID of the coordinate system in which the results are returned.\n
        **Output:**
            **vecBASE:** The coordinates of the nFrom node (possibly deformed) in CSys nCSysID\n
            **vecDist:** The components of the vector from nFrom to nTo in CSys nCSysID\n
            **magDist:** The distance between the nodes\n
        **Return Code:** True\n
        :type nFrom: int

        :type nTo: int

        :type nOutSetID: int

        :type nOutVecID: int

        :type nCSysID: int

        :type vecBASE: tuple[float]

        :type vecDist: tuple[float]

        :type magDist: float

        """
        ...

    def feMeasureDistanceBetweenSolids(self, solidID1, solidID2, dist) -> Any:
        """
        **Description:**
            This function measures the minimum distance between two solids in space
        **Remarks/Usage:**
            None
        **Input:**
            **solidID1, solidID2:** The IDs of the two solids to measure between.\n
        **Output:**
            **dist:** The minimum distance between the two solids\n
        **Return Code:** False\n
        :type solidID1: int

        :type solidID2: int

        :type dist: float

        """
        ...

    def feMeasureDistanceToPlane(self, p1, planePt, planeNorm, dist) -> Any:
        """
        **Description:**
            This function measures the distance between a coordinate location and a plane. The distance is the length of the perpendicular projection onto the plane.
        **Remarks/Usage:**
            The coordinate locations and components must be in the same rectangular coordinate system for this function to work properly - preferably in global rectangular.
        **Input:**
            **p1:** The coordinate location.\n
            **planePt:** The coordinates of any point on the plane.\n
            **planeNorm:** The components of the perpendicular vector to the plane.\n
        **Output:**
            **dist:** The distance from the coordinate location to its projection onto the plane.\n
        **Return Code:** False\n
        :type p1: tuple[float]

        :type planePt: tuple[float]

        :type planeNorm: tuple[float]

        :type dist: float

        """
        ...

    def feMeasureMeshMassProp(self, elemSET, csysID, printResults, printDetails, len, Area, volume, structMass,
                              nonstructMass, totalMass, structCG, nonstructCG, totalCG, Inertia, inertiaCG) -> Any:
        """
        **Description:**
            This function computes the mass properties of a mesh.
        **Remarks/Usage:**
            Only total mass properties are returned. If you want to get individual properties, you must call this function and just select a single element.
        **Input:**
            **elemSET:** The ID of a selection set that contains the IDs of the elements to measure. Alternatively, if you specify a negative value, this is simply the ID of the single element to measure.\n
            **csysID:** The coordinate system used to compute the mass properties.\n
            **printResults:** If True, the mass properties are also listed to the print destination.\n
            **printDetails:** If True, and printResults=True, the detailed properties for each element are listed.\n
        **Output:**
            **len:** The total length of all selected line elements.\n
            **Area:** The total area of all selected planar elements.\n
            **volume:** The total volume of all selected elements.\n
            **structMass:** The structural mass of all selected elements.\n
            **structMass:** The nonstructural mass of all selected elements.\n
            **totalMass:** The total (structural+nonstructural) mass of all selected elements.\n
            **structCG:** The center of gravity of the structural mass.\n
            **structCG:** The center of gravity of the nonstructural mass.\n
            **totalCG:** The center of gravity of the total mass.\n
            **Inertia:** The inertias of the selected elements ( 0=I11, 1=I21, 2=I22, 3=I31, 4=I32, 5=I33) about the origin of the selected coordinate system.\n
            **Inertia:** The inertias of the selected elements ( 0=I11, 1=I21, 2=I22, 3=I31, 4=I32, 5=I33) about the center of gravity.\n
        **Return Code:** True\n
        :type elemSET: int

        :type csysID: int

        :type printResults: bool

        :type printDetails: bool

        :type len: float

        :type Area: float

        :type volume: float

        :type structMass: float

        :type structMass: float

        :type totalMass: float

        :type structCG: tuple[float]

        :type structCG: tuple[float]

        :type totalCG: tuple[float]

        :type Inertia: tuple[float]

        :type Inertia: tuple[float]

        """
        ...

    def feMeasureMeshSectionProp(self, elemSET, vecBASE, vecDIR, sectProp) -> Any:
        """
        **Description:**
            This function computes the section properties for a selected set of elements.
        **Remarks/Usage:**
            The elements that you select should all be planar elements.
        **Input:**
            **elemSET:** The ID of a selection set that contains the IDs of the elements to measure. Alternatively, if you specify a negative value, this is simply the ID of the single element to measure.\n
            **vecBASE:** The coordinates of the origin of the orientation vector. Section properties are reported about this point.\n
            **vecDIR:** A vector in the direction of the Y axis of the section. Section properties are reported about this axis.\n
        **Output:**
            **sectProp:** The computed properties: \n
        **Return Code:** True\n
        :type elemSET: int

        :type vecBASE: tuple[float]

        :type vecDIR: tuple[float]

        :type sectProp: tuple[float]

        """
        ...

    def feMeasureSolidMassProp(self, solidID, Area, volume, cg, Inertia) -> Any:
        """
        **Description:**
            This function computes the mass properties of a solid.
        **Remarks/Usage:**
            The cg and inertia terms are in global rectangular coordinates.
        **Input:**
            **solidID:** The ID of the solid to compute the mass properties.\n
        **Output:**
            **Area:** The total surface area of the solid.\n
            **volume:** The volume of the solid (if closed).\n
            **cg:** The location of the center of gravity of the solid.\n
            **Inertia:** The 3x3 inertia matrix stored in row order [0][0], [0][1], [0][2], [1][0]...[2][2].\n
        **Return Code:** True\n
        :type solidID: int

        :type Area: float

        :type volume: float

        :type cg: tuple[float]

        :type Inertia: tuple[float]

        """
        ...

    def feMeasureSurfSectionProp(self, surfID, vecBASE, vecDIR, sectProp) -> Any:
        """
        **Description:**
            This function computes the section properties for a planar surface.
        **Remarks/Usage:**
            None
        **Input:**
            **surfID:** The ID of the surface to compute the properties.\n
            **vecBASE:** The coordinates of the origin of the orientation vector. Section properties are reported about this point.\n
            **vecDIR:** A vector in the direction of the Y axis of the section. Section properties are reported about this axis.\n
        **Output:**
            **sectProp:** The computed properties. \n
        **Return Code:** True\n
        :type surfID: int

        :type vecBASE: tuple[float]

        :type vecDIR: tuple[float]

        :type sectProp: tuple[float]

        """
        ...

    def feMeasureSurfaceArea(self, surfaceSET, totalArea) -> Any:
        """
        **Description:**
            This function measures the area of one or more surfaces.
        **Remarks/Usage:**
            This function only works for solid surfaces. Surfaces created with the standard geometry engine and boundary surfaces cannot be measured for area.
        **Input:**
            **surfaceSET:** The ID of a selection set that contains the IDs of the surfaces to measure. Alternatively, if you specify a negative value, this is simply the ID of the single surface to measure.\n
        **Output:**
            **totalArea:** The total area of the selected surfaces.\n
        **Return Code:** True\n
        :type surfaceSET: int

        :type totalArea: float

        """
        ...

    def feMeshApproachSurface(self, surfaceSET, approach, approachData) -> Any:
        """
        **Description:**
            Sets the meshing approach on a selected set of surfaces.
        **Remarks/Usage:**
            None
        **Input:**
            **surfaceSET:** The ID of a set that contains a list of surface IDs that will have mesh approaches defined. Alternatively, if you specify a negative value, this is simply the ID of the single surface to use.\n
            **approach:** The meshing approach for the surface: 0=Not Specified, 1=Free-Parametric, 2=Free-Planar, 3=Mapped-Four Corner, 4=Mapped-Three Corner, 5=Mapped-Three Corner Fan, 6=Link to Surface, 7=Fast Tri-Parametric, 8=Fast Tri-Planar.\n
            **approach:** The data for various approaches. For the mapped approaches, these are the point IDs defining the corners of the mapped mesh. For the Link to Surface approach, approachData[0] is the ID of the surface that this surface is linked to.\n
        **Return Code:** True\n
        :type surfaceSET: int

        :type approach: int

        :type approach: tuple[int]

        """
        ...

    def feMeshAttach(self, entityTYPE, entitySET, attachTYPE, attachID, doNodes) -> Any:
        """
        **Description:**
            Associates nodes or elements with specified geometry.
        **Remarks/Usage:**
            None
        **Input:**
            **entitySET:** The ID of a set that contains a list of entity IDs that will be attached. Alternatively, if you specify a negative value, this is simply the ID of the single entity to attach. \n
            **attachTYPE:** The type of geometry to attach the node/element to. Can be FT_POINT, FT_CURVE, FT_SURFACE, or FT_SOLID.\n
            **attachID:** The ID of the geometry to attach to.\n
            **doNodes:** Only used if entityTYPE=FT_ELEM. In this case, if True, then the nodes on the element will also be associated with the same geometry as the element.\n
        **Return Code:** True\n
        :type entitySET: int

        :type attachTYPE: int

        :type attachID: int

        :type doNodes: bool

        """
        ...

    def feMeshAttachNodes(self, nNodes, NodeID, attachTYPE, attachID) -> Any:
        """
        **Description:**
            Associates nodes with specified geometry.
        **Remarks/Usage:**
            For each node you want to attach to geometry, there must be corresponding entries in the three arrays.
        **Input:**
            **NodeID:** The IDs of the nodes being attached to geometry. \n
            **attachTYPE:** The types of geometry to attach the node/element to. Entries can be FT_POINT, FT_CURVE, FT_SURFACE, or FT_SOLID.\n
            **attachID:** The IDs of the geometry to attach each node to.\n
        **Return Code:** True\n
        :type NodeID: tuple[int]

        :type attachTYPE: tuple[int]

        :type attachID: tuple[int]

        """
        ...

    def feMeshAttrCurve(self, curveSET, propID, orient, offset1, offset2, orient_type, offset_type, release1,
                        release2) -> Any:
        """
        **Description:**
            Sets mesh attributes on a selected set of curves.
        **Remarks/Usage:**
            Only element/property types with the appropriate orient/offset/release options available can have those options defined using this method. For example, you cannot add offsets to rod elements, because they are not available.
        **Input:**
            **curveSET:** The ID of a set contains a list of curve IDs that will have mesh attributes defined. Alternatively, if you specify a negative value, this is simply the ID of the single curve to use.\n
            **propID:** Specifies the ID of the property to use as a meshing attribute at the selected curves. Set propID=0 to remove meshing attributes from the curves. If nonzero, this must be the ID of a property of an element type that is compatible with curve meshing - a beam element, for example.\n
            **orient:** The orientation vector meshing attribute. Either a location or vector (based on offset type), specified in global rectangular coordinates.\n
            **offset1:** REAL8 Offset2[0..2]\n
            **offset2:** The meshing attribute defining the offset to be applied to elements. Offset1[0..2] is at the beginning of the curve, Offset2[0..2] is at the end. Specified in global rectangular coordinates. If doing radial offsets, Offset1[0..2] contains the radial origin; Offset2[0] contains the radial offset distance.\n
            **orient:** Type of orientation for property attribute: 0=Orient By Vector, 1=Orient By Location, 2=Orient By Vector, Reversed Element Direction, 3=Orient By Location, Reversed Element Direction.\n
            **offset_type:** Type of offset for property attribute: 0=Offset by Vector, 1=Offset Radial, 2=Offset by Location.\n
            **release1:** INT4 Release2[0..5]\n
            **release2:** The release flags for the start and end of the curve. Nonzero if the associated degree of freedom is released. Release1[0..5] is at the beginning of the curve; Release2[0..5] is at the end.\n
        **Return Code:** True\n
        :type curveSET: int

        :type propID: int

        :type orient: tuple[float]

        :type offset1: tuple[float]

        :type offset2: tuple[float]

        :type orient: int

        :type offset_type: int

        :type release1: tuple[int]

        :type release2: tuple[int]

        """
        ...

    def feMeshAttrPoint(self, pointSET, propID) -> Any:
        """
        **Description:**
            Sets mesh attributes on a selected set of points.
        **Remarks/Usage:**
            None
        **Input:**
            **pointSET:** The ID of a set that contains a list of point IDs that will have mesh attributes defined. Alternatively, if you specify a negative value, this is simply the ID of the single point to use.\n
            **propID:** Specifies the ID of the property to use as a meshing attribute at the selected points. Set propID=0 to remove meshing attributes from the points. If nonzero, this must be the ID of a property of an element type that is compatible with point meshing - a mass element, for example.\n
        **Return Code:** True\n
        :type pointSET: int

        :type propID: int

        """
        ...

    def feMeshAttrSolid(self, solidSET, propID) -> Any:
        """
        **Description:**
            Sets mesh attributes on a selected set of solids or volumes.
        **Remarks/Usage:**
            None
        **Input:**
            **solidSET:** The ID of a set that contains a list of solid (or volume) IDs that will have mesh attributes defined. Alternatively, if you specify a negative value, this is simply the ID of the single solid to use.\n
            **propID:** Specifies the ID of the property to use as a meshing attribute in the selected solids or volumes. Set propID=0 to remove meshing attributes from the solids. If nonzero, this must be the ID of a property of an element type that is compatible with solid meshing - a solid element, for example.\n
        **Return Code:** True\n
        :type solidSET: int

        :type propID: int

        """
        ...

    def feMeshAttrSurface(self, surfaceSET, propID, offset) -> Any:
        """
        **Description:**
            Sets mesh attributes on a selected set of surfaces.
        **Remarks/Usage:**
            None
        **Input:**
            **surfaceSET:** The ID of a set that contains a list of surface IDs that will have mesh attributes defined. Alternatively, if you specify a negative value, this is simply the ID of the single surface to use.\n
            **propID:** Specifies the ID of the property to use as a meshing attribute at the selected surfaces. Set propID=0 to remove meshing attributes from the surfaces. If nonzero, this must be the ID of a property of an element type that is compatible with surface meshing - a planar element, for example.\n
            **offset:** The offset to be applied to elements meshed on this surface. Normally this is specified as 0 - the elements are meshed directly on the surface. Offsets can only be applied to certain planar elements such as plates.\n
        **Return Code:** True\n
        :type surfaceSET: int

        :type propID: int

        :type offset: float

        """
        ...

    def feMeshBetween(self, propID, genMode, shape, rightSplit, alternate, allQuad, logSpacing, numCorners, numNodes,
                      bias, nodeINC, cornerXYZ) -> Any:
        """
        **Description:**
            Meshes between selected coordinate locations. No geometry is required.
        **Remarks/Usage:**
            None
        **Input:**
            **propID:** Specifies the ID of the property to use for elements as they are created. The propID property must be compatible with the type of elements that you will be creating, and the shape value.\n
            **genMode:** The mesh generation mode: 0=Nodes Only, 1=Elements only on existing Nodes, 2=Both Nodes and Elements.\n
            **shape:** The shape of the elements to generate: 0=Line, 2=Tria, 4=Quad, 6=Tetra, 7=Wedge, 8=Brick. Not used if only generating nodes.\n
            **rightSplit:** Only used for Tria,Tetra and Wedge shapes. If True, indicates that the first elements should be split along a right-hand diagonal.\n
            **alternate:** Only used for Tria,Tetra and Wedge shapes. If True, indicates that the element split direction should alternate with each group of elements, eliminating any biasing in the mesh patterns.\n
            **allQuad:** Indicates that you want to use the alternate all-quad meshing scheme on a mesh that would otherwise generate triangular or wedge elements. This also requires compatible numbers of nodes along all edges.\n
            **logSpacing:** Only used if you are generating nodes (or nodes and elements), and using a bias factor other than 1.0. If True, indicates that you want the mesh spacing graded in a logarithmic manner.\n
            **numCorners:** The number of corners in the meshing region. Available values are: 2 (for line elements), 3 or 4 (for planar elements), 4,5,6, or 8 for (solid elements). \n
            **bias:** The biasing factor in each of the meshing directions. Set to 1.0 for no biasing.\n
            **cornerXYZ:** The coordinates of the corner locations, in global rectangular coordinates. Each corner is specified in consecutive locations in this array. For example, the first corner is in cornerXYZ[0..2], the second is in cornerXYZ[3..5], the third in cornerXYZ[6..8] and so on. \n
        **Return Code:** True\n
        :type propID: int

        :type genMode: int

        :type shape: int

        :type rightSplit: bool

        :type alternate: bool

        :type allQuad: bool

        :type logSpacing: bool

        :type numCorners: int

        :type bias: tuple[float]

        :type cornerXYZ: tuple[float]

        """
        ...

    def feMeshBuildRemeshRegions(self, elemSET, breakAngle) -> Any:
        """
        **Description:**
            Builds remeshing regions from a set of planar elements.
        **Remarks/Usage:**
            The elements selected must form a single, manifold hull - there can only be two elements that share each edge. Any quadrilateral elements selected will be converted to triangles.
        **Input:**
            **elemSET:** The ID of a set that contains the IDs of the elements to be checked. The elements contained in this set must be surface (planar) elements.\n
            **breakAngle:** The maximum angle between adjacent elements for those elements to be considered in the same region.\n
        **Return Code:** True\n
        :type elemSET: int

        :type breakAngle: float

        """
        ...

    def feMeshCleanupSlivers(self, elemSET, minAngle, minLength) -> Any:
        """
        **Description:**
            Automatically removes slivers from a selected set of elements.
        **Remarks/Usage:**
            You must not include missing elements in the elemSET.
        **Input:**
            **elemSET:** The ID of a set that contains the IDs of the elements to be checked. Alternatively, if you specify a negative value, this is simply the ID of the single element to check. The elements contained in this set must be surface (planar) elements.\n
            **minAngle:** Identifies slivers to be removed based on a minimum angle. Set to 0.0 to skip angle checking\n
            **minLength:** Identifies slivers to be removed based on a minimum edge length. Set to 0.0 to skip length checking.\n
        **Return Code:** True\n
        :type elemSET: int

        :type minAngle: float

        :type minLength: float

        """
        ...

    def feMeshClosestLink(self, fromSET, toSET, connectWith, orient, dof, Reverse) -> Any:
        """
        **Description:**
            Meshes connections based on the shortest distance between two sets of nodes. This method provides programmatic access to the functionality of the Mesh, Connect, Closest Link command.
        **Remarks/Usage:**
            When connectWith is set to 3 (Line Elements) the Line Orientation option is always set to Vector.
        **Input:**
            **fromSET:** A set containing the node IDs of the nodes to mesh from. Each node in this set will have one element connecting from it to the closest node in the toSET. Alternatively, if you specify a negative value, this is simply the ID of the single node to mesh.\n
            **toSET:** A set containing the node IDs to mesh to. The closest node from this set will be matched with the node from the fromSET. Alternatively, if you specify a negative value, this is simply the ID of the single node to mesh.\n
            **connectWith:** The type of element to use for the connection: 1=Constraint Equation, 2=Rigid, 3=Line Element. If you choose constraint equations, you must have an active constraint set for this method to work.\n
            **orient:** The orientation vector used for elements created with this method (if required by connectWith).\n
            **dof:** The degrees of freedom (DOF) to connect. Set values to 1 for DOF to connect; 0 for DOF to skip.\n
            **Reverse:** Reverses the connection order: connections are still made from the fromSET to the toSET, but the element nodal order is reversed. \n
        **Return Code:** True\n
        :type fromSET: int

        :type toSET: int

        :type connectWith: int

        :type orient: tuple[float]

        :type dof: tuple[int]

        :type Reverse: bool

        """
        ...

    def feMeshCoincidentLink(self, fromSET, connectWith, orient, dof, tolerance) -> Any:
        """
        **Description:**
            Meshes connections between coincident nodes. This method provides programmatic access to the functionality of the Mesh, Connect, Coincident Link command.
        **Remarks/Usage:**
            When connectWith is set to 3 (Line Elements) or 4 (Gap Elements) the Line Orientation option is always set to Vector.
        **Input:**
            **fromSET:** A set containing the node IDs of the nodes to mesh. Only nodes in this set that are coincident (within the specified tolerance) with another node in the set are meshed.\n
            **connectWith:** The type of element to use for the connection: 1=Constraint Equation, 2=Rigid, 3=Line Element, 4=Gap Element. If you choose constraint equations, you must have an active constraint set for this method to work.\n
            **orient:** The orientation vector used for elements created with this method (if required by connectWith).\n
            **dof:** The degrees of freedom (DOF) to connect. Set values to 1 for DOF to connect; 0 for DOF to skip.\n
            **tolerance:** The coincident node tolerance. Only nodes within this tolerance of each other are meshed.\n
        **Return Code:** True\n
        :type fromSET: int

        :type connectWith: int

        :type orient: tuple[float]

        :type dof: tuple[int]

        :type tolerance: float

        """
        ...

    def feMeshConnectRigid(self, nSourceNodeSetID, nTargetNodeSetID, bIsRbe3, bbSourceDoF, bbTargetDoF, bMaxDistance,
                           dMaxDistance, bMultiMap, nMinTargetNum, nMaxTargetNum, nBadSourceSet, nBadTargetSet,
                           pnCreated) -> Any:
        """
        **Description:**
            This method can be used to automatically create RBE2 or RBE3 elements using a set of Source Nodes as the Independent (RBE2) or Dependent (RBE3) node for each element, which then connect to any number of Target Nodes in the model, based on the specified parameters. This method provides programmatic access to the functionality of the Mesh, Connect, Rigid command.
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def feMeshConvertFacets(self, solidID) -> Any:
        """
        **Description:**
            Converts the current graphical facets of a solid into nodes and plot-only elements.
        **Remarks/Usage:**
            The current facetting of the solid is used to generate the elements. You can update the facetting tolerance prior to using this method if you want more (or fewer) elements.
        **Input:**
            **solidID:** The ID of the solid to use to create the nodes and elements.\n
        **Return Code:** False\n
        :type solidID: int

        """
        ...

    def feMeshCurve(self, curveSET, MeshElem, propID, orient) -> Any:
        """
        **Description:**
            Meshes a selected set of curves. This method is obsolete and should no longer be used. It has been replaced by feMeshCurve2.
        **Remarks/Usage:**
            None
        **Input:**
            **curveSET:** The ID of a set that contains a list of curve IDs that will be meshed. Alternatively, if you specify a negative value, this is simply the ID of the single curve to mesh.\n
            **MeshElem:** If True, then nodes and elements will be generated on the selected curves. If False, only nodes will be generated.\n
            **propID:** Specifies the ID of the property to use for elements as they are created. If you want to use meshing attributes, set propID=0. In this case, all selected curves must have meshing attributes defined or they will not be meshed. The propID property must be compatible with curve meshing. Set propID=-1 to automatically mesh with plot-only elements, which do not require other property information.\n
            **orient:** The components of the element orientation vector, in global rectangular coordinates. This is only used for those element types that require orientation - like bars and beams.\n
        **Return Code:** True\n
        :type curveSET: int

        :type MeshElem: bool

        :type propID: int

        :type orient: tuple[float]

        """
        ...

    def feMeshCurve2(self, curveSET, MeshElem, propID, merge_nodes, offsetToRefPt, orient) -> Any:
        """
        **Description:**
            Meshes a selected set of curves.
        **Remarks/Usage:**
            None
        **Input:**
            **curveSET:** The ID of a set that contains a list of curve IDs that will be meshed. Alternatively, if you specify a negative value, this is simply the ID of the single curve to mesh.\n
            **MeshElem:** If True, then nodes and elements will be generated on the selected curves. If False, only nodes will be generated.\n
            **propID:** Specifies the ID of the property to use for elements as they are created. If you want to use meshing attributes, set propID=0. In this case, all selected curves must have meshing attributes defined or they will not be meshed. The propID property must be compatible with curve meshing. Set propID=-1 to automatically mesh with plot-only elements, which do not require other property information.\n
            **merge_nodes:** If True, coincident nodes on curve will be merged.\n
            **offsetToRefPt:** If True, elements are offset to beam property reference point.\n
            **orient:** The components of the element orientation vector, in global rectangular coordinates. This is only used for those element types that require orientation - like bars and beams.\n
        **Return Code:** True\n
        :type curveSET: int

        :type MeshElem: bool

        :type propID: int

        :type merge_nodes: bool

        :type offsetToRefPt: bool

        :type orient: tuple[float]

        """
        ...

    def feMeshDetach(self, entityTYPE, entitySET, attachTYPE, attachID, interior) -> Any:
        """
        **Description:**
            Removes association between nodes or elements and specified geometry.
        **Remarks/Usage:**
            None
        **Input:**
            **entitySET:** The ID of a set that contains a list of entity IDs that will be detached. Alternatively, if you specify a negative value, this is simply the ID of the single entity to detach. \n
            **attachTYPE:** The type of geometry to attach the node/element to. Can be FT_POINT, FT_CURVE, FT_SURFACE, or FT_SOLID. You can also specify attachTYPE=0, in which case attachID is not used, and the node/element is detached from all geometry.\n
            **attachID:** The ID of the geometry to detach. Not used if attachTYPE=0.\n
            **interior:** Only used if entityTYPE=FT_NODE, and attachTYPE=FT_CURVE, FT_SURFACE or FT_SOLID. If True, the node is detached only if it is an interior node.\n
        **Return Code:** True\n
        :type entitySET: int

        :type attachTYPE: int

        :type attachID: int

        :type interior: bool

        """
        ...

    def feMeshEdgeMembers(self, elemSET, nodeSET, propID, orient) -> Any:
        """
        **Description:**
            Generates elements along the free edges or free faces of selected elements. This method is obsolete and should no longer be used. It has been replaced by feMeshEdgeMembers2
        **Remarks/Usage:**
            Only planar or solid elements can be selected in elemSET, not both at the same time.
        **Input:**
            **elemSET:** The ID of a set that contains the IDs of the elements to be checked. The elements contained in this set must be surface (planar) elements or solid elements.\n
            **nodeSET:** The ID of a set that contains the IDs of the nodes which define the portions of the free edge/free face where you want to define edge members. An edge member is created for every edge/face that has at least one node in this set.\n
            **propID:** The ID of an existing property used to define the edge member elements. If planar elements are selected in the elemSET, then this must be the ID of a line element property. If solid elements are selected in elemSET, then this must be a planar element property.\n
            **orient:** The element orientation vector for edge members. This is only used if elemSET contains planar elements, and propID specifies a line element type that requires orientation.\n
        **Return Code:** True\n
        :type elemSET: int

        :type nodeSET: int

        :type propID: int

        :type orient: tuple[float]

        """
        ...

    def feMeshEdgeMembers2(self, bOnFreeEdges, elemSET, nodeSET, propID, orient) -> Any:
        """
        **Description:**
            Generates elements along the free edges or free faces of selected elements.
        **Remarks/Usage:**
            Only planar or solid elements can be selected in elemSET, not both at the same time.
        **Input:**
            **bOnFreeEdges:** If true, elements will be generated on only free edges of the selected elements. \n
            **elemSET:** The ID of a set that contains the IDs of the elements to be checked. The elements contained in this set must be surface (planar) elements or solid elements.\n
            **nodeSET:** The ID of a set that contains the IDs of the nodes which define the portions of the free edge/free face where you want to define edge members. An edge member is created for every edge/face that has at least one node in this set.\n
            **propID:** The ID of an existing property used to define the edge member elements. If planar elements are selected in the elemSET, then this must be the ID of a line element property. If solid elements are selected in elemSET, then this must be a planar element property.\n
            **orient:** The element orientation vector for edge members. This is only used if elemSET contains planar elements, and propID specifies a line element type that requires orientation.\n
        **Return Code:** True\n
        :type bOnFreeEdges: bool

        :type elemSET: int

        :type nodeSET: int

        :type propID: int

        :type orient: tuple[float]

        """
        ...

    def feMeshEdgeRemoval(self, elemSET, nd1, nd2) -> Any:
        """
        **Description:**
            Removes an edge from a surface mesh by collapsing the connected elements.
        **Remarks/Usage:**
            The elements selected must form a single, manifold hull - there can only be two elements that share each edge.
        **Input:**
            **elemSET:** The ID of a set that contains the IDs of the elements to be checked. The elements contained in this set must be surface (planar) elements.\n
            **nd1:** The ID of the first node along the element edge.\n
            **nd2:** The ID of the second node along the element edge.\n
        **Return Code:** True\n
        :type elemSET: int

        :type nd1: int

        :type nd2: int

        """
        ...

    def feMeshEdgeSplit(self, nNode1, nNode2, nNodeSetorZero) -> Any:
        """
        **Description:**
            Splits a mesh by choosing an element edge
        **Remarks/Usage:**
            None
        **Input:**
            **nNode1:** The IDs of two nodes that lie on an element edge that is to be split. Only line, planar and solid (hex and wedge) elements can be split. \n
            **nNode2:** INT4 nNodeSetorZero\n
            **nNodeSetorZero:** The ID of a set containing node IDs that limit the split to a specified region of the model. If you want the split to go thru the entire model simply specify 0.\n
        **Return Code:** True\n
        :type nNode1: int

        :type nNode2: int

        :type nNodeSetorZero: int

        """
        ...

    def feMeshEdgeSplit2(self, nNode1, nNode2, nNumSplits, nBiasType, nBiasLocation, dBias, nNodeSetorZero) -> Any:
        """
        **Description:**
            Splits a mesh by choosing an element edge and allows you to enter a number of splits, bias type, bias location, and bias value.
        **Remarks/Usage:**
            None
        **Input:**
            **nNode1:** The IDs of two nodes that lie on an element edge that is to be split. Only line, planar and solid (hex and wedge) elements can be split. \n
            **nNode2:** INT4 nNumSplits\n
            **nNumSplits:** Specifies the number of splits between the two nodes (i.e., a value of 2 will split each element into three elements).\n
            **nBiasType:** Sets the option for Bias Type, 0=Equal (i.e., no biasing), 1=Biased, 2=Geometric Bias\n
            **nBiasLocation:** Sets the option for Bias Location. Only used when nBiasType is set to 1 or 2, 0=At Start (smaller elements closer to nNode1), 1=At Center, 2=At Ends\n
            **dBias:** Specifies the Bias Factor. Only used when nBiasType is set to 1 or 2, value must be between 1.0 and 65535.0\n
            **nNodeSetorZero:** The ID of a set containing node IDs that limit the split to a specified region of the model. If you want the split to go thru the entire model simply specify 0.\n
        **Return Code:** True\n
        :type nNode1: int

        :type nNode2: int

        :type nNumSplits: int

        :type nBiasType: int

        :type nBiasLocation: int

        :type dBias: float

        :type nNodeSetorZero: int

        """
        ...

    def feMeshEditRemeshRegions(self, el1, el2) -> Any:
        """
        **Description:**
            Moves an element from one remeshing region to an adjacent region.
        **Remarks/Usage:**
            The element to be moved, el1, must be adjacent, on at least one edge to the region containing element el2.
        **Input:**
            **el1:** The ID of the element to be moved to the other region.\n
            **el2:** The ID of the element used to identify the region where the first element will be placed.\n
        **Return Code:** True\n
        :type el1: int

        :type el2: int

        """
        ...

    def feMeshExtrudeCurve(self, curveSET, axisLEN, axisVEC, propID, numElem) -> Any:
        """
        **Description:**
            Extrudes existing curves into new elements.
        **Remarks/Usage:**
            The extrusion length is really the length of the axisVec multiplied by axisLen. Normally you will either want to specify axisLen=1.0, and set the axisVec to the true extrusion vector, or specify axisVec as a unit vector with the proper components, and set axisLen to the true extrusion length.
        **Input:**
            **curveSET:** The ID of a set that contains the IDs of the curves to be extruded. The curves are extruded into planar elements. The number and spacing of elements is dependent on the mesh size established on the curves.\n
            **axisLEN:** The extrusion length (See Remarks).\n
            **axisVEC:** The extrusion direction vector (See Remarks).\n
            **propID:** The ID of the property that will be used for the new elements. This property must be a planar type.\n
            **numElem:** The number of elements generated along the extrusion direction.\n
        **Return Code:** True\n
        :type curveSET: int

        :type axisLEN: float

        :type axisVEC: tuple[float]

        :type propID: int

        :type numElem: int

        """
        ...

    def feMeshExtrudeElem(self, elemSET, axisLEN, axisVEC, propID, numElem, method, matchCurrent, deleteOrig) -> Any:
        """
        **Description:**
            Extrudes existing elements into new elements.
        **Remarks/Usage:**
            The extrusion length (with method=0) is really the length of the axisVec multiplied by axisLen. Normally you will either want to specify axisLen=1.0, and set the axisVec to the true extrusion vector, or specify axisVec as a unit vector with the proper components, and set axisLen to the true extrusion length.
        **Input:**
            **elemSET:** The ID of a set that contains the IDs of the elements to be extruded. The elements contained in this set must be either line or surface (planar) elements, but not both. Line elements are extruded into planar elements; planar elements are extruded into solid elements.\n
            **axisLEN:** The extrusion length (See Remarks).\n
            **axisVEC:** The extrusion direction vector (See Remarks).\n
            **propID:** The ID of the property that will be used for the new elements. This property must be of the correct type (planar or solid), depending on the type of elements selected in elemSET.\n
            **numElem:** The number of elements generated by each original element along the extrusion direction.\n
            **method:** The method of determining the extrusion direction. 0=Along axisVec, 1=along the element normal, 2=along the element normal with thickness corrections.\n
            **matchCurrent:** If True, the attributes of the elements that are created will match the active settings. If False, they will match the generating elements.\n
            **deleteOrig:** If True, the elements in elemSET will be deleted, leaving only the new elements. If False, the elements in elemSet will remain in the model.\n
        **Return Code:** True\n
        :type elemSET: int

        :type axisLEN: float

        :type axisVEC: tuple[float]

        :type propID: int

        :type numElem: int

        :type method: int

        :type matchCurrent: bool

        :type deleteOrig: bool

        """
        ...

    def feMeshExtrudeElem2(self, elemSET, axisLEN, axisOrig, axisVEC, propID, numElem, method, radialspherical,
                           ontoSurfSetID, matchCurrent, deleteOrig) -> Any:
        """
        **Description:**
            Extrudes existing elements into new elements allowing use of all 5 methods in the Mesh, Extrude, Elements command (Vector, Normals, Normals with Thickness Correction, Radial, and Along Vector to Surfaces)
        **Remarks/Usage:**
            The extrusion length (with method=0) is really the length of the axisVec multiplied by axisLen. Normally you will either want to specify axisLen=1.0, and set the axisVec to the true extrusion vector, or specify axisVec as a unit vector with the proper components, and set axisLen to the true extrusion length.
        **Input:**
            **elemSET:** The ID of a set that contains the IDs of the elements to be extruded. The elements contained in this set must be either line or surface (planar) elements, but not both. Line elements are extruded into planar elements; planar elements are extruded into solid elements.\n
            **axisLEN:** The extrusion length (See Remarks).\n
            **axisOrig:** The extrusion direction origin (See Remarks).\n
            **axisVEC:** The extrusion direction vector (See Remarks).\n
            **propID:** The ID of the property that will be used for the new elements. This property must be of the correct type (planar or solid), depending on the type of elements selected in elemSET.\n
            **numElem:** The number of elements generated by each original element along the extrusion direction.\n
            **method:** The method of determining the extrusion direction. 0=Along axisVec, 1=along the element normal, 2=along the element normal with thickness corrections, 3=radial, 4=along vector to surfaces\n
            **radialspherical:** Only used when method is set to 3 (radial). If True, the mesh will be extruded radially around a specified coordinate location in axisOrig (spherical extrusion) to a length specified with axisLen. If False, the mesh will be extruded radially about a vector specified with axisOrig and axisVec (cylindrical extrusion) to a length specified with axisLen\n
            **matchCurrent:** If True, the attributes of the elements that are created will match the active settings. If False, they will match the generating elements.\n
            **deleteOrig:** If True, the elements in elemSET will be deleted, leaving only the new elements. If False, the elements in elemSet will remain in the model.\n
        **Return Code:** True\n
        :type elemSET: int

        :type axisLEN: float

        :type axisOrig: tuple[float]

        :type axisVEC: tuple[float]

        :type propID: int

        :type numElem: int

        :type method: int

        :type radialspherical: bool

        :type matchCurrent: bool

        :type deleteOrig: bool

        """
        ...

    def feMeshHexSolid(self, solidSET, propID, surfaceMeshOnly, makeMidside, checkSurfElem, deleteSurfElem, midsideGeom,
                       midsideAngle) -> Any:
        """
        **Description:**
            Meshes a selected set of solids with hexahedral elements.
        **Remarks/Usage:**
            For this function to work, the solids must be compatible with, and properly sized for hex meshing.
        **Input:**
            **solidSET:** The ID of a set that contains a list of solid IDs that will be meshed. Alternatively, if you specify a negative value, this is simply the ID of the single entity to mesh.\n
            **propID:** Specifies the ID of the property to use for hexahedral elements as they are created. If you want to use meshing attributes, set propID=0. In this case, all selected solids must have meshing attributes defined or they will not be meshed. The propID property must be compatible with solid meshing.\n
            **surfaceMeshOnly:** If True, only surface elements are generated, and the meshing process stops before generating hex elements.\n
            **makeMidside:** If True, the solids will have midside nodes created. Otherwise, linear elements are created.\n
            **checkSurfElem:** Checks the surface elements for validity prior to tet meshing if True. Not usually required if meshing solids, but should be done for surface or element meshing.\n
            **deleteSurfElem:** Set to True if you want to delete the surface elements that are being generated or meshed.\n
            **midsideGeom:** If True and you are meshing with parabolic elements, midside nodes will be projected toward the geometry.\n
            **midsideAngle:** The maximum angle formed by the edge of the element as the midside nodes are projected onto the geometry. If midsideAngle=0.0 and midsideGeom=True, then midside nodes will be projected completely onto the geometry regardless of the distortion introduced in the elements.\n
        **Return Code:** True\n
        :type solidSET: int

        :type propID: int

        :type surfaceMeshOnly: bool

        :type makeMidside: bool

        :type checkSurfElem: bool

        :type deleteSurfElem: bool

        :type midsideGeom: bool

        :type midsideAngle: float

        """
        ...

    def feMeshHexSolidFromElement(self, baseSET, topSET, propID, numLayer, match1, match2, makeMidside, checkSurfElem,
                                  deleteSurfElem) -> Any:
        """
        **Description:**
            Meshes selected sets of surface elements with hexahedral elements.
        **Remarks/Usage:**
            None
        **Input:**
            **baseSET:** The ID of a set that contains a list of surface element IDs that will be used as the base of the hex mesh. The base of the hex mesh is the set of elements that form the pattern that will be extruded into the hex elements.\n
            **topSET:** The ID of a set that contains a second list of surface element IDs that will be used as the top of the hex mesh. The top set can be selected in two forms. It can either contain a set of elements that match the base but is located at the opposite end of the extrusion, or it can contain all of the elements (other than those in the base) that enclose a complete, closed volume. If you use the true top option (not all the enclosing elements), then the base may not contain any holes.\n
            **propID:** Specifies the ID of the property to use for hexahedral elements as they are created. If you want to use meshing attributes, set propID=0. In this case, all selected solids must have meshing attributes defined or they will not be meshed. The propID property must be compatible with solid meshing.\n
            **numLayer:** Only used if topSET only includes the elements that match baseSET at the other end of the extrusion. This is the number of layers of hexahedral elements that will be generated.\n
            **match1:** INT4 match2\n
            **match2:** Only used if topSET only includes the elements that match baseSET at the other end of the extrusion. These should be both set to 0 if you want to automatically match the element patterns in the base and top meshes. If you have a symmetric or rotated mesh, it may be necessary to set these values to node IDs that will match the base mesh to the top. If not 0, match1 must be a node ID from the baseSET that matches the match2 nodeID from the topSET.\n
            **makeMidside:** If True, the solids will have midside nodes created. Otherwise, linear elements are created.\n
            **checkSurfElem:** Checks the surface elements for validity prior to tet meshing if True. Not usually required if meshing solids, but should be done for surface or element meshing.\n
            **deleteSurfElem:** Set to True if you want to delete the surface elements that are being generated or meshed.\n
        **Return Code:** True\n
        :type baseSET: int

        :type topSET: int

        :type propID: int

        :type numLayer: int

        :type match1: int

        :type match2: int

        :type makeMidside: bool

        :type checkSurfElem: bool

        :type deleteSurfElem: bool

        """
        ...

    def feMeshPoint(self, pointSET, MeshElem, propID) -> Any:
        """
        **Description:**
            Meshes a selected set of points. This method is obsolete an should no longer be used. It has been replaced with feMeshPoint2.
        **Remarks/Usage:**
            None
        **Input:**
            **pointSET:** The ID of a set that contains a list of point IDs that will be meshed. Alternatively, if you specify a negative value, this is simply the ID of the single point to mesh.\n
            **MeshElem:** If True, then nodes and elements will be generated on the selected points. If False, only nodes will be generated.\n
            **propID:** Specifies the ID of the property to use for elements as they are created. If you want to use meshing attributes, set propID=0. In this case, all selected points must have meshing attributes defined or they will not be meshed. The propID property must be compatible with point meshing.\n
        **Return Code:** True\n
        :type pointSET: int

        :type MeshElem: bool

        :type propID: int

        """
        ...

    def feMeshPoint2(self, pointSET, MeshElem, propID, merge_nodes) -> Any:
        """
        **Description:**
            Meshes a selected set of points.
        **Remarks/Usage:**
            None
        **Input:**
            **pointSET:** The ID of a set that contains a list of point IDs that will be meshed. Alternatively, if you specify a negative value, this is simply the ID of the single point to mesh.\n
            **MeshElem:** If True, then nodes and elements will be generated on the selected points. If False, only nodes will be generated.\n
            **propID:** Specifies the ID of the property to use for elements as they are created. If you want to use meshing attributes, set propID=0. In this case, all selected points must have meshing attributes defined or they will not be meshed. The propID property must be compatible with point meshing.\n
            **merge_nodes:** If True, coincident nodes on point will be merged.\n
        **Return Code:** True\n
        :type pointSET: int

        :type MeshElem: bool

        :type propID: int

        :type merge_nodes: bool

        """
        ...

    def feMeshRemesh(self, elemSET, nodeSET, remeshMode, refineRatio, breakAngle, deleteOrig, propID, minBetween,
                     maxASPECT, maxQuickNodes, meshApproach, quadAngle, smoothLaplacian, smoothIter, smoothTol) -> Any:
        """
        **Description:**
            Remeshes a portion of an existing mesh.
        **Remarks/Usage:**
            None
        **Input:**
            **elemSET:** The ID of a set that contains the IDs of the elements to be remeshed. Alternatively, if you specify a negative value, this is simply the ID of the single element to remesh. The elements contained in this set can be either surface (planar) elements or line elements. If you select line elements, then the only other option that is used is refineRatio.\n
            **nodeSET:** The ID of a set that contains the node IDs where the refinement will be applied. Not used if you set remeshMode=1.\n
            **remeshMode:** The remeshing mode: 0=Refine, 1=Remesh, 2=Unrefine.\n
            **refineRatio:** The ratio between the number of elements along each edge currently and the number after remeshing. This only applies to edges selected by the nodes in nodeSET. For example, if remeshMode=0, refine, and refineRatio=3, then three elements will be generated along each refined edge. If remeshMode=2, unrefine, and refineRatio=2, then half the elements along the refined edge will be removed.\n
            **breakAngle:** The break angle along the refinement edges. If two adjacent edges intersect at an angle greater than this value, then they will not be removed, no matter what the refineRatio value is. This helps to preserve corners in the mesh. Only used when remeshMode=2, unrefine.\n
            **deleteOrig:** If True, the original nodes and elements that are being remeshed (those elements selected in elemSET and their nodes) will be deleted.\n
            **propID:** Specifies the ID of the property to use for elements as they are created. Set propID=0 to mesh with whatever property and element type are currently active. Set propID=-1 to automatically mesh with plot-only elements, which do not require other property information.\n
            **maxASPECT:** The maximum allowable element aspect ratio. Not used for fast-tri mesher.\n
            **maxQuickNodes:** Boundaries/surfaces with more than this number of nodes on the boundary are quick-cut. Not used for fast-tri mesher.\n
            **meshApproach:** The mesher to use when meshing the surfaces: 0=Triangle, 1=Quad, 2=Fast-Triangle.\n
            **quadAngle:** The maximum angular deviation from 90 degrees allowed in a quad before it is split into triangles. Only applies to quad mesher.\n
            **smoothLaplacian:** If True, Laplacian smoothing is performed. If False, centroidal smoothing is used.\n
            **smoothIter:** The number of smoothing iterations to perform. Set to 0 to skip smoothing.\n
            **smoothTol:** The smoothing tolerance. Smoothing will stop if node movement during a smoothing pass falls below this tolerance.\n
        **Return Code:** True\n
        :type elemSET: int

        :type nodeSET: int

        :type remeshMode: int

        :type refineRatio: int

        :type breakAngle: float

        :type deleteOrig: bool

        :type propID: int

        :type maxASPECT: float

        :type maxQuickNodes: int

        :type meshApproach: int

        :type quadAngle: float

        :type smoothLaplacian: bool

        :type smoothIter: int

        :type smoothTol: int

        """
        ...

    def feMeshRemeshRegions(self, MeshSize, propID, minBetween, maxASPECT, maxQuickNodes, meshApproach, quadAngle,
                            smoothLaplacian, smoothIter, smoothTol) -> Any:
        """
        **Description:**
            Moves an element from one remeshing region to an adjacent region.
        **Remarks/Usage:**
            None
        **Input:**
            **MeshSize:** The default mesh size, used to determine the size of elements that will be generated.\n
            **propID:** Specifies the ID of the property to use for elements as they are created. Set propID=0 to mesh with whatever property and element type are currently active. Set propID=-1 to automatically mesh with plot-only elements, which do not require other property information.\n
            **minBetween:** The minimum number of elements between boundaries during mesh generation. Not used for fast-tri mesher.\n
            **maxASPECT:** The maximum allowable element aspect ratio. Not used for fast-tri mesher.\n
            **maxQuickNodes:** Boundaries/surfaces with more than this number of nodes on the boundary are quick-cut. Not used for fast-tri mesher.\n
            **meshApproach:** The mesher to use when meshing the surfaces (0=Triangle, 1=Quad, 2=Fast-Triangle).\n
            **quadAngle:** The maximum angular deviation from 90 degrees allowed in a quad before it is split into triangles. Only applies to quad mesher.\n
            **smoothLaplacian:** If True, Laplacian smoothing is performed. If False, centroidal smoothing is used.\n
            **smoothIter:** The number of smoothing iterations to perform. Set to 0 to skip smoothing.\n
            **smoothTol:** The smoothing tolerance. Smoothing will stop if node movement during a smoothing pass falls below this tolerance.\n
        **Return Code:** True\n
        :type MeshSize: float

        :type propID: int

        :type minBetween: int

        :type maxASPECT: float

        :type maxQuickNodes: int

        :type meshApproach: int

        :type quadAngle: float

        :type smoothLaplacian: bool

        :type smoothIter: int

        :type smoothTol: int

        """
        ...

    def feMeshRevolveCurve(self, curveSET, rotANGLE, rotThrust, axisOrig, axisVEC, propID, numElem) -> Any:
        """
        **Description:**
            Revolves existing curves into new elements.
        **Remarks/Usage:**
            None
        **Input:**
            **curveSET:** The ID of a set that contains the IDs of the curves to be revolved. The curves are revolved into planar elements. The number and spacing of elements is dependent on the mesh size established on the curves.\n
            **rotANGLE:** The angle of rotation, in degrees.\n
            **rotThrust:** The total thrust distance (along the axis of rotation), typically zero.\n
            **axisOrig:** The origin of the axis of revolution.\n
            **axisVEC:** The direction of the axis of revolution.\n
            **propID:** The ID of the property that will be used for the new elements. This property must be of the correct type (planar or solid), depending on the type of elements selected in elemSET.\n
            **numElem:** The number of elements generated by each original element along the revolution direction.\n
        **Return Code:** True\n
        :type curveSET: int

        :type rotANGLE: float

        :type rotThrust: float

        :type axisOrig: tuple[float]

        :type axisVEC: tuple[float]

        :type propID: int

        :type numElem: int

        """
        ...

    def feMeshRevolveElem(self, elemSET, rotANGLE, rotThrust, axisOrig, axisVEC, propID, numElem, matchCurrent,
                          deleteOrig) -> Any:
        """
        **Description:**
            Revolves existing elements into new elements.
        **Remarks/Usage:**
            None
        **Input:**
            **elemSET:** The ID of a set that contains the IDs of the elements to be revolved. The elements contained in this set must be either line or surface (planar) elements, but not both. Line elements are revolved into planar elements; planar elements are revolved into solid elements.\n
            **rotANGLE:** The angle of rotation, in degrees.\n
            **rotThrust:** The total thrust distance (along the axis of rotation), typically zero.\n
            **axisOrig:** The origin of the axis of revolution.\n
            **axisVEC:** The direction of the axis of revolution.\n
            **propID:** The ID of the property that will be used for the new elements. This property must be of the correct type (planar or solid), depending on the type of elements selected in elemSET.\n
            **numElem:** The number of elements generated by each original element along the revolution direction.\n
            **matchCurrent:** If True, the attributes of the elements that are created will match the active settings. If False, they will match the generating elements.\n
            **deleteOrig:** If True, the elements in elemSET will be deleted, leaving only the new elements.\n
        **Return Code:** True\n
        :type elemSET: int

        :type rotANGLE: float

        :type rotThrust: float

        :type axisOrig: tuple[float]

        :type axisVEC: tuple[float]

        :type propID: int

        :type numElem: int

        :type matchCurrent: bool

        :type deleteOrig: bool

        """
        ...

    def feMeshSizeCurve(self, curveSET, numElem, MeshSize, minLine, minClosed, minOther, spacing, biasMethod, bias,
                        biasLoc, CustomSize) -> Any:
        """
        **Description:**
            Sets mesh sizes on a selected set of curves.
        **Remarks/Usage:**
            None
        **Input:**
            **curveSET:** The ID of a set that contains a list of curve IDs that will have mesh sizes defined. Alternatively, if you specify a negative value, this is simply the ID of the single curve to use.\n
            **numElem:** The number of elements to mesh along the selected curves. If 0, then meshSize, minLine, minClosed and minOther determine the number of elements. If -1, then the mesh sizes are removed from the selected curves. \n
            **minLine:** The minimum number of elements to mesh along any curve that is a straight line. If you do not want to use this feature, simply set the value to 0 (or 1). Only used if numElem=0.\n
            **minClosed:** The minimum number of elements to mesh along any curve that is closed - like a circle. If you do not want to use this feature, simply set the value to 0 (or 1). Only used if numElem=0.\n
            **minOther:** The minimum number of elements to mesh along any curve that is not a straight line, and is not closed - like arcs and splines. If you do not want to use this feature, simply set the value to 0 (or 1). Only used if numElem=0.\n
            **spacing:** If 0, then parametric spacing is used; otherwise ,constant length spacing is used.\n
            **biasMethod:** 0=Equal length spacing, 1=Linear Bias, 2=Geometric Bias.\n
            **bias:** The bias value - greater than or equal to 1.0. A value of 1.0 is not biased. A value of 2.0 means that the largest element is approximately 2.0 times the length of the smallest.\n
            **bias:** 0=Small elements at start of curve, 1=Small elements at end of curve, 2=Small elements at center of curve, 3=Small elements at both ends of curve.\n
            **CustomSize:** For constant length spacing, mesh sizes will be saved as a custom mesh size if this is True. Not used for parametric spacing.\n
        **Return Code:** True\n
        :type curveSET: int

        :type numElem: int

        :type minLine: int

        :type minClosed: int

        :type minOther: int

        :type spacing: int

        :type biasMethod: int

        :type bias: float

        :type bias: int

        :type CustomSize: bool

        """
        ...

    def feMeshSizeCurve2(self, curveSET, numElem, MeshSize, minLine, minClosed, minOther, spacing, biasMethod, bias,
                         biasLoc, CustomSize, bPropagateMeshSize) -> Any:
        """
        **Description:**
            Sets mesh sizes on a selected set of curves.
        **Remarks/Usage:**
            None
        **Input:**
            **curveSET:** The ID of a set that contains a list of curve IDs that will have mesh sizes defined. Alternatively, if you specify a negative value, this is simply the ID of the single curve to use.\n
            **numElem:** The number of elements to mesh along the selected curves. If 0, then meshSize, minLine, minClosed and minOther determine the number of elements. If -1, then the mesh sizes are removed from the selected curves. \n
            **minLine:** The minimum number of elements to mesh along any curve that is a straight line. If you do not want to use this feature, simply set the value to 0 (or 1). Only used if numElem=0.\n
            **minClosed:** The minimum number of elements to mesh along any curve that is closed - like a circle. If you do not want to use this feature, simply set the value to 0 (or 1). Only used if numElem=0.\n
            **minOther:** The minimum number of elements to mesh along any curve that is not a straight line, and is not closed - like arcs and splines. If you do not want to use this feature, simply set the value to 0 (or 1). Only used if numElem=0.\n
            **spacing:** If 0, then parametric spacing is used; otherwise ,constant length spacing is used.\n
            **biasMethod:** 0=Equal length spacing, 1=Linear Bias, 2=Geometric Bias.\n
            **bias:** The bias value - greater than or equal to 1.0. A value of 1.0 is not biased. A value of 2.0 means that the largest element is approximately 2.0 times the length of the smallest.\n
            **bias:** 0=Small elements at start of curve, 1=Small elements at end of curve, 2=Small elements at center of curve, 3=Small elements at both ends of curve.\n
            **CustomSize:** For constant length spacing, mesh sizes will be saved as a custom mesh size if this is True. Not used for parametric spacing.\n
        **Return Code:** True\n
        :type curveSET: int

        :type numElem: int

        :type minLine: int

        :type minClosed: int

        :type minOther: int

        :type spacing: int

        :type biasMethod: int

        :type bias: float

        :type bias: int

        :type CustomSize: bool

        """
        ...

    def feMeshSizeCurveMatchNodes(self, nCurveSet, nNodeSet, dTolerance) -> Any:
        """
        **Description:**
            Sets custom mesh size locations on a selected set of curves using the locations of a selected set of nodes.
        **Remarks/Usage:**
            None
        **Input:**
            **nCurveSet:** The ID of a set that contains a list of curve IDs that will have mesh sizes defined. Alternatively, if you specify a negative value, this is simply the ID of the single curve to use.\n
            **nNodeSet:** The ID of a set that contains a list of node IDs. The location of each node in the set will be projected based on the Tolerance then used to specify custom mesh size locations on the selected curve(s). Alternatively, if you specify a negative value, this is simply the ID of a single node to use.\n
            **dTolerance:** Allows specification of a maximum distance to project the locations of the selected nodes onto the selected curves. If set to 0.0, which is the default, then the nodal locations of all selected nodes will be projected onto all of the selected curves.\n
        **Return Code:** True\n
        :type nCurveSet: int

        :type nNodeSet: int

        :type dTolerance: float

        """
        ...

    def feMeshSizeCurveMatchXYZ(self, nCurveSet, nNumXYZ, vecXYZ, dTolerance) -> Any:
        """
        **Description:**
            Sets custom mesh size locations on a selected set of curves using specified XYZ locations.
        **Remarks/Usage:**
            None
        **Input:**
            **nCurveSet:** The ID of a set that contains a list of curve IDs that will have mesh sizes defined. Alternatively, if you specify a negative value, this is simply the ID of the single curve to use.\n
            **nNumXYZ:** The number of sets of XYZ coordinates to be used for custom mesh sizing locations (i.e. the number of entries in the arrays)\n
        **Return Code:** True\n
        :type nCurveSet: int

        :type nNumXYZ: int

        """
        ...

    def feMeshSizePoint(self, pointSET, MeshSize) -> Any:
        """
        **Description:**
            Sets mesh sizes on a selected set of points.
        **Remarks/Usage:**
            None
        **Input:**
            **pointSET:** The ID of a set that contains a list of point IDs that will have mesh sizes defined. Alternatively, if you specify a negative value, this is simply the ID of the single point to use.\n
            **MeshSize:** Set this to the mesh size that you want to define at the points. The size should be in model units. Specify 0.0 to remove mesh sizes from the points.\n
        **Return Code:** True\n
        :type pointSET: int

        :type MeshSize: float

        """
        ...

    def feMeshSizePropagate(self, CurvesWithSizesToPropagateSET) -> Any:
        """
        **Description:**

        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def feMeshSizeSolid(self, surfSET, replaceAll, MeshSize, minEdge, maxANGLE, maxOnSmall, smallSize, vertexAspect,
                        mappedRefinement, GrowthFactor, refineRatio, refineSurf, matchAdjacent, hexMesh, adjustColor,
                        removeSlaving) -> Any:
        """
        **Description:**
            Sets mesh sizes on a selected set of solids.
        **Remarks/Usage:**
            None
        **Input:**
            **surfSET:** The ID of a set that contains a list of solid IDs that will have mesh sizes defined. Alternatively, if you specify a negative value, this is simply the ID of the single solid to use.\n
            **replaceAll:** If True, then mesh sizes will be replaced on all curves of all selected solids. If False, then only curves with no sizes defined will be sized.\n
            **minEdge:** The minimum number of elements to mesh along any edge. Set to 0 if you do not want to specify a minimum.\n
            **maxANGLE:** The maximum angle tolerance between the geometry tangent vector and the vector connecting consecutive mesh locations along the curves. Additional mesh locations are added along the curves to make sure this criterion is satisfied. Set to 0.0 if you do not want to use this type of mesh spacing adjustment.\n
            **maxOnSmall:** The maximum number of elements on any feature that is identified as small (depends on smallSize). Set to 0 if you do not want to adjust mesh sizes on small features.\n
            **smallSize:** The maximum size of a small feature. Set to 0.0 if you do not want to adjust mesh sizes on small features.\n
            **mappedRefinement:** If True, additional modifications are done to the mesh sizes on a surface that favor mapped meshing. This does not guarantee that mapped meshing sizes will be created. If you must have a mapped mesh, you need to set that approach on the surface before you size.\n
            **GrowthFactor:** The factor that is multiplied by the average curve element size to adjust the mesh size on the interior of a surface. Set to 0.0 to skip setting interior growth factors.\n
            **refineRatio:** The curvature-based mesh refinement ratio. Adjusts the mesh sizes along curves in areas of high curvature. Set to 0.0 to skip curvature-based sizing.\n
            **refineSurf:** Set to True to also consider curvature requirements when sizing the interior of the mesh. You must specify a nonzero refineRatio or this option will be ignored.\n
            **matchAdjacent:** Set to True to automatically find adjacent surfaces between multiple solids that you are sizing. The matched surfaces will automatically have a Linked approach defined.\n
            **adjustColor:** Set to True if you want to change the surface colors to indicate the status and success of the mesh sizing. This is especially important when sizing for hex meshing.\n
            **removeSlaving:** Set to True to remove any previous Linked approaches on the surfaces of the solids that you are sizing.\n
        **Return Code:** True\n
        :type surfSET: int

        :type replaceAll: bool

        :type minEdge: int

        :type maxANGLE: float

        :type maxOnSmall: int

        :type smallSize: float

        :type mappedRefinement: bool

        :type GrowthFactor: float

        :type refineRatio: float

        :type refineSurf: bool

        :type matchAdjacent: bool

        :type adjustColor: bool

        :type removeSlaving: bool

        """
        ...

    def feMeshSizeSurface(self, surfSET, replaceAll, MeshSize, minEdge, maxANGLE, maxOnSmall, smallSize, vertexAspect,
                          mappedRefinement, grxfprintfowthFactor, refineRatio, refineSurf) -> Any:
        """
        **Description:**
            Sets mesh sizes on a selected set of surfaces.
        **Remarks/Usage:**
            None
        **Input:**
            **surfSET:** The ID of a set that contains a list of surface IDs that will have mesh sizes defined. Alternatively, if you specify a negative value, this is simply the ID of the single surface to use.\n
            **replaceAll:** If True, then mesh sizes will be replaced on all curves of all selected surfaces. If False, then only curves with no sizes defined will be sized.\n
            **minEdge:** The minimum number of elements to mesh along any edge. Set to 0 if you do not want to specify a minimum.\n
            **maxANGLE:** The maximum angle tolerance between the geometry tangent vector and the vector connecting consecutive mesh locations along the curves. Additional mesh locations are added along the curves to make sure this criterion is satisfied. Set to 0.0 if you do not want to use this type of mesh spacing adjustment.\n
            **maxOnSmall:** The maximum number of elements on any feature that is identified as small (depends on smallSize). Set to 0 if you do not want to adjust mesh sizes on small features.\n
            **smallSize:** The maximum size of a small feature. Set to 0.0 if you do not want to adjust mesh sizes on small features.\n
            **mappedRefinement:** If True, additional modifications are done to the mesh sizes on a surface that favor mapped meshing. This does not guarantee that mapped meshing sizes will be created. If you must have a mapped mesh, you need to set that approach on the surface before you size.\n
            **grxfprintfowthFactor:** The factor that is multiplied by the average curve element size to adjust the mesh size on the interior of a surface. Set to 0.0 to skip setting interior growth factors.\n
            **refineRatio:** The curvature-based mesh refinement ratio. Adjusts the mesh sizes along curves in areas of high curvature. Set to 0.0 to skip curvature-based sizing.\n
            **refineSurf:** Set to True to also consider curvature requirements when sizing the interior of the mesh. You must specify a nonzero refineRatio, or this option will be ignored.\n
        **Return Code:** True\n
        :type surfSET: int

        :type replaceAll: bool

        :type minEdge: int

        :type maxANGLE: float

        :type maxOnSmall: int

        :type smallSize: float

        :type mappedRefinement: bool

        :type grxfprintfowthFactor: float

        :type refineRatio: float

        :type refineSurf: bool

        """
        ...

    def feMeshSmooth(self, elemSET, laplaceSmooth, iter, tolerance) -> Any:
        """
        **Description:**
            Smooths a selected set of elements.
        **Remarks/Usage:**
            Only planar or solid elements can be selected in elemSET, not both at the same time.
        **Input:**
            **elemSET:** The ID of a set that contains the IDs of the elements to be smoothed. The elements contained in this set must be surface (planar) elements or solid elements.\n
            **laplaceSmooth:** If True, Laplacian smoothing is performed; otherwise, centroidal smoothing is used.\n
            **iter:** The maximum number of smoothing passes that will be performed. Smoothing will terminate sooner if the tolerance is reached.\n
            **tolerance:** The nodal movement tolerance. If no nodes move farther than this distance during a smoothing pass, smoothing will be terminated.\n
        **Return Code:** True\n
        :type elemSET: int

        :type laplaceSmooth: bool

        :type iter: int

        :type tolerance: float

        """
        ...

    def feMeshSmooth2(self, elemSET, fixednodeSET, laplaceSmooth, iter, tolerance) -> Any:
        """
        **Description:**
            Smooths a selected set of elements while allowing any number of specified nodes to remain in a fixed location.
        **Remarks/Usage:**
            Only planar or solid elements can be selected in elemSET, not both at the same time.
        **Input:**
            **elemSET:** The ID of a set that contains the IDs of the elements to be smoothed. The elements contained in this set must be surface (planar) elements or solid elements.\n
            **fixednodeSET:** The ID of a set that contains the IDs of the nodes to remain in a fixed location during the smoothing operation. Specifying a value of 0 will create the same results as using feMeshSmooth.\n
            **laplaceSmooth:** If True, Laplacian smoothing is performed; otherwise, centroidal smoothing is used.\n
            **iter:** The maximum number of smoothing passes that will be performed. Smoothing will terminate sooner if the tolerance is reached.\n
            **tolerance:** The nodal movement tolerance. If no nodes move farther than this distance during a smoothing pass, smoothing will be terminated.\n
        **Return Code:** True\n
        :type elemSET: int

        :type fixednodeSET: int

        :type laplaceSmooth: bool

        :type iter: int

        :type tolerance: float

        """
        ...

    def feMeshSurface(self, surfaceSET, propID, minBetween, maxASPECT, maxQuickNodes, meshApproach, quadAngle,
                      midsideGeom, midsideAngle, smoothLaplacian, smoothIter, smoothTol) -> Any:
        """
        **Description:**
            Meshes a selected set of surfaces.
        **Remarks/Usage:**
            This function has been replaced by feMeshSurface2( )
        **Input:**
            **surfaceSET:** The ID of a set that contains a list of surface IDs that will be meshed. Alternatively, if you specify a negative value, this is simply the ID of the single surface to mesh.\n
            **propID:** Specifies the ID of the property to use for elements as they are created. If you want to use meshing attributes, set propID=0. In this case, all selected surfaces must have meshing attributes defined or they will not be meshed. The propID property must be compatible with surface meshing. Set propID=-1 to automatically mesh with plot-only elements, which do not require other property information.\n
            **minBetween:** The minimum number of elements between boundaries during mesh generation. Not used for fast-tri mesher.\n
            **maxASPECT:** The maximum allowable element aspect ratio. Not used for fast-tri mesher.\n
            **maxQuickNodes:** Boundaries/surfaces with more than this number of nodes on the boundary are quick-cut. Not used for fast-tri mesher.\n
            **meshApproach:** The mesher to use when meshing the surfaces. (0=Triangle, 1=Quad, 2=Fast-Triangle).\n
            **midsideGeom:** If True and you are meshing with parabolic elements, midside nodes will be projected toward the geometry.\n
            **midsideAngle:** The maximum angle formed by the edge of the element as the midside nodes are projected onto the geometry. If midsideAngle=0.0 and midsideGeom=True, then midside nodes will be projected completely onto the geometry regardless of the distortion introduced in the elements.\n
            **smoothLaplacian:** If True, Laplacian smoothing is performed. If False, centroidal smoothing is used.\n
            **smoothIter:** The number of smoothing iterations to perform. Set to 0 to skip smoothing.\n
            **smoothTol:** The smoothing tolerance. Smoothing will stop if node movement during a smoothing pass falls below this tolerance.\n
        **Return Code:** True\n
        :type surfaceSET: int

        :type propID: int

        :type minBetween: int

        :type maxASPECT: float

        :type maxQuickNodes: int

        :type meshApproach: int

        :type midsideGeom: bool

        :type midsideAngle: float

        :type smoothLaplacian: bool

        :type smoothIter: int

        :type smoothTol: int

        """
        ...

    def feMeshSurface2(self, surfaceSET, propID, elemShape, bAllowMapped, bResetDefaults) -> Any:
        """
        **Description:**
            Meshes a selected set of surfaces. This function replaces feMeshSurface( )
        **Remarks/Usage:**
            None
        **Input:**
            **surfaceSET:** The ID of a set that contains a list of surface IDs that will be meshed. Alternatively, if you specify a negative value, this is simply the ID of the single surface to mesh.\n
            **propID:** Specifies the ID of the property to use for elements as they are created. If you want to use predefined meshing attributes, set propID=0. In this case, all selected surfaces must have meshing attributes defined or they will not be meshed. The propID property must be compatible with surface meshing. \n
            **elemShape:** The shape of the elements to mesh. Must be 2=Tria3, 3=Tria6, 4=Quad4, 5=Quad8 or set to 0 to use the shape that is predefined on the meshing attributes.\n
            **bAllowMapped:** If True, mapped meshing of the surfaces is allowed, otherwise it is not. This argument is ignored if elemShape=0\n
        **Return Code:** True\n
        :type surfaceSET: int

        :type propID: int

        :type elemShape: int

        :type bAllowMapped: bool

        """
        ...

    def feMeshSurfaceByAttributes(self, surfaceSET) -> Any:
        """
        **Description:**
            Meshes a selected set of surfaces using its stored attributes.
        **Remarks/Usage:**
            None
        **Input:**
            **surfaceSET:** The ID of a set that contains a list of surface IDs that will be meshed using their saved attributes. Alternatively, if you specify a negative value, this is simply the ID of the single surface to mesh.\n
        **Return Code:** True\n
        :type surfaceSET: int

        """
        ...

    def feMeshSweepCurve(self, curveSET, numPath, curvePath, numAlign, curveAlign, alignLoc, propID) -> Any:
        """
        **Description:**
            Sweeps curves along one or more curves into new elements.
        **Remarks/Usage:**
            None
        **Input:**
            **numPath:** The number of curves in the curvePath array.\n
            **curvePath:** The IDs of the curves along the sweep path. These IDs should be specified in order, starting at the beginning of the path to sweep along.\n
            **numAlign:** The number of curves in the curveAlign array (usually 0, unless you are using an alignment path to orient the elements along sweep path).\n
            **curveAlign:** The IDs of curves along the alignment path.\n
            **alignLoc:** The alignment position. Only used if the sweep path is nonplanar, and numPath=0 (not using an alignment path).\n
            **propID:** The ID of the property that will be used for the new elements. This property must be of the correct type (planar or solid) depending on the type of elements selected in elemSET.\n
        **Return Code:** True\n
        :type numPath: int

        :type curvePath: tuple[int]

        :type numAlign: int

        :type curveAlign: tuple[int]

        :type alignLoc: tuple[float]

        :type propID: int

        """
        ...

    def feMeshSweepElem(self, elemSET, numPath, curvePath, numAlign, curveAlign, alignLoc, propID, matchCurrent,
                        deleteOrig) -> Any:
        """
        **Description:**
            Sweeps existing elements along one or more curves into new elements.
        **Remarks/Usage:**
            None
        **Input:**
            **numPath:** The number of curves in the curvePath array.\n
            **curvePath:** The IDs of the curves along the sweep path. These IDs should be specified in order, starting at the beginning of the path to sweep along.\n
            **numAlign:** The number of curves in the curveAlign array (usually 0, unless you are using an alignment path to orient the elements along sweep path).\n
            **curveAlign:** The IDs of curves along the alignment path.\n
            **alignLoc:** The alignment position. Only used if the sweep path is nonplanar, and numPath=0 (not using an alignment path).\n
            **propID:** The ID of the property that will be used for the new elements. This property must be a planar type.\n
        **Return Code:** True\n
        :type numPath: int

        :type curvePath: tuple[int]

        :type numAlign: int

        :type curveAlign: tuple[int]

        :type alignLoc: tuple[float]

        :type propID: int

        """
        ...

    def feMeshTetSolid(self, entityTYPE, entitySET, propID, surfaceMeshOnly, makeMidside, tetGrowth, checkSurfElem,
                       deleteSurfElem, midsideGeom, midsideAngle, allocateElem) -> Any:
        """
        **Description:**
            Meshes a selected set of solids (or surfaces or planar elements) with tetrahedral elements. This method has been superseded by feMeshTetSolid2 and feMeshTetSolid3.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities being meshed that are contained in entitySET. For entity information, see Section 3.3.6, "Entity Types". Can be FT_SOLID, FT_SURFACE or FT_ELEM. \n
            **entitySET:** The ID of a set that contains a list of solid/surface/element IDs that will be meshed. Alternatively, if you specify a negative value, this is simply the ID of the single entity to mesh - probably only for solids. In any case, the list of entities must form one or more closed solid volumes.\n
            **propID:** Specifies the ID of the property to use for tetrahedral elements as they are created. If you want to use meshing attributes, set propID=0. In this case, all selected solids must have meshing attributes defined or they will not be meshed. This only works if entityTYPE=FT_SOLID. The propID property must be compatible with solid meshing.\n
            **surfaceMeshOnly:** If True, only surface elements are generated, and the meshing process stops before generating tetrahedra.\n
            **makeMidside:** If True, the solids will have midside nodes created. Otherwise, linear elements are created.\n
            **tetGrowth:** The tetrahedral growth factor. Numbers larger than 1.0 mean that the elements on the inside of the solid will be larger than those on the outside. It is usually best to use a factor slightly larger than 1.0. Default value is 1.5 - if you specify tetGrowth=0.0.\n
            **deleteSurfElem:** Set to True if you want to delete the surface elements that are being generated or meshed.\n
            **midsideGeom:** If True, and you are meshing with parabolic elements, midside nodes will be projected toward the geometry.\n
            **midsideAngle:** The maximum angle formed by the edge of the element as the midside nodes are projected onto the geometry. If midsideAngle=0.0 and midsideGeom=True, then midside nodes will be projected completely onto the geometry regardless of the distortion introduced in the elements.\n
            **allocateElem:** Estimated maximum number of tetrahedral elements to be generated. This option simply controls memory allocation for the mesher - more elements may be generated. You should usually set this value to 0. This will cause the mesher to automatically estimate the memory requirements from the surface mesh.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type propID: int

        :type surfaceMeshOnly: bool

        :type makeMidside: bool

        :type tetGrowth: float

        :type deleteSurfElem: bool

        :type midsideGeom: bool

        :type midsideAngle: float

        :type allocateElem: int

        """
        ...

    def feMeshTetSolid2(self, entityTYPE, entitySET, propID, surfaceMeshOnly, makeMidside, tetGrowth, checkSurfElem,
                        deleteSurfElem, midsideGeom, midsideAngle, multiThruThickness, sliverRemoval,
                        tetOptimization) -> Any:
        """
        **Description:**
            Meshes a selected set of solids (or surfaces or planar elements) with tetrahedral elements. This method supersedes feMeshTetSolid, but has also been superseded by feMeshTetSolid3.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities being meshed that are contained in entitySET. For entity information, see Section 3.3.6, "Entity Types". Can be FT_SOLID, FT_SURFACE or FT_ELEM. \n
            **entitySET:** The ID of a set that contains a list of solid/surface/element IDs that will be meshed. Alternatively, if you specify a negative value, this is simply the ID of the single entity to mesh - probably only for solids. In any case, the list of entities must form one or more closed solid volumes.\n
            **propID:** Specifies the ID of the property to use for tetrahedral elements as they are created. If you want to use meshing attributes, set propID=0. In this case, all selected solids must have meshing attributes defined or they will not be meshed. This only works if entityTYPE=FT_SOLID. The propID property must be compatible with solid meshing.\n
            **surfaceMeshOnly:** If True, only surface elements are generated, and the meshing process stops before generating tetrahedra.\n
            **makeMidside:** If True, the solids will have midside nodes created. Otherwise, linear elements are created.\n
            **tetGrowth:** The tetrahedral growth factor. Numbers larger than 1.0 mean that the elements on the inside of the solid will be larger than those on the outside. It is usually best to use a factor slightly larger than 1.0. Default value is 1.5 - if you specify tetGrowth=0.0.\n
            **deleteSurfElem:** Set to True if you want to delete the surface elements that are being generated or meshed.\n
            **midsideGeom:** If True, and you are meshing with parabolic elements, midside nodes will be projected toward the geometry.\n
            **midsideAngle:** The maximum angle formed by the edge of the element as the midside nodes are projected onto the geometry. If midsideAngle=0.0 and midsideGeom=True, then midside nodes will be projected completely onto the geometry regardless of the distortion introduced in the elements.\n
            **multiThruThickness:** If True, mesher will place multiple tet elements through the thickness of the solid. Default should be set to False.\n
            **tetOptimization:** Sets the Tet Optimization level. Available values are 0-5, which 0=off, 1=less optimization, 5=more optimization, 3=default. \n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type propID: int

        :type surfaceMeshOnly: bool

        :type makeMidside: bool

        :type tetGrowth: float

        :type deleteSurfElem: bool

        :type midsideGeom: bool

        :type midsideAngle: float

        :type multiThruThickness: bool

        :type tetOptimization: int

        """
        ...

    def feMeshTetSolid3(self, entityTYPE, entitySET, propID, meshingApproach, makeMidside, tetGrowth, checkSurfElem,
                        deleteSurfElem, midsideGeom, midsideAngle, multiThruThickness, sliverRemoval, tetOptimization,
                        pyramidSurfaceSET, pyramidMatchAdjacentParabolic) -> Any:
        """
        **Description:**
            Meshes a selected set of solids (or surfaces or planar elements) with tetrahedral and, optionally, pyramid elements. This method supersedes feMeshTetSolid2 and feMeshTetSolid.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities being meshed that are contained in entitySET. For entity information, see Section 3.3.6, "Entity Types". Can be FT_SOLID, FT_SURFACE or FT_ELEM. \n
            **entitySET:** The ID of a set that contains a list of solid/surface/element IDs that will be meshed. Alternatively, if you specify a negative value, this is simply the ID of the single entity to mesh - probably only for solids. In any case, the list of entities must form one or more closed solid volumes.\n
            **propID:** Specifies the ID of the property to use for tetrahedral elements as they are created. If you want to use meshing attributes, set propID=0. In this case, all selected solids must have meshing attributes defined or they will not be meshed. This only works if entityTYPE=FT_SOLID. The propID property must be compatible with solid meshing.\n
            **meshingApproach:** Set to one of three values: \n
            **makeMidside:** If True, the solids will have midside nodes created. Otherwise, linear elements are created.\n
            **tetGrowth:** The tetrahedral growth factor. Numbers larger than 1.0 mean that the elements on the inside of the solid will be larger than those on the outside. It is usually best to use a factor slightly larger than 1.0. Default value is 1.1 - if you specify tetGrowth=0.0.\n
            **deleteSurfElem:** Set to True if you want to delete the surface elements that are being generated or meshed.\n
            **midsideGeom:** If True, and you are meshing with parabolic elements, midside nodes will be projected toward the geometry.\n
            **midsideAngle:** The maximum angle formed by the edge of the element as the midside nodes are projected onto the geometry. If midsideAngle=0.0 and midsideGeom=True, then midside nodes will be projected completely onto the geometry regardless of the distortion introduced in the elements.\n
            **multiThruThickness:** If True, mesher will place multiple tet elements through the thickness of the solid. Default should be set to False.\n
            **tetOptimization:** Sets the Tet Optimization level. Available values are 0-5, which 0=off, 1=less optimization, 5=more optimization, 3=default. \n
            **pyramidSurfaceSET:** Only used if meshingApproach=2 and entityType is not FT_ELEM. The ID of a Set object that contains the IDs of surfaces to mesh with quadrilateral elements used to then create pyramid elements. Any surfaces that were already meshed prior to this call do not need to be included. Also, if all desired surfaces are adjacent to or linked to quad-meshed surfaces, or have quad meshing attributes, then specify pyramidSurfaceSET=0. If you specify any other ID, the Set object must contain all unmeshed surfaces where you want pyramids.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type propID: int

        :type meshingApproach: int

        :type makeMidside: bool

        :type tetGrowth: float

        :type deleteSurfElem: bool

        :type midsideGeom: bool

        :type midsideAngle: float

        :type multiThruThickness: bool

        :type tetOptimization: int

        :type pyramidSurfaceSET: int

        """
        ...

    def feMeshTransition(self, useNodes, entCOUNT, entID, edgeNUM, edgeBIAS, edgeSIZE, propID, minBetween, maxASPECT,
                         maxQuickNodes, meshApproach, quadAngle, smoothLaplacian, smoothIter, smoothTol) -> Any:
        """
        **Description:**
            Meshes between nodes or line elements that form a closed boundary.
        **Remarks/Usage:**
            None
        **Input:**
            **useNodes:** If True, then entID contains a list of nodes used to define the boundary; otherwise, entID contains a list of line elements.\n
            **entCOUNT:** The number of items contained in entID, edgeNum, edgeBias, and edgeSize.\n
            **entID:** The IDs of the node or elements used to define the boundary being meshed.\n
            **edgeNUM:** The number of elements to create between the associated nodes. edgeNum[0] applies to the space between entID[0] and entID[1]. edgeNum[entCount-1] applies to the space between entID[entCount-1] and entID[0]; that is, the last segment closing the boundary. Specify edgeNum[i] = 0 to use edgeSize[i] to determine the number of elements. This option is not used if useNodes=False.\n
            **edgeBIAS:** The bias value to use with the elements being generated between successive nodes. Only used if edgeNum[i] is not zero, and useNodes is True. Use of indexes is the same as for edgeNum.\n
            **edgeSIZE:** Similar to edgeNum and edgeBias; this is the element size to use for each segment. The distance between nodes is simply divided by this value to find the number of elements in the segment. Usage is the same as edgeNum. Only used if edgeNum[i] = 0.\n
            **propID:** Specifies the ID of the property to use for elements as they are created. The propID property must be compatible with surface meshing. Set propID=0 to mesh with whatever property and element type are currently active. Set propID=-1 to automatically mesh with plot-only elements, which do not require other property information.\n
            **minBetween:** The minimum number of elements between boundaries during mesh generation. Not used for fast-tri mesher.\n
            **maxQuickNodes:** Boundaries/surfaces with more than this number of nodes on the boundary are quick-cut. Not used for fast-tri mesher.\n
            **meshApproach:** The mesher to use when meshing the surfaces: 0=Triangle, 1=Quad, 2=Fast-Triangle.\n
            **quadAngle:** The maximum angular deviation from 90 degrees allowed in a quad before it is split into triangles. Only applies to quad mesher.\n
            **smoothLaplacian:** If True, Laplacian smoothing is performed. If False, centroidal smoothing is used.\n
            **smoothIter:** The number of smoothing iterations to perform. Set to 0 to skip smoothing.\n
            **smoothTol:** The smoothing tolerance. Smoothing will stop if node movement during a smoothing pass falls below this tolerance.\n
        **Return Code:** True\n
        :type useNodes: bool

        :type entCOUNT: int

        :type entID: tuple[int]

        :type edgeNUM: tuple[int]

        :type edgeBIAS: tuple[int]

        :type edgeSIZE: tuple[float]

        :type propID: int

        :type minBetween: int

        :type maxQuickNodes: int

        :type meshApproach: int

        :type quadAngle: float

        :type smoothLaplacian: bool

        :type smoothIter: int

        :type smoothTol: int

        """
        ...

    def feMeshUnzip(self, fromSET, toSET, connectWith, orient, dof) -> Any:
        """
        **Description:**
            Unzips an existing mesh and places connecting elements at the new, unzipped coincident nodes. This call is obsolete, use feMeshUnzip2 instead.
        **Remarks/Usage:**
            None
        **Input:**
            **fromSET:** A set containing the element IDs on the primary side of the interface. Alternatively, if you specify a negative value, this is simply the ID of the single element to use.\n
            **toSET:** A set containing the node IDs to unzip. Each of these nodes will be duplicated and nodes on the elements that were not selected as the primary side will be replaced with the copies. Connecting elements will be created between the original and new nodes.\n
            **connectWith:** The type of element to use for the connection: 0=None, 1=Constraint Equation, 2=Rigid, 3=DOF Spring, 4=Gap Element, 5=Spring/Damper. If you choose constraint equations, you must have an active constraint set for this method to work. If you choose None, the mesh will be unzipped, but no connection elements will be created.\n
            **orient:** The orientation vector used for elements created with this method (if required by connectWith).\n
            **dof:** The degrees of freedom (DOF) to connect. Set values to 1 for DOF to connect; 0 for DOF to skip.\n
        **Return Code:** True\n
        :type fromSET: int

        :type toSET: int

        :type connectWith: int

        :type orient: tuple[float]

        :type dof: tuple[int]

        """
        ...

    def feMeshUnzip2(self, fromSET, toSET, connectWith, orientMode, orientID, orientVector, dof, rigidReverse) -> Any:
        """
        **Description:**
            Unzips an existing mesh and places connecting elements at the new, unzipped coincident nodes. This call supersedes feMeshUnzip and provides programmatic access to the functionality of the Mesh, Connect, Unzip command.
        **Remarks/Usage:**
            None
        **Input:**
            **fromSET:** A set containing the element IDs on the primary side of the interface. Alternatively, if you specify a negative value, this is simply the ID of the single element to use.\n
            **toSET:** A set containing the node IDs to unzip. Each of these nodes will be duplicated and nodes on the elements that were not selected as the primary side will be replaced with the copies. Connecting elements will be created between the original and new nodes.\n
            **connectWith:** The type of element to use for the connection: 0=None, 1=Constraint Equation, 2=Rigid, 3=DOF Spring, 4=Gap Element, 5=Spring/Damper. If you choose constraint equations, you must have an active constraint set for this method to work. If you choose None, the mesh will be unzipped, but no connection elements will be created.\n
            **orientMode:** The type of orientation to be used with Line Elements. 0=Node, 1=Vector, 2=CSys. If you specify either Node or Csys you must also specify the corresponding ID in orientID. If you specify Vector it must be specified in orientVec\n
            **orientID:** ID of the Node when orientMode = 0 or ID of CSys when orientMode = 2, used to orient Line Elements (if required by connectWith)\n
            **orientVector:** The orientation vector used for Line Elements created when orientMode = 1 (if required by connectWith)\n
            **dof:** The degrees of freedom (DOF) to connect. Set values to 1 for DOF to connect; 0 for DOF to skip\n
            **rigidReverse:** When True, reverses the direction of rigid connections so they are created from the copied nodes back to the primary side nodes\n
        **Return Code:** True\n
        :type fromSET: int

        :type toSET: int

        :type connectWith: int

        :type orientMode: int

        :type orientID: int

        :type orientVector: tuple[float]

        :type dof: tuple[int]

        :type rigidReverse: bool

        """
        ...

    def feMinInt(self, Int1, Int2) -> Any:
        """
        :type Int1: Any
        :type Int2: Any
        """
        ...

    def feMinReal(self, Real1, Real2) -> Any:
        """
        :type Real1: Any
        :type Real2: Any
        """
        ...

    def feModelFileVersionV2(self, fName, dVersion) -> Any:
        """
        **Description:**
            This function finds the FEMAP version number of a given file.
        **Remarks/Usage:**
            None
        **Return Code:** False\n
        """
        ...

    def feModifyBeamWarping(self, entitySET, method, nodeType, autoENDA, autoENDB) -> Any:
        """
        **Description:**
            Modifies/Creates warping NODES or SPOINTS for Beam Warping.
        **Remarks/Usage:**
            This method can only be used with Beam elements.
        **Input:**
            **entitySET:** The ID of a set that contains a list of element IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single element to update. \n
            **method:** Defines the method for updating the warping node. 0 = None(Remove), 1 = Continuous, 2 = All Continuous, 3 = Discontinuous.\n
            **nodeType:** The type of node to create 0 = Node, 1 = SPOINT.\n
        **Return Code:** True\n
        :type entitySET: int

        :type method: int

        :type nodeType: int

        """
        ...

    def feModifyColor(self, entityTYPE, entitySET, color, randomize) -> Any:
        """
        **Description:**
            Modifies the color of selected entities.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities to be modified. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE,\n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be modified. Alternatively, if you specify a negative value, this is simply the ID of the single entity to modify. \n
            **color:** The new color that you want to assign to the selected entities.\n
            **randomize:** Only valid for FT_PROP, FT_MATL, and FT_SURFACE. If True, then colors are randomized for the selected entities. The specified color is simply used as initialization for the randomization process.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type color: int

        :type randomize: bool

        """
        ...

    def feModifyColorMultiple(self, entityTYPE, entitySET, color, method, match_range, limit_to_groupSET) -> Any:
        """
        **Description:**
            Modifies the color of selected entities.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities to be modified. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_SOLID, FT_NODE, FT_ELEM, FT_MATL, or FT_PROP.\n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be modified. Alternatively, if you specify a negative value, this is simply the ID of the single entity to modify. \n
            **color:** The first color used when assigning colors. Other colors are assigned randomly based on this color.\n
            **method:** 0= Single Color for all entities, 1=Assign color based on entity ID, 2=Assign color based on entity Type, 3=Assign color based on inclusion in Groups\n
            **match_range:** Only used when method=1. IDs in bands of this range receive the same color. For example if matchRange=1000, then IDs 1000-1999 would all be the same color, as would 2000-2999, 3000-3999, ... . Set to 1 for fully random colors.\n
            **limit_to_groupSET:** Only used when method=3. The ID of a Set that contains the IDs of the Groups to consider when looking for entity inclusion. Set to 0 to consider all Groups.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type color: int

        :type method: int

        :type match_range: int

        :type limit_to_groupSET: int

        """
        ...

    def feModifyDefCSys(self, entityTYPE, entitySET, csysID) -> Any:
        """
        **Description:**
            Updates the definition coordinate system of selected entities.
        **Remarks/Usage:**
            None
        **Input:**
            **entitySET:** The ID of a set that contains a list of entity IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single entity to update. \n
            **csysID:** The ID of the coordinate system to use as the definition coordinate system.\n
        **Return Code:** True\n
        :type entitySET: int

        :type csysID: int

        """
        ...

    def feModifyEdit(self, entityTYPE, nEntityID) -> Any:
        """
        **Description:**
            Modifies an entity using the dialog box for the entity type available when editing via the User Interface.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities to be modified via entity specific dialog box. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_BOUNDARY, FT_CONNECTION_PROP, \n
            **nEntityID:** The ID of the entity to edit via the dialog box for that entity type available in User Interface\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type nEntityID: int

        """
        ...

    def feModifyElemOrder(self, entitySET, makeParabolic, ontoGeom, maxANGLE) -> Any:
        """
        **Description:**
            Updates the order of elements between linear and parabolic.
        **Remarks/Usage:**
            This method should only be used with elements that have both linear and parabolic types.
        **Input:**
            **entitySET:** The ID of a set that contains a list of element IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single element to update. \n
            **makeParabolic:** Set to True to convert elements to parabolic. Set to False to convert to linear elements. Midside nodes will be created when converting to parabolic.\n
            **ontoGeom:** If you are converting to parabolic, set to True to project the midside nodes onto any referenced geometry. Set to False to leave the nodes at the midside.\n
            **maxANGLE:** If you are projecting midside nodes onto geometry, this is the maximum angle that any edge can be distorted by the movement.\n
        **Return Code:** True\n
        :type entitySET: int

        :type makeParabolic: bool

        :type ontoGeom: bool

        :type maxANGLE: float

        """
        ...

    def feModifyElemPropID(self, entitySET, propID) -> Any:
        """
        **Description:**
            Updates the property ID of selected elements.
        **Remarks/Usage:**
            None
        **Input:**
            **propID:** The ID of the new property to assign to the elements. This property must be compatible with the element types chosen.\n
        **Return Code:** True\n
        :type propID: int

        """
        ...

    def feModifyElemRelease(self, entitySET, rel1, rel2) -> Any:
        """
        **Description:**
            Updates the releases at the ends at the ends of beam (and other) elements.
        **Remarks/Usage:**
            This method should only be used with beam or bar elements.
        **Input:**
            **entitySET:** The ID of a set that contains a list of element IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single element to update. \n
            **rel1:** The release flags for End 1 of the element. Specify True to release a corresponding elemental degree of freedom.\n
            **rel2:** The release flags for End 2 of the element. Specify True to release a corresponding elemental degree of freedom.\n
        **Return Code:** True\n
        :type entitySET: int

        :type rel1: tuple[bool]

        :type rel2: tuple[bool]

        """
        ...

    def feModifyElemReverse(self, entitySET, method, vecDIR) -> Any:
        """
        **Description:**
            Reverses the normal of planar elements, or optionally spins them to orient the first edge along a vector. This method is obsolete - feModifyElemReverse2( ) provides additional functionality.
        **Remarks/Usage:**
            This method should only be used with planar elements.
        **Input:**
            **entitySET:** The ID of a set that contains a list of element IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single element to update. \n
            **method:** The method for updating the elements: 0=Reverse, 1=Normals Outward, 2=Normals Inward, 3=Align to Vector.\n
            **vecDIR:** The vector to be used for aligning the first edge of the elements if method=3.\n
        **Return Code:** True\n
        :type entitySET: int

        :type method: int

        :type vecDIR: tuple[float]

        """
        ...

    def feModifyElemReverse2(self, entitySET, method, vecDIR, csysID, csysDir, bPreserveMatlDir) -> Any:
        """
        **Description:**
            Reverses the normal of planar elements, or optionally spins them to orient the first edge along a vector.
        **Remarks/Usage:**
            This method should only be used with planar elements.
        **Input:**
            **entitySET:** The ID of a set that contains a list of element IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single element to update. \n
            **method:** The method for updating the elements: 0=Reverse, 1=Normals Outward, 2=Normals Inward, 3=Align to Vector, 4=Align to CSys Direction.\n
            **vecDIR:** The vector to be used for aligning the first edge of the elements if method=3.\n
            **csysID:** ID of Coordinate System to use if method=4\n
            **csysDir:** Coordinate system axis to use to align first edge if method=4. This must have values 1=X (or R), 2=Y (or theta), 3=Z (or phi). You can also specify -1,-2, or -3 to choose the negative coordinate system direction.\n
            **bPreserveMatlDir:** Set to True to preserve the material direction of the elements being reversed or reoriented. Set to False to update the material direction of elements being reversed or reoriented.\n
        **Return Code:** True\n
        :type entitySET: int

        :type method: int

        :type vecDIR: tuple[float]

        :type csysID: int

        :type csysDir: int

        :type bPreserveMatlDir: bool

        """
        ...

    def feModifyElemType(self, entitySET, propID, method, NodeID, orVec) -> Any:
        """
        **Description:**
            Modifies the element type of elements.
        **Remarks/Usage:**
            This method will only work to change elements from one type to another if the element shapes are compatible.
        **Input:**
            **entitySET:** The ID of a set that contains a list of element IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single element to update. \n
            **propID:** The ID of the new property to assign to the elements. The element type is changed to match the type of the property.\n
            **method:** Defines the method used for updating the orientation: 0=Orient with third node, 1=Orient with Vector. This parameter is only used if you are modifying line elements with no orientation to a type that requires orientation.\n
            **NodeID:** The ID of the node to use as a third node for orientation - only used if method=0. This parameter is only used if you are modifying line elements with no orientation to a type that requires orientation.\n
        **Return Code:** True\n
        :type entitySET: int

        :type propID: int

        :type method: int

        :type NodeID: int

        """
        ...

    def feModifyFormulation(self, elemSET, form1, form2) -> Any:
        """
        **Description:**
            Updates the element formulation for selected elements.
        **Remarks/Usage:**
            None
        **Input:**
            **elemSET:** The ID of a set that contains a list of element IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single element to update. \n
            **form1, form2:** The formulation values.\n
        **Return Code:** True\n
        :type elemSET: int

        :type form1: int

        :type form2: int

        """
        ...

    def feModifyLayer(self, entityTYPE, entitySET, layer) -> Any:
        """
        **Description:**
            Modifies the layer of selected entities.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities to be modified. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE,\n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be modified. Alternatively, if you specify a negative value, this is simply the ID of the single entity to modify. \n
            **layer:** The new layer that you want to assign to the selected entities.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type layer: int

        """
        ...

    def feModifyLineElementDirection(self, elemSET, reverseMode, nAlignToElemID, AlignToVector) -> Any:
        """
        **Description:**
            Modifies line element directions.
        **Remarks/Usage:**
            This method can only be used with line elements.
        **Input:**
            **elemSET:** The ID of a set that contains a list of element IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single element to update. \n
            **reverseMode:** Specifies whether to reverse direction, align to element, or align to vector.\n
            **nAlignToElemID:** The ID of the element to align direction to.\n
            **AlignToVector:** A variant with the vector direction from original to set the element directions to. \n
        **Return Code:** True\n
        :type elemSET: int

        :type reverseMode: Any

        :type nAlignToElemID: int

        :type AlignToVector: tuple[float]

        """
        ...

    def feModifyLoadPhase(self, entityTYPE, entitySET, phase) -> Any:
        """
        **Description:**
            Updates the phase of selected loads.
        **Remarks/Usage:**
            Only loads in the active load set will be updated. The selection/specification of entities refers to the entities where the loads are applied - not the loads themselves.
        **Input:**
            **entityTYPE:** The type of entities where the loads to be modified are applied. For entity information, see Section 3.3.6, "Entity Types". Can be FT_NODE, FT_ELEM, FT_POINT, FT_CURVE, or FT_SURFACE. This is the type of entity that is selected in entitySET.\n
            **entitySET:** The ID of a set that contains a list of entity IDs where the loads are applied. Alternatively, if you specify a negative value, this is simply the ID of the single entity with a load applied. \n
            **phase:** The new phase value.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type phase: float

        """
        ...

    def feModifyMaterialAngle(self, entitySET, method, vecDIR, coordDir, coordCsys, angle) -> Any:
        """
        **Description:**
            Updates the material angle of selected entities.
        **Remarks/Usage:**
            To turn material angles off for the selected elements, simply specify method=0.
        **Input:**
            **entitySET:** The ID of a set that contains a list of element IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single element to update. \n
            **method:** The method for specifying material angles: 0=None/Off, 1=Vector, 2=CoordSys, 3=Angle.\n
            **vecDIR:** The vector to be used for definition of material angles if method=1.\n
            **coordDir:** Sets the direction (0=X,1=Y,2=Z) in the specified coordinate system to be used for material angles. Only used if method=2.\n
            **coordCsys:** Sets the coordinate system ID to be used if method=2.\n
            **angle:** Sets the angle to be used for the definition of material angles when method=3.\n
        **Return Code:** True\n
        :type entitySET: int

        :type method: int

        :type vecDIR: tuple[float]

        :type coordDir: int

        :type coordCsys: int

        :type angle: float

        """
        ...

    def feModifyMidside(self, elemSET, nodeSET) -> Any:
        """
        **Description:**
            Updates the midside nodes of selected elements to be at the middle of the element edge.
        **Remarks/Usage:**
            None
        **Input:**
            **elemSET:** The ID of a set that contains a list of element IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single element to update. \n
            **nodeSET:** The ID of a set that contains a list of node IDs that will not be updated. All midside nodes on the elements in elemSET are normally updated. If you want to skip some nodes, include them in this set. Specify nodeSET=0 if you want to update all midside nodes.\n
        **Return Code:** True\n
        :type elemSET: int

        :type nodeSET: int

        """
        ...

    def feModifyNoMergeCurve(self, entitySET, bNoMerge) -> Any:
        """
        **Description:**
            Marks selected curves as mergeable or nonmergeable.
        **Remarks/Usage:**
            Only used with solid engine curves - not standard geometry engine curves.
        **Input:**
            **bNoMerge:** If True, curves are made nonmergeable. If False, they are mergeable.\n
        **Return Code:** True\n
        :type bNoMerge: bool

        """
        ...

    def feModifyOffsets(self, entitySET, endA, endB, radial, off1, off2) -> Any:
        """
        **Description:**
            Modifies the offsets of beam and bar elements.
        **Remarks/Usage:**
            This method can only be used with elements that have offsets: beams and bars.
        **Input:**
            **entitySET:** The ID of a set that contains a list of element IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single element to update. \n
            **endA:** If True, the offset at the first end of the element will be updated.\n
            **endB:** If True, the offset at the second end of the element will be updated.\n
            **radial:** If True, the offsets are radial, around a location, instead of being vector based.\n
            **off1:** If radial=True, these are the coordinates of the center location. If radial=False, then these are components of the vector offset at the first end of the element. In either case, the values are specified in global rectangular coordinates.\n
            **off2:** If radial=True, then offB[0] is the radial offset length, and the other offB values are not used. If radial=False, then offB contains the components of the vector offset at the second end of the element.\n
        **Return Code:** True\n
        :type entitySET: int

        :type endA: bool

        :type endB: bool

        :type radial: bool

        :type off1: tuple[float]

        :type off2: tuple[float]

        """
        ...

    def feModifyOffsetsToRefPt(self, entitySET) -> Any:
        """
        **Description:**
            Modifies the offsets of beam and bar elements so that the shape reference point is at the nodes.
        **Remarks/Usage:**
            This method can only be used with elements that have offsets: beams and bars. Likewise, it can only be used if the reference point on the property associated with the elements has been properly defined. Offsets for each element are redefined so that the reference point is moved to the nodal location.
        **Input:**
            **entitySET:** The ID of a set that contains a list of element IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single element to update. \n
        **Return Code:** True\n
        :type entitySET: int

        """
        ...

    def feModifyOrient(self, entitySET, method, NodeID, orVec) -> Any:
        """
        **Description:**
            Modifies the orientation of line elements.
        **Remarks/Usage:**
            This method can only be used with elements that have orientations. Method=4 can be used to orient elements in a radial direction by specifying any type of coordinate system. Method=5 should only be used to specify an Orientation Coordinate System for Spring/Damper elements referencing a CBUSH Property or Spring/Damper to Ground elements.
        **Input:**
            **entitySET:** The ID of a set that contains a list of element IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single element to update. \n
            **method:** Defines the method used for updating the orientation: 0=Orient with third node, 1=Orient with Vector defined in Global Rectangular Coordinates, -1= Orient with Vector defined in Coordinate System specified for nNodeOrCSysID, 2=Convert existing orientation to equivalent vectors, 3=Make existing orientation perpendicular to elements, 4=Orient Radially with regard to Coordinate System specified for nNodeOrCSysID, 5=Orient by applying Orientation Coordinate System specified for nNodeOrCSysID\n
            **NodeID:** If method=0, ID of the node to use as a third node for orientation. \n
        **Return Code:** True\n
        :type entitySET: int

        :type method: int

        :type NodeID: int

        """
        ...

    def feModifyOutCSys(self, entityTYPE, entitySET, ssysID) -> Any:
        """
        **Description:**
            Updates the output coordinate system of selected entities.
        **Remarks/Usage:**
            None
        **Input:**
            **entitySET:** The ID of a set that contains a list of entity IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single entity to update. \n
            **ssysID:** The ID of the coordinate system to use as the output coordinate system.\n
        **Return Code:** True\n
        :type entitySET: int

        :type ssysID: int

        """
        ...

    def feModifyPermBC(self, entitySET, t1, t2, t3, r1, r2, r3) -> Any:
        """
        **Description:**
            Updates the permanent constraints on nodes.
        **Remarks/Usage:**
            None
        **Input:**
            **entitySET:** The ID of a set that contains a list of node IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single node to update.\n
            **t1, t2, t3, r1, r2, r3:** Corresponds to the six degrees of freedom of each node. If True, the associated degree of freedom is constrained.\n

        **Return Code:** True\n
        :type entitySET: int
        :type t1: bool

        :type t2: bool

        :type t3: bool

        :type r1: bool

        :type r2: bool

        :type r3: bool

        """
        ...

    def feModifyPlateThickOffsetBetweenNodes(self, nSetID, enUpdating, nFromNode, dFromValue, nToNode, dToValue,
                                             bAverageForElement, dTolerance, dMinValue, dMaxValue) -> Any:
        """
        **Description:**
            Modifies the Element Thickness, Property Thickness, or Element Offset of the specified elements by varying the thickness or offset from the value specified at one node (From Node) to the value specified at another node (To Node). This method provides programmatic access to functionality of the Modify, Update Elements, Adjust Plate Thickness/Offsetcommand when Methodis set to Vary Between Nodes.
        **Remarks/Usage:**
            When nUpdating is set to FPTO_PROP_THICKNESS, additional properties will be created, as that is the only way new thickness values can be assigned to the elements by property. Also, FPTO_ELEM_THICKNESS should only be used when creating a model for Nastran or another solver which supports thickness overrides of property values at element corners.
        **Return Code:** True\n
        """
        ...

    def feModifyPlateThickOffsetEquation(self, nSetID, enUpdating, enMethod, sNodeElemVariable, sEquation,
                                         bAverageForElement, dTolerance, dMinValue, dMaxValue) -> Any:
        """
        **Description:**
            Modifies the Element Thickness, Property Thickness, or Element Offset of the specified elements by varying the thickness or offset using a specified method. This method provides programmatic access to functionality of the Modify, Update Elements, Adjust Plate Thickness/Offsetcommand when Methodis set to Equation or Constant, but is specifically designed to work with equations. To use the Equation capabilities, see Section 3.10.8.19, "feModifyPlateThickOffsetValue".
        **Remarks/Usage:**
            Typically, the FEMAP Functions used for equations this command are:
        **Input:**
            **nSetID:** The ID of a set that contains a list of element IDs that will have the thickness or offset modified \n
            **enUpdating:** Specifies what is being modified.\n
            **enMethod:** Specifies the modification method which evaluates the equation.\n
            **sNodeElemVariable:** String that contains the name of the variable used for Nodes if updating thickness or Elements if updating offsets. Typically set to i, as it is in the dialog box of the command in the user interface\n
            **sEquation:** String that contains the equation, which typically would contain references to node or element locations and use the value specified for sNodeElemVariable. See Remarks.\n
            **bAverageForElement:** Only used when nUpdating is set to FPTO_ELEM_THICKNESS or FPTO_PROP_THICKNESS. When True, applies a single thickness value to an element, based on the average of the thickness values at the elements corners. When False, the corner values are used directly, creating an element with a variable thickness. See Remarks.\n
            **dTolerance:** Tolerance used to aggregate or round computed values\n
            **dMinValue:** Specifies the minimum value. Anything lower will be assigned this value. Set to 0.0 for no limit.\n
            **dMaxValue:** Specifies the maximum value. Anything higher will be assigned this value. Set to 0.0 for no limit.\n
        **Return Code:** True\n
        :type nSetID: int

        :type enUpdating: Any

        :type enMethod: Any

        :type sNodeElemVariable: str

        :type sEquation: str

        :type bAverageForElement: bool

        :type dTolerance: float

        :type dMinValue: float

        :type dMaxValue: float

        """
        ...

    def feModifyPlateThickOffsetReset(self, nSetID, bResetElementThickness, bResetElementOffset) -> Any:
        """
        **Description:**
            Resets the Element Thickness and/or Element Offset of the specified elements. This method provides programmatic access to functionality of the Reset Element Thicknessand Reset Element Offsetbuttons of the Modify, Update Elements, Adjust Plate Thickness/Offset command
        **Remarks/Usage:**
            This command cannot remove any thickness values for plate elements specified on Properties. It is only removing the thickness values specified for elements which override the property thickness values.
        **Input:**
            **nSetID:** The ID of a set that contains a list of element IDs that will have the element thickness and/or offset reset.\n
            **bResetElementThickness:** When True, resets the element thickness property overrides for the specified elements. When False, does nothing.\n
            **bResetElementOffset:** When True, resets the element offsets for the specified elements. When False, does nothing.\n
        **Return Code:** False\n
        :type nSetID: int

        :type bResetElementThickness: bool

        :type bResetElementOffset: bool

        """
        ...

    def feModifyPlateThickOffsetValue(self, nSetID, enUpdating, enMethod, dValue, bAverageForElement, dTolerance,
                                      dMinValue, dMaxValue) -> Any:
        """
        **Description:**
            Modifies the Element Thickness, Property Thickness, or Element Offset of the specified elements by varying the thickness or offset using a specified method. This method provides programmatic access to functionality of the Modify, Update Elements, Adjust Plate Thickness/Offsetcommand when Methodis set to Equation or Constant, but is specifically designed to work with constants. To use the Equation capabilities, see Section 3.10.8.20, "feModifyPlateThickOffsetEquation"
        **Remarks/Usage:**
            When nUpdating is set to FPTO_PROP_THICKNESS, additional properties will be created, as that is the only way new thickness values can be assigned to the elements by property. Also, FPTO_ELEM_THICKNESS should only be used when creating a model for Nastran or another solver which supports thickness overrides of property values at element corners.
        **Input:**
            **nSetID:** The ID of a set that contains a list of element IDs that will have the thickness or offset modified \n
            **enUpdating:** Specifies what is being modified.\n
            **enMethod:** Specifies the modification method.\n
            **dValue:** Value used when nMethod is set to FPTM_SETTOVALUE, FPTM_INCREMENT, or FPTM_ADJUSTPCT\n
            **bAverageForElement:** Only used when nUpdating is set to FPTO_ELEM_THICKNESS or FPTO_PROP_THICKNESS. When True, applies a single thickness value to an element, based on the average of the thickness values at the elements corners. When False, the corner values are used directly, creating an element with a variable thickness. See Remarks.\n
            **dTolerance:** Tolerance used to aggregate or round computed values\n
            **dMinValue:** Specifies the minimum value. Anything lower will be assigned this value. Set to 0.0 for no limit.\n
            **dMaxValue:** Specifies the maximum value. Anything higher will be assigned this value. Set to 0.0 for no limit.\n
        **Return Code:** True\n
        :type nSetID: int

        :type enUpdating: Any

        :type enMethod: Any

        :type dValue: float

        :type bAverageForElement: bool

        :type dTolerance: float

        :type dMinValue: float

        :type dMaxValue: float

        """
        ...

    def feModifyPropMatlID(self, entitySET, matlID) -> Any:
        """
        **Description:**
            Updates the material ID of selected properties.
        **Remarks/Usage:**
            This method only updates the primary material identifier. Laminate properties cannot be updated using this method.
        **Input:**
            **matlID:** The ID of the new material to assign to the properties.\n
        **Return Code:** True\n
        :type matlID: int

        """
        ...

    def feModifyRadialOffsets(self, entitySET, bAroundVector, dRadialOffset, orig, Axis) -> Any:
        """
        :type entitySET: Any
        :type bAroundVector: Any
        :type dRadialOffset: Any
        :type orig: Any
        :type Axis: Any
        """
        ...

    def feModifyReverseCurve(self, entitySET) -> Any:
        """
        **Description:**
            Reverses the direction of selected curves.
        **Remarks/Usage:**
            Only used with standard geometry engine curves - not solid engine curves.
        **Return Code:** True\n
        """
        ...

    def feModifySolidFacetting(self, entitySET, sDiv, tDiv, dAngleTol, dChordTol, dCurveFactor) -> Any:
        """
        **Description:**
            Updates the graphical divisions and facetting used to display solids.
        **Remarks/Usage:**
            None
        **Input:**
            **sDiv:** The number of divisions displayed along the first parametric direction of the surfaces of the solid.\n
            **tDiv:** The number of divisions displayed along the second parametric direction of the surfaces of the solid.\n
            **dAngleTol:** The percent of angle error allowed between the solid and facets\n
            **dChordTol:** The percent of chord error allowed between the solid and facets\n
        **Return Code:** True\n
        :type sDiv: int

        :type tDiv: int

        :type dAngleTol: float

        :type dChordTol: float

        """
        ...

    def feModifySplineKnots(self, entitySET, knotLoc) -> Any:
        """
        **Description:**
            Insert knots into b-spline curves.
        **Remarks/Usage:**
            Only used with standard geometry engine b-splines - not solid engine curves.
        **Input:**
            **knotLoc:** The location, in global rectangular coordinates, of the knot to insert.\n
        **Return Code:** True\n
        :type knotLoc: tuple[float]

        """
        ...

    def feModifySplineOrder(self, entitySET, order) -> Any:
        """
        **Description:**
            Updates the order of b-spline curves.
        **Remarks/Usage:**
            Only used with standard geometry engine b-splines - not solid engine curves.
        **Input:**
            **order:** The new order of the b-spline curve. Must be a value between 3 and 10.\n
        **Return Code:** True\n
        :type order: int

        """
        ...

    def feModifySplitQuads(self, elemSET) -> Any:
        """
        **Description:**
            Splits quadrilateral elements into triangular elements.
        **Remarks/Usage:**
            The split direction is automatically chosen to get the best shaped triangles; no further input is required.
        **Input:**
            **elemSET:** The ID of a set that contains a list of element IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single element to update. \n
        **Return Code:** True\n
        :type elemSET: int

        """
        ...

    def feModifySuperelementID(self, entitySET, nSEID) -> Any:
        """
        **Description:**
            Updates the superelementID of a set of nodes.
        **Remarks/Usage:**
            None
        **Input:**
            **nSEID:** The superelementID to assign to the nodes.\n
        **Return Code:** True\n
        :type nSEID: int

        """
        ...

    def feModifySurfaceDivisions(self, entitySET, sDiv, tDiv, tolerance) -> Any:
        """
        **Description:**
            Updates the graphical divisions and facetting used to display surfaces.
        **Remarks/Usage:**
            None
        **Input:**
            **sDiv:** The number of divisions displayed along the first parametric direction of the surface.\n
            **tDiv:** The number of divisions displayed along the second parametric direction of the surface.\n
            **tolerance:** The accuracy with which the graphical facetting of solid geometry engine surfaces is created. Decreasing this number results in more facets and slower draw times, but a closer approximation to the actual geometry. Increasing the number speeds up draw times, but can lead to coarse approximations of the true geometry.\n
        **Return Code:** True\n
        :type sDiv: int

        :type tDiv: int

        :type tolerance: float

        """
        ...

    def feModifySurfaceNormal(self, entityTYPE, entitySET) -> Any:
        """
        **Description:**
            Reverses the normal direction of surfaces of Parasolid Sheet Solids. Only surfaces which are part of a Parasolid Sheet Solid have their normal direction reversed. Also, if only a subset of surfaces comprising a sheet solid are selected, ALL of the surfaces will be reversed, not just the selected surfaces.
        **Remarks/Usage:**
            It is important that no surfaces which are on a Parasolid Solid are included in the set of surfaces, otherwise the normal direction will not be reversed on any surfaces, not just the surfaces on the Solid(s).
        **Input:**
            **entitySET:** The ID of a set that contains a list of surface or solid (sheet solids only) IDs that will be updated. Alternatively, if you specify a negative value, this is simply the ID of the single surface or sheet solid to update. \n
        **Return Code:** True\n
        :type entitySET: int

        """
        ...

    def feModifyTransparency(self, entityTYPE, entitySET, transparency) -> Any:
        """
        **Description:**
            Modifies the transparency of selected entities.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities to be modified. For entity information, see Section 3.3.6, "Entity Types". Can be FT_SURFACE, FT_ELEM, FT_PROP, or FT_MATL\n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be modified. Alternatively, if you specify a negative value, this is simply the ID of the single entity to modify. \n
            **transparency:** The transparency value to assign. Must be between 0 (opaque) and 100 (fully transparent).\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type transparency: float

        """
        ...

    def feMoveBy(self, entityTYPE, entitySET, radial, Length, vecLoc) -> Any:
        """
        **Description:**
            Moves coordinate systems, points, curves, surfaces, solids, volumes, nodes, or elements along the specified vector, by the specified length. In addition, nodes and elements can optionally be moved radially.
        **Remarks/Usage:**
            You cannot move the global coordinate systems.You can move solid points or curves on a Parasolid surface or solid, general body, or sheet solid. When a solid point or curve is moved, any surface which references that point/curve will also be modified.
        **Input:**
            **entityTYPE:** The type of entities to be moved. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_CSYS, FT_SURFACE, FT_VOLUME, FT_SOLID, FT_NODE, or FT_ELEM. \n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be moved. Alternatively, if you specify a negative value, this is simply the ID of the single entity to move. \n
            **radial:** If True, entities will be moved radially from a central location. If False, they will be moved along a vector. Only nodes and elements can be moved radially.\n
            **Length:** The distance to move. If radial = False, this is the length the entities are moved along the specified vector.\n
            **vecLoc:** If radial=False, contains the components of the vector to move along, specified in global rectangular coordinates. If radial=True, specifies the coordinates of the center that you are moving around, also specified in global rectangular coordinates.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type radial: bool

        :type Length: float

        :type vecLoc: tuple[float]

        """
        ...

    def feMoveOffset(self, elemSET, method, Length, alongVEC) -> Any:
        """
        **Description:**
            Moves elements by offsetting them from their current location (normally used with planar elements).
        **Remarks/Usage:**
            None
        **Input:**
            **elemSET:** The ID of a set that contains a list of element IDs that will be offset. Alternatively, if you specify a negative value, this is simply the ID of the single entity to offset. \n
            **method:** The method of determining the offset direction: 0=Along alongVec, 1=along the element normal, 2=along the element normal with thickness corrections.\n
            **Length:** The distance to offset. If method=0, this length is multiplied by the length of the vector to get the total distance.\n
            **alongVEC:** Only used if method=0. Contains the components of the vector to move along, specified in global rectangular coordinates. \n
        **Return Code:** True\n
        :type elemSET: int

        :type method: int

        :type Length: float

        :type alongVEC: tuple[float]

        """
        ...

    def feMoveTo(self, entityTYPE, entitySET, x, y, z, doX, doY, doZ, inCsys, moveRef) -> Any:
        """
        **Description:**
            Moves nodes, points, or coordinate systems to a new location.
        **Remarks/Usage:**
            You cannot move the global coordinate systems.
        **Input:**
            **entityTYPE:** The type of entities to be moved. For entity information, see Section 3.3.6, "Entity Types". Can be FT_CSYS, FT_POINT or FT_NODE.\n
            **entitySET:** The ID of a set that contains a list of coordinate system, point, or node IDs that will be moved. Alternatively, if you specify a negative value, this is simply the ID of the single entity to move. \n
            **x:** The coordinates that you want to move to. Specified in the inCsys coordinate system.\n
            **y:** REAL8 z\n
            **z:** BOOL doX\n
            **doX:** If True, the corresponding coordinate direction (in inCsys) will be updated to the specified value. Only directions specified as True will be moved.\n
            **doY:** BOOL doZ\n
            **doZ:** INT4 inCsys\n
            **y:** The ID of the coordinate system where the update will take place.\n
            **moveRef:** Only used if entityTYPE=FT_CSYS. If True, then all entities that reference the coordinate systems being moved will also be updated as a rigid body.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type x: float

        :type y: float

        :type z: float

        :type doX: bool

        :type doY: bool

        :type doZ: bool

        :type y: int

        :type moveRef: bool

        """
        ...

    def feNodesBetweenNodes(self, ndID1, ndID2, elSetID, nNodes, nNodeList) -> Any:
        """
        **Description:**
            Returns a list of nodes, in order, between two specified nodes (i.e., a node path). Also, the path from Node 1 to Node 2 can be limited to only consider the edges of a subset of elements specified by the user.
        **Remarks/Usage:**
            Currently, only 2D and 3D elements are considered when attempting to determine a node path.
        **Input:**
            **ndID1:** ID of node at start of the node path\n
            **ndID2:** ID of node at end of the node path\n
            **elSetID:** ID of Set Object containing element IDs to potentially limit the node path\n
        **Output:**
            **nNodes:** The number of nodes in the node path, including the nodes specified for ndID1 and ndID2 (First and last values in nNodeList)\n
        **Return Code:** True\n
        :type ndID1: int

        :type ndID2: int

        :type elSetID: int

        :type nNodes: int

        """
        ...

    def feNotesGet(self, noteSET, notes) -> Any:
        """
        **Description:**
            This function retrieves the currently defined model notes.
        **Remarks/Usage:**
            This function automatically allocates/reallocates the string for the returned notes. Notes can contain multiple lines and will have carriage return (CR) and linefeed (LF) characters between the lines. It is the responsibility of the calling program to free the memory allocated to the returned string.
        **Input:**
            **noteSET:** 1 = Model Notes, 2 = Translation Text\n
        **Output:**
            **notes:** The string containing the notes.\n
        **Return Code:** True\n
        :type noteSET: int

        :type notes: str

        """
        ...

    def feNotesPut(self, noteSET, clear, notes) -> Any:
        """
        **Description:**
            This function updates the currently defined model notes.
        **Remarks/Usage:**
            If you want to create notes with multiple lines, you must add carriage return (CR) and linefeed (LF) characters between the lines. For example, from Basic, you could use:
        **Input:**
            **noteSET:** 1 = Model Notes, 2 = Translation Text\n
            **clear:** If True, any existing notes are deleted before these notes are added; otherwise, this function appends to the current notes.\n
            **notes:** The string containing the notes to add.\n
        **Return Code:** True\n
        :type noteSET: int

        :type clear: bool

        :type notes: str

        """
        ...

    def feOutputCalculate(self, outSET, dTYPE, entSET, title, IDvar, SETvar, formula) -> Any:
        """
        **Description:**
            Computes output values based on an equation that you provide.
        **Remarks/Usage:**
            None
        **Input:**
            **outSET:** The ID of the set that contains the output set IDs where the calculations will be performed.\n
            **dTYPE:** Specifies whether the calculation will create nodal or elemental data. (7=Nodal, 8=Elemental)\n
            **entSET:** The ID of the set that contains the nodes or elements where the output will be computed.\n
            **title:** The title of the output vectors to be created\n
            **IDvar:** The name of the variable used as the Node/Element ID in the formula that you specify.\n
            **SETvar:** The name of the variable used as the Output Set ID in the formula that you specify.\n
            **formula:** The equation used to calculate the results. This must be specified in standard FEMAP form, using the two variables defined in IDvar and CASEvar.\n
        **Return Code:** True\n
        :type outSET: int

        :type dTYPE: int

        :type entSET: int

        :type title: str

        :type IDvar: str

        :type SETvar: str

        :type formula: str

        """
        ...

    def feOutputCompareV2(self, bList, bFullCase, fromSET, toSETS, ifromVEC, itoVEC, dMaxDiff) -> Any:
        """
        **Description:**
            This method is used to compare output from individual vectors or entire output sets. This method replaces feOutputCompare. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            None
        **Input:**
            **bList:** Flag to list the output at individual nodes or elements which differ.\n
            **bFullCase:** Flag to compare all vectors in the output case.\n
            **fromSET:** The ID of a Output Set you with to compare. \n
            **toSETS:** The ID of Femap Set object containing the output sets you with to compare to. Alternatively, if you specify a negative value, this is simply the ID of a single output case. \n
            **ifromVEC:** If not comparing the full output case then set ifromVEC to compare a specific output vector id in the fromSET.\n
            **itoVEC:** If not comparing the full output case then set itoVEC to compare a specific output vector id in the toSETS.\n
            **dMaxDiff:** Value specifying the maximum value used to consider the output different.\n
        **Return Code:** False\n
        :type bList: bool

        :type bFullCase: bool

        :type fromSET: int

        :type toSETS: int

        :type ifromVEC: int

        :type itoVEC: int

        :type dMaxDiff: float

        """
        ...

    def feOutputConvertV2019VectorIDToV2020V2(self, v2019VecID) -> Any:
        """
        **Description:**
            Some Output Vector IDs changed between FEMAP version 2019.1 and 2020.1. This method takes a vector ID from versions prior to 2020.1and returns the equivalent vector ID in version 2020.1. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            None
        **Input:**
            **v2019VecID:** The vector ID from versions prior to 2020.1 to be converted.\n
        **Return Code:** True\n
        :type v2019VecID: int

        """
        ...

    def feOutputConvertV2020VectorIDToV2019V2(self, v2020VecID) -> Any:
        """
        **Description:**
            Some Output Vector IDs changed between FEMAP version 2019.1 and 2020.1. This method takes a vector ID from versions 2020.1 and later and returns the equivalent vector ID in version 2019.1 and prior. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            None
        **Input:**
            **v2020VecID:** The vector ID from versions 2020.1 and later to be converted.\n
        **Return Code:** True\n
        :type v2020VecID: int

        """
        ...

    def feOutputConvertV92VectorIDV2(self, oldVecID) -> Any:
        """
        **Description:**
            Some Output Vector IDs changed between FEMAP v9.2 and v9.3. This method takes a v9.2 (and before) vector ID and returns the equivalent v9.3 vector ID. This method replaces feOutputConvertV92VectorIDV2. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            None
        **Input:**
            **oldVecID:** The v9.2 (and before) vector ID that you want to convert.\n
        **Return Code:** True\n
        :type oldVecID: int

        """
        ...

    def feOutputForceBalance(self, outSETS, boundarynodeSET, boundaryelemSET, csysID, aroundXYZ, numSETS,
                             resultant) -> Any:
        """
        **Description:**
            This method is obsolete. For new applications, use freebody objects and the CalculateSummation2 method.
        **Remarks/Usage:**
            ***This method will NOT work with attached output. Please use feOutputForceBalance2 instead. Also, this method requires that all selected output sets contain Nastran Grid Point Force Balance results.
        **Input:**
            **outSETS:** The ID of a Set object that contains the output sets to process. Alternatively, if you specify a negative value, this is simply the ID of the single output set to use.\n
            **boundarynodeSET:** The ID of a Set object that contains the nodes on the model interface where the force balance will be computed. Alternatively, if you specify a negative value, this is simply the ID of a single node. \n
            **boundaryelemSET:** The ID of a Set object that contains the elements on the model interface where the force balance will be computed. Alternatively, if you specify a negative value, this is simply the ID of a single element. \n
            **csysID:** The ID of the coordinate system to use. The coordinates in aroundXYZ must be specified in this coordinate system, and all results are returned in this coordinate system\n
            **aroundXYZ:** The coordinates of the location where the resulting force/moment are computed\n
        **Output:**
            **numSETS:** The numbef of output set results contained in resultant\n
        **Return Code:** True\n
        :type outSETS: int

        :type boundarynodeSET: int

        :type boundaryelemSET: int

        :type csysID: int

        :type aroundXYZ: tuple[float]

        :type numSETS: int

        """
        ...

    def feOutputForceBalance2(self, freebodyID, outSetID, toDataTable, printSummation, printDetails) -> Any:
        """
        **Description:**
            Outputs freebody data to the message window or the data table. To retrieve the calculated total summation load programmatically, see the CalculateSummation2() method of feFreebody.
        **Remarks/Usage:**

        **Input:**
            **freebodyID:** Freebody ID\n
            **outSetID:** Output Set ID \n
            **toDataTable:** If TRUE, output is sent to the data table; otherwise it is sent to the message window \n
            **printSummation:** When TRUE, data related to the freebody summation is printed, otherwise raw grid point force balance data for all nodes in the freebody will be output\n
            **printDetails:** If printSummation is TRUE, details regarding the force balance calculations will be output; ignored when printSummation is FALSE.\n
        **Return Code:** True\n
        :type freebodyID: int

        :type outSetID: int

        :type toDataTable: bool

        :type printSummation: bool

        :type printDetails: bool

        """
        ...

    def feOutputFromLoad(self, SetID, loadType) -> Any:
        """
        **Description:**
            Creates output from existing load information.
        **Remarks/Usage:**
            None
        **Input:**
            **SetID:** The ID of a set that contains a list of node or elements IDs that will be checked for loads to create the output. Alternatively, if you specify 0, all nodes/elements will be checked.\n
            **loadType:** The type of load to check to create output: Force=16, Displacement=32, Velocity=2048, Acceleration=64, Nodal Temperature=4096, Nodal HeatGen=2, Nodal Heat Flux=4, Elem Distributed Load=128, Pressure=256, Elem Temperature=8192, Elem Heat Gen 512, Elem Heat Flux=1024, Elem Convection=16384, Elem Radiation=32768, Fluid Pressure=131072, Fluid Tracking=262144, Fluid Fan Curve=2097152.\n
        **Return Code:** True\n
        :type SetID: int

        :type loadType: int

        """
        ...

    def feOutputGlobalPlyV2(self, nSetSet, nVectorSet, nGlobalPlySET, bTop, bBottom, bGlobalPly) -> Any:
        """
        **Description:**
            This method is used to create Top, Bottom, and/or Global Ply results in the selected output vectors in the specified output set. This method replaces feOutputGlobalPly. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            Performs the same operation as running the Model, Output, Global Ply command
        **Input:**
            **nSetSet:** The ID of a Set object that contains the Output Sets to process. Alternatively, if you specify a negative number it is the ID of a single Output Set to process. You can also specify this value as zero to process all available Output Sets.\n
            **nVectorSet:** The ID of a Set object that contains the Output Vectors to process. Alternatively, if you specify a negative number it is the ID of a single Output Vector to process. You can also specify this value as zero to process all available Output Vectors. The IDs specified here should be the IDs of existing Laminate results. You should only specify the ID from one ply for each output type.\n
            **nGlobalPlySET:** The ID of a Set object that contains the Global Plies to process. Alternatively, if you specify a negative number it is the ID of a single Global Ply to process. You can also specify this value as zero to process all available Global Plies.\n
            **bTop:** If True, results for the Top ply across all laminates are computed and stored.\n
            **bBottom:** If True, results for the Bottom ply across all laminates are computed and stored.\n
            **bGlobalPly:** If True, results for the selected Global Plys across all laminates are computed and stored.\n
        **Return Code:** True\n
        :type nSetSet: int

        :type nVectorSet: int

        :type nGlobalPlySET: int

        :type bTop: bool

        :type bBottom: bool

        :type bGlobalPly: bool

        """
        ...

    def feOutputProcessConvertV2(self, approach, from_setID, from_vectorID, to_setID, to_vectorID, groupID) -> Any:
        """
        **Description:**
            Allows you to Convert a single output vector between nodal and elemental locations. This method replaces feOutputProcessConvert. For more information see, Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            None
        **Input:**
            **approach:** 0=Avg, 1=Max\n
            **from_setID:** The ID of the output set to process.\n
            **to_setID:** Not Used\n
            **to_vectorID:** Not Used\n
            **groupID:** The ID of the group used to restrict output processing. If 0, all available output, on the full model is processed.\n
        **Return Code:** True\n
        :type approach: int

        :type from_setID: int

        :type to_setID: int

        :type to_vectorID: int

        :type groupID: int

        """
        ...

    def feOutputProcessCopyV2(self, bFullSet, from_setID, from_vectorID, to_setID) -> Any:
        """
        **Description:**
            Allows you to Copy a single output set or vector. This method replaces feOutputProcessCopy. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            None
        **Input:**
            **bFullSet:** Set to True if the operation will process entire sets of output, or False if individual vectors are to be processed. If True, from_vectorID and to_setID are ignored.\n
            **from_setID:** The ID of the output set to process.\n
            **to_setID:** The ID of the Set to contain the resulting copy. If 0, a new Output Set will be created.\n
        **Return Code:** True\n
        :type bFullSet: bool

        :type from_setID: int

        :type to_setID: int

        """
        ...

    def feOutputProcessEnvelopeFromSetsV2(self, bFullSet, ntype, nApproach, bEnvelopeInSets, bEnvelopeAcrossSets,
                                          bSetInfo, nSetSet, nVectorSet, to_setID) -> Any:
        """
        **Description:**
            Envelopes results in one or more Output Sets or Vectors to find worst-case scenarios specified via a set of Output Sets and optionally a set of Output Vectors. This method replaces feOutputProcessEnvelopeFromSets. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            Provides a streamlined method of entering multiple output sets and/or output vectors by using two Set objects. Especially useful when using the feSelectOutputV2/feSelectOutput2V2 (Section 3.15.4.2, "feSelectOutputV2"/Section 3.15.4.3, "feSelectOutput2V2") or feOutputSelectSets/feOutputSelectSets2 (Section 3.15.4.4, "feSelectOutputSets"/Section 3.15.4.5, "feSelectOutputSets2") entity selection methods for selecting the Output Set(s) and Output Vector(s).
        **Input:**
            **bFullSet:** Set to True if the operation will process entire sets of output, or False if individual vectors are to be processed. If True, from_vectorID and to_setID are ignored.\n
            **ntype:** The Type of envelope to create 0=Max, 1=Min, 2=Max Absolute Value.\n
            **nApproach:** 0=Envelope All Vectors in All Sets, 1=Envelope All Locations (like all Plys, all Stress Recovery Locations, ...), 2=Envelope Each Vector across All Sets. Ignored and always =2 if bFullSet is True.\n
            **bEnvelopeInSets:** If True, an Envelope is created and stored in the same set as the original results Ignored and always False if bFullSet=True or nApproach=2\n
            **bEnvelopeAcrossSets:** If True, results for similar vectors are enveloped across all of the selected sets. Ignored and always True if bFullSet=True or nApproach=2\n
            **bSetInfo:** If True extra output vectors are created which contain the ID of the set and possibly the location where the envelope value came from.\n
            **nSetSet:** The ID of a set that contains a list of Output Set IDs to use in the envelope. Alternatively, if you specify a negative value, this is simply the ID of the single Output Set to use.\n
            **nVectorSet:** The ID of a set that contains a list of Output Vector IDs to use in the envelope. Alternatively, if you specify a negative value, this is simply the ID of the single Output Vector to use.\n
            **to_setID:** The ID of the Set to contain the resulting combination. If 0, a new Output Set will be created. Ignored and always 0 if bFullSet=True or nApproach=2\n
        **Return Code:** True\n
        :type bFullSet: bool

        :type ntype: int

        :type nApproach: int

        :type bEnvelopeInSets: bool

        :type bEnvelopeAcrossSets: bool

        :type bSetInfo: bool

        :type nSetSet: int

        :type nVectorSet: int

        :type to_setID: int

        """
        ...

    def feOutputProcessEnvelopeV2(self, bFullSet, ntype, nApproach, bEnvelopeInSets, bEnvelopeAcrossSets, bSetInfo,
                                  nCount, from_setID, from_vectorID, to_setID) -> Any:
        """
        **Description:**
            Envelopes results in one or more Output Sets or Vectors to find worst-case scenarios. This method replaces feOutputProcessEnvelope. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            Provides more flexibility than feOutputProcessEnvelopeFromSets as different output vectors may be specified for each output set.
        **Input:**
            **bFullSet:** Set to True if the operation will process entire sets of output, or False if individual vectors are to be processed. If True, from_vectorID and to_setID are ignored.\n
            **ntype:** The Type of envelope to create 0=Max, 1=Min, 2=Max Absolute Value.\n
            **nApproach:** 0=Envelope All Vectors in All Sets, 1=Envelope All Locations (like all Plys, all Stress Recovery Locations, ...), 2=Envelope Each Vector across All Sets. Ignored and always =2 if bFullSet is True.\n
            **bEnvelopeInSets:** If True, an Envelope is created and stored in the same set as the original results Ignored and always False if bFullSet=True or nApproach=2\n
            **bEnvelopeAcrossSets:** If True, results for similar vectors are enveloped across all of the selected sets. Ignored and always True if bFullSet=True or nApproach=2\n
            **bSetInfo:** If True extra output vectors are created which contain the ID of the set and possibly the location where the envelope value came from.\n
            **nCount:** The number of entries in from_setID and from_vectorID\n
            **from_setID:** The IDs of the output sets to process.\n
            **to_setID:** The ID of the Set to contain the resulting combination. If 0, a new Output Set will be created. Ignored and always 0 if bFullSet=True or nApproach=2\n
        **Return Code:** True\n
        :type bFullSet: bool

        :type ntype: int

        :type nApproach: int

        :type bEnvelopeInSets: bool

        :type bEnvelopeAcrossSets: bool

        :type bSetInfo: bool

        :type nCount: int

        :type from_setID: tuple[int]

        :type to_setID: int

        """
        ...

    def feOutputProcessErrorEstimateV2(self, nMethod, from_setID, from_vectorID, groupID) -> Any:
        """
        **Description:**
            Allows you to compute an Error Estimate of a single output vector. This method replaces feOutputProcessErrorEstimate. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            None
        **Input:**
            **nMethod:** 0=Max Diff, 1=Diff to Avg, 2=%Max Diff, 3=%Diff to Avg, 4=Norm% Max Diff, 5=Norm% Diff to Avg\n
            **from_setID:** The ID of the output set to process.\n
            **groupID:** The ID of the group used to restrict output processing. If 0, all available output, on the full model is processed.\n
        **Return Code:** True\n
        :type nMethod: int

        :type from_setID: int

        :type groupID: int

        """
        ...

    def feOutputProcessLinearCombinationV2(self, bFullSet, nApproach, nCount, dScaleFactor, from_setID, from_vectorID,
                                           to_setID) -> Any:
        """
        **Description:**
            Performs a linear combination, with a scale factor, of Output Sets or Vectors. This method replaces feOutputProcessLinearCombination. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            None
        **Input:**
            **bFullSet:** Set to True if the operation will process entire sets of output, or False if individual vectors are to be processed. If True, from_vectorID and to_setID are ignored.\n
            **nApproach:** 0=Combine All Vectors in All Sets, 1=Combine All Vectors in Each Set, 2=Combine Each Vector across All Sets. Ignored and always =2 if bFullSet is True.\n
            **nCount:** The number of entries in dScaleFactor, from_setID and from_vectorID\n
            **from_setID:** The IDs of the output sets to process.\n
            **to_setID:** The ID of the Set to contain the resulting combination. If 0, a new Output Set will be created.\n
        **Return Code:** True\n
        :type bFullSet: bool

        :type nApproach: int

        :type nCount: int

        :type from_setID: tuple[int]

        :type to_setID: int

        """
        ...

    def feOutputProcessMergeV2(self, bFullSet, bOverwrite, nCount, from_setID, from_vectorID, to_setID) -> Any:
        """
        **Description:**
            Allows you to Combine/Merge Output in Sets or Vectors. This method replaces feOutputProcessMerge. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            Each entry in from_setID and from_vectorID is used as a pair. For example from_setID[0] and from_vectorID[0] mean output in the vector from_vectorID[0] in from_setID[0].
        **Input:**
            **bFullSet:** Set to True if the operation will process entire sets of output, or False if individual vectors are to be processed. If True, from_vectorID and to_setID are ignored.\n
            **bOverwrite:** If True, existing Output will be overwritten. If False, output will only be merged onto nodes/elements that have no output.\n
            **nCount:** The number of entries in from_setID and from_vectorID\n
            **from_setID:** The IDs of the output sets to process.\n
            **to_setID:** The ID of the Set to contain the resulting copy. If 0, a new Output Set will be created. \n
        **Return Code:** True\n
        :type bFullSet: bool

        :type bOverwrite: bool

        :type nCount: int

        :type from_setID: tuple[int]

        :type to_setID: int

        """
        ...

    def feOutputProcessRSSCombinationV2(self, bFullSet, nApproach, nCount, dScaleFactor, from_setID, from_vectorID,
                                        to_setID) -> Any:
        """
        **Description:**
            Performs an RSS (root sum squared) combination, with a scale factor, of Output Sets or Vectors. This method replaces feOutputProcessRSSCombination. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            None
        **Input:**
            **bFullSet:** Set to True if the operation will process entire sets of output, or False if individual vectors are to be processed. If True, from_vectorID and to_setID are ignored.\n
            **nApproach:** 0=Combine All Vectors in All Sets, 1=Combine All Vectors in Each Set, 2=Combine Each Vector across All Sets. Ignored and always =2 if bFullSet is True.\n
            **nCount:** The number of entries in dScaleFactor, from_setID and from_vectorID\n
            **from_setID:** The IDs of the output sets to process.\n
            **to_setID:** The ID of the Set to contain the resulting combination. If 0, a new Output Set will be created.\n
        **Return Code:** True\n
        :type bFullSet: bool

        :type nApproach: int

        :type nCount: int

        :type from_setID: tuple[int]

        :type to_setID: int

        """
        ...

    def feOutputProcessV2(self, Count, full_set, processing_method, approach, from_setID, from_vectorID, to_setID,
                          to_vectorID, groupID, factor, overwrite, ply_summary, set_info) -> Any:
        """
        **Description:**
            Provides the functionality that is available through the Model, Output, Process command to copy, combine, envelope, or convert output. This method replaces feOutputProcess. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            Only combinations of options that are available in the Model, Output, Processcommand in FEMAP will correctly process information through the API.
        **Input:**
            **Count:** The number of processing operations; that is, the number of entries in the other arrays.\n
            **full_set:** Set to True if the operations will process entire sets of output, or False if individual vectors are to be processed. If True, from_vectorID and to_vectorID are ignored.\n
            **processing_method:** The type of processing to be done: 0=Copy, 1=Combine, 2=Linear, 3=RSS, 4=Convert, 5=Envelope, 6=Error Estimate.\n
            **approach:** Additional approach required by certain methods. If processing_method=5,Envelope then (0=Max, 1=Min, 2=Max Abs). If processing_method=6, Error Estimate then (0=Max Diff, 1=Diff to Avg, 2=%Max Diff, 3=%Diff to Avg, 4=Norm% Max Diff, 5=Norm% Diff to Avg). If processing_method=4, Convert then (0=Avg, 1=Max).\n
            **from_setID:** The ID of the output set to process.\n
            **to_setID:** The ID of the output set where processed data will be created.\n
            **to_vectorID:** The ID of the output vector where processed data will be created (not used if full_set=True).\n
            **groupID:** The ID of the group used to restrict output processing. If 0, all available output, on the full model is processed.\n
            **factor:** The scale factor for linear and RSS combinations. The Skip Belowvalue for Error Estimates.\n
            **overwrite:** Flag to overwrite existing output if you are combining output.\n
            **ply_summary:** For Envelope, if True, this will compute the ply summary information for laminate output.\n
            **set_info:** For Envelope, if True and doing full sets, this will compute the additional set summary information for the enveloped data.\n
        **Return Code:** True\n
        :type Count: int

        :type full_set: bool

        :type processing_method: int

        :type approach: tuple[int]

        :type from_setID: tuple[int]

        :type to_setID: tuple[int]

        :type to_vectorID: tuple[int]

        :type groupID: tuple[int]

        :type factor: tuple[float]

        :type overwrite: tuple[bool]

        :type ply_summary: tuple[bool]

        :type set_info: tuple[bool]

        """
        ...

    def feOutputTransform2V2(self, setSET, vecSET, nodeSET, elemSET, nodalMode, nodalCSysID, nodalGlobalComp, plateMode,
                             plateCSysID, plateDOF, plateVEC, plateAngle, solidMode, solidCSysID,
                             engrShearStrain) -> Any:
        """
        **Description:**
            Transforms existing output to another orientation. This function replaces feOutputTransform, which is obsolete and should no longer be used. This method replaces feOutputTransform. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            The Output Orientation can be set using the various Pref_Orient options. See Section 3.3.1.9, "File, Preferences - Geometry/Model tab" for a complete list of available output orientation options.
        **Input:**
            **setSET:** ID of set containing the IDs of output sets containing output vectors to transform. Alternatively, if you specify a negative value, this is simply the ID of the single output set.\n
            **vecSET:** ID of set containing the IDs of output vectors to transform. Alternatively, if you specify a negative value, this is simply the ID of the single output vector.\n
            **nodeSET:** ID of set containing the IDs of nodes to transform output. Alternatively, if you specify a negative value, this is simply the ID of the single node.\n
            **elemSET:** ID of set containing the IDs of elements to transform output. Alternatively, if you specify a negative value, this is simply the ID of the single element.\n
            **nodalMode:** Sets to transformation method for Nodal Output Vectors. This can only be set to FOD_NONE (no transformation of Nodal Output Vectors), FOD_VECTOR_TO_CSYS (Into CSys transformation method), or FOD_VECTOR_TO_NODE_OUTPUT_CSYS (Into Node Output CSys transformation method)\n
            **nodalCSysID:** ID of coordinate system used to transform nodal output vectors when nodalMode is set to FOD_VECTOR_TO_CSYS.\n
            **nodalGlobalComp:** When True, additional output vectors will be created representing the components used to generate the transformed output vector(s).\n
            **plateMode:** Sets to transformation method for Plate Forces, Stresses and Strains. This can only be set to FOD_NONE (no transformation of Plate Forces, Stresses and Strains), FOD_PLATE_TO_CSYS (Into CSys transformation method), FOD_PLATE_TO_MATL (Into Matl Direction transformation method), or FOD_PLATE_TO_VECTOR (Along Vector transformation method).\n
            **plateCSysID:** ID of coordinate system used to transform plate force, stress, and/or strain vectors when plateMode is set to FOD_PLATE_TO_CSYS.\n
            **plateDOF:** Indicates which axis of the coordinate system specified in plateCSysID will be used for transformation. 1=X axis, 2=Y axis, and 3=Z axis\n
            **plateVEC:** The XYZ components of the vector to use for transformation when plateMode is set to FOD_PLATE_TO_VECTOR\n
            **plateAngle:** Specifies value for Tolerance Angle\n
            **solidMode:** Sets to transformation method for Solid Stresses and Strains. This can only be set to FOD_NONE (no transformation of Solid Stresses and Strains), FOD_SOLID_TO_CSYS (Into CSys transformation method), or FOD_SOLID_TO_MATL (Into Matl Direction transformation method).\n
            **solidCSysID:** ID of coordinate system used to transform solid stress and/or strain vectors when solidMode is set to FOD_SOLID_TO_CSYS.\n
        **Return Code:** True\n
        :type setSET: int

        :type vecSET: int

        :type nodeSET: int

        :type elemSET: int

        :type nodalMode: Any

        :type nodalCSysID: int

        :type nodalGlobalComp: bool

        :type plateMode: Any

        :type plateCSysID: int

        :type plateDOF: int

        :type plateVEC: tuple[float]

        :type plateAngle: float

        :type solidMode: Any

        :type solidCSysID: int

        """
        ...

    def feOutputValueGetRGB(self, nViewID, dValue, pdRed, pdGreen, pdBlue) -> Any:
        """
        **Description:**
            Returns the red, green and blue components from a FEMAP color ID of specific output value on a contour legend.
        **Remarks/Usage:**
            None
        **Input:**
            **nViewID:** The ID of view. If set to 0 the active view will be used.\n
            **dValue:** The value of the output desired to get color level.\n
        **Output:**
            **pdRed:** Red component. Integer value 0-255\n
            **pdGreen:** Green component. Integer value 0-255\n
            **pdBlue:** Blue component. Integer value 0-255\n
        **Return Code:** False\n
        :type nViewID: int

        :type dValue: float

        :type pdRed: int

        :type pdGreen: int

        :type pdBlue: int

        """
        ...

    def fePlaneBisect(self, p1, p2, p3, planeBase, planeNormal, planeX) -> Any:
        """
        **Description:**
            Defines a plane that bisects the angle formed between three points.
        **Remarks/Usage:**
            The plane Y axis can be computed from a cross product of the normal and the X axis.
        **Input:**
            **p1:** The location at the origin of the two vectors to be bisected.\n
            **p2:** The end of the first vector (from p1) that will be used for the bisection.\n
            **p3:** The end of the second vector (from p1) that will be used for the bisection.\n
        **Return Code:** True\n
        :type p1: tuple[float]

        :type p2: tuple[float]

        :type p3: tuple[float]

        """
        ...

    def fePlaneCSys(self, p1, csysID, planeID, planeBase, planeNormal, planeX) -> Any:
        """
        **Description:**
            Defines a plane that is one of the principal planes of a coordinate system.
        **Remarks/Usage:**
            The plane Y axis can be computed from a cross product of the normal and the X axis.
        **Input:**
            **p1:** A location that will be the origin of the plane - specified in global coordinates.\n
            **csysID:** The ID of the coordinate system to use to define the plane. Specify as 0 for global coordinates.\n
            **planeID:** A number that selects the plane of the coordinate system to use: 0=Positive XY, 1=Positive, YZ, 2=Positive ZX, 3=Negative XY, 4=Negative, YZ, 5=Negative ZX.\n
        **Return Code:** True\n
        :type p1: tuple[float]

        :type csysID: int

        :type planeID: int

        """
        ...

    def fePlaneCurveNormal(self, cuID, planeBase, planeNormal, planeX) -> Any:
        """
        **Description:**
            Defines a plane that is normal to a curve.
        **Remarks/Usage:**
            The plane Y axis can be computed from a cross product of the normal and the X axis.
        **Input:**
            **cuID:** The ID of the curve used to determine the normal. The curve must be planar, and cannot be a line. This is usually used with arcs and circles to determine their plane.\n
        **Return Code:** True\n
        :type cuID: int

        """
        ...

    def fePlaneLocation(self, p1, p2, p3, planeBase, planeNormal, planeX) -> Any:
        """
        **Description:**
            Defines a plane by specifying the coordinates of three points on the plane.
        **Remarks/Usage:**
            The plane Y axis can be computed from a cross product of the Normal and the X axis.
        **Input:**
            **p1, p2, p3:** The coordinates of the points on the plane. The first point is the origin. The vector from the first to the second point is the X axis.\n
        **Output:**
            **planeBase:** The coordinates of a location on the plane, in global rectangular coordinates.\n
            **planeNormal:** The components of the vector that is normal to the plane\n
            **planeX:** The components of a vector along the plane X axis.\n
        **Return Code:** True\n
        :type p1: tuple[float]
        :type p2: tuple[float]
        :type p3: tuple[float]
        :type planeBase: tuple[float]
        :type planeNormal: tuple[float]
        :type planeX: tuple[float]

        """
        ...

    def fePlaneNodes(self, n1, n2, n3, planeBase, planeNormal, planeX) -> Any:
        """
        **Description:**
            Defines a plane by specifying the IDs of three nodes on the plane.
        **Remarks/Usage:**
            The plane Y axis can be computed from a cross product of the normal and the X axis.
        **Input:**
            **n1, n2, n3:** The IDs of the three nodes on the plane. The first point is the origin. The vector from the first to the second point is the X axis.\n
        **Output:**
            **planeBase:** The coordinates of a location on the plane, in global rectangular coordinates.\n
            **planeNormal:** The components of the vector that is normal to the plane.\n
            **planeX:** The components of a vector along the plane X axis.\n
        **Return Code:** True\n
        :type n1: int
        :type n2: int
        :type n3: int
        :type planeBase: tuple[float]
        :type planeNormal: tuple[float]
        :type planeX: tuple[float]

        """
        ...

    def fePlanePick(self, dlgTITLE, plBase, plNormal, plAxis) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to define a plane.
        **Remarks/Usage:**
            The plane Y axis can be computed from a cross product of the normal and the X axis.
        **Output:**
            **plBase:** The coordinates of a location on the plane, in global rectangular coordinates.\n
            **plNormal:** The components of the vector that is normal to the plane.\n
            **plAxis:** The components of a vector along the plane X axis.\n
        **Return Code:** True\n
        :type plBase: tuple[float]

        :type plNormal: tuple[float]

        :type plAxis: tuple[float]

        """
        ...

    def fePlanePickByMethod(self, method, dlgTITLE, plBase, plNormal, plAxis) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to define a plane. Same as fePlanePick except you can specify the initial dialog box method.
        **Remarks/Usage:**
            The plane Y axis can be computed from a cross product of the normal and the X axis.
        **Input:**
            **method:** The initial dialog box method. Refer to Plane Dialog Methods for possible values.\n
        **Output:**
            **plBase:** The coordinates of a location on the plane, in global rectangular coordinates.\n
            **plNormal:** The components of the vector that is normal to the plane.\n
            **plAxis:** The components of a vector along the plane X axis.\n
        **Return Code:** True\n
        :type method: int

        :type plBase: tuple[float]

        :type plNormal: tuple[float]

        :type plAxis: tuple[float]

        """
        ...

    def fePlanePoints(self, p1, p2, p3, planeBase, planeNormal, planeX) -> Any:
        """
        **Description:**
            Defines a plane by specifying the IDs of three points on the plane.
        **Remarks/Usage:**
            The plane Y axis can be computed from a cross product of the normal and the X axis.
        **Input:**
            **p1, p2, p3:** The IDs of the three points on the plane. The first point is the origin. The vector from the first to the second point is the X axis.\n
        **Output:**
            **planeBase:** 	The coordinates of a location on the plane, in global rectangular coordinates.\n
            **planeNormal:** The components of the vector that is normal to the plane.\n
            **planeX:** The components of a vector along the plane X axis.\n
        **Return Code:** True\n
        :type p1: int
        :type p2: int
        :type p3: int
        :type planeBase: tuple[float]
        :type planeNormal: tuple[float]
        :type planeX: tuple[float]

        """
        ...

    def fePlaneRotate(self, baseXYZ, vecXXYZ, vecZXYZ, angle, origin, Axis, baseROT, vecXROT, vecYROT, vecZROT) -> Any:
        """
        **Description:**
            This function returns three vectors computed from rotating the original plane around a given axis using the specified angle, in degrees
        **Remarks/Usage:**
            None
        **Return Code:** True\n
        """
        ...

    def fePlaneSurfaceNormal(self, surfID, ptID1, ptID2, reversed, align, offset, planeBase, planeNormal,
                             planeX) -> Any:
        """
        **Description:**
            Defines a plane that is normal to a surface.
        **Remarks/Usage:**
            The plane Y axis can be computed from a cross product of the normal and the X axis.
        **Input:**
            **surfID:** The ID of the surface used to define the normal.\n
            **ptID1:** The ID of a point that will define the origin of the plane\n
            **ptID2:** The ID of a point that will be used to define the X axis of the plane\n
            **reversed:** Set to True if you want the normal that is reversed from the surface normal.\n
            **align:** If True, the axis of the plane will be aligned to the surface axes.\n
            **offset:** The distance that the plane will be offset, along its normal vector, from the first point (origin).\n
        **Return Code:** True\n
        :type surfID: int

        :type ptID1: int

        :type ptID2: int

        :type reversed: bool

        :type align: bool

        :type offset: float

        """
        ...

    def fePlaneViewAlign(self, viewID, intoView, planeNormal, planeX) -> Any:
        """
        **Description:**
            Defines a plane that is normal to a view.
        **Remarks/Usage:**
            The plane Y axis can be computed from a cross product of the normal and the X axis.
        **Input:**
            **viewID:** The ID of a view.\n
            **intoView:** Determines whether the normal will be into or out of the screen.\n
        **Return Code:** True\n
        :type viewID: int

        :type intoView: bool

        """
        ...

    def feProjectAlongVector(self, entityTYPE, entitySET, surfaceSET, vecAlong) -> Any:
        """
        **Description:**
            Projects points or nodes along a vector onto selected surfaces
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities to be projected. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT or FT_NODE.\n
            **entitySET:** The ID of a set that contains a list of point or node IDs that will be projected. Alternatively, if you specify a negative value, this is simply the ID of the single entity to project. \n
            **surfaceSET:** The ID of a set that contains a list of surface IDs that the entities will be projected onto. Alternatively, if you specify a negative value, this is the ID of the single surface to project onto.\n
            **vecAlong:** The XYZ components of the vector to project along. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type surfaceSET: int

        :type vecAlong: tuple[float]

        """
        ...

    def feProjectOnto(self, entityTYPE, entitySET, projOnto, projAlong, ontoSET, vOntoLocation, vOntoVector,
                      vAlongVector, bExtendCurves, bVectorBothDirections) -> Any:
        """
        **Description:**
            Projects nodes or points onto a curve, surface, vector, or plane using either a closest/normal direction or along a specified vector. Additional options to Extend Curves and Project Both Directions are also available when using certain combinations of the available options.
        **Remarks/Usage:**
            This call is similar to using the Modify, Project, Pointor Modify, Project, Node command.
        **Input:**
            **entityTYPE:** The type of entities to be projected. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT or FT_NODE.\n
            **entitySET:** The ID of a set that contains a list of point or node IDs that will be projected. Alternatively, if you specify a negative value, this is simply the ID of the single entity to project. \n
            **projOnto:** Used to set the Project Onto option. 0=onto Curve (FPO_CURVE), 1=onto Surface (FPO_SURFACE), 2=onto Vector (FPO_VECTOR), or 3=onto Plane (FPO_PLANE)\n
            **projAlong:** Used to set the Project Along option. 0=use Closest/Normal (FPA_CLOSEST) or 1=along Vector (FPA_VECTOR)\n
            **ontoSET:** The ID of a set that contains a list of curve or surface IDs to project onto.\n
            **bExtendCurves:** Only used when projOnto = 0 (FPO_CURVE) and projAlong = 0 (FPA_CLOSEST). When True, the curve to project onto will be extended and the point or node will be projected onto the location closest to the Extended Curve (i.e., not actually on the curve itself). When False, the point or node will be projected onto the curve, many projecting onto one of the curves end points.\n
            **bVectorBothDirections:** Only used when projOnto = 1 (FPO_SURFACE) and projAlong = 1 (FPA_VECTOR). When True, the point(s) or node(s) will be projected in both directions along the specified vector. This allows points on both sides of a surface to be projected using a single specified vector. When False, the point(s) and node(s) will only be projected in the direction of the specified vector.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type projOnto: int

        :type projAlong: int

        :type ontoSET: int

        :type bExtendCurves: bool

        :type bVectorBothDirections: bool

        """
        ...

    def feProjectOntoCurve(self, entityTYPE, entitySET, curveID) -> Any:
        """
        **Description:**
            Projects nodes or points onto a curve.
        **Remarks/Usage:**
            Points/nodes are projected to the closest location on the curve, not along any specified vector.
        **Input:**
            **entityTYPE:** The type of entities to be projected. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT or FT_NODE.\n
            **entitySET:** The ID of a set that contains a list of point or node IDs that will be projected. Alternatively, if you specify a negative value, this is simply the ID of the single entity to project. \n
            **curveID:** The ID of the curve to project onto.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type curveID: int

        """
        ...

    def feProjectOntoPlane(self, entityTYPE, entitySET, planeLoc, planeNormal) -> Any:
        """
        **Description:**
            Projects points or nodes onto a plane
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities to be projected. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT or FT_NODE.\n
            **entitySET:** The ID of a set that contains a list of point or node IDs that will be projected. Alternatively, if you specify a negative value, this is simply the ID of the single entity to project. \n
            **planeLoc:** The XYZ location of the base of the plane to project onto. Must be specified in Global Rectangular coordinates.\n
            **planeNormal:** The XYZ components of the plane normal to project onto. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type planeLoc: tuple[float]

        :type planeNormal: tuple[float]

        """
        ...

    def feProjectOntoSolid(self, nodeSET, elemSET, solidID, surfCount, surfID) -> Any:
        """
        **Description:**
            Projects a mesh onto a solid.
        **Remarks/Usage:**
            A mesh can either be projected to a solid by specifying solidID, or to surfaces by specifying surfCount and surfID.
        **Input:**
            **nodeSET:** The ID of a set that contains a list of node IDs that will be projected. Alternatively, if you specify a negative value, this is simply the ID of the single entity to project. \n
            **elemSET:** The ID of a set that contains a list of element IDs that reference the nodes to be projected. Alternatively, if you specify a negative value, this is simply the ID of the single entity to project. These elements are used during the smoothing process as the nodes are projected.\n
            **solidID:** The ID of the solid to project onto. Must be 0 if you are going to specify surfaces.\n
            **surfCount:** The number of surfaces specified in surfID - only used if solidID=0.\n
            **surfID:** The IDs of the surfaces to project onto - only used if solidID=0 and surfCount is not 0.\n
        **Return Code:** True\n
        :type nodeSET: int

        :type elemSET: int

        :type solidID: int

        :type surfCount: int

        :type surfID: tuple[int]

        """
        ...

    def feProjectOntoSurface(self, entityTYPE, entitySET, surfaceID) -> Any:
        """
        **Description:**
            Projects nodes or points onto a surface.
        **Remarks/Usage:**
            Points/nodes are projected to the closest location on the surface, not along any specified vector.
        **Input:**
            **entityTYPE:** The type of entities to be projected. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT or FT_NODE.\n
            **entitySET:** The ID of a set that contains a list of point or node IDs that will be projected. Alternatively, if you specify a negative value, this is simply the ID of the single entity to project. \n
            **surfaceID:** The ID of the surface to project onto.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type surfaceID: int

        """
        ...

    def feProjectOntoVector(self, entityTYPE, entitySET, vecLoc, vecDIR) -> Any:
        """
        **Description:**
            Projects points or nodes onto a vector
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities to be projected. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT or FT_NODE.\n
            **entitySET:** The ID of a set that contains a list of point or node IDs that will be projected. Alternatively, if you specify a negative value, this is simply the ID of the single entity to project. \n
            **vecLoc:** The XYZ location of the base of the vector to project onto. Must be specified in Global Rectangular coordinates.\n
            **vecDIR:** The XYZ components of the vector to project onto. Must be specified in Global Rectangular coordinates.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type vecLoc: tuple[float]

        :type vecDIR: tuple[float]

        """
        ...

    def feRenumber(self, entityTYPE, entitySET, startID) -> Any:
        """
        **Description:**
            Renumbers the IDs of selected entities.
        **Remarks/Usage:**
            For more renumbering options, use feRenumberOpt( )
        **Input:**
            **entityTYPE:** The type of entities to be modified. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_VOLUME, FT_SOLID, FT_CSYS, FT_NODE, FT_ELEM, FT_MATL, FT_PROP, FT_LAYUP, FT_OUT_CASE, FT_GROUP, FT_LOAD_DIR, FT_BC_DIR, FT_AMGR_DIR, FT_LAYER, FT_CONNECTION_PROP, FT_CONTACT, FT_CONNECTION, and FT_FUNCTION_DIR.\n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be modified. Alternatively, if you specify a negative value, this is simply the ID of the single entity to modify. \n
            **startID:** The new ID of the first entity to be renumbered. All other entities will be renumbered to available IDs that are higher than this number.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type startID: int

        """
        ...

    def feRenumberOpt(self, entityTYPE, entitySET, startID, renumMethod, renumCSys, renumAbs, renumDescend,
                      renumConstOff) -> Any:
        """
        **Description:**
            Renumbers the IDs of selected entities. This method has been superseded by feRenumberOpt2.
        **Remarks/Usage:**
            This works just like feRenumber, but allows you to specify additional renumbering options. Use feRenumber for a simpler interface if you are simply renumbering by ID.
        **Input:**
            **entityTYPE:** The type of entities to be modified. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_VOLUME, FT_SOLID, FT_CSYS, FT_NODE, FT_ELEM, FT_MATL, FT_PROP, FT_LAYUP, FT_OUT_CASE, FT_GROUP, FT_LOAD_DIR, FT_BC_DIR, FT_AMGR_DIR, FT_LAYER, FT_CONNECTION_PROP, FT_CONTACT, FT_CONNECTION, and FT_FUNCTION_DIR.\n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be modified. Alternatively, if you specify a negative value, this is simply the ID of the single entity to modify. \n
            **startID:** The new ID of the first entity to be renumbered. All other entities will be renumbered to available IDs that are higher than this number.\n
            **renumMethod:** The method used for sorting the entities to be renumbered. 0=ID, 1=Not Available, 2=Color, 3=Layer, 4=X Coord, 5=Y Coord, 6=Z Coord, 7=Reference Entity ID (Material ID if renumbering properties, Property ID if renumbering Elements), 8=Entity Type, 9=Minimum Node ID\n
            **renumCSys:** The coordinate system ID in which coordinate renumbering is done. This is only used for the entityTYPEs where X,Y,Z sorting is available, and when renumMethod is set to one of those options\n
            **renumAbs:** If True, the absolute value of coordinate values are used when sorting by coordinates\n
            **renumConstOff:** If True, all entities are renumbered with a constant ID offset\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type startID: int

        :type renumMethod: int

        :type renumCSys: int

        :type renumAbs: bool

        :type renumConstOff: bool

        """
        ...

    def feRenumberOpt2(self, entityTYPE, entitySET, startID, renumMethod, renumCSys, renumAbs, renumDescend,
                       renumConstOff, xyzSortOrder) -> Any:
        """
        **Description:**
            Renumbers the IDs of selected entities. Supersedes feRenumberOpt
        **Remarks/Usage:**
            This works just like feRenumber, but allows you to specify additional renumbering options. Use feRenumber for a simpler interface if you are simply renumbering by ID.
        **Input:**
            **entityTYPE:** The type of entities to be modified. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_VOLUME, FT_SOLID, FT_CONNECTION_PROP, FT_CONTACT, FT_CONNECTION, FT_CSYS, FT_NODE, FT_ELEM, FT_MATL, FT_PROP, FT_LAYUP, FT_LOAD_DIR, FT_LOAD_DEFINITION, \n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be modified. Alternatively, if you specify a negative value, this is simply the ID of the single entity to modify. \n
            **startID:** The new ID of the first entity to be renumbered. All other entities will be renumbered to available IDs that are higher than this number.\n
            **renumMethod:** The method used for sorting the entities to be renumbered. 0=ID, 1=Not Available, 2=Color, 3=Layer, 4=X Coord, 5=Y Coord, 6=Z Coord, 7=Reference Entity ID (Material ID if renumbering properties, Property ID if renumbering Elements), 8=Entity Type, 9=Minimum Node ID, 10=Use XYZ Sort Order (zyzSortOrder)\n
            **renumCSys:** The coordinate system ID in which coordinate renumbering is done. This is only used for the entityTYPEs where X,Y,Z sorting is available, and when renumMethod is set to one of those options\n
            **renumAbs:** If True, the absolute value of coordinate values are used when sorting by coordinates\n
            **renumConstOff:** If True, all entities are renumbered with a constant ID offset\n
            **xyzSortOrder:** Specifies the XYZ sort order using 3 unique values. 0=None, 1=+X, 2=-X, 3=+Y, 4=-Y, 5=+Z, 6=-Z\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type startID: int

        :type renumMethod: int

        :type renumCSys: int

        :type renumAbs: bool

        :type renumConstOff: bool

        :type xyzSortOrder: tuple[int]

        """
        ...

    def feResetToolbar(self, BarName) -> Any:
        """
        **Description:**
            Resets a toolbar back to its original state
        **Remarks/Usage:**
            You can call this method to reset any changes you have made in the predefined FEMAP toolbars and menu back to their default configuration.
        **Input:**
            **BarName:** The title of the toolbar to be reset. If this is an empty string () then all toolbars will be reset.\n
        **Return Code:** True\n
        :type BarName: str

        """
        ...

    def feResultsRankingToDataTableV2(self, bOverrideLock, nRankByEntity, nMethod, nApproach, ntype, nNumberToRank,
                                      nEntitySetID, nResultsSetSetID, nResultsVectorSetID) -> Any:
        """
        **Description:**
            This function is used to send a list of entities (nodes, elements, elements referencing selected materials, or elements referencing selected properties) to the Data Table, ranked using selected output values in selected output sets. This method replaces feResultsRankingToDataTable. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            This function matches the functionality of the List, Output, Results Ranking to Data Tablecommand. It may be helpful to use the AddComponentOutputVectors (Section 4.6.2.36, "AddComponentOutputVectorsV2"), AddSimilarOutputVectors (Section 4.6.2.37, "AddSimilarOutputVectorsV2"), and/or AddComplexOutputVectors Section 4.6.2.38, "AddComplexOutputVectorsV2") methods on the Set Object to select all desired output vectors.
        **Input:**
            **bOverrideLock:** Flag to unlock Data Table, if currently locked. True will unlock, False will keep the Data Table locked and no data will be sent. Ignored if Data Table is currently unlocked.\n
            **nRankByEntity:** The type of entity to Rank By. For entity information, see Section 3.3.6, "Entity Types". Can be FT_NODE, FT_ELEM, FT_MATL, or FT_PROP.\n
            **nMethod:** Ranking Method. 0=Sets for Each Entity (FRKM_SETS), 1=Entities for Each Set (FRKM_ENTITY)\n
            **nApproach:** Ranking Approach. 0=All Vectors Together (FRKA_ALL), 1=Each Vector Independently (FRKA_EACH)\n
            **ntype:** Ranking Type. 0=Max Value (FRKT_MAX), 1=Min Value (FRKT_MIN), 2=Max Absolute Value (FRKT_MAXABS)\n
            **nNumberToRank:** Number to Rank. Must be between 1 and 99,999,999\n
            **nResultsSetSetID:** Set ID of set containing IDs of Output Sets to consider. Alternatively, if you specify a negative value, this is simply the ID of a single Output Set to consider. \n
            **nResultsVectorSetID:** Set ID of set containing IDs of Output Vectors used for ranking. Alternatively, if you specify a negative value, this is simply the ID of a single output vector used for ranking.\n
        **Return Code:** True\n
        :type bOverrideLock: bool

        :type nRankByEntity: int

        :type nMethod: int

        :type nApproach: int

        :type ntype: int

        :type nNumberToRank: int

        :type nResultsSetSetID: int

        :type nResultsVectorSetID: int

        """
        ...

    def feResultsToDataTable2V2(self, bOverrideLock, nViewForTransform, bSetInColumns, bVecInColumns, bEntInColumns,
                                bAltColumnOrder, bSummaryTable, nResultsSetSetID, nResultsVectorSetID,
                                nEntitySetID) -> Any:
        """
        **Description:**
            This function is used to list output on selected nodes or elements, from a selected view, for selected Output Vectors, in selected Output Sets to the Data Table. This method replaces feResultsToDataTable2. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above"
        **Remarks/Usage:**
            This function matches the functionality of the List, Output, Results to Data Tablecommand. It may be helpful to use the AddComponentOutputVectors (Section 4.6.2.36, "AddComponentOutputVectorsV2"), AddSimilarOutputVectors (Section 4.6.2.37, "AddSimilarOutputVectorsV2"), and/or AddComplexOutputVectors Section 4.6.2.38, "AddComplexOutputVectorsV2") methods on the Set Object to select all desired output vectors.
        **Input:**
            **bOverrideLock:** Flag to unlock Data Table, if currently locked. True will unlock, False will keep the Data Table locked and no data will be sent. Ignored if Data Table is currently unlocked.\n
            **nViewForTransform:** ID of the view to list transformed data from.\n
            **bSetInColumns:** When True, Output Set information will be listed in Columns. When False, Output Set information will be listed in Rows.\n
            **bVecInColumns:** When True, Output Vector information will be listed in Columns. When False, Output Vector information will be listed in Rows.\n
            **nEntitySetID:** When True, Node/Element information will be listed in Columns. When False, Node/Element information will be listed in Rows.\n
            **bAltColumnOrder:** When True, will list columns in alternating order. When False, will list columns in standard order\n
            **nEntitySetID:** When True, will list the summary table of the data selected.\n
            **nEntitySetID:** Set ID of set containing IDs of Output Sets to list to Data Table. Alternatively, if you specify a negative value, this is simply the ID of a single Output Set to list to Data Table. \n
            **nResultsSetSetID:** Set ID of set containing IDs of Output Vectors to list to Data Table. Alternatively, if you specify a negative value, this is simply the ID of a single output vector to list to Data Table. \n
            **nEntitySetID:** Set ID of set containing Node or Element IDs to list to Data Table Alternatively, if you specify a negative value, this is simply the ID of a single node or element to list to Data Table.\n
        **Return Code:** True\n
        :type bOverrideLock: bool

        :type nViewForTransform: int

        :type bSetInColumns: bool

        :type bVecInColumns: bool

        :type nEntitySetID: bool

        :type bAltColumnOrder: bool

        :type nEntitySetID: bool

        :type nEntitySetID: int

        :type nResultsSetSetID: int

        :type nEntitySetID: int

        """
        ...

    def feResultsToDataTableV2(self, bOverrideLock, nCSysID, bSetInColumns, bVecInColumns, bEntInColumns,
                               bAltColumnOrder, nResultsSetSetID, nResultsVectorSetID, nEntitySetID) -> Any:
        """
        **Description:**
            This function is used to list output on selected nodes or elements, for selected Output Vectors, in selected Output Sets to the Data Table. This method is obsolete and should no longer be used. It has been replaced with feResultsToDataTable2. This method replaces feResultsToDataTable. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            This function matches the functionality of the List, Output, Results to Data Tablecommand. It may be helpful to use the AddComponentOutputVectors (Section 4.6.2.36, "AddComponentOutputVectorsV2"), AddSimilarOutputVectors (Section 4.6.2.37, "AddSimilarOutputVectorsV2"), and/or AddComplexOutputVectors Section 4.6.2.38, "AddComplexOutputVectorsV2") methods on the Set Object to select all desired output vectors.
        **Input:**
            **bOverrideLock:** Flag to unlock Data Table, if currently locked. True will unlock, False will keep the Data Table locked and no data will be sent. Ignored if Data Table is currently unlocked.\n
            **nCSysID:** ID of coordinate system used to list Nodal Output. If set to -1, will use each nodes Nodal Output Coordinate System.\n
            **bSetInColumns:** When True, Output Set information will be listed in Columns. When False, Output Set information will be listed in Rows.\n
            **bVecInColumns:** When True, Output Vector information will be listed in Columns. When False, Output Vector information will be listed in Rows.\n
            **bEntInColumns:** When True, Node/Element information will be listed in Columns. When False, Node/Element information will be listed in Rows.\n
            **nResultsSetSetID:** Set ID of set containing IDs of Output Sets to list to Data Table. Alternatively, if you specify a negative value, this is simply the ID of a single Output Set to list to Data Table. \n
            **nResultsVectorSetID:** Set ID of set containing IDs of Output Vectors to list to Data Table. Alternatively, if you specify a negative value, this is simply the ID of a single output vector to list to Data Table. \n
            **nEntitySetID:** Set ID of set containing Node or Element IDs to list to Data Table Alternatively, if you specify a negative value, this is simply the ID of a single node or element to list to Data Table.\n
        **Return Code:** True\n
        :type bOverrideLock: bool

        :type nCSysID: int

        :type bSetInColumns: bool

        :type bVecInColumns: bool

        :type bEntInColumns: bool

        :type nResultsSetSetID: int

        :type nResultsVectorSetID: int

        :type nEntitySetID: int

        """
        ...

    def feRotateBy(self, entityTYPE, entitySET, axisLoc, axisVEC, angle, thrust) -> Any:
        """
        **Description:**
            Rotates entities around an axis through a specified angle.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities to be moved. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_CSYS, FT_SURFACE, FT_VOLUME, FT_SOLID, FT_NODE, or FT_ELEM. \n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be rotated. Alternatively, if you specify a negative value, this is simply the ID of the single entity to rotate. \n
            **axisLoc:** The coordinates of the origin of the axis of rotation, in global rectangular coordinates.\n
            **axisVEC:** The components of the axis of rotation, in global rectangular coordinates.\n
            **angle:** The angle of rotation, in degrees.\n
            **thrust:** The total thrust distance (along the axis of rotation), typically zero.\n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type axisLoc: tuple[float]

        :type axisVEC: tuple[float]

        :type angle: float

        :type thrust: float

        """
        ...

    def feRotateTo(self, entityTYPE, entitySET, axisLoc, axisVEC, fromLoc, toLoc) -> Any:
        """
        **Description:**
            Rotates entities around an axis from one location to another.
        **Remarks/Usage:**
            The axis of rotation is combined with the fromLoc and toLoc to compute an angle of rotation, which is then applied around the axis of rotation to every entity that you select.
        **Input:**
            **entityTYPE:** The type of entities to be moved. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_CSYS, FT_SURFACE, FT_VOLUME, FT_SOLID, FT_NODE, or FT_ELEM. \n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be rotated. Alternatively, if you specify a negative value, this is simply the ID of the single entity to rotate. \n
            **axisLoc:** The coordinates of the origin of the axis of rotation, in global rectangular coordinates.\n
            **axisVEC:** The components of the axis of rotation, in global rectangular coordinates.\n
            **fromLoc:** The coordinates of a point that you will rotate from, in global rectangular coordinates.\n
            **toLoc:** The coordinates of a point that you will rotate to, in global rectangular coordinates. \n
        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type axisLoc: tuple[float]

        :type axisVEC: tuple[float]

        :type fromLoc: tuple[float]

        :type toLoc: tuple[float]

        """
        ...

    def feRotationFromDirCos(self, dircos, rot) -> Any:
        """
        **Description:**
            This function converts a 3x3 direction cosine matrix into an equivalent triple-rotation, about X, then Y, then Z.
        **Remarks/Usage:**
            There can be multiple possible solutions to the same direction cosine matrix. This routine simply returns one of the possible solutions.
        **Input:**
            **dircos:** The 3x3 direction cosine matrix. Data is stored in row-order. [0,0]=[0], [0,1]=[1], [0,2]=[2], [1,0]=3 ... [2,2]=[8].\n
        **Output:**
            **rot:** The rotations, first about X, then the rotated Y, then the doubly-rotated Z.\n
        **Return Code:** False\n
        :type dircos: tuple[float]

        :type rot: tuple[float]

        """
        ...

    def feRotationToDirCos(self, rot, dircos) -> Any:
        """
        **Description:**
            This function converts a triple-rotation, about X, then Y, then Z, into a 3x3 direction cosine matrix.
        **Remarks/Usage:**
            Throughout this description, M is the dircos matrix. The direction cosine matrix is of the following form: X'  = { M } X
        **Input:**
            **rot:** The rotations, first about X, then the rotated Y, then the doubly-rotated Z.\n
        **Output:**
            **dircos:** The 3x3 direction cosine matrix. Data is stored in row-order. [0,0]=[0], [0,1]=[1], [0,2]=[2], [1,0]=3 ... [2,2]=[8]\n
        **Return Code:** False\n
        :type rot: tuple[float]

        :type dircos: tuple[float]

        """
        ...

    def feRotationTransform(self, fromCSYS, fromROT, toCSYS, rot) -> Any:
        """
        **Description:**
            This function transforms a triple rotation from one coordinate system to another.
        **Remarks/Usage:**
            None
        **Input:**
            **fromCSYS:** The ID of the coordinate system in which the fromROT rotations are currently specified. Specify 0 for global rectangular.\n
            **fromROT:** The rotations to transform, specified in fromCSYS. The rotations are triple rotations, about X, the rotated Y and the doubly-rotated Z.\n
            **toCSYS:** The ID of the coordinate system to transform into.\n
        **Output:**
            **rot:** The transformed rotations, returned in the toCSYS coordinate system. The two sets of rotations MAY NOT be specified as the same variable.\n
        **Return Code:** True\n
        :type fromCSYS: int

        :type fromROT: tuple[float]

        :type toCSYS: int

        :type rot: tuple[float]

        """
        ...

    def feRunCommand(self, nCmdID, bWaitForCompletion) -> Any:
        """
        **Description:**
            Runs a FEMAP command
        **Remarks/Usage:**
            Command IDs can be found by calling various functions defined earlier in this section, like feGetMenuCommand( ). This method provides no means for automatically answering dialog boxes that are displayed by the selected command - the command is run interactively.
        **Input:**
            **nCmdID:** The ID of the command to run\n
            **bWaitForCompletion:** If True, this method only returns when the command is finished. If False, it returns immediately.\n
        **Return Code:** False\n
        :type nCmdID: int

        :type bWaitForCompletion: bool

        """
        ...

    def feRunIOTest(self, sPath, nMethod) -> Any:
        """
        **Description:**
            This function runs the Read/Write Test found in the Database tab of the File, Preferences command.
        **Remarks/Usage:**
            None
        **Input:**
            **sPath:** Directory path to the current Scratch directory, where the test will take place.\n
        **Output:**
            **nMethod:** Preferred result of test. 0=Windows I/O, 1=C I/O, 2=Windows 64K I/O, or 3=C 64K I/O.\n
        **Return Code:** False\n
        :type sPath: str

        :type nMethod: int

        """
        ...

    def feSEGetEntityMap(self, nEntity, numID, nFemapID, nSEdgeID) -> Any:
        """
        :type nEntity: Any
        :type numID: Any
        :type nFemapID: Any
        :type nSEdgeID: Any
        """
        ...

    def feSaveToolbarLayout(self, fName) -> Any:
        """
        **Description:**
            Saves the current toolbar and menu definition and layout to a file for later use.
        **Remarks/Usage:**
            None
        **Input:**
            **fName:** The full pathname of the file to create (normally with a .tbr extension)\n
        **Return Code:** True\n
        :type fName: str

        """
        ...

    def feScale(self, entityTYPE, entitySET, fromLoc, csysID, xScale, yScale, zScale) -> Any:
        """
        **Description:**
            Scales entities around an origin.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** The type of entities to be scaled. For entity information, see Section 3.3.6, "Entity Types". Can be FT_POINT, FT_CURVE, FT_SURFACE, FT_VOLUME, FT_SOLID, FT_NODE, or FT_ELEM. \n
            **entitySET:** The ID of a set that contains a list of entity IDs that will be scaled. Alternatively, if you specify a negative value, this is simply the ID of the single entity to scale. \n
            **fromLoc:** The coordinates of the origin around which the entities will be scaled, in global rectangular coordinates.\n
            **csysID:** The ID of the coordinate system in which scaling will take place. \n
            **xScale, yScale, zScale:** The scale factors in the axis directions of coordinate system csysID. \n

        **Return Code:** True\n
        :type entityTYPE: int

        :type entitySET: int

        :type fromLoc: tuple[float]

        :type csysID: int

        :type xScale: float

        :type yScale: float

        :type zScale: float

        """
        ...

    def feScreenPctPick(self, x, y) -> Any:
        """
        **Description:**
            Displays a dialog box that allows picking a location in a view
        **Remarks/Usage:**
            None
        **Output:**
            **x:** The x (horizontal) and y (vertical) locations in the view. These values are returned as a percentage of the overall view size - i.e. 0.8 means 80% of the way from the top/left to the bottom/right of the view.\n
            **y:** Return Code:\n
        **Return Code:** True\n
        :type x: float

        :type y: float

        """
        ...

    def feSelectOutput2V2(self, title, nBaseOutputSetID, nPreCheckedSetSetID, nPreChecedVectorSetID, limitOutputType,
                          limitComplex, limitToEntity, includeCorner, pOutputSets, pOutputVecs) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to select Output Sets and Vectors along with already selected Output Sets and/or Vectors. This method replaces feSelectOutput2. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            The following dialog box is used for the set/vector selection...
        **Input:**
            **nBaseOutputSetID:** The ID of an output set to use to fill the Output Vector selection control. If 0, then the active Output Set is used, or if none is active, the first available one is used. If specified as a negative number, then the absolute value of that number is used, but the Output Set selection control only contains that Output Set, not all the sets available.\n
            **nPreCheckedSetSetID:** The ID of the set object containing Output Set IDs to be prechecked.\n
            **nPreChecedVectorSetID:** The ID of the set object containing Output Vector IDs to be prechecked. \n
            **limitComplex:** Reduces list of output vectors shown based on type of real or complex data they contain (0=Magnitude, 1=Phase, 2=Real, 3=Imaginary, 4=Any)\n
            **limitToEntity:** Reduces list of output vectors to those containing data on the specified entity type\n
            **includeCorner:** If True, output vectors at element corners will also be included\n
        **Output:**
            **pOutputSets:** A Set object that contains the Output Sets that were selected.\n
        **Return Code:** True\n
        :type nBaseOutputSetID: int

        :type nPreCheckedSetSetID: int

        :type nPreChecedVectorSetID: int

        :type limitComplex: int

        :type limitToEntity: int

        :type includeCorner: bool

        :type pOutputSets: Any

        """
        ...

    def feSelectOutputSets(self, title, pOutputSets) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to select Output Sets. This method is obsolete and should no longer be used. It has been replaced by feSelectOutputSets2.
        **Remarks/Usage:**
            The following dialog box is used for the set selection:
        **Input:**
            **title:** A string that specifies a title to be used as the dialog box title.\n
        **Output:**
            **pOutputSets:** A Set object that contains the Output Sets that were selected.\n
        **Return Code:** True\n
        :type title: str

        :type pOutputSets: Any

        """
        ...

    def feSelectOutputSets2(self, title, nPreCheckedSetSetID, pOutputSets) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to select Output Sets with prechecked Output Sets.
        **Remarks/Usage:**
            The following dialog box is used for the set selection:
        **Input:**
            **title:** A string that specifies a title to be used as the dialog box title.\n
            **nPreCheckedSetSetID:** The ID of the set object containing Output Set IDs to be prechecked.\n
        **Output:**
            **pOutputSets:** A Set object that contains the Output Sets that were selected.\n
        **Return Code:** True\n
        :type title: str

        :type nPreCheckedSetSetID: int

        :type pOutputSets: Any

        """
        ...

    def feSelectOutputV2(self, title, nBaseOutputSetID, limitOutputType, limitComplex, limitToEntity, includeCorner,
                         pOutputSets, pOutputVecs) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to select Output Sets and Vectors. This method is obsolete and should no longer be used. It has been replaced by feSelectOutput2. This method replaces feSelectOutput. For more information, see Section 2.4, "Working with Output in FEMAP 2020.1 and above".
        **Remarks/Usage:**
            The following dialog box is used for the set/vector selection...
        **Input:**
            **title:** A string that specifies a title to be used as the dialog box title.\n
            **nBaseOutputSetID:** The ID of an output set to use to fill the Output Vector selection control. If 0, then the active Output Set is used, or if none is active, the first available one is used. If specified as a negative number, then the absolute value of that number is used, but the Output Set selection control only contains that Output Set, not all the sets available.\n
            **limitOutputType:** Reduces list of output vectors shown to the specified type (0=All, 1=Disp, 2=Accel, 3=Force, 4=Stress, 5=Strain, 6=Temp)\n
            **limitComplex:** Reduces list of output vectors shown based on type of real or complex data they contain (0=Magnitude, 1=Phase, 2=Real, 3=Imaginary, 4=Any)\n
            **limitToEntity:** Reduces list of output vectors to those containing data on the specified entity type\n
        **Output:**
            **pOutputSets:** A Set object that contains the Output Sets that were selected.\n
        **Return Code:** True\n
        :type title: str

        :type nBaseOutputSetID: int

        :type limitOutputType: int

        :type limitComplex: int

        :type limitToEntity: int

        :type pOutputSets: Any

        """
        ...

    def feSelectOutputVectorV2(self, title, outputSetID, limitOutputType, limitComplex, limitToEntity, allowCorner,
                               selID) -> Any:
        """
        :type title: Any
        :type outputSetID: Any
        :type limitOutputType: Any
        :type limitComplex: Any
        :type limitToEntity: Any
        :type allowCorner: Any
        :type selID: Any
        """
        ...

    def feSetCurrentLibraryName(self, entityTYPE, libraryTYPE, libraryNAME) -> Any:
        """
        **Description:**
            Sets or changes the current library file (*.esp file) being used for a particular entity type.
        **Remarks/Usage:**
             The full directory path to the library file should be included in libraryNAME
        **Input:**
            **libraryNAME:** Name of current library to use for the specified entity type.\n
        **Return Code:** True\n
        :type libraryNAME: str

        """
        ...

    def feSetFree(self, nSetID) -> Any:
        """
        **Description:**
            Deletes a saved Femap Set.
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of saved Set you wish to delete.\n
        **Return Code:** False\n
        :type nSetID: int

        """
        ...

    def feSetFreeNotInSet(self, nSetID) -> Any:
        """
        **Description:**
            Deletes all saved sets not in the input set.
        **Remarks/Usage:**
            None
        **Input:**
            **nSetID:** ID of Set that contains IDS to not delete. Set to 0 to delete all saved Sets.\n
        **Return Code:** True\n
        :type nSetID: int

        """
        ...

    def feSetToolbarCommandBitmap(self, cmdID, cmdBitmap) -> Any:
        """
        **Description:**
            Sets the icon for a command on the menu or toolbar
        **Remarks/Usage:**
            The Bitmap file that you specify must be created following very specific guidelines, or this method will not work properly - possibly resulting in FEMAP crashing. The bitmap file must contain a single 16x16 pixel image. Other sizes are not supported. If you want part of the bitmap to be transparent, set those pixels to RGB=(192,192,192) - light gray. This means that you can not use this color in your image - it will be replaced by the appropriate background color.
        **Input:**
            **cmdID:** The ID of the command to update\n
            **cmdBitmap:** The full pathname to a Windows Bitmap file that is used for the command icon.\n
        **Return Code:** True\n
        :type cmdID: int

        :type cmdBitmap: str

        """
        ...

    def feSetToolbarCommandTitle(self, BarName, cmdID, cmdTitle, cmdToolTip, cmdDescription) -> Any:
        """
        **Description:**
            Sets the title, tooltip and description of a command on the menu or toolbars
        **Remarks/Usage:**
            None
        **Input:**
            **BarName:** The title of the toolbar where the command button is found. Specify an empty string () to set the titles for the command on all toolbars and the menu.\n
            **cmdID:** The ID of the command to update\n
            **cmdTitle:** Sets the title of the command. The title is the text shown on the toolbar or menu. Specify an empty string () if you do not want to update the command title. \n
            **cmdToolTip:** Sets the tooltip for the command. The tooltip is the text shown in the popup when you leave your mouse pointing at the command. Specify an empty string () if you do not want to update the command tooltip.\n
            **cmdDescription:** Sets the description for the command. The description is the one-line help text shown in the status bar when you point your mouse at the command. Specify an empty string () if you do not want to update the command description.\n
        **Return Code:** True\n
        :type BarName: str

        :type cmdID: int

        :type cmdTitle: str

        :type cmdToolTip: str

        :type cmdDescription: str

        """
        ...

    def feSetToolbarCommandVisible(self, BarName, cmdID, bVisible) -> Any:
        """
        **Description:**
            Shows (or hides) a specified command on a toolbar or menu
        **Remarks/Usage:**
            None
        **Input:**
            **BarName:** The title of the toolbar where the command button is found. Specify an empty string () to show or hide the command on all toolbars and the menu.\n
            **cmdID:** The ID of the command to show or hide.\n
            **bVisible:** True=Show the command, False=Hide\n
        **Return Code:** True\n
        :type BarName: str

        :type cmdID: int

        :type bVisible: bool

        """
        ...

    def feSetToolbarSeparator(self, BarName, cmdID, bAddSep) -> Any:
        """
        **Description:**
            Adds or removes a separator from before a command or menu on a toolbar.
        **Remarks/Usage:**
            None
        **Input:**
            **BarName:** The title of the toolbar where the command button is found. Specify an empty string () to show or hide the command on all toolbars and the menu.\n
            **cmdID:** The ID of the command or menu to modify the separator\n
            **bAddSep:** True=Add a separator before the command/menu, False=Remove separator\n
        **Return Code:** True\n
        :type BarName: str

        :type cmdID: int

        :type bAddSep: bool

        """
        ...

    def feSetToolbarVisible(self, BarName, bVisible) -> Any:
        """
        **Description:**
            Makes one or more toolbars visible (or hidden)
        **Remarks/Usage:**
            The names of the toolbars can be found by running FEMAP manually and looking on the Tools->Toolbars menu. In addition to the toolbars listed there, you can also control the visibility of the Menu using this method - simply use the barName of Menu Bar.
        **Input:**
            **BarName:** The title of the toolbar to be updated. If this is an empty string () then all toolbars will be reset.\n
            **bVisible:** If True, the toolbar will be made visible. If False, it will be hidden.\n
        **Return Code:** True\n
        :type BarName: str

        :type bVisible: bool

        """
        ...

    def feSolidAdd(self, solidSET, Redraw) -> Any:
        """
        **Description:**
            Adds two or more solids to form a new solid.
        **Remarks/Usage:**
            None
        **Input:**
            **solidSET:** The ID of a set that contains a list of Solid IDs that will be added. This list must contain at least two solids to be added.\n
            **Redraw:** If True, the graphics will be redrawn to reflect the updated solids following this operation.\n
        **Return Code:** True\n
        :type solidSET: int

        :type Redraw: bool

        """
        ...

    def feSolidAlignSplits(self, entityTYPE, SetID, vecMode, axisVEC) -> Any:
        """
        **Description:**
            The method attempts to reorient the split lines of periodic faces (i.e., holes, cylinders, cones, etc), either automatically or using a alignment vector specified by the user.
        **Remarks/Usage:**
            None
        **Input:**
            **entityTYPE:** Type of entities which will be in the input set, setID, will contain, surfaces (5=FT_SURFACE) or solids (39=FT_SOLID). If you specify just surfaces, only those specified will be reoriented (and their matching 180 to 360 surface). If you specify solids, all faces on the solid that can be reoriented, will be reoriented.\n
            **SetID:** ID of a Set object containing existing surfaces or solids of a solid. Alternatively, specify as a negative value to select a single surface or solid.\n
            **vecMode:** Vector Mode.\n
            **axisVEC:** Alignment Vector (only vecMode = FSAV_VECINPUT)\n
        **Return Code:** False\n
        :type entityTYPE: int

        :type SetID: int

        :type vecMode: int

        :type axisVEC: tuple[float]

        """
        ...

    def feSolidChamfer(self, curveSET, radius) -> Any:
        """
        **Description:**
            Chamfers one or more edges of a solid.
        **Remarks/Usage:**
            None
        **Input:**
            **curveSET:** The ID of a set that contains a list of Curve IDs that will be chamfered. Alternatively, if you specify a negative value, this is simply the ID of the single curve to chamfer.\n
        **Return Code:** True\n
        :type curveSET: int

        """
        ...

    def feSolidCleanup(self, solidSET, redundant, sliver, check) -> Any:
        """
        **Description:**
            Performs various cleanup and checking on selected solids.
        **Remarks/Usage:**
            None
        **Input:**
            **solidSET:** The ID of a set that contains a list of solid IDs that will be checked. Alternatively, if you specify a negative value, this is simply the ID of the single solid to check.\n
            **redundant:** If True, redundant geometry that is not required to define the solid will be removed. For example, extra lines or surfaces that were cut into the underlying surfaces will be removed.\n
            **sliver:** If True, an attempt will be made to remove any and all small sliver surfaces. This option is only available if the solid is a Parasolid solid.\n
            **check:** If True, the solids will be checked to ensure that they are still valid. This is especially important if you have attempted to remove sliver surfaces.\n
        **Return Code:** True\n
        :type solidSET: int

        :type redundant: bool

        :type sliver: bool

        :type check: bool

        """
        ...

    def feSolidCleanupAdvanced(self, solidSET, RepairEdges, RepairEdgesVal, CleanSmoothDiscont, CleanSmoothDiscontVal,
                               RemoveSelfInt, AllowSurfMod, RemoveSpikes, RemoveSpikesVal, RemoveSmallEdges,
                               RemoveSmallEdgesVal, RemoveSmallFaces, RemoveSmallFacesVal, RemoveSliverFaces,
                               RemoveSliverFacesVal, ConvertToAnalytic, ConvertToAnalyticVal, RecalcEdges,
                               RecalcEdgesVal, MergeEdges, HealSurfaces, HealSurfacesVal, HealSmoothDiscont,
                               HealSmoothDiscontVal, ReplaceMissing) -> Any:
        """
        **Description:**
            Performs more advanced cleanup and checking on selected solids.
        **Remarks/Usage:**
            For all numeric values used by this method, specifying a value of 0.0 will automatically use the default value that is shown in the dialog when you access this functionality from the user interface.
        **Input:**
            **solidSET:** The ID of a set that contains a list of solid IDs that will be checked. Alternatively, if you specify a negative value, this is simply the ID of the single solid to check.\n
            **RepairEdges:** If True, turn on Cleaning Repair Edges\n
            **RepairEdges:** Size for repairing edges\n
            **CleanSmoothDiscont:** If True, turn on Cleaning Smooth or Split Discontinuities\n
            **CleanSmoothDiscont:** Angle for Smooth or Split Discontinuities\n
            **RemoveSelfInt:** If True, turn on Cleaning Remove Surface Self-Intersections\n
            **AllowSurfMod:** If True, turn on Cleaning Allow Surface Modifications\n
            **RemoveSpikes:** If True, turn on Small Feature Remove Spikes\n
            **RemoveSpikes:** Size for spike removal\n
            **RemoveSmallEdgesVal:** Size for small edge removal\n
            **RemoveSmallFaces:** If True, turn on Small Feature Remove Small Faces\n
            **RemoveSmallFaces:** Size for small face removal\n
            **RemoveSliverFaces:** If True, turn on Small Feature Remove Sliver Faces\n
            **RemoveSliverFaces:** Size for sliver face removal\n
            **ConvertToAnalytic:** If True, turn on Geometry Simplification Convert to Analytic Geometry\n
            **ConvertToAnalytic:** Value for Analytic Geometry conversion\n
            **RecalcEdges:** If True, turn on Edge Heal Recalculate Edge Geometry\n
            **RecalcEdges:** Value for recalculating edge geometry\n
            **MergeEdges:** If True, turn on Edge Heal Merge Edges\n
            **HealSurfaces:** If True, turn on Surface Heal and Stitch Heal Surfaces\n
            **HealSurfaces:** Value for healing surfaces\n
            **HealSmoothDiscont:** If True, turn on Surface Heal and Stitch Smooth or Split Discontinuities\n
            **HealSmoothDiscont:** Value for Smoothing/Splitting Discontinuities during Surface Healing\n
            **ReplaceMissing:** If True, turn on Surface Heal and Stitch Replace Missing Geometry\n
        **Return Code:** True\n
        :type solidSET: int

        :type RepairEdges: bool

        :type RepairEdges: float

        :type CleanSmoothDiscont: bool

        :type CleanSmoothDiscont: float

        :type RemoveSelfInt: bool

        :type AllowSurfMod: bool

        :type RemoveSpikes: bool

        :type RemoveSpikes: float

        :type RemoveSmallEdgesVal: float

        :type RemoveSmallFaces: bool

        :type RemoveSmallFaces: float

        :type RemoveSliverFaces: bool

        :type RemoveSliverFaces: float

        :type ConvertToAnalytic: bool

        :type ConvertToAnalytic: float

        :type RecalcEdges: bool

        :type RecalcEdges: float

        :type MergeEdges: bool

        :type HealSurfaces: bool

        :type HealSurfaces: float

        :type HealSmoothDiscont: bool

        :type HealSmoothDiscont: float

        :type ReplaceMissing: bool

        """
        ...

    def feSolidCommon(self, baseID, toolID, Redraw) -> Any:
        """
        **Description:**
            Creates a new solid that represents the common volume between two original solids.
        **Remarks/Usage:**
            None
        **Input:**
            **baseID:** The ID of the base solid.\n
            **toolID:** The ID of the tool solid.\n
            **Redraw:** If True, the graphics will be redrawn to reflect the updated solids following this operation.\n
        **Return Code:** True\n
        :type baseID: int

        :type toolID: int

        :type Redraw: bool

        """
        ...

    def feSolidElementsInARow(self, numElems, nElemIDs, nFaceIDs, nMaxFind, bVisibleOnly, nCount, nElemList) -> Any:
        """
        **Description:**
            Returns a list of solid hex and wedge elements found in a row, starting with a specified element face and continuing through a mesh until no additional hex or wedge elements can be found for a particular row. If a row of hex elements comes to a quadrilateral face of a wedge element, the row ends at the wedge. In addition, there is an option to consider all hex and wedge elements or only hex and wedge elements visible in the active view.
        **Remarks/Usage:**
            To determine when one found row ends and another found row begins, it will often be helpful to compare the element IDs in vElemList to the ones found in nElemIDs. Also, it maybe helpful to use this call with feGetElementFaces (see Section 3.15.4.6, "feGetElementFaces"), feGetElementFacesFromSet (see Section 3.15.4.8, "feGetElementFacesFromSet") or feGetElementAdjacentFaces (see Section 3.15.4.9, "feGetElementAdjacentFaces").
        **Return Code:** True\n
        """
        ...

    def feSolidEmbed(self, baseID, toolID, Redraw) -> Any:
        """
        **Description:**
            Embeds one solid (the tool) inside another (the base).
        **Remarks/Usage:**
            None
        **Input:**
            **baseID:** The ID of the base solid.\n
            **toolID:** The ID of the tool solid.\n
            **Redraw:** If True, the graphics will be redrawn to reflect the updated solids following this operation.\n
        **Return Code:** True\n
        :type baseID: int

        :type toolID: int

        :type Redraw: bool

        """
        ...

    def feSolidEmbedFace(self, surfID, directionMode, curveOpt, dirVec, offset, Redraw) -> Any:
        """
        **Description:**
            Uses a surface of a solid to divide it.
        **Remarks/Usage:**
            None
        **Input:**
            **surfID:** The ID of the surface used to slice the solid. This surface is also used to determine the solid to slice, since only the solid that contains the surface can be sliced.\n
            **directionMode:** The option used to determine which direction the surface will be projected as it is embedded into the solid: 0=Automatic direction and offset selection, 1=Specified direction, Automatic offset, 2= Automatic Direction, Specified offset.\n
            **curveOpt:** The option used to determine which curves of the surface will be embedded: 0=Outline only (skip interior curves/holes), 1=All Curves.\n
            **dirVec:** The vector used to specify the direction to embed the face - only used if dirMode=1.\n
            **offset:** The distance that the face will be embedded into the solid. Only used if dirMode=1 or dirMode=2.\n
            **Redraw:** If True, the graphics will be redrawn to reflect the updated solids following this operation.\n
        **Return Code:** True\n
        :type surfID: int

        :type directionMode: int

        :type curveOpt: int

        :type dirVec: tuple[float]

        :type offset: float

        :type Redraw: bool

        """
        ...

    def feSolidEmbedMultiple(self, baseID, toolSetID, Redraw) -> Any:
        """
        **Description:**
            Embeds any number of solids (the tools) inside another solid (the base).
        **Remarks/Usage:**
            None
        **Input:**
            **baseID:** The ID of the base solid.\n
            **toolSetID:** The ID of a set that contains a list of solid IDs to embed into the base solid. Alternatively, if you specify a negative value, this is simply the ID of the single curve to use.\n
            **Redraw:** If True, the graphics will be redrawn to reflect the updated solids following this operation.\n
        **Return Code:** True\n
        :type baseID: int

        :type toolSetID: int

        :type Redraw: bool

        """
        ...

    def feSolidExplode(self, solidSET) -> Any:
        """
        **Description:**
            Explodes selected solids into individual surfaces.
        **Remarks/Usage:**
            None
        **Input:**
            **solidSET:** The ID of a set that contains a list of Solid IDs that will be exploded. Alternatively, if you specify a negative value, this is simply the ID of the single solid to explode.\n
        **Return Code:** True\n
        :type solidSET: int

        """
        ...

    def feSolidExtendEdgesToSurfaces(self, cuSetID, suSetID, nExtendShape, bEdgeAuto) -> Any:
        """
        **Description:**
            This method mimics the functionality of the Meshing Toolbox's Geometry Editing Tool - Extend Operation, which extends any number of selected surface edge curves to the selected surfaces
        **Remarks/Usage:**
            Using this call with bAutoEdge set to False mimics behavior of the Extend Operation when using Extend To set to Surface, while setting it to True mimics behavior of Extend To set to Surface Auto Curve.
        **Input:**
            **cuSetID:** ID of a Set object containing existing surface edge curves to extend to a surface. Alternatively, specify as a negative value to extend a single surface edge curve.\n
            **suSetID:** ID of a Set object containing existing surfaces to extend to. Alternatively, specify as a negative value to extend to a single surface.\n
            **nExtendShape:** Specifies the Extend Shape, 0=Linear, 1=Continuous Curvature, 2=Reflective\n
        **Return Code:** False\n
        :type cuSetID: int

        :type suSetID: int

        :type nExtendShape: int

        """
        ...

    def feSolidExtendToSurface(self, suID1, suID2) -> Any:
        """
        **Description:**
            Attempts to extend a selected surface on a solid to a different surface, which may or may not be part of a solid. If successful, the original solid will be modified.
        **Remarks/Usage:**
            None
        **Input:**
            **suID1:** The ID of a set that contains a list of surface IDs that will be extended. Alternatively, if you specify a negative value, this is simply the ID of the single surface on a solid to extend.\n
            **suID2:** ID of a single surface or surface on a solid to extend the solid containing the surface specified in suID1 to.\n
        **Return Code:** True\n
        :type suID1: int

        :type suID2: int

        """
        ...

    def feSolidExtractCenterlines(self, soSetID, inMatID, bTubularOnly) -> Any:
        """
        **Description:**
            Extracts lines and arcs at the centerline of the input solid geometry. Straight and curved tubes are extracted first, properties are created as FEMAP Circular Bar or Circular Tube. A second method is used for all other solids, the longest line or arc on the surface is found, a cross section is then found perpendicular to this curve. A new centerline line or arc is then created through the neutral axis of that section and added to the model
        **Remarks/Usage:**
            None
        **Input:**
            **soSetID:** ID of a Set object containing existing solids to be processed. Alternatively, specify as a negative value to process a single solid.\n
            **inMatID:** The input material ID. \n
            **bTubularOnly:** If True, command will only attempt to find circular bar and tube cross sections. If False, after all circular bar and tube cross sections are processed, command moves on to other selected solids using the longest line/arc algorithm described above.\n
        **Return Code:** True\n
        :type soSetID: int

        :type inMatID: int

        :type bTubularOnly: bool

        """
        ...

    def feSolidExtrude(self, operation, surfID, dirmode, depthMode, dirVec, depthVec) -> Any:
        """
        **Description:**
            Extrudes a surface into a solid, or modifies an existing solid by extruding.
        **Remarks/Usage:**
            The Add and Remove operations manipulate the active solid. You can select the active solid by setting femap.Info_ActiveID(39) to the ID of the solid that you want to use.
        **Input:**
            **operation:** The type of operation to perform when creating the solid: 0=Create New Solid, 1=Add to Active Solid, 2=Remove from Active Solid.\n
            **surfID:** The surface to extrude. This surface can either be an existing solid surface, or a planar boundary.\n
            **dirmode:** Specifies the approach you will use to specify the extrusion direction: 0=Positive Surface Normal, 1=Negative Surface Normal, 2=Surface Normal, Both Positive and Negative, 3=Along the Vector specified in dirVec, 4=Opposite the Vector specified in dirVec, 5=Along and Opposite the Vector specified in dirVec.\n
            **depthMode:** Specifies the approach you will use to specify the extrusion length/depth: 0=Specified Depth - the depth is defined in depthVec[0], 1=To Location - the location to extrude to is specified in depthVec[0..2], in global coordinates, 2=Thru All - Only used for the Removeoperation to cut completely through the active solid.\n
            **dirVec:** The components, in global rectangular coordinates, of the extrusion vector. Only used if dirMode = 3, 4 or 5.\n
            **depthVec:** The extrusion length (depthMode=0) or the location to extrude to, in global rectangular coordinates (depthMode=1). Not used for Thru All extrusions.\n
        **Return Code:** True\n
        :type operation: int

        :type surfID: int

        :type dirmode: int

        :type depthMode: int

        :type dirVec: tuple[float]

        :type depthVec: tuple[float]

        """
        ...

    def feSolidFillCavity(self, curveID) -> Any:
        """
        **Description:**
            Fills a cavity or hole in a solid by selecting a single seed curve, usually part of a loop.
        **Remarks/Usage:**
            Using this API call is essentially the same as using the Geometry, Solid, Fill Holecommand in the user interface.
        **Input:**
            **curveID:** The ID of a single curve to use as the seed curve, usually part of a loop.\n
        **Return Code:** True\n
        :type curveID: int

        """
        ...

    def feSolidFillet(self, curveSET, radius) -> Any:
        """
        **Description:**
            Fillets one or more edges of a solid.
        **Remarks/Usage:**
            None
        **Input:**
            **curveSET:** The ID of a set that contains a list of Curve IDs that will be filleted. Alternatively, if you specify a negative value, this is simply the ID of the single curve to fillet.\n
            **radius:** The fillet radius.\n
        **Return Code:** True\n
        :type curveSET: int

        :type radius: float

        """
        ...

    def feSolidInsideMulti(self, soSetID, nNumPts, vPtLocs, nInside) -> Any:
        """
        **Description:**
            The method determines if a location is inside, outside, or on a point, curve, or surface of all the selected solids considered as a single combined solid. To determine if a location is inside, outside, or on a point, curve, or surface of a particular solid, then only the ID of that single solid should be included in the Set object.
        **Remarks/Usage:**
            None
        **Input:**
            **soSetID:** ID of a Set object containing existing solids to be considered as a single combined solid. Alternatively, specify as a negative value to select a single solid.\n
            **vPtLocs:** [0..3*nNumPts-1]\n
        **Output:**
            **nInside:** 0=Location is outside the single combined solid, 1=Location is inside the single combined solid, 2=Location is on a point, curve, or surface of the single combined solid.\n
        **Return Code:** False\n
        :type soSetID: int

        :type vPtLocs: float

        :type nInside: int

        """
        ...

    def feSolidIntersect(self, solidSET, Redraw) -> Any:
        """
        **Description:**
            Breaks all of the surfaces of the selected solids at their intersections with other surfaces.
        **Remarks/Usage:**
            None
        **Input:**
            **solidSET:** The ID of a set that contains a list of solid IDs that will be intersected. This list must contain at least two solids.\n
            **Redraw:** If True, the graphics will be redrawn to reflect the updated solids following this operation.\n
        **Return Code:** True\n
        :type solidSET: int

        :type Redraw: bool

        """
        ...

    def feSolidMidSurfaceManualInput(self, suSet1_ID, suSet2_ID) -> Any:
        """
        **Description:**
            This method attempts to create a midsurface using the Variable Thickness Processing option between two sets of specified surfaces.
        **Remarks/Usage:**

        **Input:**
            **suSet1_ID:** ID of a Set object containing existing surfaces on side 1 of a solid. Alternatively, specify as a negative value to select a single surface.\n
            **suSet2_ID:** ID of a Set object containing existing surfaces on side 2 of a solid. Alternatively, specify as a negative value to select a single surface.\n
        **Return Code:** True\n
        :type suSet1_ID: int

        :type suSet2_ID: int

        """
        ...

    def feSolidMovePointOntoGeometry(self, ptSetID, geomID, geomTYPE, bAlongEdge) -> Any:
        """
        **Description:**
            This method mimics the functionality of the Meshing Toolbox's Geometry Editing Tool - Project/Move Point Operation, which moves points to a specified point or projects points onto the specified curve, surface, or solid. This only works for points on solid or surface geometry and the underlying geometry will be modified after the points are moved/projected.
        **Remarks/Usage:**

        **Input:**
            **ptSetID:** ID of a Set object containing existing points on solids or surfaces to move onto the type of geometry selected with geomType. Alternatively, specify as a negative value to move a single point.\n
            **geomID:** ID of geometric entity to move/project the points. Type of entity defined using geomType\n
            **bAlongEdge:** If True, will project using a vector matching an edge each point is connected to instead of doing a normal projection based on proximity to the curve, surface, or solid.\n
        **Return Code:** False\n
        :type ptSetID: int

        :type geomID: int

        :type bAlongEdge: bool

        """
        ...

    def feSolidPrimitive(self, operation, shape, positive, origin, Size, title) -> Any:
        """
        **Description:**
            Creates a solid primitive.
        **Remarks/Usage:**
            The Add, Remove and Common operations manipulate the active solid. You can select the active solid by setting femap.Info_ActiveID(39) to the ID of the solid that you want to use.
        **Input:**
            **operation:** The type of operation to perform when creating the solid: 0=Create New Solid, 1=Add to Active Solid, 2=Remove from Active Solid, 3=Common with Active Solid.\n
            **shape:** The type of primitive to create: 0=Block (Center), 1=Block (Corner), 2=Cylinder, 3=Cone, 4=Sphere, 5=Sphere (Alt)\n
            **positive:** Set to True if the Z direction should be in the positive workplane Z direction, or False to go in the negative workplane Z direction. Dimensions should all be positive.\n
            **origin:** The location, in the workplane, of the origin of the solid.\n
            **Size:** The size of the primitive to create. The exact meaning of these dimensions varies depending on the value of shape. Refer to the table at the end of this command for details.\n
            **title:** The title to assign to the solid - only used if creating a new solid.\n
        **Return Code:** True\n
        :type operation: int

        :type shape: int

        :type positive: bool

        :type origin: tuple[float]

        :type Size: tuple[float]

        :type title: str

        """
        ...

    def feSolidRayFire(self, soSetID, nNumRay, vRayLoc, vRayDir, nHitSurface, vHitLoc) -> Any:
        """
        **Description:**
            This method finds the locations on solids hit by rays specified by the user
        **Remarks/Usage:**

        **Input:**
            **soSetID:** ID of a Set object containing the IDs of the solids that you want to hit\n
            **nNumRay:** The number of rays that are contained in vRayLoc, vRayDir\n
            **vRayLoc:** The location of the base of the ray/vector in Global Rectangular coordinates\n
            **vRayDir:** The components of the direction of the ray\n
        **Output:**
            **nHitSurface:** The ID of the surface that each ray hits (0 if it misses all surfaces)\n
            **vHitLoc:** The Global Rectangular XYZ coordinates where the ray hit the surfaces\n
        **Return Code:** True\n
        :type soSetID: int

        :type nNumRay: int

        :type vRayLoc: tuple[float]

        :type vRayDir: tuple[float]

        :type nHitSurface: tuple[int]

        :type vHitLoc: tuple[float]

        """
        ...

    def feSolidRemove(self, baseID, solidSET, Redraw) -> Any:
        """
        **Description:**
            Removes (subtracts) one or more solids from a base solid.
        **Remarks/Usage:**
            None
        **Input:**
            **baseID:** The ID of the base solid, from which the solids in solidSET will be removed.\n
            **solidSET:** The ID of a set that contains a list of Solid IDs that will be removed. Alternatively, if you specify a negative value, this is simply the ID of the single solid to remove.\n
            **Redraw:** If True, the graphics will be redrawn to reflect the updated solids following this operation.\n
        **Return Code:** True\n
        :type baseID: int

        :type solidSET: int

        :type Redraw: bool

        """
        ...

    def feSolidRemoveBlendsBelowRadius(self, soSetID, max_rad) -> Any:
        """
        **Description:**
            This method attempts to remove all blends (fillet surfaces) from a solid, with an option to limit blend removal to the blends which have a radius less than or equal to the specified value.
        **Remarks/Usage:**
            Using this call is essentially the same as using the Feature Removal Tool in the Meshing Toolbox with Feature Type set to Blends and max_rad being > 0.0 enables Limit Size and sets the value.
        **Input:**
            **max_rad:** Value of maximum blend radius to remove. An attempt will be made to remove all blends with a radius less than or equal to this value. Enter a value of 0.0 to attempt to remove all blends, regardless of radius.\n
        **Return Code:** True\n
        :type max_rad: float

        """
        ...

    def feSolidRemoveCurve(self, cuSetID, nRemoveOption) -> Any:
        """
        **Description:**
            Removes curve(s) from a solid or sheet solid.
        **Remarks/Usage:**
            None
        **Input:**
            **cuSetID:** The ID of a set that contains a list of curve IDs that will be removed. Alternatively, if you specify a negative value, this is simply the ID of the single curve to remove.\n
            **nRemoveOption:** Allows you to choose a curves removal strategy:\n
        **Return Code:** True\n
        :type cuSetID: int

        :type nRemoveOption: int

        """
        ...

    def feSolidRemoveFace(self, surfaceSET, agressive, Redraw) -> Any:
        """
        **Description:**
            Removes face(s) from a solid and then heals the gap.
        **Remarks/Usage:**
            None
        **Input:**
            **surfaceSET:** The ID of a set that contains a list of surface IDs that will be removed. Alternatively, if you specify a negative value, this is simply the ID of the single surface to remove.\n
            **agressive:** Attempts aggressive face removal.\n
            **Redraw:** Redraw the model after command.\n
        **Return Code:** True\n
        :type surfaceSET: int

        :type agressive: bool

        :type Redraw: bool

        """
        ...

    def feSolidRemoveRedundantPoint(self, ptID) -> Any:
        """
        **Description:**
            This method attempts to remove redundant vertices from a solid. Internally, this command will take a vertex on a Parasolid body, and if the attached curves are tangent, it attempts to replace the curves with a single one, and remove the vertex.
        **Remarks/Usage:**

        **Input:**
            **ptID:** ID of point to attempt to remove\n
        **Return Code:** True\n
        :type ptID: int

        """
        ...

    def feSolidRevolve(self, operation, surfID, dirmode, angleMode, axisBASE, axisVEC, angleVec) -> Any:
        """
        **Description:**
            Revolves a surface into a solid, or modifies an existing solid by revolving.
        **Remarks/Usage:**
            The Add and Remove operations manipulate the active solid. You can select the active solid by setting femap.Info_ActiveID(39) to the ID of the solid that you want to use.
        **Input:**
            **operation:** The type of operation to perform when creating the solid: 0=Create New Solid, 1=Add to Active Solid, 2=Remove from Active Solid.\n
            **surfID:** The surface to revolve. This surface can either be an existing solid surface, or a planar boundary.\n
            **dirmode:** Specifies the approach you will use to specify the extrusion direction: 0=Positive Around Axis, 1=Negative Around Axis, 2=Both Positive and Negative Around Axis.\n
            **angleMode:** Specifies the approach you will use to specify the angle of revolution: 0=Specified Angle - the angle is defined in angleVec[0], 1=To Location - the location to revolve to is specified in angleVec[0..2], 2=Full 360 degree revolution. All angles are specified in degrees.\n
            **axisBASE:** The location of the base of the axis of revolution, specified in global rectangular coordinates.\n
            **axisVEC:** The components of the axis of revolution, specified in global rectangular coordinates.\n
            **angleVec:** The angle of revolution (angleMode=0) or the location to revolve to, in global rectangular coordinates (angleMode=1). Not used for Full 360 revolutions.\n
        **Return Code:** True\n
        :type operation: int

        :type surfID: int

        :type dirmode: int

        :type angleMode: int

        :type axisBASE: tuple[float]

        :type axisVEC: tuple[float]

        :type angleVec: tuple[float]

        """
        ...

    def feSolidShell(self, baseID, surfaceSET, thickness, Redraw) -> Any:
        """
        **Description:**
            Converts a solid into a thin-walled solid by offsetting outer surfaces.
        **Remarks/Usage:**
            None
        **Input:**
            **baseID:** The ID of the base solid to be modified.\n
            **surfaceSET:** The ID of a set that contains a list of surface IDs that will be pierced by the shelling operation: that is, the list of surfaces that are really on the thru-the-thickness edges of the shelled solid. Alternatively, if you specify a negative value, this is simply the ID of the single surface to pierce.\n
            **thickness:** The thickness of the resulting shelled solid. This is the distance that the outer surfaces are offset to form the inner surfaces.\n
            **Redraw:** If True, the graphics will be redrawn to reflect the updated solids following this operation.\n
        **Return Code:** True\n
        :type baseID: int

        :type surfaceSET: int

        :type thickness: float

        :type Redraw: bool

        """
        ...

    def feSolidSlice(self, solidSET, planeBase, planeNormal, Redraw) -> Any:
        """
        **Description:**
            Slices one or more solids with a plane.
        **Remarks/Usage:**
            This method corresponds to the Geometry, Solid, Slicecommand found in FEMAP prior to version 11.2 To use features of the Geometry, Solid, Slice command implemented in FEMAP 11.2, use feSolidSlice2
        **Input:**
            **solidSET:** The ID of a set that contains a list of solid IDs that will be sliced. Alternatively, if you specify a negative value, this is simply the ID of the single solid to slice.\n
            **planeBase:** Any location that lies on the plane used to slice the solid.\n
            **planeNormal:** The components of a vector that is normal to the plane.\n
            **Redraw:** If True, the graphics will be redrawn to reflect the updated solids following this operation.\n
        **Return Code:** True\n
        :type solidSET: int

        :type planeBase: tuple[float]

        :type planeNormal: tuple[float]

        :type Redraw: bool

        """
        ...

    def feSolidSlice2(self, solidSET, planeBase, planeNormal, bSliceOrSection, bMatchAcrossSlice, nNumberOfPlanes,
                      dMultiPlaneOffset, nSliceColor, Redraw) -> Any:
        """
        **Description:**
            Slices one or more solids with a single plane or any number of planes which are parallel to, and offset from, the specified plane. Also, offers an option to use each slice plane to create a surface representing the cross-section of each solid at the slice location, instead of slicing each solid into multiple solids.
        **Remarks/Usage:**
            This method provides access to features of the Geometry, Solid, Slicecommand implemented in FEMAP 11.2, when Methodis set to With Plane. Also, combines functionality of feSolidSlice and feSolidSliceMatch.
        **Input:**
            **solidSET:** The ID of a set that contains a list of solid IDs that will be sliced. Alternatively, if you specify a negative value, this is simply the ID of the single solid to slice.\n
            **planeBase:** Any location that lies on the plane used to slice the solid.\n
            **planeNormal:** The components of a vector that is normal to the plane.\n
            **bSliceOrSection:** If True, each solid will be sliced into multiple solids. If False, cross-sectional surface(s) will be created for each solid.\n
            **bMatchAcrossSlice:** If True, matching surfaces will be created on both new solids. Only used when bSliceOrSection is True.\n
            **dMultiPlaneOffset:** Offset distance between each parallel plane. Only used when nNumberOfPlanes is > 1.\n
            **nSliceColor:** Specifies the color of the surfaces at the slice locations. To use the Active Color for Solids, specify a -1\n
            **Redraw:** If True, the graphics will be redrawn to reflect the updated solids following this operation.\n
        **Return Code:** True\n
        :type solidSET: int

        :type planeBase: tuple[float]

        :type planeNormal: tuple[float]

        :type bSliceOrSection: bool

        :type bMatchAcrossSlice: bool

        :type dMultiPlaneOffset: float

        :type nSliceColor: int

        :type Redraw: bool

        """
        ...

    def feSolidSliceAlongFace(self, surfaceID) -> Any:
        """
        **Description:**
            Separates a solid by slicing it with one of its surfaces.
        **Remarks/Usage:**
            This method corresponds to the Geometry, Solid, Slice Along Facecommand found in FEMAP prior to version 11.2. To use features of the Geometry, Solid, Slicecommand implemented in FEMAP 11.2, use feSolidSliceAlongFace2
        **Input:**
            **surfaceID:** The ID of the surface used to slice the solid. This surface is also used to determine the solid to slice, since only the solid that contains the surface can be sliced.\n
        **Return Code:** True\n
        :type surfaceID: int

        """
        ...

    def feSolidSliceAlongFace2(self, surfaceID, bSliceOrSection, bMatchAcrossSlice, nSliceColor, Redraw) -> Any:
        """
        **Description:**
            Separates a solid by slicing it with one of its surfaces. Essentially, performs the same operation as feSolidSliceAlongFace, while offering some additional options.
        **Remarks/Usage:**
            This method provides access to features of the Geometry, Solid, Slice command implemented in FEMAP 11.2, when Methodis set to Along Face.
        **Input:**
            **surfaceID:** The ID of the surface used to slice the solid. This surface is also used to determine the solid to slice, since only the solid that contains the surface can be sliced. To prompt the user to select a surface via a dialog box, enter a value of 0.\n
            **bSliceOrSection:** If True, each solid will be sliced into multiple solids. If False, cross-sectional surface(s) will be created for each solid.\n
            **bMatchAcrossSlice:** If True, matching surfaces will be created on both new solids. Only used when bSliceOrSection is True.\n
            **nSliceColor:** Specifies the color of the surfaces at the slice locations. To use the Active Color for Solids, specify a -1\n
            **Redraw:** If True, the graphics will be redrawn to reflect the updated solids following this operation.\n
        **Return Code:** True\n
        :type surfaceID: int

        :type bSliceOrSection: bool

        :type bMatchAcrossSlice: bool

        :type nSliceColor: int

        :type Redraw: bool

        """
        ...

    def feSolidSliceMatch(self, solidSET, planeBase, planeNormal, Redraw) -> Any:
        """
        **Description:**
            Slices one or more solids with a plane and leaves matching surfaces on both new solids.
        **Remarks/Usage:**
            This method corresponds to the Geometry, Solid, Slice Match command found in FEMAP prior to version 11.2. The functionality of Geometry, Solid, Slice Matchwas incorporated into the Geometry, Solid, Slicecommand implemented in FEMAP 11.2, so use feSolidSlice2 with bMatchAcrossSlice=True to duplicate the functionality of this method.
        **Input:**
            **solidSET:** The ID of a set that contains a list of solid IDs that will be sliced. Alternatively, if you specify a negative value, this is simply the ID of the single solid to slice.\n
            **planeBase:** Any location that lies on the plane used to slice the solid.\n
            **planeNormal:** The components of a vector that is normal to the plane.\n
            **Redraw:** If True, the graphics will be redrawn to reflect the updated solids following this operation.\n
        **Return Code:** True\n
        :type solidSET: int

        :type planeBase: tuple[float]

        :type planeNormal: tuple[float]

        :type Redraw: bool

        """
        ...

    def feSolidSliceWithCurve2(self, solidSET, curveSET, bSliceOrSection, bMatchAcrossSlice, nSliceColor,
                               bAlongCurveNormal, bVectorDirectionOnly, vectorBase, vectorDirection, deleteTool,
                               Redraw) -> Any:
        """
        **Description:**
            Slices one or more solids with any number of curves, which has been extruded along a vector normal to the curve normal or along a vector specified by the user. Also, offers an option to use the extruded curve to create a surface representing the cross-section of each solid at the slice location, instead of slicing each solid into multiple solids.
        **Remarks/Usage:**
            This method provides access to features of the Geometry, Solid, Slice command implemented in FEMAP 11.2, when Methodis set to With Curve. Also, there was never a feSolidSliceWithCurve method, as the 2 simply indicates this method was implemented at the same time as feSolidSlice2.
        **Input:**
            **solidSET:** The ID of a set that contains a list of solid IDs that will be sliced. Alternatively, if you specify a negative value, this is simply the ID of the single solid to slice.\n
            **curveSET:** The ID of a set that contains a list of curve IDs that will be used as slicing tools. Alternatively, if you specify a negative value, this is simply the ID of the single curve to use as a slicing tool.\n
            **bSliceOrSection:** If True, each solid will be sliced into multiple solids. If False, cross-sectional surface(s) will be created for each solid.\n
            **bMatchAcrossSlice:** If True, matching surfaces will be created on both new solids. Only used when bSliceOrSection is True.\n
            **nSliceColor:** Specifies the color of the surfaces at the slice locations. To use the Active Color for Solids, specify a -1\n
            **bAlongCurveNormal:** If True, extrudes the curve along the curve normal, which can only be inferred for planar curves (i.e., arcs, circles, but NOT straight lines). If False, extrudes the curve along the vector specified with the vectorBase and vectorDirection arguments.\n
            **bAlongCurveNormal:** If True, extrudes, thus slices in the vector direction only. If False, extrudes, thus slices in both the positive and negative vector directions. Only used when bAlongCurveNormal = False\n
            **bAlongCurveNormal:** Location at base of vector to slice along\n
            **bAlongCurveNormal:** Direction of slice\n
            **bAlongCurveNormal:** If True, the curves used as slicing tools will be deleted.\n
            **bAlongCurveNormal:** If True, the graphics will be redrawn to reflect the updated solids following this operation.\n
        **Return Code:** True\n
        :type solidSET: int

        :type curveSET: int

        :type bSliceOrSection: bool

        :type bMatchAcrossSlice: bool

        :type nSliceColor: int

        :type bAlongCurveNormal: bool

        :type bAlongCurveNormal: bool

        :type bAlongCurveNormal: tuple[float]

        :type bAlongCurveNormal: tuple[float]

        :type bAlongCurveNormal: bool

        :type bAlongCurveNormal: bool

        """
        ...

    def feSolidSliceWithSheet2(self, solidSET, sheetSET, bSliceOrSection, bMatchAcrossSlice, nSliceColor, deleteTool,
                               Redraw) -> Any:
        """
        **Description:**
            Slices one or more solids with any number of sheet solids (i.e., any number of surfaces stitched together into a single body or a single surface). Also, offers an option to use each sheet solid to create a surface representing the cross-section of each solid at the slice location, instead of slicing each solid into multiple solids.
        **Remarks/Usage:**
            This method provides access to features of the Geometry, Solid, Slice command implemented in FEMAP 11.2, when Methodis set to With Sheet Solid. Also, there was never a feSolidSliceWithSheet method, as the 2 simply indicates this method was implemented at the same time as feSolidSlice2.
        **Input:**
            **solidSET:** The ID of a set that contains a list of solid IDs that will be sliced. Alternatively, if you specify a negative value, this is simply the ID of the single solid to slice.\n
            **bSliceOrSection:** If True, each solid will be sliced into multiple solids. If False, cross-sectional surface(s) will be created for each solid.\n
            **bMatchAcrossSlice:** If True, matching surfaces will be created on both new solids. Only used when bSliceOrSection is True.\n
            **nSliceColor:** Specifies the color of the surfaces at the slice locations. To use the Active Color for Solids, specify a -1\n
            **deleteTool:** If True, the sheet solids used as slicing tools will be deleted.\n
            **Redraw:** If True, the graphics will be redrawn to reflect the updated solids following this operation.\n
        **Return Code:** True\n
        :type solidSET: int

        :type bSliceOrSection: bool

        :type bMatchAcrossSlice: bool

        :type nSliceColor: int

        :type deleteTool: bool

        :type Redraw: bool

        """
        ...

    def feSolidStitch(self, surfaceSET, tolerance) -> Any:
        """
        **Description:**
            Stitches selected surfaces into solids. A solid cleanup routine is run at the end of the command to remove any redundant geometry and simplify the geometry.
        **Remarks/Usage:**
            None
        **Input:**
            **surfaceSET:** The ID of a set that contains a list of Surface IDs that will be stitched. Alternatively, if you specify a negative value, this is simply the ID of the single surface to stitch.\n
            **tolerance:** The tolerance to use when stitching the surfaces (Parasolid only). Specify 0.0 to use the default stitching tolerance.\n
        **Return Code:** True\n
        :type surfaceSET: int

        :type tolerance: float

        """
        ...

    def feSolidStitchNoCleanup(self, surfaceSET, tolerance) -> Any:
        """
        **Description:**
            Stitches selected surfaces into solids. A solid cleanup routine is NOT run at the end of the command to remove any redundant geometry, therefore all internal curves and individual surfaces remain intact.
        **Remarks/Usage:**
            None
        **Input:**
            **surfaceSET:** The ID of a set that contains a list of Surface IDs that will be stitched. Alternatively, if you specify a negative value, this is simply the ID of the single surface to stitch.\n
            **tolerance:** The tolerance to use when stitching the surfaces (Parasolid only). Specify 0.0 to use the default stitching tolerance.\n
        **Return Code:** True\n
        :type surfaceSET: int

        :type tolerance: float

        """
        ...

    def feSolidSweep(self, surfaceSET, curveSET) -> Any:
        """
        **Description:**
            Creates solid(s) by selecting any number of surfaces to be swept along any number of curves along a connected path.
        **Remarks/Usage:**
            Similar functionality to the Geometry, Solid, Sweep command.
        **Input:**
            **surfaceSET:** The ID of a set that contains a list of Surface IDs to sweep. Alternatively, if you specify a negative value, this is simply the ID of a single surface to sweep.\n
            **curveSET:** The ID of a set that contains a list of Curve IDs representing a sweep path. Alternatively, if you specify a negative value, this is simply the ID of a single curve to use as the sweep path.\n
        **Return Code:** True\n
        :type surfaceSET: int

        :type curveSET: int

        """
        ...

    def feSolidSweepBetween(self, nSurfID1, nSurfID2, nPtID1, nPtID2, blendFactor) -> Any:
        """
        **Description:**
            Creates a swept solid between from one surface to another surface by matching a point specified on one surface to a point specified on the other surface. Additionally, a blend factor may be specified to potentially change the curvature of the swept solid.
        **Remarks/Usage:**
            Similar functionality to the Geometry, Solid, Sweep Between command.
        **Input:**
            **nSurfID1:** The ID of a surface to use as the From surface\n
            **nSurfID2:** The ID of a surface to use as the To surface.\n
            **nPtID1:** The ID of a point to use as the From point\n
            **nPtID2:** The ID of a point to use as the To point.\n
            **blendFactor:** Adjusts the curvature of the swept solid (default = 1.0).\n
        **Return Code:** True\n
        :type nSurfID1: int

        :type nSurfID2: int

        :type nPtID1: int

        :type nPtID2: int

        :type blendFactor: float

        """
        ...

    def feSolidThicken(self, nSurfaceSet, dThickIn, dThickOut, nBooleanMode, bClean, bIndividual,
                       bDeleteOriginalSurface) -> Any:
        """
        **Description:**
            The method attempts to thicken a surface of a solid.
        **Remarks/Usage:**
            None
        **Input:**
            **nSurfaceSet:** ID of a Set object containing existing surfaces of a solid. Alternatively, specify as a negative value to select a single surface.\n
            **dThickIn:** The value of the distance to thicken the surface inward.\n
            **dThickOut:** The value of the distance to thicken the surface outward.\n
            **nBooleanMode:** Number of the mode to use. Use 0 for None, 1 for Add, 2 for Subtract, or 3 for Embed.\n
            **bIndividual:** If True, an attempt will be made to delete the selected surface(s). \n
        **Return Code:** False\n
        :type nSurfaceSet: int

        :type dThickIn: float

        :type dThickOut: float

        :type nBooleanMode: int

        :type bIndividual: bool

        """
        ...

    def feSplineBlend(self, curve1, near1, curve2, near2, factor, messages) -> Any:
        """
        **Description:**
            Creates a spline in that blends the ends of two curves.
        **Remarks/Usage:**
            None
        **Input:**
            **curve1:** The ID of the first curve.\n
            **near1:** Coordinates near the desired end of curve1.\n
            **curve2:** The ID of the second curve.\n
            **near2:** Coordinates near the desired end of curve2.\n
            **factor:** The blend factor - adjusts the curvature of the spline between the curves.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type curve1: int

        :type near1: tuple[float]

        :type curve2: int

        :type near2: tuple[float]

        :type factor: float

        :type messages: bool

        """
        ...

    def feSplineEllipse(self, center, vector, a, b, messages) -> Any:
        """
        **Description:**
            Creates splines in the workplane that form an ellipse.
        **Remarks/Usage:**
            None
        **Input:**
            **center:** The coordinates at the center of the ellipse.\n
            **vector:** The components of the vector along one axis of the ellipse.\n
            **a:** The radius of the ellipse along the vector.\n
            **b:** The radius of the ellipse perpendicular to the vector.\n
            **a:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type center: tuple[float]

        :type vector: tuple[float]

        :type a: float

        :type b: float

        :type a: bool

        """
        ...

    def feSplineHyperbola(self, center, towardfocus, angle, height, trim, messages) -> Any:
        """
        **Description:**
            Creates a spline in the workplane in the shape of a hyperbola.
        **Remarks/Usage:**
            None
        **Input:**
            **center:** The coordinates at the center of the hyperbola.\n
            **towardfocus:** The components of a vector in the direction pointing toward the focus from the center.\n
            **angle:** The asymptote angle.\n
            **height:** The vertex height.\n
            **trim:** The coordinates used to trim the outer end of the hyperbola.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type center: tuple[float]

        :type towardfocus: tuple[float]

        :type angle: float

        :type height: float

        :type trim: tuple[float]

        :type messages: bool

        """
        ...

    def feSplineMultipleCurves(self, cuSetID) -> Any:
        """
        **Description:**
            This method creates a spline from a set of curves.
        **Remarks/Usage:**
            None
        **Input:**
            **cuSetID:** The ID of the set of curves.\n
        **Return Code:** True\n
        :type cuSetID: int

        """
        ...

    def feSplineParabola(self, center, focus, trim, messages) -> Any:
        """
        **Description:**
            Creates a spline in the workplane in the shape of a parabola.
        **Remarks/Usage:**
            None
        **Input:**
            **center:** The coordinates at the center of the parabola.\n
            **focus:** The coordinates of the focus of the parabola.\n
            **trim:** The coordinates used to trim the outer end of the parabola.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type center: tuple[float]

        :type focus: tuple[float]

        :type trim: tuple[float]

        :type messages: bool

        """
        ...

    def feSplinePoints(self, propject, controlpoints, Count, xyz, messages) -> Any:
        """
        **Description:**
            Creates a spline using the specified points.
        **Remarks/Usage:**
            None
        **Input:**
            **propject:** Set to True if you want to project the xyz coordinates onto the workplane before creating the spline.\n
            **controlpoints:** Set to True if xys contains coordinates of the spline control points. Set to False if it contains coordinates of points that actually lie on the spline.\n
            **Count:** The number of coordinates specified in xyz. Count must be at least 4, and can be no larger than 109.\n
            **xyz:** The coordinates of the locations used to define the spline. This array contains 3 * count entries stored as: x1,y1,z1,x2,y2,z2...xN,yN,zN.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type propject: bool

        :type controlpoints: bool

        :type Count: int

        :type xyz: tuple[float]

        :type messages: bool

        """
        ...

    def feSplineTangent(self, x1, v1, x2, v2, messages) -> Any:
        """
        **Description:**
            Creates a spline using the tangent vectors at each end.
        **Remarks/Usage:**
            None
        **Input:**
            **x1:** The coordinates of the start of the spline.\n
            **v1:** The components of the starting tangent of the spline.\n
            **x2:** The coordinates of the ending location of the spline.\n
            **v2:** The components of the ending tangent of the spline.\n
            **messages:** If True, messages are written to the Messages and Lists window as the curve is created.\n
        **Return Code:** True\n
        :type x1: tuple[float]

        :type v1: tuple[float]

        :type x2: tuple[float]

        :type v2: tuple[float]

        :type messages: bool

        """
        ...

    def feSurfaceAlignedCurves(self, curveCOUNT, curveID) -> Any:
        """
        **Description:**
            Creates a surface defined by multiple aligned curves.
        **Remarks/Usage:**
            None
        **Input:**
            **curveCOUNT:** The number of curve IDs that are specified in curveID.\n
            **curveID:** The IDs of the curves that will be used to create the surface. This array must contain as many curveIDs as are specified by curveCOUNT. Furthermore, the curves must be specified in the order that they will be used to create the lofted surface.\n
        **Return Code:** True\n
        :type curveCOUNT: int

        :type curveID: tuple[int]

        """
        ...

    def feSurfaceConvert(self, surfaceSET, bDelete) -> Any:
        """
        **Description:**
            Converts FEMAP boundary surfaces into Solid (Parasolid) surfaces.
        **Remarks/Usage:**
            None
        **Input:**
            **bDelete:** If True, the original Boundary Surfaces are deleted after being converted.\n
        **Return Code:** True\n
        :type bDelete: bool

        """
        ...

    def feSurfaceCorners(self, fourCorners, c1, c2, c3, c4) -> Any:
        """
        **Description:**
            Creates a surface defined by three or four corner locations.
        **Remarks/Usage:**
            None
        **Input:**
            **fourCorners:** Set to True to define a surface from four corners, or False to define a three-corner surface.\n
            **c1, c2, c3, c4:** The corner locations. These locations should be specified in global coordinates, and must be specified in a continuous loop around the surface. When fourCorners is set to False, values must be specified in the c4 array, even though these values will be ignored\n

        **Return Code:** True\n
        :type fourCorners: bool

        :type c1: tuple[float]

        :type c2: tuple[float]

        :type c3: tuple[float]

        :type c4: tuple[float]

        """
        ...

    def feSurfaceCornersMultiple(self, NumberOfSurfaces, fourCorners, c1, c2, c3, c4) -> Any:
        """
        **Description:**
            Creates multiple surfaces, each defined by three or four corner locations.
        **Remarks/Usage:**
            None
        **Input:**
            **NumberOfSurfaces:** The number of surfaces to create.\n
            **fourCorners:** Set to True to define a surface from four corners, or False to define a three-corner surface.\n
            **c1, c2, c3, c4:** The corner locations. These locations should be specified in global coordinates, and must be specified in a continuous loop around each surface. When fourCorners is set to False, values must be specified in the c4 array for every surface, even though the values will be ignored.\n
        **Return Code:** True\n
        :type NumberOfSurfaces: int
        :type fourCorners: tuple[bool]
        :type c1: tuple[float]
        :type c2: tuple[float]
        :type c3: tuple[float]
        :type c4: tuple[float]

        """
        ...

    def feSurfaceEdgeCurves(self, curve1, curve2, curve3, curve4) -> Any:
        """
        **Description:**
            Creates a surface defined by three or four edge curves.
        **Remarks/Usage:**
            The curve IDs must be specified in order, forming a closed loop around the surface.
        **Input:**
            **curve1:** ID of the first curve to select as a surface edge\n
            **curve2:** ID of the second curve\n
            **curve3:** ID of the third curve\n
            **curve4:** ID of the fourth curve (If curve4=0, create a 3 sided surface)\n
        **Return Code:** True\n
        :type curve1: int

        :type curve2: int

        :type curve3: int

        :type curve4: int

        """
        ...

    def feSurfaceExtend(self, curveSET, shape, ExtendTo, ExtendToSolidID, ExtendToLoc, ExtendDist) -> Any:
        """
        **Description:**
            Extends a surface edge using one of several methods.
        **Remarks/Usage:**
            Although only one of the ExtendToSolidID, ExtendToLoc and ExtendDist are used depending on the value of ExtendTo, all must be provided. The values of the unused ones do not matter.
        **Input:**
            **curveSET:** ID of set containing the IDs of the curves to be used for trimming. Alternatively, if you specify a negative value, this is simply the ID of the single curve to use.\n
            **shape:** The Shape of the extended Surface 0=Linear, 1=Continuous Curvature, 2=Reflective\n
            **ExtendTo:** The Location to Extend the surface to 0=ID of Solid, 1=To Specified Location, 2=Specified Distance\n
            **ExtendTo:** Only used if ExtendTo=0. The ID of the Solid to extend surface until it hits this solid\n
            **ExtendTo:** Only used if ExtendTo=1. The location in Global Rectangular coordinates of the location to extend to.\n
            **ExtendDist:** Only used if ExtendTo=2. The distance to extend the surface\n
        **Return Code:** True\n
        :type curveSET: int

        :type shape: int

        :type ExtendTo: int

        :type ExtendTo: int

        :type ExtendTo: tuple[float]

        :type ExtendDist: float

        """
        ...

    def feSurfaceExtract(self, suSetID) -> Any:
        """
        **Description:**
            Extracts surfaces from existing Parasolid bodies (Solids, Sheet Solids, General Bodies) and creates appropriate sheet solids and/or general bodies, as needed
        **Remarks/Usage:**
            None
        **Input:**
            **suSetID:** The ID of a Set containing the IDs of one or more Surfaces to extract from an existing Parasolid body. Alternatively, if you want to extract just one surface from a Parasolid body, simply specify suSetID equal to the negative of the Surface ID.\n
        **Return Code:** True\n
        :type suSetID: int

        """
        ...

    def feSurfaceExtrude(self, curveSET, axisLEN, axisVEC) -> Any:
        """
        **Description:**
            Creates one or more surfaces by extruding a set of curves.
        **Remarks/Usage:**
            Curves are extruded from their current location along the specified vector.
        **Input:**
            **curveSET:** ID of set containing the IDs of the curves to be extruded. Alternatively, if you specify a negative value, this is simply the ID of the single curve to extrude.\n
            **axisLEN:** The length of the extrusion.\n
            **axisVEC:** The components of the extrusion vector. This vector is normalized and multiplied by axisLEN to find the total extrusion vector.\n
        **Return Code:** True\n
        :type curveSET: int

        :type axisLEN: float

        :type axisVEC: tuple[float]

        """
        ...

    def feSurfaceFromMesh(self, elemSetID, bDeleteMesh, bWireframeOnly, tolerance, bLengthCutoff, len_cut_val) -> Any:
        """
        **Description:**
            This method is obsolete and should no longer be used. It has been replaced by feSurfaceFromMesh2. Create a surface that approximates a shell element mesh.
        **Remarks/Usage:**
            None
        **Input:**
            **elemSetID:** The ID of a set that contains a list of shell element IDs that are used to create an approximate surface.\n
            **bDeleteMesh:** If True, the specified elements will be deleted when the surface is created.\n
            **bWireframeOnly:** Create only the edges/curves that bound the mesh, not the surface.\n
            **tolerance:** The tolerance that is used to calculate an approximate surface fit thru the mesh.\n
            **bLengthCutoff:** If True, the lengthCutVal is used so that any edge greater than this value will create a single line. The edge will not be included in any spline or curved edge of the surface.\n
            **len_cut_val:** The length used if bLengthCutoff is True\n
        **Return Code:** True\n
        :type elemSetID: int

        :type bDeleteMesh: bool

        :type bWireframeOnly: bool

        :type tolerance: float

        :type bLengthCutoff: bool

        :type len_cut_val: float

        """
        ...

    def feSurfaceFromMesh2(self, elemSetID, bDeleteMesh, bWireframeOnly, tolerance, bLengthCutoff, len_cut_val,
                           ang_tol) -> Any:
        """
        **Description:**
            Create a surface that approximates a shell element mesh. This method supersedes feSurfaceFromMesh.
        **Remarks/Usage:**
            None
        **Input:**
            **elemSetID:** The ID of a set that contains a list of shell element IDs that are used to create an approximate surface.\n
            **bDeleteMesh:** If True, the specified elements will be deleted when the surface is created.\n
            **bWireframeOnly:** Create only the edges/curves that bound the mesh, not the surface.\n
            **tolerance:** The tolerance that is used to calculate an approximate surface fit thru the mesh.\n
            **bLengthCutoff:** If True, the lengthCutVal is used so that any edge greater than this value will create a single line. The edge will not be included in any spline or curved edge of the surface.\n
            **len_cut_val:** The length used if bLengthCutoff is True\n
            **ang_tol:** The tolerance controls how close the resulting surface will match the average mesh normal at each node.\n
        **Return Code:** True\n
        :type elemSetID: int

        :type bDeleteMesh: bool

        :type bWireframeOnly: bool

        :type tolerance: float

        :type bLengthCutoff: bool

        :type len_cut_val: float

        :type ang_tol: float

        """
        ...

    def feSurfaceGetUnderlying(self, nSurfaceID, bAutoOffset, dOffset, dSizeFactor) -> Any:
        """
        **Description:**
            This function extracts the complete surface underlying a Parasolid face, i.e. without any of its current edge curves, it then make a parametrically rectangular patch, matching the rough size of the surface
        **Remarks/Usage:**

        **Input:**
            **nSurfaceID:** ID of the original Parasolid surface\n
            **bAutoOffset:** When True, the new surface will be offset an amount determined by the program. When False, the new surface will be offset using the value specified in dOffset\n
            **dOffset:** Distance to offset new surface from original surface when bAutoOffset is set to False\n
            **dSizeFactor:** Scale Factor applied to new surface. Setting this value above 1.0 will create a larger rectangular surface, while setting the value below 1.0 will create a smaller rectangular surface.\n
        **Return Code:** True\n
        :type nSurfaceID: int

        :type bAutoOffset: bool

        :type dOffset: float

        :type dSizeFactor: float

        """
        ...

    def feSurfaceMidAttrib(self, surfSET, matlID) -> Any:
        """
        **Description:**
            Assigns meshing attributes, including thicknesses, to surfaces that were created as midsurfaces.
        **Remarks/Usage:**
            The surface set that you specify can include surfaces that were not generated as midsurfaces, but only those surfaces that were midsurfaces will have meshing attributes assigned. This means that you can simply include all surfaces in the model and it will automatically find all the midsurfaces and assign attributes.
        **Input:**
            **surfSET:** ID of set containing the IDs of the surfaces to have attributes assigned. Alternatively, if you specify a negative value, this is simply the ID of the single surface to use.\n
            **matlID:** The ID of the material to assign as a meshing attribute.\n
        **Return Code:** True\n
        :type surfSET: int

        :type matlID: int

        """
        ...

    def feSurfaceMidAuto(self, surfSET, thick) -> Any:
        """
        **Description:**
            Creates midsurfaces between a set of selected surfaces using the Pre-V11.1 midsurfacing capabilities (i.e., does not use Parasolid face pairing algorithm).
        **Remarks/Usage:**
            Similar to the Geometry, Midsurface, Automatic command when using the pre-V11.1 Midsurface Method
        **Input:**
            **surfSET:** ID of set containing the IDs of the surfaces to be used to generate midsurfaces.\n
            **thick:** The target thickness to be used to find midsurfaces.\n
        **Return Code:** True\n
        :type surfSET: int

        :type thick: float

        """
        ...

    def feSurfaceMidAuto2(self, suSetID, dTargetThickness, bCombineTangent, dAngleTolerance, bAutoAdd,
                          bReversePairs) -> Any:
        """
        **Description:**
            Creates midsurfaces between a set of selected surfaces using Parasolid face pairing algorithm. This method is obsolete ans should no longer be used. It has been replaced by feSurfaceMidAuto3.
        **Remarks/Usage:**
            Similar to the Geometry, Midsurface, Automatic command
        **Input:**
            **suSetID:** ID of set containing the IDs of the surfaces to be used to generate midsurfaces.\n
            **dTargetThickness:** The target thickness to be used to find midsurfaces.\n
            **bCombineTangent:** When True, uses Combine Tangent Surfaces option\n
            **dAngleTolerance:** The Angle Tolerance used to determine surface tangency. Only used when bCombineTangent = True\n
            **bAutoAdd:** When True, uses Combine Midsurfaces option\n
        **Return Code:** True\n
        :type suSetID: int

        :type dTargetThickness: float

        :type bCombineTangent: bool

        :type dAngleTolerance: float

        :type bAutoAdd: bool

        """
        ...

    def feSurfaceMidAuto3(self, suSetID, dTargetThickness, bCombineTangent, dAngleTolerance, bAutoAdd, bReversePairs,
                          bVariableThick) -> Any:
        """
        **Description:**
            Creates midsurfaces between a set of selected surfaces using Parasolid face pairing algorithm
        **Remarks/Usage:**
            Similar to the Geometry, Midsurface, Automatic command
        **Input:**
            **suSetID:** ID of set containing the IDs of the surfaces to be used to generate midsurfaces.\n
            **dTargetThickness:** The target thickness to be used to find midsurfaces.\n
            **bCombineTangent:** When True, uses Combine Tangent Surfaces option\n
            **dAngleTolerance:** The Angle Tolerance used to determine surface tangency. Only used when bCombineTangent = True\n
            **bAutoAdd:** When True, uses Combine Midsurfaces option\n
            **bVariableThick:** When True, uses Variable Thickness Processing option\n
        **Return Code:** True\n
        :type suSetID: int

        :type dTargetThickness: float

        :type bCombineTangent: bool

        :type dAngleTolerance: float

        :type bAutoAdd: bool

        :type bVariableThick: bool

        """
        ...

    def feSurfaceMidAuto4(self, suSetID, dTargetThickness, bCombineTangent, dAngleTolerance, bAutoAdd, bReversePairs,
                          bVariableThick, bOverlapRepair) -> Any:
        """
        **Description:**
            Creates midsurfaces between a set of selected surfaces using Parasolid face pairing algorithm
        **Remarks/Usage:**
            Similar to the Geometry, Midsurface, Automatic command
        **Input:**
            **suSetID:** ID of set containing the IDs of the surfaces to be used to generate midsurfaces.\n
            **dTargetThickness:** The target thickness to be used to find midsurfaces.\n
            **bCombineTangent:** When True, uses Combine Tangent Surfaces option\n
            **dAngleTolerance:** The Angle Tolerance used to determine surface tangency. Only used when bCombineTangent = True\n
            **bAutoAdd:** When True, uses Combine Midsurfaces option\n
            **bVariableThick:** When True, uses Variable Thickness Processing option\n
            **bOverlapRepair:** When True, uses Overlap Repair option\n
        **Return Code:** True\n
        :type suSetID: int

        :type dTargetThickness: float

        :type bCombineTangent: bool

        :type dAngleTolerance: float

        :type bAutoAdd: bool

        :type bVariableThick: bool

        :type bOverlapRepair: bool

        """
        ...

    def feSurfaceMidSingle(self, trim, surfID1, surfID2) -> Any:
        """
        **Description:**
            Creates a midsurface between two existing surfaces.
        **Remarks/Usage:**
            None
        **Input:**
            **trim:** If True, the new surface is trimmed to lie within the bounds of the solid containing the original surfaces.\n
            **surfID1:** The first surface to use to generate the midsurface.\n
            **surfID2:** The other surface used to generate the midsurface.\n
        **Return Code:** True\n
        :type trim: bool

        :type surfID1: int

        :type surfID2: int

        """
        ...

    def feSurfaceNonManifoldAdd(self, solidSET) -> Any:
        """
        **Description:**
            Adds solids and sheet solids (surfaces) together to create a general body in parasolid using the default Non-Manifold Add Tolerance.
        **Remarks/Usage:**
            None
        **Input:**
            **solidSET:** The ID of a set that contains a list of Solid IDs that will be added to create a general body.\n
        **Return Code:** True\n
        :type solidSET: int

        """
        ...

    def feSurfaceNonManifoldAdd2(self, solidSET, dTolerance) -> Any:
        """
        **Description:**
            Adds solids and sheet solids (surfaces) together to create a general body in Parasolid using the specified Non-Manifold Add Tolerance.
        **Remarks/Usage:**
            None
        **Input:**
            **solidSET:** The ID of a set that contains a list of Solid IDs that will be added to create a general body.\n
            **dTolerance:** The tolerance at which to attempt to add the solids together.\n
        **Return Code:** True\n
        :type solidSET: int

        :type dTolerance: float

        """
        ...

    def feSurfaceNonManifoldAdd3(self, solidSET, dTolerance, bIntermediateCheck) -> Any:
        """
        **Description:**
            Adds solids and sheet solids (surfaces) together to create a general body in parasolid using a user-specified Non-Manifold Add Tolerance value. Also has an option to enable or disable Incremental Checking when more than 2 solids and/or sheet solids are being Non-Manifold added together.
        **Remarks/Usage:**
            None
        **Input:**
            **solidSET:** The ID of a set that contains a list of Solid IDs that will be added to create a general body.\n
            **bIntermediateCheck:** If True, Incremental Checking will be enabled, meaning that the general body is checked after each solid or sheet solid is added to the general body to make sure it passes body checking. If the addition of a solid or sheet solid causes the general body to fail body checking, that addition will be rolled back and that solid or sheet solid will not be added to the general body. If False, Incremental Checking will not be done.\n
        **Return Code:** True\n
        :type solidSET: int

        :type bIntermediateCheck: bool

        """
        ...

    def feSurfaceNonManifoldAddExpress(self, solidSetID, dTolerance) -> Any:
        """
        **Description:**
            Adds solids and sheet solids (surfaces) together to create a general body using a single call to the Parasolid engine and also allows a user-specified Non-Manifold Add Tolerance value.
        **Remarks/Usage:**
            None
        **Input:**
            **solidSetID:** The ID of a set that contains a list of Solid IDs that will be added to create a general body.\n
        **Return Code:** True\n
        :type solidSetID: int

        """
        ...

    def feSurfaceNormalDeviation(self, surfaceSetID, dAvgNormal, dMaxAngle) -> Any:
        """
        **Description:**
            Finds the average normal of a set of surfaces and the maximum deviation of the normal from that average
        **Remarks/Usage:**
            None
        **Input:**
            **surfaceSetID:** The ID of a Set containing the IDs of one or more Surfaces. If you want to test just one surface, simply specify surfaceSetID equal to the negative of the Surface ID.\n
        **Output:**
            **dAvgNormal:** The vector components of the average normal to the entire set of selected surfaces\n
            **dMaxAngle:** The maximum angle, in degrees, that any surface normal deviates from the vector returned in dAvgNormal.\n
        **Return Code:** True\n
        :type surfaceSetID: int

        :type dAvgNormal: tuple[float]

        :type dMaxAngle: float

        """
        ...

    def feSurfaceOffset(self, surfID, dOffset) -> Any:
        """
        **Description:**
            Creates a new surface offset from the original surface by the specified amount. This method is obsolete and should no longer be used. It has been replaced by feSurfaceOffset2.
        **Remarks/Usage:**
            None
        **Input:**
            **surfID:** ID of surface to offset\n
            **dOffset:** Offset value. Positive value = offset direction matches surface normal, negative value = offset direction opposite surface normal.\n
        **Return Code:** True\n
        :type surfID: int

        :type dOffset: float

        """
        ...

    def feSurfaceOffset2(self, surfaceSET, dOffset) -> Any:
        """
        **Description:**
            Creates a new surface offset from the original surface(s) by the specified amount.
        **Remarks/Usage:**
            None
        **Input:**
            **surfaceSET:** ID of the set object containing the surfaces to offset. Alternatively use a negative value to identify a single surface.\n
            **dOffset:** Offset value. Positive value = offset direction matches surface normal, negative value = offset direction opposite surface normal.\n
        **Return Code:** True\n
        :type surfaceSET: int

        :type dOffset: float

        """
        ...

    def feSurfaceOffsetTangent(self, nSeedSurface, dTolerance, bAutoOffset, dOffset, bDeleteOriginal,
                               bCreateGroup) -> Any:
        """
        **Description:**
            Creates midsurfaces by offsetting a set of surfaces tangent to specified seed surface
        **Remarks/Usage:**
            None
        **Input:**
            **nSeedSurface:** Seed surface ID to find tangent surfaces.\n
            **dTolerance:** Tangency tolerance (default in GUI is 0.1). Value between 0.0 and 360.0.\n
            **bAutoOffset:** Automatically attempt to offset to the solid mid-thickness\n
            **dOffset:** Offset value, ignored if bAutoOffset is TRUE\n
            **bDeleteOriginal:** Delete the original solid\n
            **bCreateGroup:** Create a group of new surfaces\n
        **Return Code:** True\n
        :type nSeedSurface: int

        :type dTolerance: float

        :type bAutoOffset: bool

        :type dOffset: float

        :type bDeleteOriginal: bool

        :type bCreateGroup: bool

        """
        ...

    def feSurfaceRayFire(self, suSetID, nNumRay, vRayLoc, vRayDir, nHitSurface, vHitLoc) -> Any:
        """
        **Description:**
            This method finds the locations on surfaces hit by rays specified by the user
        **Remarks/Usage:**

        **Input:**
            **nNumRay:** The number of rays that are contained in vRayLoc, vRayDir\n
            **vRayLoc:** The location of the base of the ray/vector in Global Rectangular coordinates\n
            **vRayDir:** The components of the direction of the ray\n
        **Output:**
            **nHitSurface:** The ID of the surface that each ray hits (0 if it misses all surfaces)\n
            **vHitLoc:** The Global Rectangular XYZ coordinates where the ray hit the surfaces\n
        **Return Code:** True\n
        :type nNumRay: int

        :type vRayLoc: tuple[float]

        :type vRayDir: tuple[float]

        :type nHitSurface: tuple[int]

        :type vHitLoc: tuple[float]

        """
        ...

    def feSurfaceRecoverManifold(self, solidSET) -> Any:
        """
        **Description:**
            Recovers manifold solids and sheet solids from General Bodies created using NonManifold Add command.
        **Remarks/Usage:**
            None
        **Input:**
            **solidSET:** The ID of a set that contains a list of Solid IDs (General Body IDs) to recover manifold geometry from. Alternatively, if you specify a negative value, this is simply the ID of the single General Body.\n
        **Return Code:** True\n
        :type solidSET: int

        """
        ...

    def feSurfaceRemoveHole(self, curveSET) -> Any:
        """
        **Description:**
            Removes holes from a surface by curve.
        **Remarks/Usage:**
            None
        **Input:**
            **curveSET:** The ID of a set that contains a list of Curve IDs that are part of a one or more holes to remove from a surface. Alternatively, if you specify a negative value, this is simply the ID of the single curve.\n
        **Return Code:** True\n
        :type curveSET: int

        """
        ...

    def feSurfaceRevolve(self, curveSET, axisANGLE, axisBASE, axisVEC) -> Any:
        """
        **Description:**
            Creates one or more surfaces by revolving a set of curves.
        **Remarks/Usage:**
            Curves are revolved from their current location around the specified vector.
        **Input:**
            **curveSET:** ID of set containing the IDs of the curves to be revolved. Alternatively, if you specify a negative value, this is simply the ID of the single curve to revolve.\n
            **axisANGLE:** The angle of revolution, in degrees.\n
            **axisBASE:** A location, specified in global coordinates, that defines the base of the axis of revolution.\n
            **axisVEC:** The components of the axis of revolution. This vector will be located at the axisBASE location, and the curves will be revolved around it.\n
        **Return Code:** True\n
        :type curveSET: int

        :type axisANGLE: float

        :type axisBASE: tuple[float]

        :type axisVEC: tuple[float]

        """
        ...

    def feSurfaceRuled(self, cu1, cu2) -> Any:
        """
        **Description:**
            Creates a ruled surface between two curves.
        **Remarks/Usage:**
            None
        **Input:**
            **cu1:** The ID of the first curve used to define the surface.\n
            **cu2:** The ID of the second curve used to define the surface.\n
        **Return Code:** True\n
        :type cu1: int

        :type cu2: int

        """
        ...

    def feSurfaceSweep(self, curveSET, pathSET) -> Any:
        """
        **Description:**
            Creates one or more surfaces by sweeping a set of curves along a path.
        **Remarks/Usage:**
            None
        **Input:**
            **curveSET:** ID of set containing the IDs of the curves to be swept. Alternatively, if you specify a negative value, this is simply the ID of the single curve to sweep.\n
            **pathSET:** ID of a set containing the IDs of the curves to be used as a path. Alternatively, if you specify a negative value, this is simply the ID of the single curve to use as the path. If you specify a set, the curves must form a single connected path. If you are not using the standard FEMAP geometry engine, then this set must contain a single curve. Only the standard engine can sweep along a multicurve path.\n
        **Return Code:** True\n
        :type curveSET: int

        :type pathSET: int

        """
        ...

    def feSurfaceTrimToSolid(self, sheetID, solidID) -> Any:
        """
        **Description:**
            Trims an open, sheet solid to the boundaries of a solid that contains it.
        **Remarks/Usage:**
            None
        **Input:**
            **sheetID:** The ID of the solid that is defined by the surfaces that are to be trimmed.\n
            **solidID:** The ID of the bounding solid used to trim the sheet.\n
        **Return Code:** True\n
        :type sheetID: int

        :type solidID: int

        """
        ...

    def feSurfaceTrimWithCurves(self, surfID, curveSET) -> Any:
        """
        **Description:**
            Trims a surface with one or more curves.
        **Remarks/Usage:**
            None
        **Input:**
            **surfID:** The ID of the surface to be trimmed.\n
            **curveSET:** ID of set containing the IDs of the curves to be used for trimming. Alternatively, if you specify a negative value, this is simply the ID of the single curve to use.\n
        **Return Code:** True\n
        :type surfID: int

        :type curveSET: int

        """
        ...

    def feTextGet(self, textID, DrawPointer, DrawBorder, modelPos, horzJust, vertJust, visView, layer, fontID,
                  BackColor, bordColor, textColor, textLoc, pointerLoc, text) -> Any:
        """
        **Description:**
            This function retrieves a text entity.
        **Remarks/Usage:**
            None
        **Input:**
            **textID:** The ID of the text entity to create or update.\n
        **Output:**
            **DrawPointer:** The status of the pointer (True=On).\n
            **DrawBorder:** The status of the border (True=On).\n
            **modelPos:** If True, both the textLoc and pointerLoc are in global Cartesian model coordinates. If False, they are in screen coordinates.\n
            **horzJust:** The horizontal justification: 0=Center, 1=Left, 2=Right.\n
            **vertJust:** The vertical justification: 0=Center, 1=Top, 2=Bottom.\n
            **visView:** Specifies the views where the text will be visible: -1=All Views, 0=Currently Active View, >0=Specified View ID.\n
            **layer:** The layer attribute for the text.\n
            **fontID:** The ID of the font for the text. Same fonts as in the Tools, Text command.\n
            **BackColor:** The color of the background of the border (if drawBorder=True).\n
            **bordColor:** The color of the edge of the border (if drawBorder=True).\n
            **textColor:** The color of the text.\n
            **textLoc:** The location of the text. If in model coordinates, the X,Y,Z coordinates in global Cartesian. If in screen, the X and Y screen coordinates. In this case the third coordinate should always be 0.0.\n
            **pointerLoc:** The location of the tip of the pointer.\n
            **text:** The text. If there are multiple lines of text, there will be carriage return and linefeed characters in the string.\n
        **Return Code:** True\n
        :type textID: int

        :type DrawPointer: bool

        :type DrawBorder: bool

        :type modelPos: bool

        :type horzJust: int

        :type vertJust: int

        :type visView: int

        :type layer: int

        :type fontID: int

        :type BackColor: int

        :type bordColor: int

        :type textColor: int

        :type textLoc: tuple[float]

        :type pointerLoc: tuple[float]

        :type text: str

        """
        ...

    def feTextMultiPut(self, DrawPointer, DrawBorder, modelPos, horzJust, vertJust, visView, layer, fontID, BackColor,
                       bordColor, textColor, nCount, textLoc, pointerLoc, tText) -> Any:
        """
        **Description:**
            This function creates multiple text annotations.
        **Remarks/Usage:**
            If you want to create text with multiple lines, you must add carriage return (CR) and linefeed (LF) characters between the lines. For example, from Basic, you could use:
        **Input:**
            **DrawPointer:** If True, a pointer will be drawn from the text to a location that you specify in pointerLoc.\n
            **DrawBorder:** If True, a border will be drawn around the text.\n
            **modelPos:** If True, both the textLoc and pointerLoc are in global Cartesian model coordinates. If False, they are in screen coordinates.\n
            **horzJust:** The horizontal justification: 0=Center, 1=Left, 2=Right.\n
            **vertJust:** The vertical justification: 0=Center, 1=Top, 2=Bottom.\n
            **visView:** Specifies the views where the text will be visible: -1=All Views, 0=Currently Active View, >0=Specified View ID.\n
            **layer:** The layer attribute for the text.\n
            **fontID:** The ID of the font for the text. Same fonts as in the Tools, Text command.\n
            **bordColor:** The color of the edge of the border (if drawBorder=True).\n
            **textColor:** The color of the text.\n
            **nCount:** The number of text items to create. This value specifies the number of entries in the remaining parameters\n
            **textLoc:** The location of the text. If in model coordinates, the X,Y,Z coordinates in global Cartesian. If in screen, the X and Y screen coordinates. In this case, the third coordinate should always be 0.0. Entries in this array are stored [Text1X,Text1Y,Text1Z,Text2X,...TextNZ]\n
            **tText:** The text items to create. Each string creates a unique Text entity.\n
        **Return Code:** False\n
        :type DrawPointer: bool

        :type DrawBorder: bool

        :type modelPos: bool

        :type horzJust: int

        :type vertJust: int

        :type visView: int

        :type layer: int

        :type fontID: int

        :type bordColor: int

        :type textColor: int

        :type nCount: int

        :type textLoc: tuple[float]

        :type tText: tuple[str]

        """
        ...

    def feTextPut(self, textID, DrawPointer, DrawBorder, modelPos, horzJust, vertJust, visView, layer, fontID,
                  BackColor, bordColor, textColor, textLoc, pointerLoc, tText) -> Any:
        """
        **Description:**
            This function creates or updates a text annotation.
        **Remarks/Usage:**
            If you want to create text with multiple lines, you must add carriage return (CR) and linefeed (LF) characters between the lines. For example, from Basic, you could use:
        **Input:**
            **textID:** The ID of the text entity to create or update.\n
            **DrawPointer:** If True, a pointer will be drawn from the text to a location that you specify in pointerLoc.\n
            **DrawBorder:** If True, a border will be drawn around the text.\n
            **modelPos:** If True, both the textLoc and pointerLoc are in global Cartesian model coordinates. If False, they are in screen coordinates.\n
            **horzJust:** The horizontal justification: 0=Center, 1=Left, 2=Right.\n
            **vertJust:** The vertical justification: 0=Center, 1=Top, 2=Bottom.\n
            **visView:** Specifies the views where the text will be visible: -1=All Views, 0=Currently Active View, >0=Specified View ID.\n
            **layer:** The layer attribute for the text.\n
            **fontID:** The ID of the font for the text. Same fonts as in the Tools, Text command.\n
            **BackColor:** The color of the background of the border (if drawBorder=True).\n
            **bordColor:** The color of the edge of the border (if drawBorder=True).\n
            **textColor:** The color of the text.\n
            **textLoc:** The location of the text. If in model coordinates, the X,Y,Z coordinates in global Cartesian. If in screen, the X and Y screen coordinates. In this case, the third coordinate should always be 0.0\n
            **pointerLoc:** The location of the tip of the pointer.\n
            **tText:** The text to create.\n
        **Return Code:** False\n
        :type textID: int

        :type DrawPointer: bool

        :type DrawBorder: bool

        :type modelPos: bool

        :type horzJust: int

        :type vertJust: int

        :type visView: int

        :type layer: int

        :type fontID: int

        :type BackColor: int

        :type bordColor: int

        :type textColor: int

        :type textLoc: tuple[float]

        :type pointerLoc: tuple[float]

        :type tText: str

        """
        ...

    def feToolUnitConvert(self, baseMult, baseAdd, factorMult, factorAdd) -> Any:
        """
        **Description:**
            This function converts the units of the current model.
        **Remarks/Usage:**
            For baseMult[ ] and baseAdd[ ] the array indices are:
        **Input:**
            **baseMult:** Base factors used to multiply dimensions.\n
            **baseAdd:** Base factors added to converted dimensions.\n
            **factorMult:** Computed factors used to multiply dimensions\n
            **factorAdd:** Computed factors added to converted dimensions.\n
        **Return Code:** True\n
        :type baseMult: tuple[float]

        :type baseAdd: tuple[float]

        :type factorMult: tuple[float]

        :type factorAdd: tuple[float]

        """
        ...

    def feToolUnitConvertFactors(self, baseMult, baseAdd, factorMult, factorAdd) -> Any:
        """
        **Description:**
            This function computes the computed factors to use in a unit conversion of the current model.
        **Remarks/Usage:**
            For baseMult[ ] and baseAdd[ ] the array indices are:
        **Input:**
            **baseMult:** Base factors used to multiply dimensions.\n
            **baseAdd:** Base factors added to converted dimensions.\n
        **Output:**
            **factorMult:** Computed factors used to multiply dimensions\n
            **factorAdd:** Computed factors added to converted dimensions.\n
        **Return Code:** True\n
        :type baseMult: tuple[float]

        :type baseAdd: tuple[float]

        :type factorMult: tuple[float]

        :type factorAdd: tuple[float]

        """
        ...

    def feTruncateReal(self, dValue, nWidth, nDecimal, nFormat, truncValue) -> Any:
        """
        **Description:**
            Truncates a real number to the precision of a formatted text string.
        **Remarks/Usage:**
            This is the same as calling feFormatReal() and then parsing the resulting text string into a new real variable.
        **Input:**
            **dValue:** The real value to format\n
            **nWidth:** The overall width of the text string to produce\n
            **nDecimal:** The number of significant figures to attempt to format. Must be able to fit within the specified width\n
            **nFormat:** The formatting method to use 0=Normal, 1=Force Exponential, 2=Nastran\n
        **Output:**
            **truncValue:** The precision truncated version of the formatted real number\n
        **Return Code:** False\n
        :type dValue: float

        :type nWidth: int

        :type nDecimal: int

        :type nFormat: int

        :type truncValue: float

        """
        ...

    def feUnLockAbort(self) -> Any:
        """
        """
        ...

    def feUnlockApiOnly(self, nCode) -> Any:
        """
        :type nCode: Any
        """
        ...

    def feUnlockOEM(self, nCode) -> Any:
        """
        :type nCode: Any
        """
        ...

    def feVarEval(self, vareqn, varvalue) -> Any:
        """
        **Description:**
            This function evaluates an equation.
        **Remarks/Usage:**
            This function does not store its results or create any variables. It simply evaluates the expression that you supply.
        **Input:**
            **vareqn:** The equation to be evaluated. This string can follow the syntax of any equation that you can define in FEMAP, including the use of functions and other variables.\n
        **Output:**
            **varvalue:** Evaluated value for the equation.\n
        **Return Code:** True\n
        :type vareqn: str

        :type varvalue: float

        """
        ...

    def feVarGet(self, varname, varvalue, vareqn) -> Any:
        """
        **Description:**
            This function retrieves a variable including its current value and defining equation.
        **Remarks/Usage:**
            None
        **Input:**
            **varname:** Specifies the name of the variable to retrieve. Must follow normal FEMAP variable naming conventions - start with a letter, unique to 5 characters.\n
        **Output:**
            **varvalue:** Current evaluated value for the variable.\n
            **vareqn:** The defining equation for the variable.\n
        **Return Code:** True\n
        :type varname: str

        :type varvalue: float

        :type vareqn: str

        """
        ...

    def feVarPut(self, varname, evalEqn, setConst, varvalue, vareqn) -> Any:
        """
        **Description:**
            This function adds a variable/equation to the model.
        **Remarks/Usage:**
            Normally you will not specify both evalEqn=True and setConst=True, but if you do, evalEqn is done first. Your original varEqn will be evaluated to find a constant which will then overwrite the original equation.
        **Input:**
            **varname:** Specifies the name of the variable to define. Must follow normal FEMAP variable naming conventions - start with a letter, unique to 5 characters.\n
            **evalEqn:** If True, the varEqn equation is evaluated to compute varValue.\n
            **setConst:** If True, the varValue value is converted to a text string and used as a constant equation in varEqn.\n
            **varvalue:** Current evaluated value for the variable. Should be the current value of the equation specified.\n
            **vareqn:** The defining equation for the variable.\n
        **Return Code:** True\n
        :type varname: str

        :type evalEqn: bool

        :type setConst: bool

        :type varvalue: float

        :type vareqn: str

        """
        ...

    def feVectorAngle(self, VecA, VecB, angle) -> Any:
        """
        **Description:**
            This function computes the angle between two vectors. 
        **Remarks/Usage:**
            The angle is always between 0 and 180 degrees. There is no indication or consideration of the direction of the included angle between the vectors.
        **Input:**
            **VecA:** The components of the first vector.\n
            **VecB:** The components of the second vector.\n
        **Output:**
            **angle:** The included angle between the two vectors.\n
        **Return Code:** False\n
        :type VecA: tuple[float]

        :type VecB: tuple[float]

        :type angle: float

        """
        ...

    def feVectorAngleAxis(self, VecA, VecB, vecAXIS, angle) -> Any:
        """
        **Description:**
            This function computes the angle between two vectors rotating around an axis. 
        **Remarks/Usage:**
            The angle is always between -180 and 180 degrees. If the angle subtended when going from vecA to vecB is in a positive direction (right-hand rule sense) around the axis of rotation, then the returned angle is positive; otherwise a negative angle is returned.
        **Input:**
            **VecA:** The components of the first vector.\n
            **VecB:** The components of the second vector.\n
            **vecAXIS:** The components of the axis of rotation.\n
        **Output:**
            **angle:** The included angle between the two vectors.\n
        **Return Code:** False\n
        :type VecA: tuple[float]

        :type VecB: tuple[float]

        :type vecAXIS: tuple[float]

        :type angle: float

        """
        ...

    def feVectorArrayTransform(self, Count, fromCSYS, toCSYS, baseXYZ, fromxyz, xyz) -> Any:
        """
        **Description:**
            This function transforms an array of vectors from one coordinate system to another.
        **Remarks/Usage:**
            None
        **Input:**
            **Count:** The number of vectors to be transformed, not the total size of the baseXYZ and fromXYZ arrays.\n
            **fromCSYS:** The ID of the coordinate system in which the fromXYZ coordinates are currently specified. Specify 0 for global rectangular.\n
            **baseXYZ:** The coordinates at the base of the vector to be transformed. Must be specified in the fromCSYS coordinate system.\n
            **fromxyz:** The components of the vector to be transformed. Must be specified in the fromCSYS coordinate system.\n
        **Output:**
            **xyz:** The transformed vector components for each original vector, returned in the toCSYS coordinate system.\n
        **Return Code:** True\n
        :type Count: int

        :type fromCSYS: int

        :type baseXYZ: tuple[float]

        :type fromxyz: tuple[float]

        :type xyz: tuple[float]

        """
        ...

    def feVectorAxis(self, csysID, Axis, positive, vecDIR) -> Any:
        """
        **Description:**
            This function creates a unit vector in the direction of one of the axes of a coordinate system.
        **Remarks/Usage:**
            The components in vecDir will always be those of a unit vector.
        **Input:**
            **csysID:** The ID of the coordinate system to use for the vector definition.\n
            **Axis:** Set to 0=X axis, 1=Y axis, 2=Z axis.\n
            **positive:** True if you want the positive axis; False for the negative axis.\n
        **Output:**
            **vecDIR:** The components of the vector.\n
        **Return Code:** True\n
        :type csysID: int

        :type Axis: int

        :type positive: bool

        :type vecDIR: tuple[float]

        """
        ...

    def feVectorAxisOfSurface(self, suID, baseXYZ, vecDIR) -> Any:
        """
        **Description:**
            This function returns the axis of revolution for a surface.
        **Remarks/Usage:**
            None
        **Input:**
            **suID:** The ID of the surface to find revolution axis.\n
        **Output:**
            **baseXYZ:** The coordinates at the base of the revolution vector.\n
            **vecDIR:** The components of the revolution vector.\n
        **Return Code:** True\n
        :type suID: int

        :type baseXYZ: tuple[float]

        :type vecDIR: tuple[float]

        """
        ...

    def feVectorCrossProduct(self, VecA, VecB, vecAxB) -> Any:
        """
        **Description:**
            This function computes the cross product of two vectors.
        **Remarks/Usage:**
            None
        **Input:**
            **VecA:** The components of the first vector.\n
            **VecB:** The components of the second vector.\n
        **Output:**
            **VecA:** The components of the cross product of the two vectors.\n
        **Return Code:** False\n
        :type VecA: tuple[float]

        :type VecB: tuple[float]

        :type VecA: tuple[float]

        """
        ...

    def feVectorDotProduct(self, VecA, VecB, dot) -> Any:
        """
        **Description:**
            This function computes the dot (scalar) product of two vectors.
        **Remarks/Usage:**
            In versions prior to v10.3, this method normalized the supplied vectors prior to computing the dot product. It now computes a true dot product and a new method feVectorNormalizedDotProduct( ) was added to provide the previous functionality.
        **Input:**
            **VecA:** The components of the first vector.\n
            **VecB:** The components of the second vector.\n
        **Output:**
            **dot:** The scalar product of the two vectors.\n
        **Return Code:** False\n
        :type VecA: tuple[float]

        :type VecB: tuple[float]

        :type dot: float

        """
        ...

    def feVectorFromBeam(self, elemID, bmXYZ, xyz) -> Any:
        """
        **Description:**
            This function transforms a vector from beam/bar elemental coordinates to global rectangular.
        **Remarks/Usage:**
            The element specified must exist, and must be an appropriate line element (beam, bar...) type.
        **Input:**
            **elemID:** The ID of the element that defines the coordinate system where the bmXYZ components are defined.\n
            **bmXYZ:** The components of the vector to be transformed. Must be specified in the elemental coordinate system of element elemID.\n
        **Output:**
            **xyz:** The transformed vector components, returned in the global rectangular coordinate system.\n
        **Return Code:** False\n
        :type elemID: int

        :type bmXYZ: tuple[float]

        :type xyz: tuple[float]

        """
        ...

    def feVectorLength(self, xyz, vecLength) -> Any:
        """
        **Description:**
            This function computes the length of a vector.
        **Remarks/Usage:**
            None
        **Input:**
            **xyz:** The components of the vector to be measure. Must be specified in rectangular coordinates.\n
        **Output:**
            **vecLength:** The length of the vector.\n
        **Return Code:** False\n
        :type xyz: tuple[float]

        :type vecLength: float

        """
        ...

    def feVectorNormalToSurface(self, suID, baseXYZ, vecDIR) -> Any:
        """
        **Description:**
            This function returns a unit vector that is the normal to a surface at a specified location.
        **Remarks/Usage:**
            The components in vecDir will always be those of a unit vector. If the location specified in baseXYZ is not on the surface, it will be projected onto the surface and the normal will be at the projected location.
        **Input:**
            **suID:** The ID of the surface used to compute the normal.\n
            **baseXYZ:** The coordinates of the location used to compute the normal.\n
        **Output:**
            **vecDIR:** The components of the normal vector at baseXYZ.\n
        **Return Code:** True\n
        :type suID: int

        :type baseXYZ: tuple[float]

        :type vecDIR: tuple[float]

        """
        ...

    def feVectorNormalToView(self, vuID, vecDIR) -> Any:
        """
        **Description:**
            This function returns a unit vector that is the normal to a view.
        **Remarks/Usage:**
            The components in vecDir will always be those of a unit vector. The normal vector always points out of the screen.
        **Output:**
            **vecDIR:** The components of the normal vector.\n
        **Return Code:** True\n
        :type vecDIR: tuple[float]

        """
        ...

    def feVectorNormalizedDotProduct(self, VecA, VecB, dot) -> Any:
        """
        **Description:**
            This function normalizes the supplied vectors and computes their dot (scalar) product.
        **Remarks/Usage:**
            The result of this method is the cosine of the angle between the vectors.
        **Input:**
            **VecA:** The components of the first vector.\n
            **VecB:** The components of the second vector.\n
        **Output:**
            **dot:** The scalar product of the two vectors.\n
        **Return Code:** False\n
        :type VecA: tuple[float]

        :type VecB: tuple[float]

        :type dot: float

        """
        ...

    def feVectorPerpendicular(self, vecIN, vecPERP) -> Any:
        """
        **Description:**
            This function computes an arbitrary vector that is perpendicular to the specified vector.
        **Remarks/Usage:**
            If the vector specified is aligned with a global axis, you will always get a different global axis returned. If not, a cross product with either the global X (or global Z if the original vector is too close to the global X axis) is used to determine the perpendicular.
        **Input:**
            **vecIN:** The components of the first vector.\n
        **Output:**
            **vecPERP:** The perpendicular vector.\n
        **Return Code:** False\n
        :type vecIN: tuple[float]

        :type vecPERP: tuple[float]

        """
        ...

    def feVectorPick(self, dlgTITLE, unitVector, vecLength, vecBASE, vecDIR) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to pick or enter vectors.
        **Remarks/Usage:**
            The components in vecDir will always be those of a unit vector. The vector length is always returned in vecLength.
        **Input:**
            **dlgTITLE:** A string that specifies a title to be added to the dialog box title.\n
            **unitVector:** Set to False if you want the user to be able to enter a vector length.\n
        **Output:**
            **vecLength:** The length of the vector. This will be 1.0 if unitVector=True.\n
            **vecBASE:** The coordinates at the base of the vector.\n
            **vecDIR:** The components of the vector.\n
        **Return Code:** True\n
        :type dlgTITLE: str

        :type unitVector: bool

        :type vecLength: float

        :type vecBASE: tuple[float]

        :type vecDIR: tuple[float]

        """
        ...

    def feVectorPickByMethod(self, method, dlgTITLE, unitVector, vecLength, vecBASE, vecDIR) -> Any:
        """
        **Description:**
            This function displays a dialog box to allow a user to pick or enter vectors. Same as feVectorPick except that you can specify the initial dialog box method.
        **Remarks/Usage:**
            The components in vecDir will always be those of a unit vector. The vector length is always returned in vecLength.
        **Input:**
            **method:** The initial dialog box method. Refer to Vector Dialog Methods for possible values.\n
            **dlgTITLE:** A string that specifies a title to be added to the dialog box title.\n
            **unitVector:** Set to False if you want the user to be able to enter a vector length.\n
        **Output:**
            **vecLength:** The length of the vector. This will be 1.0 if unitVector=True.\n
            **vecBASE:** The coordinates at the base of the vector.\n
            **vecDIR:** The components of the vector.\n
        **Return Code:** True\n
        :type method: int

        :type dlgTITLE: str

        :type unitVector: bool

        :type vecLength: float

        :type vecBASE: tuple[float]

        :type vecDIR: tuple[float]

        """
        ...

    def feVectorPlaneIntersect(self, baseA, normA, baseB, normB, ptV, dirV) -> Any:
        """
        **Description:**
            This function computes the vector at the intersection of two planes.
        **Remarks/Usage:**
            All coordinates and components must be specified in the same rectangular coordinate system - normally global rectangular.
        **Input:**
            **baseA:** The coordinates of a location on the first plane.\n
            **normA:** The components of the normal vector of the first plane.\n
            **baseB:** The coordinates of a location on the second plane.\n
            **normB:** The components of the normal vector of the second plane.\n
        **Output:**
            **ptV:** The coordinates of a location on the intersection vector.\n
            **dirV:** The components of the vector along the line of intersection.\n
        **Return Code:** False\n
        :type baseA: tuple[float]

        :type normA: tuple[float]

        :type baseB: tuple[float]

        :type normB: tuple[float]

        :type ptV: tuple[float]

        :type dirV: tuple[float]

        """
        ...

    def feVectorRotate(self, baseXYZ, vecXYZ, angle, origin, Axis, baseROT, vecROT) -> Any:
        """
        **Description:**
            This function returns a vector computed from rotating the original vector around a given axis using the specified angle, in degrees
        **Remarks/Usage:**
            None
        **Input:**
            **baseXYZ:** The coordinates at the base of the original vector.\n
            **vecXYZ:** The components of the original vector.\n
            **angle:** Rotation angle in degrees\n
            **origin:** The coordinates at the base of the vector to rotate about.\n
            **Axis:** The components of the vector to rotate about.\n
        **Output:**
            **baseROT:** The coordinates at the base of the rotated vector.\n
            **vecROT:** The components of the rotated vector.\n
        **Return Code:** True\n
        :type baseXYZ: tuple[float]

        :type vecXYZ: tuple[float]

        :type angle: float

        :type origin: tuple[float]

        :type Axis: tuple[float]

        :type baseROT: tuple[float]

        :type vecROT: tuple[float]

        """
        ...

    def feVectorTangentToCurve(self, cuID, baseXYZ, vecDIR) -> Any:
        """
        **Description:**
            This function returns a unit vector that is the tangent to a curve at a specified location.
        **Remarks/Usage:**
            The components in vecDir will always be those of a unit vector. If the location specified in baseXYZ is not on the curve, it will be projected onto the curve and the tangent will be at the projected location.
        **Input:**
            **cuID:** The ID of the curve used to compute the tangent.\n
            **baseXYZ:** The coordinates of the location used to compute the tangent.\n
        **Output:**
            **vecDIR:** The components of the tangent vector at baseXYZ.\n
        **Return Code:** True\n
        :type cuID: int

        :type baseXYZ: tuple[float]

        :type vecDIR: tuple[float]

        """
        ...

    def feVectorToBeam(self, elemID, xyz, bmXYZ) -> Any:
        """
        **Description:**
            This function transforms a vector from global rectangular coordinates into beam/bar elemental coordinates.
        **Remarks/Usage:**
            The element specified must exist, and must be an appropriate line element (beam, bar...) type.
        **Input:**
            **elemID:** The ID of the element that defines the coordinate system where the bmXYZ components are defined.\n
            **xyz:** The components of the vector to be transformed. Must be specified in global rectangular coordinates.\n
        **Output:**
            **bmXYZ:** The transformed vector components, returned in the elemental coordinates of elemID.\n
        **Return Code:** False\n
        :type elemID: int

        :type xyz: tuple[float]

        :type bmXYZ: tuple[float]

        """
        ...

    def feVectorTransform(self, fromCSYS, baseXYZ, fromxyz, toCSYS, xyz) -> Any:
        """
        **Description:**
            This function transforms vectors from one coordinate system to another.
        **Remarks/Usage:**
            None
        **Input:**
            **fromCSYS:** The ID of the coordinate system in which the fromXYZ coordinates are currently specified. Specify 0 for global rectangular.\n
            **baseXYZ:** The coordinates at the base of the vector to be transformed. Must be specified in the fromCSYS coordinate system.\n
            **fromxyz:** The components of the vector to be transformed. Must be specified in the fromCSYS coordinate system.\n
            **toCSYS:** The ID of the coordinate system to transform into.\n
        **Output:**
            **xyz:** The transformed vector components, returned in the toCSYS coordinate system.\n
        **Return Code:** True\n
        :type fromCSYS: int

        :type baseXYZ: tuple[float]

        :type fromxyz: tuple[float]

        :type toCSYS: int

        :type xyz: tuple[float]

        """
        ...

    def feVectorUnit(self, vecIN, vecOUT) -> Any:
        """
        **Description:**
            This function normalizes a vector to make it into an equivalent unit vector.
        **Remarks/Usage:**
            In addition to simply dividing by the length of the vector, this function also completely eliminates components of the vector that are very small ( less than 1E-8 times the length) compared to the other components. This helps to eliminate numerical errors which can creep in during transformations or other vector operations.
        **Input:**
            **vecIN:** The componets of the vector to be normalized\n
        **Output:**
            **vecOUT:** The normalized vector\n
        **Return Code:** False\n
        :type vecIN: tuple[float]

        :type vecOUT: tuple[float]

        """
        ...

    def feViewAllViews(self, on_off) -> Any:
        """
        **Description:**
            This function turns on and off the All Views functionality.
        **Remarks/Usage:**
            Same as the View, All Views command.
        **Input:**
            **on_off:** Set to True to enable All Views; False to only update a single view.\n
        **Return Code:** False\n
        :type on_off: bool

        """
        ...

    def feViewAutoscaleAll(self, vuID, redoBox) -> Any:
        """
        **Description:**
            This method performs an autoscale on the selected view using all of the entities in the model, visible or hidden
        **Remarks/Usage:**
            The selected view does not have to be visible. This command must be used in combination with feWindowRegenerate or feWindowRedraw in order to see the view update.
        **Input:**
            **vuID:** The ID of the view to Autoscale. Use viewID=0 to autoscale the active view.\n
            **redoBox:** When set to True, forces a recalculation of the box containing all of the entities in the model.\n
        **Return Code:** False\n
        :type vuID: int

        :type redoBox: bool

        """
        ...

    def feViewAutoscaleVisible(self, vuID, redoBox) -> Any:
        """
        **Description:**
            This method performs an autoscale on the selected view while only considering entities currently visible in the selected view.
        **Remarks/Usage:**
            The selected view does not have to be visible. This command must be used in combination with feWindowRegenerate or feWindowRedraw in order to see the view update.
        **Input:**
            **vuID:** The ID of the view to Autoscale. Use viewID=0 to autoscale the active view.\n
            **redoBox:** When set to True, forces a recalculation of the box containing all of the visible entities in the selected view.\n
        **Return Code:** False\n
        :type vuID: int

        :type redoBox: bool

        """
        ...

    def feViewCascade(self) -> Any:
        """
        **Description:**
            This function cascades all of the active views.
        **Remarks/Usage:**
            Like the Window, Cascade command.feViewCascade and feWindowCascade are identical.
        **Return Code:** False\n
        """
        ...

    def feViewRedraw(self, vuID) -> Any:
        """
        **Description:**
            This method redraws the selected view.
        **Remarks/Usage:**
            The selected view must be visible. Same as the Window, Redraw command. feViewRedraw and feWindowRedraw are identical.
        **Input:**
            **vuID:** The ID of the view to redraw. Use viewID=0 to redraw the active view.\n
        **Return Code:** False\n
        :type vuID: int

        """
        ...

    def feViewRegenerate(self, vuID) -> Any:
        """
        **Description:**
            This method regenerates the selected view.
        **Remarks/Usage:**
            The selected view must be visible. Same as the Window, Regeneratecommand.feViewRegenerate and feWindowRegenerate are identical
        **Input:**
            **vuID:** The ID of the view to regenerate. Use viewID=0 to regenerate the active view.\n
        **Return Code:** False\n
        :type vuID: int

        """
        ...

    def feViewShow(self, dTYPE, ID) -> Any:
        """
        **Description:**
            This function shows a selected group of entities.
        **Remarks/Usage:**
            Like the Window, Show Entities command. feViewShow and feWindowShow are identical.
        **Input:**
            **dTYPE:** The entity type to show: 3=Point, 4=Curve, 5=Surface, 7=Node, 8=Element, 9=Coordinate System, 10=Material (shows Elements referencing Material), 11=Property (shows Elements referencing Property), 53=Solid/Volume, 58=Connection Region/Region, 71=Connector, 81=Layup (shows Elements referencing Layup), 83=Global Ply (shows Elements referencing Layups which use Global Ply), 95=Areo Panel, 98=Aero Spline, and 99=Aero Control Surface.\n
            **ID:** The ID of a selection set that contains the IDs of the entities to show. Alternatively, if you specify a negative value, this is simply the ID of the single entity to show.\n
        **Return Code:** False\n
        :type dTYPE: int

        :type ID: int

        """
        ...

    def feViewShow2(self, dTYPE, ID, qAutoscale) -> Any:
        """
        **Description:**
            This function shows a selected group of entities and has the option to Autoscale around the entities being shown.
        **Remarks/Usage:**
            Like the Window, Show Entities command. feViewShow2 and feWindowShow2 are identical.
        **Input:**
            **dTYPE:** The entity type to show: 3=Point, 4=Curve, 5=Surface, 7=Node, 8=Element, 9=Coordinate System, 10=Material (shows Elements referencing Material), 11=Property (shows Elements referencing Property), 53=Solid/Volume, 58=Connection Region/Region, 71=Connector, 81=Layup (shows Elements referencing Layup), 83=Global Ply (shows Elements referencing Layups which use Global Ply), 95=Areo Panel, 98=Aero Spline, and 99=Aero Control Surface.\n
            **ID:** The ID of a selection set that contains the IDs of the entities to show. Alternatively, if you specify a negative value, this is simply the ID of the single entity to show.\n
            **qAutoscale:** If True, the view will autoscale around the entities being shown. If False, only the entities will be shown and the scaling of the view will remain the same.\n
        **Return Code:** False\n
        :type dTYPE: int

        :type ID: int

        :type qAutoscale: bool

        """
        ...

    def feViewShowMultiple(self, nSets, piTYPEs, piSetIDs, qAutoscale) -> Any:
        """
        **Description:**
            This function shows multiple sets of entities.
        **Remarks/Usage:**
            The sets can be of different types of entities. If they are of the same type, duplicates are not removed
        **Input:**
            **nSets:** Number of different sets of entities to show\n
            **qAutoscale:** If True, the view will autoscale around the entities being shown. If False, only the entities will be shown and the scaling of the view will remain the same.\n
        **Return Code:** False\n
        :type nSets: int

        :type qAutoscale: bool

        """
        ...

    def feViewTile(self) -> Any:
        """
        **Description:**
            This function tiles all of the active views vertically.
        **Remarks/Usage:**
            Like the Window, Tile Vertical command. feViewTile and feWindowTile are identical.
        **Return Code:** False\n
        """
        ...

    def feViewVisible(self, vuID, Visible) -> Any:
        """
        **Description:**
            This method makes views visible or removes them from the screen.
        **Remarks/Usage:**
            This is similar to the Window, New Windowcommand. feViewVisible and feWindowVisible perform identical functions.
        **Input:**
            **vuID:** The ID of the view to manipulate.\n
            **Visible:** Set to True to activate a view; False to remove it from the screen.\n
        **Return Code:** True\n
        :type vuID: int

        :type Visible: bool

        """
        ...

    def feWindowCascade(self) -> Any:
        """
        """
        ...

    def feWindowMaximize(self, vuID) -> Any:
        """
        **Description:**
            This function maximizes the window that contains the specified view
        **Remarks/Usage:**
            None
        **Input:**
            **vuID:** The ID of the view in the window to be modified. Specify vuID=0 to modify the active view.\n
        **Return Code:** False\n
        :type vuID: int

        """
        ...

    def feWindowMinimize(self, vuID) -> Any:
        """
        **Description:**
            This function minimizes the window that contains the specified view
        **Remarks/Usage:**
            None
        **Input:**
            **vuID:** The ID of the view in the window to be modified. Specify vuID=0 to modify the active view.\n
        **Return Code:** False\n
        :type vuID: int

        """
        ...

    def feWindowRedraw(self, vuID) -> Any:
        """
        :type vuID: Any
        """
        ...

    def feWindowRegenerate(self, vuID) -> Any:
        """
        :type vuID: Any
        """
        ...

    def feWindowRestore(self, vuID) -> Any:
        """
        **Description:**
            This function restores the window (from either a maximized or minimized state) that contains the specified view
        **Remarks/Usage:**
            None
        **Input:**
            **vuID:** The ID of the view in the window to be modified. Specify vuID=0 to modify the active view.\n
        **Return Code:** False\n
        :type vuID: int

        """
        ...

    def feWindowSetRect(self, vuID, pctLeft, pctTop, pctRight, pctBottom) -> Any:
        """
        **Description:**
            This function sizes the window using percentages of graphics area from the Left, Top, Right, and/or Bottom of the graphics area.
        **Remarks/Usage:**
            None
        **Input:**
            **vuID:** The ID of the view in the window to be modified. Specify vuID=0 to modify the active view.\n
            **pctLeft, pctTop, pctRight, pctBottom:** Location of view window in percent of graphics area. Numbers must be between 0.0 and 100.0\n

        **Return Code:** True\n
        :type vuID: int

        :type pctLeft: float

        :type pctTop: float

        :type pctRight: float

        :type pctBottom: float

        """
        ...

    def feWindowSetSize(self, vuID, left, top, horz, vert) -> Any:
        """
        **Description:**
            This function sizes the window by specifying the location of the top left corner of the view in number of pixels from the top left corner of the graphics area. The overall size of the view is then specified using number of pixels from the top left corner in the horizontal and vertical directions.
        **Remarks/Usage:**
            None
        **Input:**
            **vuID:** The ID of the view in the window to be modified. Specify vuID=0 to modify the active view\n
            **left:** Number of pixels from left edge of graphics area to left edge of view window\n
            **top:** Number of pixels from top edge of graphics area to top edge of view window\n
            **horz:** Number of pixels from left of view window to right of view window\n
            **vert:** Number of pixels from top of view window to bottom of view window\n
        **Return Code:** True\n
        :type vuID: int

        :type left: int

        :type top: int

        :type horz: int

        :type vert: int

        """
        ...

    def feWindowShow(self, dTYPE, ID) -> Any:
        """
        :type dTYPE: Any
        :type ID: Any
        """
        ...

    def feWindowShow2(self, dTYPE, ID, qAutoscale) -> Any:
        """
        :type dTYPE: Any
        :type ID: Any
        :type qAutoscale: Any
        """
        ...

    def feWindowTile(self) -> Any:
        """
        """
        ...

    def feWindowTileHorz(self) -> Any:
        """
        **Description:**
            This function tiles all of the active views horizontally.
        **Remarks/Usage:**
            Like the Window, Tile Horizontal command. 
        **Return Code:** False\n
        """
        ...

    def feWindowTitle(self, vuID, sTitle) -> Any:
        """
        **Description:**
            This function sets the View Title and the Tab Title at once for an existing view.
        **Remarks/Usage:**
            None
        **Input:**
            **vuID:** The ID of the view in the window to be modified. Specify vuID=0 to modify the active view.\n
            **sTitle:** View and Tab Title (maximum 79 characters).\n
        **Return Code:** True\n
        :type vuID: int

        :type sTitle: str

        """
        ...

    def feWindowVisible(self, vuID, Visible) -> Any:
        """
        **Description:**
            This method makes views visible or removes them from the screen.
        :type vuID: Any
        :type Visible: Any
        """
        ...
